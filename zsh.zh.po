# Chinese translations for PACKAGE package
# Copyright (C) 2023 Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# Automatically generated, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2023-10-17 14:31+0800\n"
"PO-Revision-Date: 2024-07-02 14:03+0800\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: zh\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 3.4.2\n"

#. type: settitle
#: zsh.texi:7
#, no-wrap
msgid "zsh"
msgstr "zsh"

#. type: node
#: zsh.texi:19 zsh.texi:35486 zsh.texi:35488 zsh.texi:35932
#, no-wrap
msgid "Utilities"
msgstr "实用程序"

#. type: menuentry
#: zsh.texi:22
msgid "ZSH: (zsh)"
msgstr "ZSH: (zsh)"

#. type: menuentry
#: zsh.texi:22
msgid "The Z Shell Manual."
msgstr "Z Shell 手册。"

#. type: node
#: zsh.texi:29 zsh.texi:55 zsh.texi:56 zsh.texi:306 zsh.texi:308 zsh.texi:350
#, no-wrap
msgid "The Z Shell Manual"
msgstr "Z Shell 手册"

#. type: subtitle
#: zsh.texi:30
#, no-wrap
msgid "Version 5.9"
msgstr "版本 5.9"

#. type: subtitle
#: zsh.texi:31
#, no-wrap
msgid "Updated May 14, 2022"
msgstr "2022 年 5 月 14 日更新"

#. type: author
#: zsh.texi:32
#, no-wrap
msgid "Original documentation by Paul Falstad"
msgstr "Original documentation by Paul Falstad"

#. type: titlepage
#: zsh.texi:36
msgid "This is a texinfo version of the documentation for the Z Shell, originally by Paul Falstad."
msgstr "This is a texinfo version of the documentation for the Z Shell, originally by Paul Falstad."

#. type: titlepage
#: zsh.texi:41
msgid "Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies."
msgstr "Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies."

#. type: titlepage
#: zsh.texi:47
msgid ""
"Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided also that the entire resulting derived work is distributed under the terms "
"of a permission notice identical to this one."
msgstr ""
"Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided also that the entire resulting derived work is distributed under the terms "
"of a permission notice identical to this one."

#. type: titlepage
#: zsh.texi:51
msgid "Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions."
msgstr "Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions."

#. type: node
#: zsh.texi:55 zsh.texi:306 zsh.texi:350 zsh.texi:515 zsh.texi:753 zsh.texi:1086 zsh.texi:1179 zsh.texi:2014 zsh.texi:2470 zsh.texi:2523 zsh.texi:3018 zsh.texi:3186 zsh.texi:3535 zsh.texi:3814 zsh.texi:4264
#: zsh.texi:7702 zsh.texi:9690 zsh.texi:12712 zsh.texi:16079 zsh.texi:19221 zsh.texi:20546 zsh.texi:26821 zsh.texi:27603 zsh.texi:32609 zsh.texi:33721 zsh.texi:34690 zsh.texi:35454 zsh.texi:41268
#: zsh.texi:41275 zsh.texi:41282 zsh.texi:41289 zsh.texi:41296 zsh.texi:41303
#, no-wrap
msgid "Top"
msgstr "目录"

#. type: node
#: zsh.texi:55
#, no-wrap
msgid "(dir)"
msgstr "(dir)"

#. type: ifinfo
#: zsh.texi:63
msgid ""
"This Info file documents Zsh, a freely available UNIX command interpreter (shell), which of the standard shells most closely resembles the Korn shell (ksh), although it is not completely compatible.  Zsh "
"is able to emulate POSIX shells, but its default mode is not POSIX compatible, either."
msgstr "该 Info 文件记录了 Zsh，一种可免费使用的 UNIX 命令解释器（shell），它是标准 shell 中与 Korn shell (ksh) 最为相似的一种，但并不完全兼容。 Zsh 可以模拟 POSIX shell，但其默认模式也不兼容 POSIX。"

#. type: cindex
#: zsh.texi:65
#, no-wrap
msgid "version"
msgstr "版本"

#. type: ifinfo
#: zsh.texi:67
msgid "Version 5.9, last updated May 14, 2022."
msgstr "版本 5.9，最后更新日期 2022 年 5 月 14 日。"

#. type: menuentry
#: zsh.texi:96
msgid "The Z Shell Manual::"
msgstr "Z Shell 手册::"

#. type: menuentry
#: zsh.texi:96
msgid "Introduction::"
msgstr "导言::"

#. type: menuentry
#: zsh.texi:96
msgid "Roadmap::"
msgstr "路线图::"

#. type: menuentry
#: zsh.texi:96
msgid "Invocation::"
msgstr "调用::"

#. type: menuentry
#: zsh.texi:96
msgid "Files::"
msgstr "文件::"

#. type: menuentry
#: zsh.texi:96
msgid "Shell Grammar::"
msgstr "Shell 语法::"

#. type: menuentry
#: zsh.texi:96
msgid "Redirection::"
msgstr "重定向::"

#. type: menuentry
#: zsh.texi:96
msgid "Command Execution::"
msgstr "命令执行::"

#. type: menuentry
#: zsh.texi:96
msgid "Functions::"
msgstr "函数::"

#. type: menuentry
#: zsh.texi:96
msgid "Jobs & Signals::"
msgstr "工作与信号::"

#. type: menuentry
#: zsh.texi:96
msgid "Arithmetic Evaluation::"
msgstr "算术求值::"

#. type: menuentry
#: zsh.texi:96
msgid "Conditional Expressions::"
msgstr "条件表达式::"

#. type: menuentry
#: zsh.texi:96
msgid "Prompt Expansion::"
msgstr "提示符扩展::"

#. type: menuentry
#: zsh.texi:96
msgid "Expansion::"
msgstr "扩展::"

#. type: menuentry
#: zsh.texi:96
msgid "Parameters::"
msgstr "参数::"

#. type: menuentry
#: zsh.texi:96
msgid "Options::"
msgstr "选项::"

#. type: menuentry
#: zsh.texi:96
msgid "Shell Builtin Commands::"
msgstr "Shell 内置命令::"

#. type: menuentry
#: zsh.texi:96
msgid "Zsh Line Editor::"
msgstr "Zsh 行编辑器::"

#. type: menuentry
#: zsh.texi:96
msgid "Completion Widgets::"
msgstr "补全小部件::"

#. type: menuentry
#: zsh.texi:96
msgid "Completion System::"
msgstr "补全系统::"

#. type: menuentry
#: zsh.texi:96
msgid "Completion Using compctl::"
msgstr "用 compctl 补全::"

#. type: menuentry
#: zsh.texi:96
msgid "Zsh Modules::"
msgstr "Zsh 模块::"

#. type: menuentry
#: zsh.texi:96
msgid "Calendar Function System::"
msgstr "日历函数系统::"

#. type: menuentry
#: zsh.texi:96
msgid "TCP Function System::"
msgstr "TCP 函数系统::"

#. type: menuentry
#: zsh.texi:96
msgid "Zftp Function System::"
msgstr "Zftp 函数系统::"

#. type: node
#: zsh.texi:96 zsh.texi:290 zsh.texi:34690 zsh.texi:35454 zsh.texi:35456 zsh.texi:35486 zsh.texi:35932 zsh.texi:36273 zsh.texi:36505 zsh.texi:37906 zsh.texi:38080 zsh.texi:39808 zsh.texi:39908 zsh.texi:40326
#: zsh.texi:40615 zsh.texi:40673
#, no-wrap
msgid "User Contributions"
msgstr "用户贡献"

#. type: menuentry
#: zsh.texi:99
msgid "--- Indices ---"
msgstr "--- Indices ---"

#. type: menuentry
#: zsh.texi:107
msgid "Concept Index::"
msgstr "概念索引::"

#. type: menuentry
#: zsh.texi:107
msgid "Variables Index::"
msgstr "变量索引::"

#. type: menuentry
#: zsh.texi:107
msgid "Options Index::"
msgstr "选项索引::"

#. type: menuentry
#: zsh.texi:107
msgid "Functions Index::"
msgstr "函数索引::"

#. type: menuentry
#: zsh.texi:107
msgid "Editor Functions Index::"
msgstr "编辑器函数索引::"

#. type: unnumbered
#: zsh.texi:107 zsh.texi:41296 zsh.texi:41303 zsh.texi:41305
#, no-wrap
msgid "Style and Tag Index"
msgstr "样式和标签索引"

#. type: menuentry
#: zsh.texi:110
msgid "--- The Detailed Node Listing ---"
msgstr "--- The Detailed Node Listing ---"

#. type: node
#: zsh.texi:113 zsh.texi:306 zsh.texi:350 zsh.texi:352 zsh.texi:376 zsh.texi:387 zsh.texi:407 zsh.texi:467 zsh.texi:477 zsh.texi:483 zsh.texi:496 zsh.texi:515
#, no-wrap
msgid "Introduction"
msgstr "简介"

#. type: menuentry
#: zsh.texi:122 zsh.texi:375
msgid "Author::"
msgstr "作者::"

#. type: menuentry
#: zsh.texi:122 zsh.texi:375
msgid "Availability::"
msgstr "可用性::"

#. type: menuentry
#: zsh.texi:122 zsh.texi:375
msgid "Mailing Lists::"
msgstr "邮件列表::"

#. type: menuentry
#: zsh.texi:122 zsh.texi:375
msgid "The Zsh FAQ::"
msgstr "zsh 常见问题::"

#. type: menuentry
#: zsh.texi:122 zsh.texi:375
msgid "The Zsh Web Page::"
msgstr "Zsh 网页::"

#. type: menuentry
#: zsh.texi:122 zsh.texi:375
msgid "The Zsh Userguide::"
msgstr "Zsh 用户指南::"

#. type: section
#: zsh.texi:122 zsh.texi:375 zsh.texi:483 zsh.texi:496 zsh.texi:498
#, no-wrap
msgid "See Also"
msgstr "另请参见"

#. type: node
#: zsh.texi:125 zsh.texi:515 zsh.texi:753 zsh.texi:755 zsh.texi:759 zsh.texi:886 zsh.texi:975 zsh.texi:1086
#, no-wrap
msgid "Invocation"
msgstr "调用"

#. type: menuentry
#: zsh.texi:129 zsh.texi:882
msgid "Compatibility::"
msgstr "兼容性::"

#. type: section
#: zsh.texi:129 zsh.texi:882 zsh.texi:886 zsh.texi:975 zsh.texi:977
#, no-wrap
msgid "Restricted Shell"
msgstr "受限的 Shell"

#. type: node
#: zsh.texi:132 zsh.texi:1086 zsh.texi:1179 zsh.texi:1181 zsh.texi:1196 zsh.texi:1302 zsh.texi:1370 zsh.texi:1644 zsh.texi:1733 zsh.texi:1751 zsh.texi:1831 zsh.texi:1843 zsh.texi:1975 zsh.texi:2014
#, no-wrap
msgid "Shell Grammar"
msgstr "Shell 语法"

#. type: menuentry
#: zsh.texi:142 zsh.texi:1195
msgid "Simple Commands & Pipelines::"
msgstr "简单命令和管道::"

#. type: menuentry
#: zsh.texi:142 zsh.texi:1195
msgid "Precommand Modifiers::"
msgstr "前置命令修饰符::"

#. type: menuentry
#: zsh.texi:142 zsh.texi:1195
msgid "Complex Commands::"
msgstr "复杂命令::"

#. type: menuentry
#: zsh.texi:142 zsh.texi:1195
msgid "Alternate Forms For Complex Commands::"
msgstr "复杂命令的替代形式::"

#. type: menuentry
#: zsh.texi:142 zsh.texi:1195
msgid "Reserved Words::"
msgstr "保留字::"

#. type: menuentry
#: zsh.texi:142 zsh.texi:1195
msgid "Comments::"
msgstr "注释::"

#. type: menuentry
#: zsh.texi:142 zsh.texi:1195
msgid "Aliasing::"
msgstr "别名::"

#. type: section
#: zsh.texi:142 zsh.texi:1195 zsh.texi:1843 zsh.texi:1975 zsh.texi:1977
#, no-wrap
msgid "Quoting"
msgstr "引用"

#. type: node
#: zsh.texi:145 zsh.texi:3814 zsh.texi:4264 zsh.texi:4266 zsh.texi:4321 zsh.texi:4754 zsh.texi:4919 zsh.texi:6249 zsh.texi:6276 zsh.texi:6288 zsh.texi:6364 zsh.texi:6583 zsh.texi:7702
#, no-wrap
msgid "Expansion"
msgstr "扩展"

#. type: menuentry
#: zsh.texi:155 zsh.texi:4320
msgid "History Expansion::"
msgstr "历史扩展::"

#. type: menuentry
#: zsh.texi:155 zsh.texi:4320
msgid "Process Substitution::"
msgstr "进程替换::"

#. type: menuentry
#: zsh.texi:155 zsh.texi:4320
msgid "Parameter Expansion::"
msgstr "参数扩展::"

#. type: menuentry
#: zsh.texi:155 zsh.texi:4320
msgid "Command Substitution::"
msgstr "命令替换::"

#. type: menuentry
#: zsh.texi:155 zsh.texi:4320
msgid "Arithmetic Expansion::"
msgstr "算术扩展::"

#. type: menuentry
#: zsh.texi:155 zsh.texi:4320
msgid "Brace Expansion::"
msgstr "括号扩展::"

#. type: menuentry
#: zsh.texi:155 zsh.texi:4320
msgid "Filename Expansion::"
msgstr "文件名扩展::"

#. type: section
#: zsh.texi:155 zsh.texi:4302 zsh.texi:4320 zsh.texi:6364 zsh.texi:6583 zsh.texi:6585
#, no-wrap
msgid "Filename Generation"
msgstr "文件名生成"

#. type: subsection
#: zsh.texi:158 zsh.texi:4264 zsh.texi:7702 zsh.texi:7704 zsh.texi:7800 zsh.texi:8391 zsh.texi:8423 zsh.texi:8468 zsh.texi:8930 zsh.texi:9690 zsh.texi:28767 zsh.texi:30803 zsh.texi:31584
#, no-wrap
msgid "Parameters"
msgstr "参数"

#. type: menuentry
#: zsh.texi:165 zsh.texi:7799
msgid "Array Parameters::"
msgstr "数组参数::"

#. type: menuentry
#: zsh.texi:165 zsh.texi:7799
msgid "Positional Parameters::"
msgstr "位置参数::"

#. type: menuentry
#: zsh.texi:165 zsh.texi:7799
msgid "Local Parameters::"
msgstr "局部参数::"

#. type: menuentry
#: zsh.texi:165 zsh.texi:7799
msgid "Parameters Set By The Shell::"
msgstr "由 Shell 设置的参数::"

#. type: section
#: zsh.texi:165 zsh.texi:7799 zsh.texi:8468 zsh.texi:8930 zsh.texi:8932
#, no-wrap
msgid "Parameters Used By The Shell"
msgstr "Shell 使用的参数"

#. type: subsection
#: zsh.texi:168 zsh.texi:652 zsh.texi:7702 zsh.texi:9690 zsh.texi:9692 zsh.texi:9701 zsh.texi:9746 zsh.texi:12428 zsh.texi:12533 zsh.texi:12712 zsh.texi:36024
#, no-wrap
msgid "Options"
msgstr "选项"

#. type: menuentry
#: zsh.texi:174 zsh.texi:9700
msgid "Specifying Options::"
msgstr "指定选项::"

#. type: menuentry
#: zsh.texi:174 zsh.texi:9700
msgid "Description of Options::"
msgstr "选项说明::"

#. type: menuentry
#: zsh.texi:174 zsh.texi:9700
msgid "Option Aliases::"
msgstr "选项别名::"

#. type: section
#: zsh.texi:174 zsh.texi:9700 zsh.texi:12428 zsh.texi:12533 zsh.texi:12535
#, no-wrap
msgid "Single Letter Options"
msgstr "单字母选项"

#. type: node
#: zsh.texi:177 zsh.texi:12712 zsh.texi:16079 zsh.texi:16081 zsh.texi:16152 zsh.texi:16273 zsh.texi:16937 zsh.texi:16964 zsh.texi:17475 zsh.texi:18972 zsh.texi:19221
#, no-wrap
msgid "Zsh Line Editor"
msgstr "Zsh 行编辑器"

#. type: menuentry
#: zsh.texi:185 zsh.texi:16149
msgid "Keymaps::"
msgstr "键映射::"

#. type: menuentry
#: zsh.texi:185 zsh.texi:16149
msgid "Zle Builtins::"
msgstr "Zle 内置命令::"

#. type: menuentry
#: zsh.texi:185 zsh.texi:16149
msgid "Zle Widgets::"
msgstr "Zle 小部件::"

#. type: menuentry
#: zsh.texi:185 zsh.texi:16149
msgid "User-Defined Widgets::"
msgstr "用户自定义小部件::"

#. type: menuentry
#: zsh.texi:185 zsh.texi:16149
msgid "Standard Widgets::"
msgstr "标准小部件::"

#. type: section
#: zsh.texi:185 zsh.texi:16149 zsh.texi:17475 zsh.texi:18972 zsh.texi:18974
#, no-wrap
msgid "Character Highlighting"
msgstr "字符高亮"

#. type: node
#: zsh.texi:188 zsh.texi:16079 zsh.texi:19221 zsh.texi:19223 zsh.texi:19284 zsh.texi:19692 zsh.texi:20146 zsh.texi:20177 zsh.texi:20508 zsh.texi:20546
#, no-wrap
msgid "Completion Widgets"
msgstr "补全小部件"

#. type: menuentry
#: zsh.texi:195 zsh.texi:19281
msgid "Completion Special Parameters::"
msgstr "补全特殊参数::"

#. type: menuentry
#: zsh.texi:195 zsh.texi:19281
msgid "Completion Builtin Commands::"
msgstr "补全内置命令::"

#. type: menuentry
#: zsh.texi:195 zsh.texi:19281
msgid "Completion Condition Codes::"
msgstr "补全条件代码::"

#. type: menuentry
#: zsh.texi:195 zsh.texi:19281
msgid "Completion Matching Control::"
msgstr "补全匹配控制::"

#. type: section
#: zsh.texi:195 zsh.texi:19281 zsh.texi:20177 zsh.texi:20508 zsh.texi:20510
#, no-wrap
msgid "Completion Widget Example"
msgstr "补全小部件举例"

#. type: node
#: zsh.texi:198 zsh.texi:19221 zsh.texi:20546 zsh.texi:20548 zsh.texi:20656 zsh.texi:21171 zsh.texi:23839 zsh.texi:24336 zsh.texi:24562 zsh.texi:26735 zsh.texi:26776 zsh.texi:26821
#, no-wrap
msgid "Completion System"
msgstr "补全系统"

#. type: menuentry
#: zsh.texi:206 zsh.texi:20653
msgid "Initialization::"
msgstr "初始化::"

#. type: menuentry
#: zsh.texi:206 zsh.texi:20653
msgid "Completion System Configuration::"
msgstr "补全系统配置::"

#. type: menuentry
#: zsh.texi:206 zsh.texi:20653
msgid "Control Functions::"
msgstr "控制函数::"

#. type: menuentry
#: zsh.texi:206 zsh.texi:20653
msgid "Bindable Commands::"
msgstr "可绑定命令::"

#. type: menuentry
#: zsh.texi:206 zsh.texi:20653
msgid "Completion Functions::"
msgstr "补全函数::"

#. type: section
#: zsh.texi:206 zsh.texi:26735 zsh.texi:26776 zsh.texi:26778
#, no-wrap
msgid "Completion Directories"
msgstr "补全目录"

#. type: node
#: zsh.texi:209 zsh.texi:20546 zsh.texi:26821 zsh.texi:26823 zsh.texi:26870 zsh.texi:26980 zsh.texi:27421 zsh.texi:27440 zsh.texi:27568 zsh.texi:27603
#, no-wrap
msgid "Completion Using compctl"
msgstr "用 compctl 补全"

#. type: menuentry
#: zsh.texi:216 zsh.texi:26867
msgid "Command Flags::"
msgstr "命令标志::"

#. type: menuentry
#: zsh.texi:216 zsh.texi:26867
msgid "Option Flags::"
msgstr "选项标志::"

#. type: menuentry
#: zsh.texi:216 zsh.texi:26867
msgid "Alternative Completion::"
msgstr "备选补全::"

#. type: menuentry
#: zsh.texi:216 zsh.texi:26867
msgid "Extended Completion::"
msgstr "扩展补全::"

#. type: subsection
#: zsh.texi:216 zsh.texi:26867 zsh.texi:27440 zsh.texi:27568 zsh.texi:27570 zsh.texi:31019 zsh.texi:32185 zsh.texi:32985
#, no-wrap
msgid "Example"
msgstr "举例"

#. type: node
#: zsh.texi:219 zsh.texi:26821 zsh.texi:27603 zsh.texi:27605 zsh.texi:27780 zsh.texi:27827 zsh.texi:27861 zsh.texi:27928 zsh.texi:27941 zsh.texi:27951 zsh.texi:28401 zsh.texi:28494 zsh.texi:28812
#: zsh.texi:28919 zsh.texi:28994 zsh.texi:29018 zsh.texi:29041 zsh.texi:29264 zsh.texi:29309 zsh.texi:29381 zsh.texi:29499 zsh.texi:29545 zsh.texi:29601 zsh.texi:29883 zsh.texi:29989 zsh.texi:30108
#: zsh.texi:30164 zsh.texi:30245 zsh.texi:30342 zsh.texi:30526 zsh.texi:30847 zsh.texi:31068 zsh.texi:31098 zsh.texi:31128 zsh.texi:31291 zsh.texi:31845 zsh.texi:31854 zsh.texi:31888 zsh.texi:31959
#: zsh.texi:32064 zsh.texi:32146 zsh.texi:32609
#, no-wrap
msgid "Zsh Modules"
msgstr "Zsh 模块"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/attr Module::"
msgstr "zsh/attr 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/cap Module::"
msgstr "zsh/cap 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/clone Module::"
msgstr "zsh/clone 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/compctl Module::"
msgstr "zsh/compctl 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/complete Module::"
msgstr "zsh/complete 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/complist Module::"
msgstr "zsh/complist 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/computil Module::"
msgstr "zsh/computil 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/curses Module::"
msgstr "zsh/curses 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/datetime Module::"
msgstr "zsh/datetime 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/db/gdbm Module::"
msgstr "zsh/db/gdbm 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/deltochar Module::"
msgstr "zsh/deltochar 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/example Module::"
msgstr "zsh/example 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/files Module::"
msgstr "zsh/files 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/langinfo Module::"
msgstr "zsh/langinfo 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/mapfile Module::"
msgstr "zsh/mapfile 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/mathfunc Module::"
msgstr "zsh/mathfunc 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/nearcolor Module::"
msgstr "zsh/nearcolor 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/newuser Module::"
msgstr "zsh/newuser 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/parameter Module::"
msgstr "zsh/parameter 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/pcre Module::"
msgstr "zsh/pcre 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/param/private Module::"
msgstr "zsh/param/private 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/regex Module::"
msgstr "zsh/regex 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/sched Module::"
msgstr "zsh/sched 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/net/socket Module::"
msgstr "zsh/net/socket 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/stat Module::"
msgstr "zsh/stat 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/system Module::"
msgstr "zsh/system 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/net/tcp Module::"
msgstr "zsh/net/tcp 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/termcap Module::"
msgstr "zsh/termcap 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/terminfo Module::"
msgstr "zsh/terminfo 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/watch Module::"
msgstr "zsh/watch 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/zftp Module::"
msgstr "zsh/zftp 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/zle Module::"
msgstr "zsh/zle 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/zleparameter Module::"
msgstr "zsh/zleparameter 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/zprof Module::"
msgstr "zsh/zprof 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/zpty Module::"
msgstr "zsh/zpty 模块::"

#. type: menuentry
#: zsh.texi:260 zsh.texi:27778
msgid "The zsh/zselect Module::"
msgstr "zsh/zselect 模块::"

#. type: section
#: zsh.texi:260 zsh.texi:27778 zsh.texi:32064 zsh.texi:32146 zsh.texi:32148
#, no-wrap
msgid "The zsh/zutil Module"
msgstr "zsh/zutil 模块"

#. type: node
#: zsh.texi:263 zsh.texi:27603 zsh.texi:32609 zsh.texi:32611 zsh.texi:32652 zsh.texi:33013 zsh.texi:33496 zsh.texi:33569 zsh.texi:33688 zsh.texi:33721
#, no-wrap
msgid "Calendar Function System"
msgstr "日历函数系统"

#. type: menuentry
#: zsh.texi:270 zsh.texi:32649
msgid "Calendar File and Date Formats::"
msgstr "日历文件和日期格式::"

#. type: menuentry
#: zsh.texi:270 zsh.texi:32649
msgid "Calendar System User Functions::"
msgstr "日历系统用户函数::"

#. type: menuentry
#: zsh.texi:270 zsh.texi:32649
msgid "Calendar Styles::"
msgstr "日历样式::"

#. type: menuentry
#: zsh.texi:270 zsh.texi:32649
msgid "Calendar Utility Functions::"
msgstr "日历工具函数::"

#. type: node
#: zsh.texi:270 zsh.texi:32649 zsh.texi:33569 zsh.texi:33688
#, no-wrap
msgid "Calendar Bugs"
msgstr "日历问题"

#. type: node
#: zsh.texi:273 zsh.texi:32609 zsh.texi:33721 zsh.texi:33723 zsh.texi:33768 zsh.texi:34402 zsh.texi:34617 zsh.texi:34674 zsh.texi:34690
#, no-wrap
msgid "TCP Function System"
msgstr "TCP 函数系统"

#. type: menuentry
#: zsh.texi:279 zsh.texi:33765
msgid "TCP Functions::"
msgstr "TCP 函数::"

#. type: menuentry
#: zsh.texi:279 zsh.texi:33765
msgid "TCP Parameters::"
msgstr "TCP 参数::"

#. type: menuentry
#: zsh.texi:279 zsh.texi:33765
msgid "TCP Examples::"
msgstr "TCP 举例::"

#. type: section
#: zsh.texi:279 zsh.texi:33765 zsh.texi:34617 zsh.texi:34674 zsh.texi:34676
#, no-wrap
msgid "TCP Bugs"
msgstr "TCP 问题"

#. type: node
#: zsh.texi:282 zsh.texi:33721 zsh.texi:34690 zsh.texi:34692 zsh.texi:34736 zsh.texi:34768 zsh.texi:35266 zsh.texi:35454
#, no-wrap
msgid "Zftp Function System"
msgstr "Zftp 函数系统"

#. type: menuentry
#: zsh.texi:287 zsh.texi:34733
msgid "Installation::"
msgstr "安装::"

#. type: menuentry
#: zsh.texi:287 zsh.texi:34733
msgid "Zftp Functions::"
msgstr "Zftp 函数::"

#. type: section
#: zsh.texi:287 zsh.texi:34733 zsh.texi:34768 zsh.texi:35266 zsh.texi:35268
#, no-wrap
msgid "Miscellaneous Features"
msgstr "杂项功能"

#. type: menuentry
#: zsh.texi:303 zsh.texi:35483
msgid "Utilities::"
msgstr "实用程序::"

#. type: menuentry
#: zsh.texi:303 zsh.texi:35483
msgid "Recent Directories::"
msgstr "近期目录::"

#. type: menuentry
#: zsh.texi:303 zsh.texi:35483
msgid "Other Directory Functions::"
msgstr "其它目录函数::"

#. type: menuentry
#: zsh.texi:303 zsh.texi:35483
msgid "Version Control Information::"
msgstr "版本控制信息::"

#. type: menuentry
#: zsh.texi:303 zsh.texi:35483
msgid "Prompt Themes::"
msgstr "提示符主题::"

#. type: menuentry
#: zsh.texi:303 zsh.texi:35483
msgid "ZLE Functions::"
msgstr "ZLE 函数::"

#. type: menuentry
#: zsh.texi:303 zsh.texi:35483
msgid "Exception Handling::"
msgstr "异常处理::"

#. type: menuentry
#: zsh.texi:303 zsh.texi:35483
msgid "MIME Functions::"
msgstr "MIME 函数::"

#. type: menuentry
#: zsh.texi:303 zsh.texi:35483
msgid "Mathematical Functions::"
msgstr "数学函数::"

#. type: menuentry
#: zsh.texi:303 zsh.texi:35483
msgid "User Configuration Functions::"
msgstr "用户配置函数::"

#. type: section
#: zsh.texi:303 zsh.texi:35483 zsh.texi:40615 zsh.texi:40673 zsh.texi:40675
#, no-wrap
msgid "Other Functions"
msgstr "其它函数"

#. type: Plain text
#: zsh.texi:312
msgid "This document has been produced from the texinfo file @t{zsh.texi}, included in the @t{Doc} sub-directory of the Zsh distribution."
msgstr "本文档是根据 Zsh 发行版 @t{Doc} 子目录中的 texinfo 文件 @t{zsh.texi} 制作的。"

#. type: section
#: zsh.texi:313
#, no-wrap
msgid "Producing documentation from zsh.texi"
msgstr "从 zsh.texi 制作文档"

#. type: Plain text
#: zsh.texi:316
msgid "The texinfo source may be converted into several formats:"
msgstr "texinfo 源文件可转换成多种格式："

#. type: item
#: zsh.texi:319
#, no-wrap
msgid "The Info manual"
msgstr "Info 手册"

#. type: table
#: zsh.texi:323
msgid "The Info format allows searching for topics, commands, functions, etc.  from the many Indices. The command `@t{makeinfo zsh.texi}' is used to produce the Info documentation."
msgstr "Info 格式允许从众多索引中搜索主题、命令、函数等。命令 `@t{makeinfo zsh.texi}'用于生成 Info 文档。"

#. type: item
#: zsh.texi:324
#, no-wrap
msgid "The printed manual"
msgstr "印刷手册"

#. type: table
#: zsh.texi:328
msgid "The command `@t{texi2dvi zsh.texi}' will output @t{zsh.dvi} which can then be processed with @cite{dvips} and optionally @cite{gs} (Ghostscript) to produce a nicely formatted printed manual."
msgstr "命令`@t{texi2dvi zsh.texi}' 将输出 @t{zsh.dvi}，然后使用 @cite{dvips} 和可选的 @cite{gs} （Ghostscript）对其进行处理，以生成格式精美的打印手册。"

#. type: item
#: zsh.texi:329
#, no-wrap
msgid "The HTML manual"
msgstr "HTML 手册"

#. type: table
#: zsh.texi:331
msgid "An HTML version of this manual is available at the Zsh web site via:"
msgstr "本手册的 HTML 版本可通过 Zsh 网站获取："

#. type: table
#: zsh.texi:334
msgid "@t{@uref{https://zsh.sourceforge.io/Doc/}}."
msgstr "@t{@uref{https://zsh.sourceforge.io/Doc/}}。"

#. type: table
#: zsh.texi:340
msgid ""
"(The HTML version is produced with @cite{texi2html}, which may be obtained from @t{@uref{http://www.nongnu.org/texi2html/}}. The command is `@t{texi2html --output .  --ifinfo --split=chapter --node-files "
"zsh.texi}'.  If necessary, upgrade to version 1.78 of texi2html.)"
msgstr ""
"(HTML 版本通过 @cite{texi2html} 生成，可从 @t{@uref{http://www.nongnu.org/texi2html/}} 获取。命令为`@t{texi2html --output .  --ifinfo --split=chapter --node-files zsh.texi}'。 如有必要，请升级至 1.78 版 "
"texi2html）。"

#. type: Plain text
#: zsh.texi:350
msgid ""
"For those who do not have the necessary tools to process texinfo, precompiled documentation (PostScript, dvi, PDF, info and HTML formats)  is available from the zsh archive site or its mirrors, in the "
"file @t{zsh-doc.tar.gz}. (See @ref{Availability} for a list of sites.)"
msgstr "对于那些没有处理 texinfo 所需的工具的用户，可从 zsh 归档站点或其镜像站点获取预编译文档（PostScript、dvi、PDF、info 和 HTML 格式），文件名为 @t{zsh-doc.tar.gz}。(站点列表请参见@ref{可用性}）。"

#. type: node
#: zsh.texi:350 zsh.texi:515 zsh.texi:517 zsh.texi:753
#, no-wrap
msgid "Roadmap"
msgstr "路线图"

#. type: cindex
#: zsh.texi:354
#, no-wrap
msgid "introduction"
msgstr "导言"

#. type: Plain text
#: zsh.texi:361
msgid ""
"Zsh is a UNIX command interpreter (shell) usable as an interactive login shell and as a shell script command processor.  Of the standard shells, zsh most closely resembles @cite{ksh} but includes many "
"enhancements.  It does not provide compatibility with POSIX or other shells in its default operating mode: see the section @ref{Compatibility}."
msgstr ""
"Zsh 是一种 UNIX 命令解释器（shell），可用作交互式登录 shell 和 shell 脚本命令处理器。 在标准 shell 中，zsh 与 @cite{ksh} 最为相似，但包含许多增强功能。 在默认运行模式下，zsh 与 POSIX 或其他 shell 不兼容："
"请参阅 @ref{兼容性} 章节。"

#. type: Plain text
#: zsh.texi:367
msgid "Zsh has command line editing, builtin spelling correction, programmable command completion, shell functions (with autoloading), a history mechanism, and a host of other features."
msgstr "Zsh 具有命令行编辑、内置拼写校正、可编程命令补全、shell 函数（带自动加载功能）、历史记录机制以及大量其他功能。"

#. type: node
#: zsh.texi:376 zsh.texi:378 zsh.texi:387
#, no-wrap
msgid "Author"
msgstr "作者"

#. type: node
#: zsh.texi:376 zsh.texi:387 zsh.texi:389 zsh.texi:407
#, no-wrap
msgid "Availability"
msgstr "可用性"

#. type: cindex
#: zsh.texi:380
#, no-wrap
msgid "author"
msgstr "作者"

#. type: Plain text
#: zsh.texi:387
msgid ""
"Zsh was originally written by Paul Falstad.  Zsh is now maintained by the members of the zsh-workers mailing list @t{<zsh-workers@@zsh.org>}.  The development is currently coordinated by Peter Stephenson "
"@t{<pws@@zsh.org>}.  The coordinator can be contacted at @t{<coordinator@@zsh.org>}, but matters relating to the code should generally go to the mailing list."
msgstr ""
"Zsh 最初由 Paul Falstad 编写。 Zsh 现在由 zsh-workers 邮件列表 @t{<zsh-workers@@zsh.org>} 的成员维护。 目前由 Peter Stephenson @t{<pws@@zsh.org>}负责协调开发工作。 您可以通过 @t{<coordinator@@zsh.org>} 与"
"协调人联系，但有关代码的事宜一般应在邮件列表中进行讨论。"

#. type: node
#: zsh.texi:387 zsh.texi:407 zsh.texi:409 zsh.texi:467
#, no-wrap
msgid "Mailing Lists"
msgstr "邮件列表"

#. type: Plain text
#: zsh.texi:392
msgid "Zsh is available from the following HTTP and anonymous FTP site."
msgstr "Zsh 可从以下 HTTP 和匿名 FTP 站点获取。"

#. type: cindex
#: zsh.texi:394
#, no-wrap
msgid "FTP sites for zsh"
msgstr "zsh 的 FTP 站点"

#. type: cindex
#: zsh.texi:395
#, no-wrap
msgid "acquiring zsh by FTP"
msgstr "通过 FTP 获取 zsh"

#. type: cindex
#: zsh.texi:396
#, no-wrap
msgid "availability of zsh"
msgstr "zsh 的可用性"

#. type: Plain text
#: zsh.texi:399
msgid "@t{@uref{ftp://ftp.zsh.org/pub/}}@* @t{@uref{https://www.zsh.org/pub/}}"
msgstr "@t{@uref{ftp://ftp.zsh.org/pub/}}@* @t{@uref{https://www.zsh.org/pub/}}"

#. type: Plain text
#: zsh.texi:405
msgid ""
"The up-to-date source code is available via Git from Sourceforge.  See @t{@uref{https://sourceforge.net/projects/zsh/}} for details.  A summary of instructions for the archive can be found at "
"@t{@uref{https://zsh.sourceforge.io/}}."
msgstr "最新源代码可通过 Git 从 Sourceforge 获取。 详情请参见 @t{@uref{https://sourceforge.net/projects/zsh/}}。 有关存档的说明摘要，请参见 @t{@uref{https://zsh.sourceforge.io/}}。"

#. type: node
#: zsh.texi:407 zsh.texi:467 zsh.texi:469 zsh.texi:477
#, no-wrap
msgid "The Zsh FAQ"
msgstr "Zsh 常见问题"

#. type: cindex
#: zsh.texi:411
#, no-wrap
msgid "mailing lists"
msgstr "邮件列表"

#. type: Plain text
#: zsh.texi:413
msgid "Zsh has several mailing lists:"
msgstr "Zsh 有多个邮件列表："

#. type: t{#1}
#: zsh.texi:416
#, no-wrap
msgid "<zsh-announce@@zsh.org>"
msgstr "<zsh-announce@@zsh.org>"

#. type: table
#: zsh.texi:419
msgid "Announcements about releases, major changes in the shell and the monthly posting of the Zsh FAQ.  (moderated)"
msgstr "有关版本发布、shell 重大变更以及每月发布的 Zsh 常见问题的公告。 （审核）"

#. type: t{#1}
#: zsh.texi:420
#, no-wrap
msgid "<zsh-users@@zsh.org>"
msgstr "<zsh-users@@zsh.org>"

#. type: table
#: zsh.texi:422
msgid "User discussions."
msgstr "用户讨论。"

#. type: t{#1}
#: zsh.texi:423
#, no-wrap
msgid "<zsh-workers@@zsh.org>"
msgstr "<zsh-workers@@zsh.org>"

#. type: table
#: zsh.texi:425
msgid "Hacking, development, bug reports and patches."
msgstr "黑客、开发、错误报告和补丁。"

#. type: t{#1}
#: zsh.texi:426
#, no-wrap
msgid "<zsh-security@@zsh.org>"
msgstr "<zsh-security@@zsh.org>"

#. type: table
#: zsh.texi:429
msgid "Private mailing list (the general public cannot subscribe to it) for discussing bug reports with security implications, i.e., potential vulnerabilities."
msgstr "私人邮件列表（一般公众无法订阅），用于讨论具有安全影响的错误报告，即潜在漏洞。"

#. type: table
#: zsh.texi:432
msgid "If you find a security problem in zsh itself, please mail this address."
msgstr "如果您发现 zsh 本身存在安全问题，请发送邮件至此地址。"

#. type: Plain text
#: zsh.texi:438
msgid "To subscribe or unsubscribe, send mail to the associated administrative address for the mailing list."
msgstr "如需订阅或取消订阅，请向邮件列表的相关管理地址发送邮件。"

#. type: t{#1}
#: zsh.texi:441
#, no-wrap
msgid "<zsh-announce-subscribe@@zsh.org>"
msgstr "<zsh-announce-subscribe@@zsh.org>"

#. type: t{#1}
#: zsh.texi:442
#, no-wrap
msgid "<zsh-users-subscribe@@zsh.org>"
msgstr "<zsh-users-subscribe@@zsh.org>"

#. type: t{#1}
#: zsh.texi:443
#, no-wrap
msgid "<zsh-workers-subscribe@@zsh.org>"
msgstr "<zsh-workers-subscribe@@zsh.org>"

#. type: t{#1}
#: zsh.texi:446
#, no-wrap
msgid "<zsh-announce-unsubscribe@@zsh.org>"
msgstr "<zsh-announce-unsubscribe@@zsh.org>"

#. type: t{#1}
#: zsh.texi:447
#, no-wrap
msgid "<zsh-users-unsubscribe@@zsh.org>"
msgstr "<zsh-users-unsubscribe@@zsh.org>"

#. type: t{#1}
#: zsh.texi:448
#, no-wrap
msgid "<zsh-workers-unsubscribe@@zsh.org>"
msgstr "<zsh-workers-unsubscribe@@zsh.org>"

#. type: Plain text
#: zsh.texi:457
msgid ""
"YOU ONLY NEED TO JOIN ONE OF THE MAILING LISTS AS THEY ARE NESTED.  All submissions to @cite{zsh-announce} are automatically forwarded to @cite{zsh-users}.  All submissions to @cite{zsh-users} are "
"automatically forwarded to @cite{zsh-workers}."
msgstr "您只需加入其中一个邮件列表，因为它们是嵌套的。 所有提交到 @cite{zsh-announce} 的内容都会自动转发给 @cite{zsh-users}。 所有向 @cite{zsh-users} 提交的内容都会自动转发给 @cite{zsh-workers}。"

#. type: Plain text
#: zsh.texi:461
msgid "If you have problems subscribing/unsubscribing to any of the mailing lists, send mail to @t{<listmaster@@zsh.org>}."
msgstr "如果您在订阅/退订任何邮件列表时遇到问题，请发送邮件至 @t{<listmaster@@zsh.org>}。"

#. type: Plain text
#: zsh.texi:467
msgid "The mailing lists are archived; the archives can be accessed via the administrative addresses listed above.  There is also a hypertext archive available at @t{@uref{https://www.zsh.org/mla/}}."
msgstr "邮件列表已存档；可通过上述管理地址访问存档。 此外，@t{@uref{https://www.zsh.org/mla/}}还提供超文本档案。"

#. type: node
#: zsh.texi:467 zsh.texi:477 zsh.texi:479 zsh.texi:483
#, no-wrap
msgid "The Zsh Web Page"
msgstr "Zsh 网页"

#. type: Plain text
#: zsh.texi:477
msgid ""
"Zsh has a list of Frequently Asked Questions (FAQ), maintained by Peter Stephenson @t{<pws@@zsh.org>}.  It is regularly posted to the newsgroup @cite{comp.unix.shell} and the @cite{zsh-announce} mailing "
"list.  The latest version can be found at any of the Zsh FTP sites, or at @t{@uref{https://www.zsh.org/FAQ/}}.  The contact address for FAQ-related matters is @t{<faqmaster@@zsh.org>}."
msgstr ""
"Zsh 有一个常见问题（FAQ）列表，由 Peter Stephenson @t{<pws@@zsh.org>} 维护。 它定期发布到 @cite{comp.unix.shell} 新闻组和 @cite{zsh-announce} 邮件列表。 最新版本可在任何 Zsh FTP 站点或 @t{@uref{https://"
"www.zsh.org/FAQ/}} 上找到。 常见问题相关事宜的联系地址是 @t{<faqmaster@@zsh.org>}。"

#. type: node
#: zsh.texi:477 zsh.texi:483 zsh.texi:485 zsh.texi:496
#, no-wrap
msgid "The Zsh Userguide"
msgstr "Zsh 用户指南"

#. type: Plain text
#: zsh.texi:483
msgid "Zsh has a web page which is located at @t{@uref{https://www.zsh.org/}}.  The contact address for web-related matters is @t{<webmaster@@zsh.org>}."
msgstr "Zsh 有一个网页，位于 @t{@uref{https://www.zsh.org/}}。 网站相关事宜的联系地址是 @t{<webmaster@@zsh.org>}。"

#. type: Plain text
#: zsh.texi:496
msgid ""
"A userguide is currently in preparation.  It is intended to complement the manual, with explanations and hints on issues where the manual can be cabbalistic, hierographic, or downright mystifying (for "
"example, the word `hierographic' does not exist).  It can be viewed in its current state at @t{@uref{https://zsh.sourceforge.io/Guide/}}.  At the time of writing, chapters dealing with startup files and "
"their contents and the new completion system were essentially complete."
msgstr ""
"目前正在编写用户指南。 该指南旨在对手册进行补充，对手册中可能存在的卡巴拉式、等级式或完全神秘化（例如，\"等级式 \"一词并不存在）的问题进行解释和提示。 您可以通过 @t{@uref{https://zsh.sourceforge.io/"
"Guide/}} 查看该手册的当前状态。 在撰写本文时，关于启动文件及其内容以及新的补全系统的章节已基本完成。"

#. type: Plain text
#: zsh.texi:506
msgid "sh(1), csh(1), tcsh(1), rc(1), bash(1), ksh(1)"
msgstr "sh(1), csh(1), tcsh(1), rc(1), bash(1), ksh(1)"

#. type: Plain text
#: zsh.texi:515
msgid "@cite{IEEE Standard for information Technology - Portable Operating System Interface (POSIX) - Part 2: Shell and Utilities}, IEEE Inc, 1993, ISBN 1-55937-255-9."
msgstr "@cite{IEEE Standard for information Technology - Portable Operating System Interface (POSIX) - Part 2: Shell and Utilities}, IEEE Inc, 1993, ISBN 1-55937-255-9."

#. type: cindex
#: zsh.texi:519
#, no-wrap
msgid "roadmap"
msgstr "路线图"

#. type: Plain text
#: zsh.texi:524
msgid ""
"The Zsh Manual, like the shell itself, is large and often complicated.  This section of the manual provides some pointers to areas of the shell that are likely to be of particular interest to new users, "
"and indicates where in the rest of the manual the documentation is to be found."
msgstr "Zsh 手册，就像 shell 本身一样，庞大而复杂。 手册的这一部分为新用户可能特别感兴趣的 shell 领域提供了一些提示，并指出了在手册其余部分在文档中的位置。"

#. type: section
#: zsh.texi:527
#, no-wrap
msgid "When the shell starts"
msgstr "当 shell 启动时"

#. type: Plain text
#: zsh.texi:533
msgid "When it starts, the shell reads commands from various files.  These can be created or edited to customize the shell.  See @ref{Files}."
msgstr "shell 启动时会从各种文件中读取命令。 可以创建或编辑这些文件来定制 shell。 参见 @ref{文件}。"

#. type: Plain text
#: zsh.texi:542
msgid ""
"If no personal initialization files exist for the current user, a function is run to help you change some of the most common settings.  It won't appear if your administrator has disabled the @t{zsh/"
"newuser} module.  The function is designed to be self-explanatory.  You can run it by hand with `@t{autoload -Uz zsh-newuser-install; zsh-newuser-install -f}'.  See also @ref{User Configuration Functions}."
msgstr ""
"如果当前用户不存在个人初始化文件，则会运行一个函数来帮助您更改一些最常用的设置。 如果管理员禁用了 @t{zsh/newuser} 模块，该函数将不会出现。 该函数的设计不言自明。 你可以使用`@t{autoload -Uz zsh-newuser-"
"install; zsh-newuser-install -f}'手动运行它。 另请参阅 @ref{用户配置函数}。"

#. type: section
#: zsh.texi:545
#, no-wrap
msgid "Interactive Use"
msgstr "互动式使用"

#. type: Plain text
#: zsh.texi:551
msgid "Interaction with the shell uses the builtin Zsh Line Editor, ZLE.  This is described in detail in @ref{Zsh Line Editor}."
msgstr "与 shell 的交互使用内置的 Zsh 行编辑器（ZLE）。 @ref{Zsh 行编辑器}中对此有详细介绍。"

#. type: Plain text
#: zsh.texi:557
msgid ""
"The first decision a user must make is whether to use the Emacs or Vi editing mode as the keys for editing are substantially different.  Emacs editing mode is probably more natural for beginners and can "
"be selected explicitly with the command @t{bindkey -e}."
msgstr "用户必须做出的第一个决定是使用 Emacs 还是 Vi 编辑模式，因为两者的编辑键大不相同。 对于初学者来说，Emacs 编辑模式可能更为自然，可以使用 @t{bindkey -e} 命令明确选择。"

#. type: Plain text
#: zsh.texi:568
msgid ""
"A history mechanism for retrieving previously typed lines (most simply with the Up or Down arrow keys) is available; note that, unlike other shells, zsh will not save these lines when the shell exits "
"unless you set appropriate variables, and the number of history lines retained by default is quite small (30 lines).  See the description of the shell variables (referred to in the documentation as "
"parameters) @t{HISTFILE}, @t{HISTSIZE} and @t{SAVEHIST} in @ref{Parameters Used By The Shell}.  Note that it's currently only possible to read and write files saving history when the shell is interactive, "
"i.e. it does not work from scripts."
msgstr ""
"历史记录机制可用于检索以前键入的行（最简单的方法是使用向上或向下箭头键）；请注意，与其他 shell 不同，zsh 在退出 shell 时不会保存这些行，除非您设置了适当的变量，而且默认情况下保留的历史行数很少（30 行）。请"
"参阅 @ref{Shell 使用的参数} 中对 shell 变量（在文档中称为参数）@t{HISTFILE}、@t{HISTSIZE} 和 @t{SAVEHIST} 的描述。 需要注意的是，目前只有在 shell 处于交互状态时才能读写保存历史的文件，也就是说，它无法通过"
"脚本工作。"

#. type: Plain text
#: zsh.texi:586
msgid ""
"The shell now supports the UTF-8 character set (and also others if supported by the operating system).  This is (mostly) handled transparently by the shell, but the degree of support in terminal emulators "
"is variable.  There is some discussion of this in the shell FAQ, @t{@uref{https://www.zsh.org/FAQ/}}.  Note in particular that for combining characters to be handled the option @t{COMBINING_CHARS} needs "
"to be set.  Because the shell is now more sensitive to the definition of the character set, note that if you are upgrading from an older version of the shell you should ensure that the appropriate "
"variable, either @t{LANG} (to affect all aspects of the shell's operation) or @t{LC_CTYPE} (to affect only the handling of character sets) is set to an appropriate value.  This is true even if you are "
"using a single-byte character set including extensions of ASCII such as @t{ISO-8859-1} or @t{ISO-8859-15}.  See the description of @t{LC_CTYPE} in @ref{Parameters}."
msgstr ""
"shell 现在支持 UTF-8 字符集（以及操作系统支持的其他字符集）。 这（大部分）由 shell 透明处理，但终端模拟器的支持程度不一。 shell FAQ @t{@uref{https://www.zsh.org/FAQ/}}中对此有一些讨论。 请特别注意，要处理"
"组合字符，需要设置 @t{COMBINING_CHARS} 选项。 由于 shell 现在对字符集的定义更加敏感，因此如果您是从旧版本的 shell 升级，则应确保设置了 @t{LANG}（影响 shell 运行的所有方面）或 @t{LC_CTYPE}（仅影响字符集的处"
"理）这两个变量。(只影响字符集的处理）设置为适当的值。 即使使用的是单字节字符集，包括 ASCII 扩展字符集，如 @t{ISO-8859-1} 或 @t{ISO-8859-15}，也是如此。 请参阅 @ref{参数} 中 @t{LC_CTYPE} 的描述。"

#. type: subsection
#: zsh.texi:589 zsh.texi:9907 zsh.texi:18366 zsh.texi:18422 zsh.texi:18424 zsh.texi:18499 zsh.texi:35442
#, no-wrap
msgid "Completion"
msgstr "补全"

#. type: Plain text
#: zsh.texi:601
msgid ""
"Completion is a feature present in many shells. It allows the user to type only a part (usually the prefix) of a word and have the shell fill in the rest.  The completion system in zsh is programmable.  "
"For example, the shell can be set to complete email addresses in arguments to the mail command from your @t{~/.abook/addressbook}; usernames, hostnames, and even remote paths in arguments to scp, and so "
"on.  Anything that can be written in or glued together with zsh can be the source of what the line editor offers as possible completions."
msgstr ""
"补全是许多 shell 中都有的一项功能。它允许用户只键入单词的一部分（通常是前缀），然后由 shell 来补全其余部分。 zsh 中的补全系统是可编程的。 例如，可以设置 shell 在 @t{~/.abook/addressbook} 的邮件命令参数中补"
"全电子邮件地址；在 scp 的参数中补全用户名、主机名甚至远程路径，等等。 任何可以用 zsh 写入或粘合在一起的内容都可以成为行编辑器提供的可能补全内容的来源。"

#. type: Plain text
#: zsh.texi:611
msgid ""
"Zsh has two completion systems, an old, so called @t{compctl} completion (named after the builtin command that serves as its complete and only user interface), and a new one, referred to as @t{compsys}, "
"organized as library of builtin and user-defined functions.  The two systems differ in their interface for specifying the completion behavior.  The new system is more customizable and is supplied with "
"completions for many commonly used commands; it is therefore to be preferred."
msgstr ""
"Zsh 有两个补全系统，一个是旧的补全系统，即 @t{compctl}（以作为其完整且唯一用户界面的内置命令命名），另一个是新的补全系统，即 @t{compsys}，由内置函数库和用户自定义函数库组成。 这两个系统在指定补全行为的界面"
"上有所不同。 新系统的可定制性更强，并为许多常用命令提供了补全功能，因此更受欢迎。"

#. type: Plain text
#: zsh.texi:616
msgid "The completion system must be enabled explicitly when the shell starts.  For more information see @ref{Completion System}."
msgstr "必须在 shell 启动时明确启用补全系统。 更多信息，请参阅 @ref{补全系统}。"

#. type: subsection
#: zsh.texi:619
#, no-wrap
msgid "Extending the line editor"
msgstr "扩展行编辑器"

#. type: Plain text
#: zsh.texi:626
msgid "Apart from completion, the line editor is highly extensible by means of shell functions.  Some useful functions are provided with the shell; they provide facilities such as:"
msgstr "除补全功能外，行编辑器还可通过 shell 函数进行高度扩展。 shell 提供了一些有用的功能，如"

#. type: t{#1}
#: zsh.texi:629 zsh.texi:38722 zsh.texi:38723
#, no-wrap
msgid "insert-composed-char"
msgstr "insert-composed-char"

#. type: table
#: zsh.texi:631
msgid "composing characters not found on the keyboard"
msgstr "编写键盘上没有的字符"

#. type: tindex
#: zsh.texi:632 zsh.texi:38133
#, no-wrap
msgid "match-words-by-style"
msgstr "match-words-by-style"

#. type: table
#: zsh.texi:635
msgid "configuring what the line editor considers a word when moving or deleting by word"
msgstr "在按字移动或删除时，配置行编辑器认为什么是字"

#. type: item
#: zsh.texi:636
#, no-wrap
msgid "@t{history-beginning-search-backward-end}, etc."
msgstr "@t{history-beginning-search-backward-end}, 等等。"

#. type: table
#: zsh.texi:638
msgid "alternative ways of searching the shell history"
msgstr "搜索 shell 历史记录的其他方法"

#. type: item
#: zsh.texi:639 zsh.texi:39241
#, no-wrap
msgid "@t{replace-string}, @t{replace-pattern}"
msgstr "@t{replace-string}, @t{replace-pattern}"

#. type: table
#: zsh.texi:641
msgid "functions for replacing strings or patterns globally in the command line"
msgstr "在命令行中全局替换字符串或模式的函数"

#. type: t{#1}
#: zsh.texi:642 zsh.texi:38587 zsh.texi:38588
#, no-wrap
msgid "edit-command-line"
msgstr "edit-command-line"

#. type: table
#: zsh.texi:644
msgid "edit the command line with an external editor."
msgstr "使用外部编辑器编辑命令行。"

#. type: Plain text
#: zsh.texi:649
msgid "See @ref{ZLE Functions} for descriptions of these."
msgstr "请参阅 @ref{ZLE 函数}，了解这些函数的描述。"

#. type: Plain text
#: zsh.texi:660
msgid ""
"The shell has a large number of options for changing its behaviour.  These cover all aspects of the shell; browsing the full documentation is the only good way to become acquainted with the many "
"possibilities.  See @ref{Options}."
msgstr "shell 有大量用于改变其行为的选项。 这些选项涵盖了 shell 的方方面面；浏览完整的文档是熟悉众多选项的唯一好方法。 参见 @ref{选项}。"

#. type: section
#: zsh.texi:663
#, no-wrap
msgid "Pattern Matching"
msgstr "模式匹配"

#. type: Plain text
#: zsh.texi:671
msgid ""
"The shell has a rich set of patterns which are available for file matching (described in the documentation as `filename generation' and also known for historical reasons as `globbing') and for use when "
"programming.  These are described in @ref{Filename Generation}."
msgstr "shell 有一套丰富的模式，可用于文件匹配（在文档中称为 `文件名生成'，由于历史原因也称为 `globbing'）和编程。 这些模式在 @ref{文件名生成} 中有所描述。"

#. type: Plain text
#: zsh.texi:675
msgid "Of particular interest are the following patterns that are not commonly supported by other systems of pattern matching:"
msgstr "Of particular interest are the following patterns that are not commonly supported by other systems of pattern matching:"

#. type: t{#1}
#: zsh.texi:678 zsh.texi:3359 zsh.texi:3396
#, no-wrap
msgid "**"
msgstr "**"

#. type: table
#: zsh.texi:680
msgid "for matching over multiple directories"
msgstr "用于匹配多个目录"

#. type: t{#1}
#: zsh.texi:681 zsh.texi:3357 zsh.texi:3412
#, no-wrap
msgid "|"
msgstr "|"

#. type: table
#: zsh.texi:683
msgid "for matching either of two alternatives"
msgstr "用于匹配两个备选方案中的任何一个"

#. type: item
#: zsh.texi:684
#, no-wrap
msgid "@t{~}, @t{^}"
msgstr "@t{~}, @t{^}"

#. type: table
#: zsh.texi:687
msgid "the ability to exclude patterns from matching when the @t{EXTENDED_GLOB} option is set"
msgstr "当设置 @t{EXTENDED_GLOB} 选项时，能够从匹配中排除模式"

#. type: item
#: zsh.texi:688
#, no-wrap
msgid "@t{(}@var{...}@t{)}"
msgstr "@t{(}@var{...}@t{)}"

#. type: table
#: zsh.texi:692
msgid "glob qualifiers, included in parentheses at the end of the pattern, which select files by type (such as directories) or attribute (such as size)."
msgstr "glob 限定符，包含在模式末尾的括号中，可按类型（如目录）或属性（如大小）选择文件。"

#. type: section
#: zsh.texi:697
#, no-wrap
msgid "General Comments on Syntax"
msgstr "关于语法的一般性评论"

#. type: Plain text
#: zsh.texi:705
msgid ""
"Although the syntax of zsh is in ways similar to the Korn shell, and therefore more remotely to the original UNIX shell, the Bourne shell, its default behaviour does not entirely correspond to those "
"shells.  General shell syntax is introduced in @ref{Shell Grammar}."
msgstr "尽管 zsh 的语法在某些方面与 Korn shell 相似，因此更接近于最初的 UNIX shell，即 Bourne shell，但其默认行为并不完全与这些 shell 一致。 一般 shell 语法在 @ref{Shell 语法} 中介绍。"

#. type: Plain text
#: zsh.texi:714
msgid ""
"One commonly encountered difference is that variables substituted onto the command line are not split into words.  See the description of the shell option @t{SH_WORD_SPLIT} in @ref{Parameter Expansion}.  "
"In zsh, you can either explicitly request the splitting (e.g. @t{$@{=foo@}})  or use an array when you want a variable to expand to more than one word.  See @ref{Array Parameters}."
msgstr ""
"一个常见的区别是，替换到命令行中的变量不会被分割成单词。 参见 @ref{ 参数扩展} 中 shell 选项 @t{SH_WORD_SPLIT} 的描述。 在 zsh 中，您可以明确请求分割（例如 @t{$@{=foo@}}），或者在希望变量扩展为多个单词时使"
"用数组。 请参见 @ref{数组参数}。"

#. type: section
#: zsh.texi:717
#, no-wrap
msgid "Programming"
msgstr "编程"

#. type: Plain text
#: zsh.texi:726
msgid ""
"The most convenient way of adding enhancements to the shell is typically by writing a shell function and arranging for it to be autoloaded.  Functions are described in @ref{Functions}.  Users changing "
"from the C shell and its relatives should notice that aliases are less used in zsh as they don't perform argument substitution, only simple text replacement."
msgstr ""
"为 shell 添加增强功能的最便捷方法通常是编写 shell 函数，并安排其自动加载。 函数在 @ref{函数} 中有所描述。 从 C shell 及其近似 shell 转变而来的用户应该注意到，别名在 zsh 中使用较少，因为它们不执行参数替换，"
"而只是简单的文本替换。"

#. type: Plain text
#: zsh.texi:731
msgid "A few general functions, other than those for the line editor described above, are provided with the shell and are described in @ref{User Contributions}.  Features include:"
msgstr "除了上述用于行编辑器的功能外，Shell 还提供了一些常规功能，这些功能在 @ref{用户贡献} 中进行了描述。 这些功能包括:"

#. type: t{#1}
#: zsh.texi:734
#, no-wrap
msgid "promptinit"
msgstr "promptinit"

#. type: table
#: zsh.texi:736
msgid "a prompt theme system for changing prompts easily, see @ref{Prompt Themes}"
msgstr "提示符主题系统，可轻松更改提示符，请参阅 @ref{提示符主题}"

#. type: findex
#: zsh.texi:737 zsh.texi:39920
#, no-wrap
msgid "zsh-mime-setup"
msgstr "zsh-mime-setup"

#. type: table
#: zsh.texi:740
msgid "a MIME-handling system which dispatches commands according to the suffix of a file as done by graphical file managers"
msgstr "一种 MIME 处理系统，它能像图形文件管理器那样，根据文件的后缀发送命令"

#. type: findex
#: zsh.texi:741 zsh.texi:40333
#, no-wrap
msgid "zcalc"
msgstr "zcalc"

#. type: table
#: zsh.texi:743
msgid "a calculator"
msgstr "计算器"

#. type: findex
#: zsh.texi:744 zsh.texi:40941
#, no-wrap
msgid "zargs"
msgstr "zargs"

#. type: table
#: zsh.texi:746
msgid "a version of @t{xargs} that makes the @t{find} command redundant"
msgstr "@t{xargs} 的另一个版本，使 @t{find} 命令变得多余"

#. type: findex
#: zsh.texi:747 zsh.texi:41096
#, no-wrap
msgid "zmv"
msgstr "zmv"

#. type: table
#: zsh.texi:749
msgid "a command for renaming files by means of shell patterns."
msgstr "重命名文件的命令。"

#. type: node
#: zsh.texi:753 zsh.texi:1086 zsh.texi:1088 zsh.texi:1153 zsh.texi:1179
#, no-wrap
msgid "Files"
msgstr "文件"

#. type: cindex
#: zsh.texi:757
#, no-wrap
msgid "invocation"
msgstr "调用"

#. type: cindex
#: zsh.texi:761
#, no-wrap
msgid "shell options"
msgstr "shell 选项"

#. type: cindex
#: zsh.texi:762
#, no-wrap
msgid "options, shell"
msgstr "选项, shell"

#. type: cindex
#: zsh.texi:763
#, no-wrap
msgid "shell flags"
msgstr "shell 标志"

#. type: cindex
#: zsh.texi:764
#, no-wrap
msgid "flags, shell"
msgstr "标志, shell"

#. type: Plain text
#: zsh.texi:767
msgid "The following flags are interpreted by the shell when invoked to determine where the shell will read commands from:"
msgstr "调用 shell 时，shell 会解释以下标志，以确定 shell 从何处读取命令：@uref{comments/invocation.html#invocation-overview,[译注:调用]}"

#. type: t{#1}
#: zsh.texi:770 zsh.texi:12701 zsh.texi:13124 zsh.texi:14208 zsh.texi:14474 zsh.texi:15345 zsh.texi:15543 zsh.texi:25755 zsh.texi:27023 zsh.texi:37969 zsh.texi:38388
#, no-wrap
msgid "-c"
msgstr "-c"

#. type: table
#: zsh.texi:775
msgid ""
"Take the first argument as a command to execute, rather than reading commands from a script or standard input.  If any further arguments are given, the first one is assigned to @t{$0}, rather than being "
"used as a positional parameter."
msgstr ""
"将第一个参数作为要执行的命令，而不是从脚本或标准输入中读取命令。 如果还有其他参数，第一个参数会被赋值给 @t{$0}，而不是作为位置参数使用。@uref{comments/invocation.html#invocation-flag-c,[译注:调用.标志.c]}"

#. type: t{#1}
#: zsh.texi:776 zsh.texi:12623 zsh.texi:12670 zsh.texi:13612 zsh.texi:14220 zsh.texi:15351 zsh.texi:41136
#, no-wrap
msgid "-i"
msgstr "-i"

#. type: table
#: zsh.texi:779
msgid "Force shell to be interactive.  It is still possible to specify a script to execute."
msgstr "强制 shell 为交互式。 仍可指定要执行的脚本。"

#. type: t{#1}
#: zsh.texi:780 zsh.texi:12637 zsh.texi:12682 zsh.texi:12707 zsh.texi:14268 zsh.texi:14436 zsh.texi:15369 zsh.texi:15575 zsh.texi:24719 zsh.texi:30509 zsh.texi:33105 zsh.texi:33658 zsh.texi:37979
#: zsh.texi:38386 zsh.texi:41148
#, no-wrap
msgid "-s"
msgstr "-s"

#. type: table
#: zsh.texi:785
msgid "Force shell to read commands from the standard input.  If the @t{-s} flag is not present and an argument is given, the first argument is taken to be the pathname of a script to execute."
msgstr "强制 shell 从标准输入端读取命令。 如果没有 @t{-s} 标志，且给出了参数，则第一个参数将被视为要执行的脚本的路径名。"

#. type: Plain text
#: zsh.texi:797
msgid ""
"If there are any remaining arguments after option processing, and neither of the options @t{-c} or @t{-s} was supplied, the first argument is taken as the file name of a script containing shell commands "
"to be executed.  If the option @t{PATH_SCRIPT} is set, and the file name does not contain a directory path (i.e. there is no `@t{/}' in the name), first the current directory and then the command path "
"given by the variable @t{PATH} are searched for the script.  If the option is not set or the file name contains a `@t{/}' it is used directly."
msgstr ""
"如果选项处理后还有剩余参数，且未提供 @t{-c} 或 @t{-s} 选项，则第一个参数将作为包含要执行的 shell 命令的脚本文件名。 如果设置了选项 @t{PATH_SCRIPT}，且文件名不包含目录路径（即文件名中没有`@t{/}'），那么首先"
"会搜索当前目录，然后在变量 @t{PATH} 给出的命令路径中查找脚本。 如果未设置该选项或文件名中包含`@t{/}'，则直接使用该脚本。"

#. type: Plain text
#: zsh.texi:801
msgid "After the first one or two arguments have been appropriated as described above, the remaining arguments are assigned to the positional parameters."
msgstr "在前一或两个参数按上述方式分配后，其余参数将分配给位置参数。"

#. type: Plain text
#: zsh.texi:806
msgid "For further options, which are common to invocation and the @t{set} builtin, see @ref{Options}."
msgstr "有关调用和 @t{set} 内置函数通用的其他选项，请参见 @ref{选项}。"

#. type: Plain text
#: zsh.texi:820
msgid ""
"The long option `@t{-}@t{-emulate}' followed (in a separate word) by an emulation mode may be passed to the shell.  The emulation modes are those described for the @t{emulate} builtin, see @ref{Shell "
"Builtin Commands}.  The `@t{-}@t{-emulate}' option must precede any other options (which might otherwise be overridden), but following options are honoured, so may be used to modify the requested "
"emulation mode.  Note that certain extra steps are taken to ensure a smooth emulation when this option is used compared with the @t{emulate} command within the shell: for example, variables that conflict "
"with POSIX usage such as @t{path} are not defined within the shell."
msgstr ""
"可以向 shell 传递长选项`@t{-}@t{-emulate}'，后跟仿真模式（用单独的字）。 仿真模式为 @t{emulate} 内置命令所描述的模式，参见 @ref{Shell 内置命令}。`@t{-}@t{-emulate}'选项必须先于其他选项（否则可能被覆盖），"
"但后面的选项会被执行，因此可以用来修改请求的仿真模式。 需要注意的是，与 shell 中的 @t{emulate} 命令相比，在使用该选项时，会采取一些额外的步骤来确保仿真的顺利进行：例如，不会在 shell 中定义与 POSIX 使用相冲"
"突的变量，如 @t{path}。"

#. type: Plain text
#: zsh.texi:825
msgid "Options may be specified by name using the @t{-o} option.  @t{-o} acts like a single-letter option, but takes a following string as the option name.  For example,"
msgstr "可以使用 @t{-o} 选项指定选项名称。 @t{-o} 的作用与单字母选项类似，但选项名称需要使用下面的字符串。 例如"

#. type: example
#: zsh.texi:829
#, no-wrap
msgid "zsh -x -o shwordsplit scr\n"
msgstr "zsh -x -o shwordsplit scr\n"

#. type: Plain text
#: zsh.texi:838
msgid ""
"runs the script @t{scr}, setting the @t{XTRACE} option by the corresponding letter `@t{-x}' and the @t{SH_WORD_SPLIT} option by name.  Options may be turned @emph{off} by name by using @t{+o} instead of "
"@t{-o}.  @t{-o} can be stacked up with preceding single-letter options, so for example `@t{-xo shwordsplit}' or `@t{-xoshwordsplit}' is equivalent to `@t{-x -o shwordsplit}'."
msgstr ""
"运行脚本 @t{scr}，用相应的字母`@t{-x}'设置 @t{XTRACE} 选项，用名称设置 @t{SH_WORD_SPLIT} 选项。 使用 @t{+o} 代替 @t{-o}，可以按名称 @emph{关闭} 选项。 @t{-o} 可以与前面的单字母选项叠加，例如，`@t{-xo "
"shwordsplit}'或`@t{-xoshwordsplit}'等同于`@t{-x -o shwordsplit}'。"

#. type: cindex
#: zsh.texi:840
#, no-wrap
msgid "long option"
msgstr "长选项"

#. type: Plain text
#: zsh.texi:851
msgid ""
"Options may also be specified by name in GNU long option style, `@t{-}@t{-}@var{option-name}'.  When this is done, `@t{-}' characters in the option name are permitted: they are translated into `@t{_}', "
"and thus ignored.  So, for example, `@t{zsh -}@t{-sh-word-split}' invokes zsh with the @t{SH_WORD_SPLIT} option turned on.  Like other option syntaxes, options can be turned off by replacing the initial "
"`@t{-}' with a `@t{+}'; thus `@t{+-sh-word-split}' is equivalent to `@t{-}@t{-no-sh-word-split}'.  Unlike other option syntaxes, GNU-style long options cannot be stacked with any other options, so for "
"example `@t{-x-shwordsplit}' is an error, rather than being treated like `@t{-x -}@t{-shwordsplit}'."
msgstr ""
"选项名称也可以用 GNU 长选项风格指定，即`@t{-}@t{-}@var{option-name}'。 这样做时，选项名称中的`@t{-}'字符是允许的：它们会被翻译成`@t{_}'，因此会被忽略。 因此，举例来说，`@t{zsh -}@t{-sh-word-split}'调用的是"
"打开 @t{SH_WORD_SPLIT} 选项的 zsh。 与其他选项语法一样，可以通过用`@t{+}'替换开头的`@t{-}'来关闭选项；因此`@t{+-sh-word-split}'等同于`@t{-}@t{-no-sh-word-split}'。 与其他选项语法不同，GNU 风格的长选项不能"
"与任何其他选项堆叠，因此，例如 `@t{-x-shwordsplit}'是一个错误，而不是像 `@t{-x -}@t{-shwordsplit}'那样处理。"

#. type: cindex
#: zsh.texi:853
#, no-wrap
msgid "--version"
msgstr "--version"

#. type: cindex
#: zsh.texi:854
#, no-wrap
msgid "--help"
msgstr "--help"

#. type: Plain text
#: zsh.texi:859
msgid ""
"The special GNU-style option `@t{-}@t{-version}' is handled; it sends to standard output the shell's version information, then exits successfully.  `@t{-}@t{-help}' is also handled; it sends to standard "
"output a list of options that can be used when invoking the shell, then exits successfully."
msgstr "特殊的 GNU 风格选项`@t{-}@t{-version}'会被处理；它会向标准输出发送 shell 的版本信息，然后成功退出。 `@t{-}@t{-help}' 也会被处理；它会向标准输出发送调用 shell 时可以使用的选项列表，然后成功退出。"

#. type: Plain text
#: zsh.texi:871
msgid ""
"Option processing may be finished, allowing following arguments that start with `@t{-}' or `@t{+}' to be treated as normal arguments, in two ways.  Firstly, a lone `@t{-}' (or `@t{+}') as an argument by "
"itself ends option processing.  Secondly, a special option `@t{-}@t{-}' (or `@t{+-}'), which may be specified on its own (which is the standard POSIX usage) or may be stacked with preceding options (so "
"`@t{-x-}' is equivalent to `@t{-x -}@t{-}').  Options are not permitted to be stacked after `@t{-}@t{-}' (so `@t{-x-f}' is an error), but note the GNU-style option form discussed above, where `@t{-}@t{-"
"shwordsplit}' is permitted and does not end option processing."
msgstr ""
"选项处理可以通过两种方式完成，即允许将后面以`@t{-}' 或 `@t{+}'开头的参数视为普通参数。 首先，单独的参数`@t{-}'（或`@t{+}'）本身会结束选项处理。 其次，特殊选项`@t{-}@t{-}' (或 `@t{+-}')可以单独指定（这是 "
"POSIX 的标准用法），也可以与前面的选项堆叠（因此`@t{-x-}'等同于`@t{-x -}@t{-}'）。 选项不允许堆叠在`@t{-}@t{-}'之后（因此`@t{-x-f}'是错误的），但请注意上文讨论的 GNU 风格选项形式，其中`@t{-}@t{-"
"shwordsplit}'是允许的，并且不会结束选项处理。"

#. type: Plain text
#: zsh.texi:877
msgid ""
"Except when the @cite{sh}/@cite{ksh} emulation single-letter options are in effect, the option `@t{-b}' (or `@t{+b}') ends option processing.  `@t{-b}' is like `@t{-}@t{-}', except that further single-"
"letter options can be stacked after the `@t{-b}' and will take effect as normal."
msgstr "除非启用了 @cite{sh}/@cite{ksh} 模拟单字母选项效果，否则选项`@t{-b}' (或 `@t{+b}') 会结束选项处理。 `@t{-b}'类似于`@t{-}@t{-}'，只是在`@t{-b}' 之后可以堆叠更多的单字母选项，并按正常方式生效。"

#. type: node
#: zsh.texi:886 zsh.texi:888 zsh.texi:975
#, no-wrap
msgid "Compatibility"
msgstr "兼容性"

#. type: cindex
#: zsh.texi:890
#, no-wrap
msgid "compatibility"
msgstr "兼容性"

#. type: cindex
#: zsh.texi:891
#, no-wrap
msgid "sh compatibility"
msgstr "sh 兼容性"

#. type: cindex
#: zsh.texi:892
#, no-wrap
msgid "ksh compatibility"
msgstr "ksh 兼容性"

#. type: Plain text
#: zsh.texi:901
msgid ""
"Zsh tries to emulate @cite{sh} or @cite{ksh} when it is invoked as @t{sh} or @t{ksh} respectively; more precisely, it looks at the first letter of the name by which it was invoked, excluding any initial "
"`@t{r}' (assumed to stand for `restricted'), and if that is `@t{b}', `@t{s}' or `@t{k}' it will emulate @cite{sh} or @cite{ksh}.  Furthermore, if invoked as @t{su} (which happens on certain systems when "
"the shell is executed by the @t{su} command), the shell will try to find an alternative name from the @t{SHELL} environment variable and perform emulation based on that."
msgstr ""
"当 Zsh 分别以 @t{sh} 或 @t{ksh} 的方式调用时，它会尝试模拟 @cite{sh} 或 @cite{ksh}；更确切地说，它会查看调用名称的第一个字母，不包括任何首字母`@t{r}'（假定代表 \"受限\"），如果是`@t{b}'、`@t{s}'或`@t{k}'，"
"它就会模拟 @cite{sh} 或 @cite{ksh}。 此外，如果以 @t{su} 的方式调用 shell（在某些系统中，通过 @t{su} 命令执行 shell 时会出现这种情况），shell 会尝试从 @t{SHELL} 环境变量中找到一个替代名称，并以此为基础进行"
"仿真。"

#. type: Plain text
#: zsh.texi:922
msgid ""
"In @cite{sh} and @cite{ksh} compatibility modes the following parameters are not special and not initialized by the shell: @t{ARGC}, @t{argv}, @t{cdpath}, @t{fignore}, @t{fpath}, @t{HISTCHARS}, "
"@t{mailpath}, @t{MANPATH}, @t{manpath}, @t{path}, @t{prompt}, @t{PROMPT}, @t{PROMPT2}, @t{PROMPT3}, @t{PROMPT4}, @t{psvar}, @t{status}."
msgstr ""
"在 @cite{sh} 和 @cite{ksh} 兼容模式下，以下参数并不特殊，也不会被 shell 初始化: @t{ARGC}, @t{argv}, @t{cdpath}, @t{fignore}, @t{fpath}, @t{HISTCHARS}, @t{mailpath}, @t{MANPATH}, @t{manpath}, @t{path}, "
"@t{prompt}, @t{PROMPT}, @t{PROMPT2}, @t{PROMPT3}, @t{PROMPT4}, @t{psvar}, @t{status}."

#. type: vindex
#: zsh.texi:924
#, no-wrap
msgid "ENV, use of"
msgstr "ENV, use of"

#. type: Plain text
#: zsh.texi:932
msgid ""
"The usual zsh startup/shutdown scripts are not executed.  Login shells source @t{/etc/profile} followed by @t{$HOME/.profile}.  If the @t{ENV} environment variable is set on invocation, @t{$ENV} is "
"sourced after the profile scripts.  The value of @t{ENV} is subjected to parameter expansion, command substitution, and arithmetic expansion before being interpreted as a pathname.  Note that the "
"@t{PRIVILEGED} option also affects the execution of startup files."
msgstr ""
"通常的 zsh 启动/关闭脚本不会被执行。 登录 shell 引入（source） @t{/etc/profile}，然后是 @t{$HOME/.profile}。 如果在调用时设置了 @t{ENV} 环境变量，则 @t{$ENV} 会在 profile 脚本之后引入（sourced）。 在将 "
"@t{ENV} 的值解释为路径名之前，会对其进行参数扩展、命令替换和算术扩展。 请注意，@t{PRIVILEGED} 选项也会影响启动文件的执行。"

#. type: Plain text
#: zsh.texi:966
msgid ""
"The following options are set if the shell is invoked as @t{sh} or @t{ksh}: @t{NO_BAD_PATTERN}, @t{NO_BANG_HIST}, @t{NO_BG_NICE}, @t{NO_EQUALS}, @t{NO_FUNCTION_ARGZERO}, @t{GLOB_SUBST}, "
"@t{NO_GLOBAL_EXPORT}, @t{NO_HUP}, @t{INTERACTIVE_COMMENTS}, @t{KSH_ARRAYS}, @t{NO_MULTIOS}, @t{NO_NOMATCH}, @t{NO_NOTIFY}, @t{POSIX_BUILTINS}, @t{NO_PROMPT_PERCENT}, @t{RM_STAR_SILENT}, "
"@t{SH_FILE_EXPANSION}, @t{SH_GLOB}, @t{SH_OPTION_LETTERS}, @t{SH_WORD_SPLIT}.  Additionally the @t{BSD_ECHO} and @t{IGNORE_BRACES} options are set if zsh is invoked as @t{sh}.  Also, the "
"@t{KSH_OPTION_PRINT}, @t{LOCAL_OPTIONS}, @t{PROMPT_BANG}, @t{PROMPT_SUBST} and @t{SINGLE_LINE_ZLE} options are set if zsh is invoked as @t{ksh}."
msgstr ""
"如果以 @t{sh} 或 @t{ksh} 调用 shell，则会设置以下选项: @t{NO_BAD_PATTERN}, @t{NO_BANG_HIST}, @t{NO_BG_NICE}, @t{NO_EQUALS}, @t{NO_FUNCTION_ARGZERO}, @t{GLOB_SUBST}, @t{NO_GLOBAL_EXPORT}, @t{NO_HUP}, "
"@t{INTERACTIVE_COMMENTS}, @t{KSH_ARRAYS}, @t{NO_MULTIOS}, @t{NO_NOMATCH}, @t{NO_NOTIFY}, @t{POSIX_BUILTINS}, @t{NO_PROMPT_PERCENT}, @t{RM_STAR_SILENT}, @t{SH_FILE_EXPANSION}, @t{SH_GLOB}, "
"@t{SH_OPTION_LETTERS}, @t{SH_WORD_SPLIT}.  此外，如果以 @t{sh} 的方式调用 zsh，则会设置 @t{BSD_ECHO} 和 @t{IGNORE_BRACES} 选项。 如果以 @t{ksh} 的方式调用 zsh，还会设置 @t{KSH_OPTION_PRINT}、"
"@t{LOCAL_OPTIONS}、@t{PROMPT_BANG}、@t{PROMPT_SUBST} 和 @t{SINGLE_LINE_ZLE} 选项。"

#. type: Plain text
#: zsh.texi:975
msgid ""
"Please note that, whilst reasonable efforts are taken to address incompatibilities when they arise, zsh does not guarantee complete emulation of other shells, nor POSIX compliance. For more information on "
"the differences between zsh and other shells, please refer to chapter 2 of the shell FAQ, @t{@uref{https://www.zsh.org/FAQ/}}."
msgstr ""
"请注意，尽管在出现不兼容问题时，zsh 会尽力解决，但并不保证完全模拟其他 shell，也不保证符合 POSIX。有关 zsh 与其他 shell 之间差异的更多信息，请参阅 shell 常见问题 第 2 章 @t{@uref{https://www.zsh.org/"
"FAQ/}}。"

#. type: cindex
#: zsh.texi:979 zsh.texi:12295
#, no-wrap
msgid "restricted shell"
msgstr "受限的 shell"

#. type: table
#: zsh.texi:980 zsh.texi:12292 zsh.texi:12637 zsh.texi:12682
#, no-wrap
msgid "RESTRICTED"
msgstr "RESTRICTED"

#. type: Plain text
#: zsh.texi:986
msgid ""
"When the basename of the command used to invoke zsh starts with the letter `@t{r}' or the `@t{-r}' command line option is supplied at invocation, the shell becomes restricted.  Emulation mode is "
"determined after stripping the letter `@t{r}' from the invocation name.  The following are disabled in restricted mode:"
msgstr "当用于调用 zsh 的命令基名以字母`@t{r}'开头，或在调用时提供了`@t{-r}'命令行选项时，shell 将成为受限模式。 仿真模式是在去掉调用名称中的字母 `@t{r}' 后确定的。 在受限模式下，以下功能将被禁用："

#. type: itemize
#: zsh.texi:992
msgid "changing directories with the @t{cd} builtin"
msgstr "使用 @t{cd} 内置命令更改目录"

#. type: itemize
#: zsh.texi:998
msgid ""
"changing or unsetting the @t{EGID}, @t{EUID}, @t{GID}, @t{HISTFILE}, @t{HISTSIZE}, @t{IFS}, @t{LD_AOUT_LIBRARY_PATH}, @t{LD_AOUT_PRELOAD}, @t{LD_LIBRARY_PATH}, @t{LD_PRELOAD}, @t{MODULE_PATH}, "
"@t{module_path}, @t{PATH}, @t{path}, @t{SHELL}, @t{UID} and @t{USERNAME} parameters"
msgstr ""
"更改或取消设置 @t{EGID}, @t{EUID}, @t{GID}, @t{HISTFILE}, @t{HISTSIZE}, @t{IFS}, @t{LD_AOUT_LIBRARY_PATH}, @t{LD_AOUT_PRELOAD}, @t{LD_LIBRARY_PATH}, @t{LD_PRELOAD}, @t{MODULE_PATH}, @t{module_path}, "
"@t{PATH}, @t{path}, @t{SHELL}, @t{UID} 和 @t{USERNAME} 参数"

#. type: itemize
#: zsh.texi:1000
msgid "specifying command names containing @t{/}"
msgstr "指定包含 @t{/} 的命令名称"

#. type: itemize
#: zsh.texi:1002
msgid "specifying command pathnames using @t{hash}"
msgstr "使用 @t{hash} 指定命令路径名"

#. type: itemize
#: zsh.texi:1004
msgid "redirecting output to files"
msgstr "将输出重定向到文件"

#. type: itemize
#: zsh.texi:1007
msgid "using the @t{exec} builtin command to replace the shell with another command"
msgstr "使用 @t{exec} 内置命令将 shell 替换为另一条命令"

#. type: itemize
#: zsh.texi:1010
msgid "using @t{jobs -Z} to overwrite the shell process' argument and environment space"
msgstr "使用 @t{jobs -Z} 覆盖 shell 进程的参数和环境空间"

#. type: itemize
#: zsh.texi:1013
msgid "using the @t{ARGV0} parameter to override @t{argv[0]} for external commands"
msgstr "使用 @t{ARGV0} 参数覆盖外部命令的 @t{argv[0]}"

#. type: itemize
#: zsh.texi:1016
msgid "turning off restricted mode with @t{set +r} or @t{unsetopt RESTRICTED}"
msgstr "使用 @t{set +r} 或 @t{unsetopt RESTRICTED} 关闭受限模式"

#. type: Plain text
#: zsh.texi:1023
msgid ""
"These restrictions are enforced after processing the startup files.  The startup files should set up @t{PATH} to point to a directory of commands which can be safely invoked in the restricted "
"environment.  They may also add further restrictions by disabling selected builtins."
msgstr "这些限制会在处理启动文件后执行。 启动文件应设置 @t{PATH}，指向可在受限环境中安全调用的命令目录。 启动文件还可以通过禁用选定的内置命令来添加更多限制。"

#. type: Plain text
#: zsh.texi:1029
msgid ""
"Restricted mode can also be activated any time by setting the @t{RESTRICTED} option.  This immediately enables all the restrictions described above even if the shell still has not processed all startup "
"files."
msgstr "受限模式也可以通过设置 @t{RESTRICTED} 选项随时激活。 即使 shell 仍未处理完所有启动文件，也能立即启用上述所有限制。"

#. type: Plain text
#: zsh.texi:1035
msgid ""
"A shell @emph{Restricted Mode} is an outdated way to restrict what users may do: modern systems have better, safer and more reliable ways to confine user actions, such as @emph{chroot jails}, "
"@emph{containers} and @emph{zones}."
msgstr "shell的 @emph{受限模式} 是一种过时的限制用户行为的方法：现代系统有更好、更安全、更可靠的方法来限制用户行为，例如 @emph{chroot jails}、@emph{containers} 和 @emph{zones}。"

#. type: Plain text
#: zsh.texi:1039
msgid "A restricted shell is very difficult to implement safely.  The feature may be removed in a future version of zsh."
msgstr "限制的 shell 很难安全地实现。 该功能可能会在未来的 zsh 版本中删除。"

#. type: Plain text
#: zsh.texi:1046
msgid ""
"It is important to realise that the restrictions only apply to the shell, not to the commands it runs (except for some shell builtins).  While a restricted shell can only run the restricted list of "
"commands accessible via the predefined `@t{PATH}' variable, it does not prevent those commands from running any other command."
msgstr ""
"需要注意的是，这些限制只适用于 shell，而不适用于 shell 运行的命令（某些 shell 内置命令除外）。 虽然受限的 shell 只能运行通过预定义的`@t{PATH}'变量访问的受限命令列表，但并不能阻止这些命令运行任何其他命令。"

#. type: Plain text
#: zsh.texi:1051
msgid "As an example, if `@t{env}' is among the list of @emph{allowed} commands, then it allows the user to run any command as `@t{env}' is not a shell builtin command and can run arbitrary executables."
msgstr "例如，如果 @emph{允许} 命令列表中有`@t{env}'，则允许用户运行任何命令，因为 `@t{env}' 不是 shell 内置命令，可以运行任意可执行文件。"

#. type: Plain text
#: zsh.texi:1056
msgid ""
"So when implementing a restricted shell framework it is important to be fully aware of what actions each of the @emph{allowed} commands or features (which may be regarded as @emph{modules}) can perform."
msgstr "因此，在实施受限的 shell 框架时，必须充分了解每个 @emph{允许} 的命令或功能（可视为 @emph{模块}）可以执行哪些操作。"

#. type: Plain text
#: zsh.texi:1061
msgid "Many commands can have their behaviour affected by environment variables.  Except for the few listed above, zsh does not restrict the setting of environment variables."
msgstr "许多命令的行为都会受到环境变量的影响。 除上述少数命令外，zsh 并不限制环境变量的设置。"

#. type: Plain text
#: zsh.texi:1071
msgid ""
"If a `@t{perl}', `@t{python}', `@t{bash}', or other general purpose interpreted script it treated as a restricted command, the user can work around the restriction by setting specially crafted "
"`@t{PERL5LIB}', `@t{PYTHONPATH}', `@t{BASHENV}' (etc.) environment variables. On GNU systems, any command can be made to run arbitrary code when performing character set conversion (including zsh itself) "
"by setting a `@t{GCONV_PATH}' environment variable.  Those are only a few examples."
msgstr ""
"如果 `@t{perl}'、`@t{python}'、 `@t{bash}'或其他通用解释脚本被视为受限命令，用户可以通过设置特制的`@t{PERL5LIB}'、`@t{PYTHONPATH}'、 `@t{BASHENV}' （等）环境变量来规避限制。在 GNU 系统中，通过设置 "
"`@t{GCONV_PATH}'环境变量，任何命令都可以在执行字符集转换时运行任意代码（包括 zsh 本身）。 以上只是几个例子。"

#. type: Plain text
#: zsh.texi:1076
msgid "Bear in mind that, contrary to some other shells, `@t{readonly}' is not a security feature in zsh as it can be undone and so cannot be used to mitigate the above."
msgstr "请记住，与其他一些 shell 不同，`@t{readonly}'在 zsh 中并不是一种安全功能，因为它可以被撤销，所以不能用来缓解上述问题。"

#. type: Plain text
#: zsh.texi:1086
msgid ""
"A restricted shell only works if the allowed commands are few and carefully written so as not to grant more access to users than intended.  It is also important to restrict what zsh module the user may "
"load as some of them, such as `@t{zsh/system}', `@t{zsh/mapfile}' and `@t{zsh/files}', allow bypassing most of the restrictions."
msgstr ""
"受限的 shell 只有在允许的命令较少且编写谨慎以避免授予用户超出预期的访问权限时才会起作用。 限制用户可以加载的 zsh 模块也很重要，因为其中一些模块（如`@t{zsh/system}'、`@t{zsh/mapfile}'和 `@t{zsh/files}'）可"
"以绕过大部分限制。"

#. type: section
#: zsh.texi:1091
#, no-wrap
msgid "Startup/Shutdown Files"
msgstr "启动/关闭文件"

#. type: cindex
#: zsh.texi:1093
#, no-wrap
msgid "files, startup"
msgstr "文件, 启动"

#. type: cindex
#: zsh.texi:1094
#, no-wrap
msgid "startup files"
msgstr "启动文件"

#. type: cindex
#: zsh.texi:1095
#, no-wrap
msgid "files, shutdown"
msgstr "文件, 关闭"

#. type: cindex
#: zsh.texi:1096
#, no-wrap
msgid "shutdown files"
msgstr "关闭文件"

#. type: pindex
#: zsh.texi:1097
#, no-wrap
msgid "RCS, use of"
msgstr "RCS, use of"

#. type: pindex
#: zsh.texi:1098
#, no-wrap
msgid "GLOBAL_RCS, use of"
msgstr "GLOBAL_RCS, use of"

#. type: pindex
#: zsh.texi:1099
#, no-wrap
msgid "NO_RCS, use of"
msgstr "NO_RCS, use of"

#. type: pindex
#: zsh.texi:1100
#, no-wrap
msgid "NO_GLOBAL_RCS, use of"
msgstr "NO_GLOBAL_RCS, use of"

#. type: vindex
#: zsh.texi:1101
#, no-wrap
msgid "ZDOTDIR, use of"
msgstr "ZDOTDIR, use of"

#. type: cindex
#: zsh.texi:1102
#, no-wrap
msgid "zshenv"
msgstr "zshenv"

#. type: Plain text
#: zsh.texi:1113
msgid ""
"Commands are first read from @t{/etc/zshenv}; this cannot be overridden.  Subsequent behaviour is modified by the @t{RCS} and @t{GLOBAL_RCS} options; the former affects all startup files, while the second "
"only affects global startup files (those shown here with an path starting with a @t{/}).  If one of the options is unset at any point, any subsequent startup file(s)  of the corresponding type will not be "
"read.  It is also possible for a file in @t{$ZDOTDIR} to re-enable @t{GLOBAL_RCS}. Both @t{RCS} and @t{GLOBAL_RCS} are set by default."
msgstr ""
"命令首先从 @t{/etc/zshenv}中读取；该选项不可覆盖。 @t{RCS} 和 @t{GLOBAL_RCS} 选项可修改后续行为；前者影响所有启动文件，后者仅影响全局启动文件（此处显示的文件路径以 @t{/} 开头）。 如果在任何时候未设置"
"@emph{[译注:”未设置“在很多时候也是”取消设置“的意思，这时显然是”取消设置“的意思]}其中一个选项，则不会读取相应类型的后续启动文件。 @t{$ZDOTDIR} 中的文件也有可能重新启用 @t{GLOBAL_RCS}。@t{RCS} 和 "
"@t{GLOBAL_RCS} 均为默认设置。"

#. type: Plain text
#: zsh.texi:1116
msgid "Commands are then read from @t{$ZDOTDIR/.zshenv}."
msgstr "然后从 @t{$ZDOTDIR/.zshenv} 中读取命令。"

#. type: pindex
#: zsh.texi:1116
#, no-wrap
msgid "LOGIN, use of"
msgstr "LOGIN, use of"

#. type: cindex
#: zsh.texi:1117
#, no-wrap
msgid "zprofile"
msgstr "zprofile"

#. type: Plain text
#: zsh.texi:1120
msgid "If the shell is a login shell, commands are read from @t{/etc/zprofile} and then @t{$ZDOTDIR/.zprofile}."
msgstr "如果 shell 是登录 shell，命令将从 @t{/etc/zprofile} 读取，然后再从 @t{$ZDOTDIR/.zprofile} 读取。"

#. type: cindex
#: zsh.texi:1120
#, no-wrap
msgid "zshrc"
msgstr "zshrc"

#. type: Plain text
#: zsh.texi:1123
msgid "Then, if the shell is interactive, commands are read from @t{/etc/zshrc} and then @t{$ZDOTDIR/.zshrc}."
msgstr "然后，如果 shell 是交互式的，命令将从 @t{/etc/zshrc} 读取，然后再从 @t{$ZDOTDIR/.zshrc} 读取。"

#. type: cindex
#: zsh.texi:1123
#, no-wrap
msgid "zlogin"
msgstr "zlogin"

#. type: Plain text
#: zsh.texi:1126
msgid "Finally, if the shell is a login shell, @t{/etc/zlogin} and @t{$ZDOTDIR/.zlogin} are read."
msgstr "最后，如果 shell 是登录 shell，则会读取 @t{/etc/zlogin} 和 @t{$ZDOTDIR/.zlogin} 。"

#. type: cindex
#: zsh.texi:1128
#, no-wrap
msgid "zlogout"
msgstr "zlogout"

#. type: Plain text
#: zsh.texi:1138
msgid ""
"When a login shell exits, the files @t{$ZDOTDIR/.zlogout} and then @t{/etc/zlogout} are read.  This happens with either an explicit exit via the @t{exit} or @t{logout} commands, or an implicit exit by "
"reading end-of-file from the terminal.  However, if the shell terminates due to @t{exec}'ing another process, the logout files are not read.  These are also affected by the @t{RCS} and @t{GLOBAL_RCS} "
"options.  Note also that the @t{RCS} option affects the saving of history files, i.e. if @t{RCS} is unset when the shell exits, no history file will be saved."
msgstr ""
"当登录 shell 退出时，将读取 @t{$ZDOTDIR/.zlogout} 和 @t{/etc/zlogout} 文件。 这可以通过 @t{exit} 或 @t{logout} 命令显式退出，也可以通过从终端读取文件结尾隐式退出。 不过，如果由于 @t{exec} 操作了另一个进程"
"而导致 shell 终止，则不会读取注销文件。 这些文件也会受到 @t{RCS} 和 @t{GLOBAL_RCS} 选项的影响。 另外，请注意 @t{RCS} 选项会影响历史文件的保存，也就是说，如果 shell 退出时 @t{RCS} 未设置，则不会保存任何历史"
"文件。"

#. type: vindex
#: zsh.texi:1140
#, no-wrap
msgid "HOME, use of"
msgstr "HOME, use of"

#. type: Plain text
#: zsh.texi:1144
msgid "If @t{ZDOTDIR} is unset, @t{HOME} is used instead.  Files listed above as being in @t{/etc} may be in another directory, depending on the installation."
msgstr "如果 @t{ZDOTDIR} 未设置，则使用 @t{HOME} 代替。 上面列出的 @t{/etc} 中的文件可能在其他目录下，具体取决于安装情况。"

#. type: Plain text
#: zsh.texi:1152
msgid ""
"As @t{/etc/zshenv} is run for all instances of zsh, it is important that it be kept as small as possible.  In particular, it is a good idea to put code that does not need to be run for every single shell "
"behind a test of the form `@t{if [[ -o rcs ]]; then ...}' so that it will not be executed when zsh is invoked with the `@t{-f}' option."
msgstr ""
"由于 @t{/etc/zshenv} 会在 zsh 的所有实例中运行，因此必须尽可能地缩小它的规模。 特别要注意的是，最好将不需要在每个 shell 中运行的代码放在`@t{if [[ -o rcs ]]; then ...}'形式的测试后面，这样当使用`@t{-f}'选项"
"调用 zsh 时，它就不会被执行。"

#. type: cindex
#: zsh.texi:1155
#, no-wrap
msgid "files used"
msgstr "使用的文件"

#. type: t{#1}
#: zsh.texi:1157
#, no-wrap
msgid "$ZDOTDIR/.zshenv"
msgstr "$ZDOTDIR/.zshenv"

#. type: t{#1}
#: zsh.texi:1158
#, no-wrap
msgid "$ZDOTDIR/.zprofile"
msgstr "$ZDOTDIR/.zprofile"

#. type: t{#1}
#: zsh.texi:1159
#, no-wrap
msgid "$ZDOTDIR/.zshrc"
msgstr "$ZDOTDIR/.zshrc"

#. type: t{#1}
#: zsh.texi:1160
#, no-wrap
msgid "$ZDOTDIR/.zlogin"
msgstr "$ZDOTDIR/.zlogin"

#. type: t{#1}
#: zsh.texi:1161
#, no-wrap
msgid "$ZDOTDIR/.zlogout"
msgstr "$ZDOTDIR/.zlogout"

#. type: item
#: zsh.texi:1162
#, no-wrap
msgid "@t{$@{TMPPREFIX@}*}   (default is /tmp/zsh*)"
msgstr "@t{$@{TMPPREFIX@}*}   (默认是 /tmp/zsh*)"

#. type: t{#1}
#: zsh.texi:1163
#, no-wrap
msgid "/etc/zshenv"
msgstr "/etc/zshenv"

#. type: t{#1}
#: zsh.texi:1164
#, no-wrap
msgid "/etc/zprofile"
msgstr "/etc/zprofile"

#. type: t{#1}
#: zsh.texi:1165
#, no-wrap
msgid "/etc/zshrc"
msgstr "/etc/zshrc"

#. type: t{#1}
#: zsh.texi:1166
#, no-wrap
msgid "/etc/zlogin"
msgstr "/etc/zlogin"

#. type: item
#: zsh.texi:1167
#, no-wrap
msgid "@t{/etc/zlogout}    (installation-specific - @t{/etc} is the default)"
msgstr "@t{/etc/zlogout}（根据安装情况而定，@t{/etc} 为默认设置）"

#. type: Plain text
#: zsh.texi:1179
msgid ""
"Any of these files may be pre-compiled with the @t{zcompile} builtin command (@ref{Shell Builtin Commands}).  If a compiled file exists (named for the original file plus the @t{.zwc} extension) and it is "
"newer than the original file, the compiled file will be used instead."
msgstr "这些文件中的任何一个都可以使用 @t{zcompile} 内置命令（@ref{Shell 内置命令}）进行预编译。 如果存在编译后的文件（以原始文件命名，外加 @t{.zwc} 扩展名），且该文件比原始文件新，则将使用编译后的文件。"

#. type: node
#: zsh.texi:1179 zsh.texi:2014 zsh.texi:2016 zsh.texi:2470
#, no-wrap
msgid "Redirection"
msgstr "重定向"

#. type: cindex
#: zsh.texi:1183
#, no-wrap
msgid "shell grammar"
msgstr "shell 语法"

#. type: cindex
#: zsh.texi:1184
#, no-wrap
msgid "grammar, shell"
msgstr "语法, shell"

#. type: menuentry
#: zsh.texi:1195
msgid "Errors::"
msgstr "错误::"

#. type: node
#: zsh.texi:1196 zsh.texi:1198 zsh.texi:1302
#, no-wrap
msgid "Simple Commands & Pipelines"
msgstr "简单命令和管道"

#. type: node
#: zsh.texi:1196 zsh.texi:1302 zsh.texi:1304 zsh.texi:1370
#, no-wrap
msgid "Precommand Modifiers"
msgstr "前置命令修饰符"

#. type: cindex
#: zsh.texi:1200
#, no-wrap
msgid "simple commands"
msgstr "简单命令"

#. type: cindex
#: zsh.texi:1201
#, no-wrap
msgid "commands, simple"
msgstr "命令, 简单"

#. type: Plain text
#: zsh.texi:1207
msgid ""
"A @emph{simple command} is a sequence of optional parameter assignments followed by blank-separated words, with optional redirections interspersed.  For a description of assignment, see the beginning of "
"@ref{Parameters}."
msgstr "一条 @emph{简单命令} 是一连串可选的参数赋值，后面是空白分隔的词语，中间穿插着可选的重定向。 关于赋值的说明，请参阅 @ref{参数} 的开头。"

#. type: Plain text
#: zsh.texi:1216
msgid ""
"The first word is the command to be executed, and the remaining words, if any, are arguments to the command.  If a command name is given, the parameter assignments modify the environment of the command "
"when it is executed.  The value of a simple command is its exit status, or 128 plus the signal number if terminated by a signal.  For example,"
msgstr "第一个单词是要执行的命令，其余单词（如果有）是该命令的参数。 如果给出了命令名，参数赋值将在执行命令时修改命令的环境。 简单命令的值是其退出状态，如果由信号终止，则是 128 加上信号编号。 例如"

#. type: example
#: zsh.texi:1220
#, no-wrap
msgid "echo foo\n"
msgstr "echo foo\n"

#. type: Plain text
#: zsh.texi:1224
msgid "is a simple command with arguments."
msgstr "是一个带有参数的简单命令。"

#. type: cindex
#: zsh.texi:1226
#, no-wrap
msgid "pipeline"
msgstr "管道"

#. type: Plain text
#: zsh.texi:1238
msgid ""
"A @emph{pipeline} is either a simple command, or a sequence of two or more simple commands where each command is separated from the next by `@t{|}' or `@t{|&}'.  Where commands are separated by `@t{|}', "
"the standard output of the first command is connected to the standard input of the next.  `@t{|&}' is shorthand for `@t{2>&1 |}', which connects both the standard output and the standard error of the "
"command to the standard input of the next.  The value of a pipeline is the value of the last command, unless the pipeline is preceded by `@t{!}' in which case the value is the logical inverse of the value "
"of the last command.  For example,"
msgstr ""
"一条 @emph{管道} 既可以是一条简单的命令，也可以是由两条或多条简单命令组成的序列，其中每条命令之间用`@t{|}' 或 `@t{|&}'分隔。 如果命令之间用`@t{|}'分隔，则第一条命令的标准输出与下一条命令的标准输入相连。 "
"`@t{|&}'是`@t{2>&1 |}'的简写，它将命令的标准输出和标准错误连接到下一条命令的标准输入。 管道的值是最后一条命令的值，除非管道前面有`@t{!}'，在这种情况下，管道的值是最后一条命令值的逻辑倒数。 例如"

#. type: example
#: zsh.texi:1242
#, no-wrap
msgid "echo foo | sed 's/foo/bar/'\n"
msgstr "echo foo | sed 's/foo/bar/'\n"

#. type: Plain text
#: zsh.texi:1247
msgid "is a pipeline, where the output (`@t{foo}' plus a newline) of the first command will be passed to the input of the second."
msgstr "是一条管道，第一条命令的输出（`@t{foo}' 加上换行符）将传递到第二条命令的输入。"

#. type: findex
#: zsh.texi:1249
#, no-wrap
msgid "coproc"
msgstr "coproc"

#. type: cindex
#: zsh.texi:1250
#, no-wrap
msgid "coprocess"
msgstr "coprocess"

#. type: Plain text
#: zsh.texi:1258
msgid ""
"If a pipeline is preceded by `@t{coproc}', it is executed as a coprocess; a two-way pipe is established between it and the parent shell.  The shell can read from or write to the coprocess by means of the "
"`@t{>&p}' and `@t{<&p}' redirection operators or with `@t{print -p}' and `@t{read -p}'.  A pipeline cannot be preceded by both `@t{coproc}' and `@t{!}'.  If job control is active, the coprocess can be "
"treated in other than input and output as an ordinary background job."
msgstr ""
"如果管道前面有`@t{coproc}'，则它将作为协进程执行；它与父 shell 之间将建立双向管道。 shell 可以通过 `@t{>&p}'和`@t{<&p}'重定向操作符或`@t{print -p}'和`@t{read -p}'读取或写入协进程。 一条管道前面不能同时出"
"现 `@t{coproc}' 和 `@t{!}'。 如果作业控制处于激活状态，则协程除了输入和输出外，可以作为普通后台作业处理。"

#. type: cindex
#: zsh.texi:1260
#, no-wrap
msgid "sublist"
msgstr "sublist"

#. type: Plain text
#: zsh.texi:1269
msgid ""
"A @emph{sublist} is either a single pipeline, or a sequence of two or more pipelines separated by `@t{&&}' or `@t{||}'.  If two pipelines are separated by `@t{&&}', the second pipeline is executed only if "
"the first succeeds (returns a zero status).  If two pipelines are separated by `@t{||}', the second is executed only if the first fails (returns a nonzero status).  Both operators have equal precedence "
"and are left associative.  The value of the sublist is the value of the last pipeline executed.  For example,"
msgstr ""
"一个 @emph{sublist} 既可以是一条管道，也可以是由两条或多条管道组成的序列，中间用`@t{&&}'或`@t{||}'隔开。 如果两条管道由`@t{&&}'分隔，则只有在第一条管道成功（返回零状态）后，才会执行第二条管道。 如果两条管"
"道之间用`@t{||}'隔开，则只有在第一条管道失败（返回非零状态）时，才会执行第二条管道。 这两个操作符具有相同的优先级，并且都是左关联。 子列表的值是最后执行的管道的值。 例如"

#. type: example
#: zsh.texi:1273
#, no-wrap
msgid "dmesg | grep panic && print yes\n"
msgstr "dmesg | grep panic && print yes\n"

#. type: Plain text
#: zsh.texi:1280
msgid ""
"is a sublist consisting of two pipelines, the second just a simple command which will be executed if and only if the @t{grep} command returns a zero status.  If it does not, the value of the sublist is "
"that return status, else it is the status returned by the @t{print} (almost certainly zero)."
msgstr ""
"是一个由两条管道组成的子列表（sublist），第二条管道只是一条简单的命令，只有当 @t{grep} 命令返回零状态时才会执行。 如果 @t{grep} 返回非零状态，子列表的值就是这个非零返回状态，否则就是 @t{print} 返回的状态"
"（几乎肯定是零）。"

#. type: t{#1}
#: zsh.texi:1282 zsh.texi:19512 zsh.texi:22733 zsh.texi:39682
#, no-wrap
msgid "list"
msgstr "list"

#. type: Plain text
#: zsh.texi:1296
msgid ""
"A @emph{list} is a sequence of zero or more sublists, in which each sublist is terminated by `@t{;}', `@t{&}', `@t{&|}', `@t{&!}', or a newline.  This terminator may optionally be omitted from the last "
"sublist in the list when the list appears as a complex command inside `@t{(}...@t{)}' or `@t{@{}...@t{@}}'.  When a sublist is terminated by `@t{;}' or newline, the shell waits for it to finish before "
"executing the next sublist.  If a sublist is terminated by a `@t{&}', `@t{&|}', or `@t{&!}', the shell executes the last pipeline in it in the background, and does not wait for it to finish (note the "
"difference from other shells which execute the whole sublist in the background).  A backgrounded pipeline returns a status of zero."
msgstr ""
"一个 @emph{list} 是由 0 个或多个子列表组成的序列，其中每个子列表都以 `@t{;}'、`@t{&}'、`@t{&|}'、`@t{&!}' 或换行符结束。 当列表作为复合命令出现在`@t{(}...@t{)}' 或`@t{@{}...@t{@}}'中时，可以选择省略列表中"
"最后一个子列表的结束符。 当子列表以 `@t{;}' 或换行结束时，shell 会等待该子列表结束后再执行下一个子列表。 如果子列表以`@t{&}', `@t{&|}', 或 `@t{&!}'结束，shell 会在后台执行其中的最后一条管道，而不会等待它结"
"束（注意这与其他 shell 在后台执行整个子列表的做法不同）。 后台管道的返回状态为 0。"

#. type: Plain text
#: zsh.texi:1302
msgid ""
"More generally, a list can be seen as a set of any shell commands whatsoever, including the complex commands below; this is implied wherever the word `list' appears in later descriptions.  For example, "
"the commands in a shell function form a special sort of list."
msgstr "更广义地说，list可以看作是任何 shell 命令的集合，包括下面的复杂命令；在后面的描述中，只要出现 `list' 一词，就意味着这一点。 例如，shell 函数中的命令就是一种特殊的列表(list)。"

#. type: node
#: zsh.texi:1302 zsh.texi:1370 zsh.texi:1372 zsh.texi:1644
#, no-wrap
msgid "Complex Commands"
msgstr "复杂命令"

#. type: cindex
#: zsh.texi:1306
#, no-wrap
msgid "precommand modifiers"
msgstr "前置命令修饰符"

#. type: cindex
#: zsh.texi:1307
#, no-wrap
msgid "modifiers, precommand"
msgstr "修饰符, 前置命令"

#. type: Plain text
#: zsh.texi:1312
msgid ""
"A simple command may be preceded by a @emph{precommand modifier}, which will alter how the command is interpreted.  These modifiers are shell builtin commands with the exception of @t{nocorrect} which is "
"a reserved word."
msgstr "一条简单命令的前面可以加上 @emph{前置命令修饰符}，它将改变命令的解释方式。 除了 @t{nocorrect} 是保留字外，这些修改器都是 shell 内置命令。"

#. type: t{#1}
#: zsh.texi:1315 zsh.texi:1316 zsh.texi:5515 zsh.texi:7493 zsh.texi:8515 zsh.texi:20012 zsh.texi:23558 zsh.texi:28597 zsh.texi:28600 zsh.texi:28603 zsh.texi:28685 zsh.texi:28688 zsh.texi:28693 zsh.texi:28698
#: zsh.texi:28700 zsh.texi:28702 zsh.texi:38783
#, no-wrap
msgid "-"
msgstr "-"

#. type: table
#: zsh.texi:1319
msgid "The command is executed with a `@t{-}' prepended to its @t{argv[0]} string."
msgstr "执行命令时，会在 @t{argv[0]} 字符串前加上`@t{-}'。"

#. type: findex
#: zsh.texi:1320 zsh.texi:1321 zsh.texi:12973
#, no-wrap
msgid "builtin"
msgstr "builtin"

#. type: table
#: zsh.texi:1324
msgid "The command word is taken to be the name of a builtin command, rather than a shell function or external command."
msgstr "命令字被视为内置命令的名称，而不是 shell 函数或外部命令的名称。"

#. type: t{#1}
#: zsh.texi:1325 zsh.texi:13055 zsh.texi:16185 zsh.texi:19409 zsh.texi:21953 zsh.texi:36730 zsh.texi:36876 zsh.texi:36877 zsh.texi:37020 zsh.texi:40307
#, no-wrap
msgid "command"
msgstr "command"

#. type: item
#: zsh.texi:1326
#, no-wrap
msgid "@t{command} [ @t{-pvV} ]"
msgstr "@t{command} [ @t{-pvV} ]"

#. type: table
#: zsh.texi:1334
msgid ""
"The command word is taken to be the name of an external command, rather than a shell function or builtin.  If the @t{POSIX_BUILTINS} option is set, builtins will also be executed but certain special "
"properties of them are suppressed. The @t{-p} flag causes a default path to be searched instead of that in @t{$path}. With the @t{-v} flag, @t{command} is similar to @t{whence} and with @t{-V}, it is "
"equivalent to @t{whence -v}."
msgstr ""
"命令字将被视为外部命令的名称，而不是 shell 函数或内置程序的名称。 如果设置了 @t{POSIX_BUILTINS} 选项，内置程序也会被执行，但它们的某些特殊属性会被抑制。@t{-p} 标志会导致搜索默认路径，而不是 @t{$path} 中的"
"路径。使用 @t{-v} 标志时，@t{command} 类似于 @t{whence}；使用 @t{-V} 时，它等同于 @t{whence -v}。"

#. type: findex
#: zsh.texi:1335
#, no-wrap
msgid "exec"
msgstr "exec"

#. type: item
#: zsh.texi:1336
#, no-wrap
msgid "@t{exec} [ @t{-cl} ] [ @t{-a} @var{argv0} ]"
msgstr "@t{exec} [ @t{-cl} ] [ @t{-a} @var{argv0} ]"

#. type: table
#: zsh.texi:1342
msgid ""
"The following command together with any arguments is run in place of the current process, rather than as a sub-process.  The shell does not fork and is replaced.  The shell does not invoke @t{TRAPEXIT}, "
"nor does it source @t{zlogout} files.  The options are provided for compatibility with other shells."
msgstr "以下命令连同参数将代替当前进程运行，而不是作为子进程运行。 shell 不会分叉,并被替换。 shell 不会调用 @t{TRAPEXIT}，也不会引入 @t{zlogout} 文件。 提供这些选项是为了与其他 shell 兼容。"

#. type: table
#: zsh.texi:1345
msgid "The @t{-c} option clears the environment."
msgstr "@t{-c} 选项会清除环境。"

#. type: table
#: zsh.texi:1351
msgid ""
"The @t{-l} option is equivalent to the @t{-} precommand modifier, to treat the replacement command as a login shell; the command is executed with a @t{-} prepended to its @t{argv[0]} string.  This flag "
"has no effect if used together with the @t{-a} option."
msgstr "@t{-l} 选项等同于 @t{-} 前置命令修饰符，将替换命令视为登录 shell；执行命令时，会在 @t{argv[0]} 字符串前加上 @t{-}。 如果与 @t{-a} 选项一起使用，则该标记无效。"

#. type: table
#: zsh.texi:1357
msgid ""
"The @t{-a} option is used to specify explicitly the @t{argv[0]} string (the name of the command as seen by the process itself) to be used by the replacement command and is directly equivalent to setting a "
"value for the @t{ARGV0} environment variable."
msgstr "@t{-a} 选项用于明确指定替换命令将使用的 @t{argv[0]} 字符串（进程本身看到的命令名称），直接等同于为 @t{ARGV0} 环境变量设置值。"

#. type: t{#1}
#: zsh.texi:1358 zsh.texi:1359
#, no-wrap
msgid "nocorrect"
msgstr "nocorrect"

#. type: table
#: zsh.texi:1363
msgid ""
"Spelling correction is not done on any of the words.  This must appear before any other precommand modifier, as it is interpreted immediately, before any parsing is done.  It has no effect in non-"
"interactive shells."
msgstr "不对任何单词进行拼写校正。 它必须出现在任何其他前置命令修饰符之前，因为它会在进行任何解析之前立即被解释。 在非交互式 shell 中没有作用。"

#. type: t{#1}
#: zsh.texi:1364 zsh.texi:1365
#, no-wrap
msgid "noglob"
msgstr "noglob"

#. type: table
#: zsh.texi:1368
msgid "Filename generation (globbing) is not performed on any of the words."
msgstr "不对任何单词执行文件名生成（通配）。"

#. type: node
#: zsh.texi:1370 zsh.texi:1644 zsh.texi:1646 zsh.texi:1733
#, no-wrap
msgid "Alternate Forms For Complex Commands"
msgstr "复杂命令的替代形式"

#. type: cindex
#: zsh.texi:1374
#, no-wrap
msgid "complex commands"
msgstr "复杂命令"

#. type: cindex
#: zsh.texi:1375
#, no-wrap
msgid "commands, complex"
msgstr "命令， 复杂"

#. type: Plain text
#: zsh.texi:1377
msgid "A @emph{complex command} in zsh is one of the following:"
msgstr "zsh 中的 @emph{复杂命令}是以下命令之一："

#. type: findex
#: zsh.texi:1380
#, no-wrap
msgid "if"
msgstr "if"

#. type: cindex
#: zsh.texi:1381
#, no-wrap
msgid "if construct"
msgstr "if construct"

#. type: item
#: zsh.texi:1382
#, no-wrap
msgid "@t{if} @var{list} @t{then} @var{list} [ @t{elif} @var{list} @t{then} @var{list} ] ... [ @t{else} @var{list} ] @t{fi}"
msgstr "@t{if} @var{list} @t{then} @var{list} [ @t{elif} @var{list} @t{then} @var{list} ] ... [ @t{else} @var{list} ] @t{fi}"

#. type: table
#: zsh.texi:1389
msgid ""
"The @t{if} @var{list} is executed, and if it returns a zero exit status, the @t{then} @var{list} is executed.  Otherwise, the @t{elif} @var{list} is executed and if its status is zero, the @t{then} "
"@var{list} is executed.  If each @t{elif} @var{list} returns nonzero status, the @t{else} @var{list} is executed."
msgstr ""
"执行@t{if} @var{list}，如果返回零退出状态，则执行 @t{then}  @var{list}。 否则，执行 @t{elif} @var{list}，如果状态为零，则执行 @t{then} @var{list} 。 如果每个 @t{elif} @var{list}返回非零状态，则执行 "
"@t{else} @var{list} 。"

#. type: findex
#: zsh.texi:1390
#, no-wrap
msgid "for"
msgstr "for"

#. type: cindex
#: zsh.texi:1391
#, no-wrap
msgid "for loops"
msgstr "for loops"

#. type: cindex
#: zsh.texi:1392
#, no-wrap
msgid "loops, for"
msgstr "loops, for"

#. type: item
#: zsh.texi:1393
#, no-wrap
msgid "@t{for} @var{name} ... [ @t{in} @var{word} ... ] @var{term} @t{do} @var{list} @t{done}"
msgstr "@t{for} @var{name} ... [ @t{in} @var{word} ... ] @var{term} @t{do} @var{list} @t{done}"

#. type: table
#: zsh.texi:1398
msgid ""
"Expand the list of @var{word}s, and set the parameter @var{name} to each of them in turn, executing @var{list} each time.  If the `@t{in} @var{word}' is omitted, use the positional parameters instead of "
"the @var{word}s."
msgstr ""
"展开 @var{word} 列表，依次将参数 @var{name} 设置为其中的每一个，每次都执行 @var{list}。 如果省略`@t{in} @var{word}'，则将使用位置参数而不是 @var{word}。@uref{comments/syntax.html#syntax-for-ex1,[译注:for."
"示例1]}"

#. type: table
#: zsh.texi:1403
msgid "The @var{term} consists of one or more newline or @t{;} which terminate the @var{word}s, and are optional when the `@t{in} @var{word}' is omitted."
msgstr "@var{term} 由一个或多个换行符或 @t{;} 组成，用于终止 @var{word}，当省略 `@t{in} @var{word}' 时是可选的。"

#. type: table
#: zsh.texi:1413
msgid ""
"More than one parameter @var{name} can appear before the list of @var{word}s.  If @var{N} @var{name}s are given, then on each execution of the loop the next @var{N} @var{word}s are assigned to the "
"corresponding parameters.  If there are more @var{name}s than remaining @var{word}s, the remaining parameters are each set to the empty string.  Execution of the loop ends when there is no remaining "
"@var{word} to assign to the first @var{name}.  It is only possible for @t{in} to appear as the first @var{name} in the list, else it will be treated as marking the end of the list."
msgstr ""
"在 @var{word} 之前可以出现多个参数 @var{name}。 如果给出 @var{N} 个 @var{name}，那么在循环的每次执行中，下面每 @var{N} 个 @var{word}s 都会分配给相应的参数。 如果 @var{name} 个数多于剩余的 @var{word}，剩余"
"的参数将被设置为空字符串。 @uref{comments/syntax.html#syntax-for-ex2,[译注:for.示例2]}当没有剩余的 @var{word} 可以分配给第一个 @var{name} 时，循环执行结束。 @t{in} 作为 @var{name} 列表中的第一个 "
"@var{name} 出现时，才能作为 @var{name} 使用，否则它将被视为 @var{name} 列表的结束符。@uref{comments/syntax.html#syntax-for-ex3,[译注:for.示例3]}"

#. type: item
#: zsh.texi:1414
#, no-wrap
msgid "@t{for ((} [@var{expr1}] @t{;} [@var{expr2}] @t{;} [@var{expr3}] @t{)) do} @var{list} @t{done}"
msgstr "@t{for ((} [@var{expr1}] @t{;} [@var{expr2}] @t{;} [@var{expr3}] @t{)) do} @var{list} @t{done}"

#. type: table
#: zsh.texi:1421
msgid ""
"The arithmetic expression @var{expr1} is evaluated first (see @ref{Arithmetic Evaluation}).  The arithmetic expression @var{expr2} is repeatedly evaluated until it evaluates to zero and when non-zero, "
"@var{list} is executed and the arithmetic expression @var{expr3} evaluated.  If any expression is omitted, then it behaves as if it evaluated to 1."
msgstr ""
"首先对算术表达式 @var{expr1} 进行求值（参见 @ref{算术求值}）。 算术表达式 @var{expr2} 会被反复求值，直到求值为零，如果不为零，则执行 @var{list} 并求值算术表达式 @var{expr3}。 如果省略了任何表达式，则该表达"
"式的值为 1。"

#. type: findex
#: zsh.texi:1422
#, no-wrap
msgid "while"
msgstr "while"

#. type: cindex
#: zsh.texi:1423
#, no-wrap
msgid "while loops"
msgstr "while 循环"

#. type: cindex
#: zsh.texi:1424
#, no-wrap
msgid "loops, while"
msgstr "循环, while"

#. type: item
#: zsh.texi:1425
#, no-wrap
msgid "@t{while} @var{list} @t{do} @var{list} @t{done}"
msgstr "@t{while} @var{list} @t{do} @var{list} @t{done}"

#. type: table
#: zsh.texi:1428
msgid "Execute the @t{do} @var{list} as long as the @t{while} @var{list} returns a zero exit status."
msgstr "只要 @t{while} @var{list} 返回的退出状态为零，就执行 @t{do} @var{list} 。"

#. type: findex
#: zsh.texi:1429
#, no-wrap
msgid "until"
msgstr "until"

#. type: cindex
#: zsh.texi:1430
#, no-wrap
msgid "until loops"
msgstr "until 循环"

#. type: cindex
#: zsh.texi:1431
#, no-wrap
msgid "loops, until"
msgstr "循环, until"

#. type: item
#: zsh.texi:1432
#, no-wrap
msgid "@t{until} @var{list} @t{do} @var{list} @t{done}"
msgstr "@t{until} @var{list} @t{do} @var{list} @t{done}"

#. type: table
#: zsh.texi:1435
msgid "Execute the @t{do} @var{list} as long as @t{until} @var{list} returns a nonzero exit status."
msgstr "只要 @t{until} @var{list} 返回非零退出状态，就执行 @t{do} @var{list} 。"

#. type: findex
#: zsh.texi:1436
#, no-wrap
msgid "repeat"
msgstr "repeat"

#. type: cindex
#: zsh.texi:1437
#, no-wrap
msgid "repeat loops"
msgstr "repeat 循环"

#. type: cindex
#: zsh.texi:1438
#, no-wrap
msgid "loops, repeat"
msgstr "循环, repeat"

#. type: item
#: zsh.texi:1439
#, no-wrap
msgid "@t{repeat} @var{word} @t{do} @var{list} @t{done}"
msgstr "@t{repeat} @var{word} @t{do} @var{list} @t{done}"

#. type: table
#: zsh.texi:1443
msgid "@var{word} is expanded and treated as an arithmetic expression, which must evaluate to a number @var{n}.  @var{list} is then executed @var{n} times."
msgstr "@var{word} 将被展开并视为算术表达式，其值必须为数值 @var{n}。 然后 @var{list} 会被执行 @var{n} 次。"

#. type: table
#: zsh.texi:1448
msgid "The @t{repeat} syntax is disabled by default when the shell starts in a mode emulating another shell.  It can be enabled with the command `@t{enable -r repeat}'"
msgstr "当 shell 以模拟其他 shell 的模式启动时，@t{repeat} 语法默认为禁用。 可以使用`@t{enable -r repeat}'命令启用该语法。"

#. type: findex
#: zsh.texi:1449
#, no-wrap
msgid "case"
msgstr "case"

#. type: cindex
#: zsh.texi:1450
#, no-wrap
msgid "case selection"
msgstr "case 选择"

#. type: cindex
#: zsh.texi:1451
#, no-wrap
msgid "selection, case"
msgstr "选择, case"

#. type: item
#: zsh.texi:1452
#, no-wrap
msgid "@t{case} @var{word} @t{in} [ [@t{(}] @var{pattern} [ @t{|} @var{pattern} ] ... @t{)} @var{list} (@t{;;}|@t{;&}|@t{;|}) ] ... @t{esac}"
msgstr "@t{case} @var{word} @t{in} [ [@t{(}] @var{pattern} [ @t{|} @var{pattern} ] ... @t{)} @var{list} (@t{;;}|@t{;&}|@t{;|}) ] ... @t{esac}"

#. type: table
#: zsh.texi:1457
msgid ""
"Execute the @var{list} associated with the first @var{pattern} that matches @var{word}, if any.  The form of the patterns is the same as that used for filename generation.  See @ref{Filename Generation}."
msgstr "执行与第一个匹配 @var{word} 的 @var{pattern} 相关的 @var{list}（如果有）。 模式的形式与文件名生成使用的模式相同。 请参阅 @ref{文件名生成}。"

#. type: table
#: zsh.texi:1468
msgid ""
"Note further that, unless the @t{SH_GLOB} option is set, the whole pattern with alternatives is treated by the shell as equivalent to a group of patterns within parentheses, although white space may "
"appear about the parentheses and the vertical bar and will be stripped from the pattern at those points.  White space may appear elsewhere in the pattern; this is not stripped.  If the @t{SH_GLOB} option "
"is set, so that an opening parenthesis can be unambiguously treated as part of the case syntax, the expression is parsed into separate words and these are treated as strict alternatives (as in other "
"shells)."
msgstr ""
"还需要注意的是，除非设置了 @t{SH_GLOB} 选项，否则 shell 会将整个模式视为括号内的模式组对待，尽管在括号和竖线附近可能会出现空白，但这些空白会从模式中删除。 空格可能出现在模式的其他地方，但不会被删除。 如果"
"设置了 @t{SH_GLOB} 选项，那么开头的括号明确地视为case语法的一部分，那么表达式将被解析为单独的单词，这些单词将被视为严格的替代词（与其他 shell 相同）。[译注:这里只是shell处理时的内部逻辑，在这里使用时不必关"
"心]"

#. type: table
#: zsh.texi:1474
msgid ""
"If the @var{list} that is executed is terminated with @t{;&} rather than @t{;;}, the following list is also executed.  The rule for the terminator of the following list @t{;;}, @t{;&} or @t{;|} is applied "
"unless the @t{esac} is reached."
msgstr "如果执行的 @var{list} 的结束符是 @t{;&} 而不是 @t{;;}，则也会执行下面的列表。 除非到达 @t{esac}，否则将执行下面列表的终止符 @t{;;}、@t{;&} 或 @t{;|} 的规则。"

#. type: table
#: zsh.texi:1482
msgid ""
"If the @var{list} that is executed is terminated with @t{;|} the shell continues to scan the @var{pattern}s looking for the next match, executing the corresponding @var{list}, and applying the rule for "
"the corresponding terminator @t{;;}, @t{;&} or @t{;|}.  Note that @var{word} is not re-expanded; all applicable @var{pattern}s are tested with the same @var{word}."
msgstr ""
"如果执行的 @var{list} 以 @t{;|} 结尾，则 shell 会继续扫描 @var{pattern} 寻找下一个匹配项，执行相应的 @var{list} 并应用相应的结尾 @t{;;}、@t{;&} 或 @t{;|} 规则。 请注意，@var{word} 不会重新扩展；所有适用的 "
"@var{pattern} 都将使用相同的 @var{word} 进行测试。"

#. type: t{#1}
#: zsh.texi:1483 zsh.texi:17037
#, no-wrap
msgid "select"
msgstr "select"

#. type: cindex
#: zsh.texi:1484
#, no-wrap
msgid "user selection"
msgstr "user selection"

#. type: cindex
#: zsh.texi:1485
#, no-wrap
msgid "selection, user"
msgstr "selection, user"

#. type: item
#: zsh.texi:1486
#, no-wrap
msgid "@t{select} @var{name} [ @t{in} @var{word} ... @var{term} ] @t{do} @var{list} @t{done}"
msgstr "@t{select} @var{name} [ @t{in} @var{word} ... @var{term} ] @t{do} @var{list} @t{done}"

#. type: table
#: zsh.texi:1488
msgid "where @var{term} is one or more newline or @t{;} to terminate the @var{word}s."
msgstr "其中 @var{term} 是一个或多个换行符，或 @t{;} ，用以终止 @var{word}s."

#. type: vindex
#: zsh.texi:1488 zsh.texi:7387 zsh.texi:14419
#, no-wrap
msgid "REPLY, use of"
msgstr "REPLY, use of"

#. type: table
#: zsh.texi:1501
msgid ""
"Print the set of @var{word}s, each preceded by a number.  If the @t{in} @var{word} is omitted, use the positional parameters.  The @t{PROMPT3} prompt is printed and a line is read from the line editor if "
"the shell is interactive and that is active, or else standard input.  If this line consists of the number of one of the listed @var{word}s, then the parameter @var{name} is set to the @var{word} "
"corresponding to this number.  If this line is empty, the selection list is printed again.  Otherwise, the value of the parameter @var{name} is set to null.  The contents of the line read from standard "
"input is saved in the parameter @t{REPLY}.  @var{list} is executed for each selection until a break or end-of-file is encountered."
msgstr ""
"打印一组 @var{word}，每个前面都有一个数字。 如果省略 @t{in} @var{word}  则使用位置参数。 如果 shell 是交互式的，并且行编辑器处于激活状态，则会打印 @t{PROMPT3} 提示符，然后从行编辑器读取一行，否则从标准输入"
"读取一行。 如果该行包含所列 @var{word} 的编号，那么参数 @var{name} 将被设置为与该编号对应的 @var{word}。 如果该行为空，则再次打印选择列表。 否则，参数 @var{name} 的值将被设置为空。 从标准输入读取的行内容将"
"保存在参数 @t{REPLY} 中。 @var{list} 会在每次选择时执行，直到遇到中断或文件结束。@uref{comments/syntax.html#syntax-select-name,[译注:语法.select]}"

#. type: cindex
#: zsh.texi:1502
#, no-wrap
msgid "subshell"
msgstr "subshell"

#. type: item
#: zsh.texi:1503
#, no-wrap
msgid "@t{(} @var{list} @t{)}"
msgstr "@t{(} @var{list} @t{)}"

#. type: table
#: zsh.texi:1508
msgid ""
"Execute @var{list} in a subshell.  Traps set by the @t{trap} builtin are reset to their default values while executing @var{list}; an exception is that ignored signals will continue to be ignored if the "
"option @t{POSIXTRAPS} is set."
msgstr "在子shell中执行 @var{list}。 在执行 @var{list} 时，由 @t{trap} 内置函数设置的陷阱将被重置为默认值；但如果设置了 @t{POSIXTRAPS} 选项，被忽略的信号将继续被忽略。"

#. type: item
#: zsh.texi:1509
#, no-wrap
msgid "@t{@{} @var{list} @t{@}}"
msgstr "@t{@{} @var{list} @t{@}}"

#. type: table
#: zsh.texi:1511
msgid "Execute @var{list}."
msgstr "执行 @var{list}."

#. type: findex
#: zsh.texi:1512
#, no-wrap
msgid "always"
msgstr "always"

#. type: cindex
#: zsh.texi:1513
#, no-wrap
msgid "always blocks"
msgstr "always 块"

#. type: cindex
#: zsh.texi:1514
#, no-wrap
msgid "try blocks"
msgstr "try 块"

#. type: item
#: zsh.texi:1515
#, no-wrap
msgid "@t{@{} @var{try-list} @t{@} always @{} @var{always-list} @t{@}}"
msgstr "@t{@{} @var{try-list} @t{@} always @{} @var{always-list} @t{@}}"

#. type: table
#: zsh.texi:1523
msgid ""
"First execute @var{try-list}.  Regardless of errors, or @t{break} or @t{continue} commands encountered within @var{try-list}, execute @var{always-list}.  Execution then continues from the result of the "
"execution of @var{try-list}; in other words, any error, or @t{break} or @t{continue} command is treated in the normal way, as if @var{always-list} were not present.  The two chunks of code are referred to "
"as the `try block' and the `always block'."
msgstr ""
"首先执行 @var{try-list}。 无论在 @var{try-list} 中遇到任何错误、@t{break} 或 @t{continue} 命令，都要执行 @var{always-list}。 换句话说，任何错误、@t{break} 或 @t{continue}命令都会以正常方式处理，就好像 "
"@var{always-list} 不存在一样。 这两段代码被称为 `try 块'和 `always 块'。"

#. type: table
#: zsh.texi:1528
msgid "Optional newlines or semicolons may appear after the @t{always}; note, however, that they may @emph{not} appear between the preceding closing brace and the @t{always}."
msgstr "在 @t{always} 之后可以出现可选的换行符或分号，但要注意，换行符或分号 @emph{不可以} 出现在前面的收尾括号和 @t{always} 之间。"

#. type: table
#: zsh.texi:1538
msgid ""
"An `error' in this context is a condition such as a syntax error which causes the shell to abort execution of the current function, script, or list.  Syntax errors encountered while the shell is parsing "
"the code do not cause the @var{always-list} to be executed.  For example, an erroneously constructed @t{if} block in @var{try-list} would cause the shell to abort during parsing, so that @var{always-list} "
"would not be executed, while an erroneous substitution such as @t{$@{*foo*@}} would cause a run-time error, after which @var{always-list} would be executed."
msgstr ""
"在这个语境中，`错误' 是指诸如语法错误之类的条件，会导致shell 中止当前函数、脚本或列表的执行。shell 解析代码时遇到的语法错误不会导致 @var{always-list} 被执行。 例如，在 @var{try-list} 中构造错误的 @t{if} 块"
"会导致 shell 在解析过程中中止，因此 @var{always-list} 不会被执行，而错误的替换（如 @t{$@{*foo*@}}）会导致运行时错误，之后 @var{always-list} 将被执行。"

#. type: table
#: zsh.texi:1549
msgid ""
"An error condition can be tested and reset with the special integer variable @t{TRY_BLOCK_ERROR}.  Outside an @var{always-list} the value is irrelevant, but it is initialised to @t{-1}.  Inside "
"@var{always-list}, the value is 1 if an error occurred in the @var{try-list}, else 0.  If @t{TRY_BLOCK_ERROR} is set to 0 during the @var{always-list}, the error condition caused by the @var{try-list} is "
"reset, and shell execution continues normally after the end of @var{always-list}.  Altering the value during the @var{try-list} is not useful (unless this forms part of an enclosing @t{always} block)."
msgstr ""
"错误条件可以通过特殊的整数变量 @t{TRY_BLOCK_ERROR} 进行测试和重置。 在 @var{always-list} 之外，该变量的值无关紧要，但会被初始化为 @t{-1}。 在 @var{always-list} 中，如果 @var{try-list} 发生错误，则值为 1，"
"否则为 0。 如果 @t{TRY_BLOCK_ERROR} 在 @var{always-list} 中被设置为 0，由 @var{try-list} 引起的错误将被重置，shell 执行将在 @var{always-list} 结束后继续正常进行。 在 @var{try-list}期间更改值并无用处（除非"
"它构成了外层 @t{always} 代码块的一部分）。@uref{comments/syntax.html#syntax-always,[译注:语法.always]}"

#. type: table
#: zsh.texi:1555
msgid ""
"Regardless of @t{TRY_BLOCK_ERROR}, after the end of @var{always-list} the normal shell status @t{$?} is the value returned from @var{try-list}.  This will be non-zero if there was an error, even if "
"@t{TRY_BLOCK_ERROR} was set to zero."
msgstr "无论 @t{TRY_BLOCK_ERROR} 如何设置，在 @var{always-list} 结束后，正常的 shell 状态 @t{$?} 就是 @var{try-list} 返回的值。 如果出现错误，即使 @t{TRY_BLOCK_ERROR} 被设置为零，该值也不会为零。"

#. type: table
#: zsh.texi:1560
msgid "The following executes the given code, ignoring any errors it causes.  This is an alternative to the usual convention of protecting code by executing it in a subshell."
msgstr "下面的代码会执行给定的代码，并忽略它引起的任何错误。 这与通常在子 shell 中执行代码以保护代码的做法不同。"

#. type: example
#: zsh.texi:1570
#, no-wrap
msgid ""
"@{\n"
"    # code which may cause an error\n"
"  @} always @{\n"
"    # This code is executed regardless of the error.\n"
"    (( TRY_BLOCK_ERROR = 0 ))\n"
"@}\n"
"# The error condition has been reset.\n"
msgstr ""
"@{\n"
"    # code which may cause an error\n"
"  @} always @{\n"
"    # This code is executed regardless of the error.\n"
"    (( TRY_BLOCK_ERROR = 0 ))\n"
"@}\n"
"# The error condition has been reset.\n"

#. type: table
#: zsh.texi:1579
msgid ""
"When a @t{try} block occurs outside of any function, a @t{return} or a @t{exit} encountered in @var{try-list} does @emph{not} cause the execution of @var{always-list}.  Instead, the shell exits "
"immediately after any @t{EXIT} trap has been executed.  Otherwise, a @t{return} command encountered in @var{try-list} will cause the execution of @var{always-list}, just like @t{break} and @t{continue}."
msgstr ""
"当 @t{try} 代码块出现在任何函数之外时，在 @var{try-list} 中遇到 @t{return} 或 @t{exit} 不会 @emph{不会} 导致 @var{always-list} 的执行。 相反，shell 会在执行 @t{EXIT} 陷阱后立即退出。 否则，与 @t{break} 和 "
"@t{continue} 一样，在 @var{try-list} 中执行 @t{return} 命令也会导致 @var{always-list} 的执行。"

#. type: findex
#: zsh.texi:1583
#, no-wrap
msgid "function"
msgstr "function"

#. type: item
#: zsh.texi:1584
#, no-wrap
msgid "@t{function} [ @t{-T} ] @var{word} ... [ @t{()} ] [ @var{term} ] @t{@{} @var{list} @t{@}}"
msgstr "@t{function} [ @t{-T} ] @var{word} ... [ @t{()} ] [ @var{term} ] @t{@{} @var{list} @t{@}}"

#. type: itemx
#: zsh.texi:1585
#, no-wrap
msgid "@var{word} ... @t{()} [ @var{term} ] @t{@{} @var{list} @t{@}}"
msgstr "@var{word} ... @t{()} [ @var{term} ] @t{@{} @var{list} @t{@}}"

#. type: itemx
#: zsh.texi:1586
#, no-wrap
msgid "@var{word} ... @t{()} [ @var{term} ] @var{command}"
msgstr "@var{word} ... @t{()} [ @var{term} ] @var{command}"

#. type: table
#: zsh.texi:1593
msgid ""
"where @var{term} is one or more newline or @t{;}.  Define a function which is referenced by any one of @var{word}.  Normally, only one @var{word} is provided; multiple @var{word}s are usually only useful "
"for setting traps.  The body of the function is the @var{list} between the @t{@{} and @t{@}}.  See @ref{Functions}."
msgstr ""
"其中 @var{term} 是一个或多个换行符或 @t{;}。 定义一个函数，该函数由 @var{word} 中的任意一个引用。 通常只提供一个 @var{word}；多个 @var{word} 通常只在设置陷阱时有用。 函数的主体是 @t{@{} 和 @t{@}} 之间的 "
"@var{list}。 参见 @ref{函数}。@uref{comments/syntax.html#syntax-function,[译注:语法.function]}"

#. type: table
#: zsh.texi:1596
msgid "The options of @t{function} have the following meanings:"
msgstr "@t{function} 的选项具有以下含义:"

#. type: t{#1}
#: zsh.texi:1599 zsh.texi:12599 zsh.texi:12658 zsh.texi:15371 zsh.texi:16852 zsh.texi:26919 zsh.texi:30519
#, no-wrap
msgid "-T"
msgstr "-T"

#. type: table
#: zsh.texi:1603
msgid "Enable tracing for this function, as though with @t{functions -T}.  See the documentation of the @t{-f} option to the @t{typeset} builtin, in @ref{Shell Builtin Commands}."
msgstr "启用对该函数的跟踪，就像使用 @t{functions -T} 一样。 请参阅 @ref{Shell 内置命令}中 @t{typeset} 内置命令的 @t{-f} 选项文档。"

#. type: table
#: zsh.texi:1611
msgid ""
"If the option @t{SH_GLOB} is set for compatibility with other shells, then whitespace may appear between the left and right parentheses when there is a single @var{word}; otherwise, the parentheses will "
"be treated as forming a globbing pattern in that case."
msgstr ""
"如果为了与其他 shell 兼容而设置了 @t{SH_GLOB} 选项，那么当只有一个 @var{word} 时，左右括号之间可能会出现空白；否则，在这种情况下，括号将被视为形成一个 globbing 模式。@uref{comments/syntax.html#syntax-"
"function-shglob,[译注:语法.function.shglob]}"

#. type: table
#: zsh.texi:1615
msgid "In any of the forms above, a redirection may appear outside the function body, for example"
msgstr "在上述任何一种形式中，重定向都可能出现在函数体之外，例如"

#. type: example
#: zsh.texi:1619
#, no-wrap
msgid "func() @{ ... @} 2>&1\n"
msgstr "func() @{ ... @} 2>&1\n"

#. type: table
#: zsh.texi:1625
msgid ""
"The redirection is stored with the function and applied whenever the function is executed.  Any variables in the redirection are expanded at the point the function is executed, but outside the function "
"scope."
msgstr "重定向与函数一起存储，并在执行函数时应用。 重定向中的任何变量都会在函数执行时展开，但不在函数范围内。"

#. type: cindex
#: zsh.texi:1626
#, no-wrap
msgid "timing"
msgstr "计时"

#. type: t{#1}
#: zsh.texi:1627 zsh.texi:33294
#, no-wrap
msgid "time"
msgstr "time"

#. type: item
#: zsh.texi:1628
#, no-wrap
msgid "@t{time} [ @var{pipeline} ]"
msgstr "@t{time} [ @var{pipeline} ]"

#. type: table
#: zsh.texi:1634
msgid ""
"The @var{pipeline} is executed, and timing statistics are reported on the standard error in the form specified by the @t{TIMEFMT} parameter.  If @var{pipeline} is omitted, print statistics about the shell "
"process and its children."
msgstr "执行 @var{pipeline}，并以 @t{TIMEFMT} 参数指定的形式在标准错误中报告计时统计数据。 如果省略 @var{pipeline}，则打印 shell 进程及其子进程的统计信息。"

#. type: cindex
#: zsh.texi:1635
#, no-wrap
msgid "conditional expression"
msgstr "条件表达式"

#. type: findex
#: zsh.texi:1636
#, no-wrap
msgid "[["
msgstr "[["

#. type: item
#: zsh.texi:1637
#, no-wrap
msgid "@t{[[} @var{exp} @t{]]}"
msgstr "@t{[[} @var{exp} @t{]]}"

#. type: table
#: zsh.texi:1642
msgid "Evaluates the conditional expression @var{exp} and return a zero exit status if it is true.  See @ref{Conditional Expressions} for a description of @var{exp}."
msgstr "计算条件表达式 @var{exp}，如果为真，则返回零退出状态。 有关 @var{exp} 的描述，请参阅 @ref{条件表达式}。"

#. type: node
#: zsh.texi:1644 zsh.texi:1733 zsh.texi:1735 zsh.texi:1751
#, no-wrap
msgid "Reserved Words"
msgstr "保留字"

#. type: cindex
#: zsh.texi:1648
#, no-wrap
msgid "alternate forms for complex commands"
msgstr "复杂命令的替代形式"

#. type: cindex
#: zsh.texi:1649
#, no-wrap
msgid "commands, alternate forms for complex"
msgstr "命令, 复杂命令的替代形式"

#. type: Plain text
#: zsh.texi:1654
msgid ""
"Many of zsh's complex commands have alternate forms.  These are non-standard and are likely not to be obvious even to seasoned shell programmers; they should not be used anywhere that portability of shell "
"code is a concern."
msgstr "zsh 的许多复杂命令都有替代形式。 这些命令都是非标准的，即使是经验丰富的 shell 程序员也很难看出它们的区别；在任何需要考虑 shell 代码可移植性的地方，都不应该使用它们。"

#. type: Plain text
#: zsh.texi:1667
msgid ""
"The short versions below only work if @var{sublist} is of the form `@t{@{} @var{list} @t{@}}' or if the @t{SHORT_LOOPS} option is set.  For the @t{if}, @t{while} and @t{until} commands, in both these "
"cases the test part of the loop must also be suitably delimited, such as by `@t{[[} @var{...} @t{]]}' or `@t{((} @var{...} @t{))}', else the end of the test will not be recognized.  For the @t{for}, "
"@t{repeat}, @t{case} and @t{select} commands no such special form for the arguments is necessary, but the other condition (the special form of @var{sublist} or use of the @t{SHORT_LOOPS} option) still "
"applies.  The @t{SHORT_REPEAT} option is available to enable the short version only for the @t{repeat} command."
msgstr ""
"只有当 @var{sublist} 的形式为`@t{@{} @var{list} @t{@}}'时，或设置了 @t{SHORT_LOOPS} 选项@uref{comments/syntax.html#syntax-alternate-shortloops,[译注:语法.短循环.shortloops]}，下面的简短版本才有效。 对于 "
"@t{if}、@t{while} 和 @t{until} 命令，在这两种情况下，循环的测试部分也必须适当分隔，例如使用 `@t{[[} @var{...} @t{]]}' 或 `@t{((} @var{...} @t{))}'，否则将无法识别测试的结束。 对于 @t{for}、@t{repeat}、"
"@t{case} 和 @t{select}，不需要为参数设置特殊形式，但其他条件（@var{sublist} 的特殊形式或使用 @t{SHORT_LOOPS} 选项）仍然适用。 @t{SHORT_REPEAT} 选项只能用于 @t{repeat} 命令的简短版本。"

#. type: item
#: zsh.texi:1670
#, no-wrap
msgid "@t{if} @var{list} @t{@{} @var{list} @t{@}} [ @t{elif} @var{list} @t{@{} @var{list} @t{@}} ] ... [ @t{else @{} @var{list} @t{@}} ]"
msgstr "@t{if} @var{list} @t{@{} @var{list} @t{@}} [ @t{elif} @var{list} @t{@{} @var{list} @t{@}} ] ... [ @t{else @{} @var{list} @t{@}} ]"

#. type: table
#: zsh.texi:1672
msgid "An alternate form of @t{if}.  The rules mean that"
msgstr "@t{if} 的另一种形式。 规则的意思是"

#. type: example
#: zsh.texi:1678
#, no-wrap
msgid ""
"if [[ -o ignorebraces ]] @{\n"
"  print yes\n"
"@}\n"
msgstr ""
"if [[ -o ignorebraces ]] @{\n"
"  print yes\n"
"@}\n"

#. type: table
#: zsh.texi:1682
msgid "works, but"
msgstr "是有效的，但"

#. type: example
#: zsh.texi:1688
#, no-wrap
msgid ""
"if true @{  # Does not work!\n"
"  print yes\n"
"@}\n"
msgstr ""
"if true @{  # Does not work!\n"
"  print yes\n"
"@}\n"

#. type: table
#: zsh.texi:1692
msgid "does @emph{not}, since the test is not suitably delimited."
msgstr "则@emph{不会}，因为测试（条件）没有适当的分隔（符）。"

#. type: item
#: zsh.texi:1693
#, no-wrap
msgid "@t{if} @var{list} @var{sublist}"
msgstr "@t{if} @var{list} @var{sublist}"

#. type: table
#: zsh.texi:1696
msgid "A short form of the alternate @t{if}.  The same limitations on the form of @var{list} apply as for the previous form."
msgstr "另一种 @t{if} 的简写形式。 对 @var{list} 形式的限制与前一种形式相同。"

#. type: item
#: zsh.texi:1697
#, no-wrap
msgid "@t{for} @var{name} ... @t{(} @var{word} ... @t{)} @var{sublist}"
msgstr "@t{for} @var{name} ... @t{(} @var{word} ... @t{)} @var{sublist}"

#. type: table
#: zsh.texi:1699
msgid "A short form of @t{for}."
msgstr "@t{for} 的简写。"

#. type: item
#: zsh.texi:1700
#, no-wrap
msgid "@t{for} @var{name} ... [ @t{in} @var{word} ... ] @var{term} @var{sublist}"
msgstr "@t{for} @var{name} ... [ @t{in} @var{word} ... ] @var{term} @var{sublist}"

#. type: table
#: zsh.texi:1703
msgid "where @var{term} is at least one newline or @t{;}.  Another short form of @t{for}."
msgstr "其中 @var{term} 是至少一个换行符或 @t{;}。 @t{for} 的另一种简写形式。"

#. type: item
#: zsh.texi:1704
#, no-wrap
msgid "@t{for ((} [@var{expr1}] @t{;} [@var{expr2}] @t{;} [@var{expr3}] @t{))} @var{sublist}"
msgstr "@t{for ((} [@var{expr1}] @t{;} [@var{expr2}] @t{;} [@var{expr3}] @t{))} @var{sublist}"

#. type: table
#: zsh.texi:1706
msgid "A short form of the arithmetic @t{for} command."
msgstr "算术 @t{for} 命令的简写。"

#. type: findex
#: zsh.texi:1707
#, no-wrap
msgid "foreach"
msgstr "foreach"

#. type: item
#: zsh.texi:1708
#, no-wrap
msgid "@t{foreach} @var{name} ... @t{(} @var{word} ... @t{)} @var{list} @t{end}"
msgstr "@t{foreach} @var{name} ... @t{(} @var{word} ... @t{)} @var{list} @t{end}"

#. type: table
#: zsh.texi:1710
msgid "Another form of @t{for}."
msgstr "@t{for} 的另一种形式。"

#. type: item
#: zsh.texi:1711
#, no-wrap
msgid "@t{while} @var{list} @t{@{} @var{list} @t{@}}"
msgstr "@t{while} @var{list} @t{@{} @var{list} @t{@}}"

#. type: table
#: zsh.texi:1714
msgid "An alternative form of @t{while}.  Note the limitations on the form of @var{list} mentioned above."
msgstr "@t{while} 的另一种形式。 请注意上述对 @var{list} 形式的限制。"

#. type: item
#: zsh.texi:1715
#, no-wrap
msgid "@t{until} @var{list} @t{@{} @var{list} @t{@}}"
msgstr "@t{until} @var{list} @t{@{} @var{list} @t{@}}"

#. type: table
#: zsh.texi:1718
msgid "An alternative form of @t{until}.  Note the limitations on the form of @var{list} mentioned above."
msgstr "@t{until} 的另一种形式。 请注意上述对 @var{list} 形式的限制。"

#. type: item
#: zsh.texi:1719
#, no-wrap
msgid "@t{repeat} @var{word} @var{sublist}"
msgstr "@t{repeat} @var{word} @var{sublist}"

#. type: table
#: zsh.texi:1721
msgid "This is a short form of @t{repeat}."
msgstr "这是 @t{repeat} 的简写。"

#. type: item
#: zsh.texi:1722
#, no-wrap
msgid "@t{case} @var{word} @t{@{} [ [@t{(}] @var{pattern} [ @t{|} @var{pattern} ] ... @t{)} @var{list} (@t{;;}|@t{;&}|@t{;|}) ] ... @t{@}}"
msgstr "@t{case} @var{word} @t{@{} [ [@t{(}] @var{pattern} [ @t{|} @var{pattern} ] ... @t{)} @var{list} (@t{;;}|@t{;&}|@t{;|}) ] ... @t{@}}"

#. type: table
#: zsh.texi:1724
msgid "An alternative form of @t{case}."
msgstr "@t{case} 的另一种形式。"

#. type: item
#: zsh.texi:1725
#, no-wrap
msgid "@t{select} @var{name} [ @t{in} @var{word} ... @var{term} ] @var{sublist}"
msgstr "@t{select} @var{name} [ @t{in} @var{word} ... @var{term} ] @var{sublist}"

#. type: table
#: zsh.texi:1728
msgid "where @var{term} is at least one newline or @t{;}.  A short form of @t{select}."
msgstr "其中 @var{term} 至少是一个换行符或 @t{;}。 @t{select} 的简写。"

#. type: item
#: zsh.texi:1729
#, no-wrap
msgid "@t{function} @var{word} ... [ @t{()} ] [ @var{term} ] @var{sublist}"
msgstr "@t{function} @var{word} ... [ @t{()} ] [ @var{term} ] @var{sublist}"

#. type: table
#: zsh.texi:1731
msgid "This is a short form of @t{function}."
msgstr "这是 @t{function} 的简写。"

#. type: node
#: zsh.texi:1733 zsh.texi:1751 zsh.texi:1753 zsh.texi:1831
#, no-wrap
msgid "Errors"
msgstr "错误"

#. type: cindex
#: zsh.texi:1737
#, no-wrap
msgid "reserved words"
msgstr "保留字"

#. type: findex
#: zsh.texi:1738
#, no-wrap
msgid "disable, use of"
msgstr "disable, use of"

#. type: Plain text
#: zsh.texi:1741
msgid "The following words are recognized as reserved words when used as the first word of a command unless quoted or disabled using @t{disable -r}:"
msgstr "除非加引号或使用 @t{disable -r} 禁用，否则下列单词作为命令的第一个单词使用时将被视为保留字："

#. type: t{#1}
#: zsh.texi:1747
msgid "do done esac then elif else fi for case if while function repeat time until select coproc nocorrect foreach end ! [[ @{ @} declare export float integer local readonly typeset"
msgstr "do done esac then elif else fi for case if while function repeat time until select coproc nocorrect foreach end ! [[ @{ @} declare export float integer local readonly typeset"

#. type: Plain text
#: zsh.texi:1751
msgid "Additionally, `@t{@}}' is recognized in any position if neither the @t{IGNORE_BRACES} option nor the @t{IGNORE_CLOSE_BRACES} option is set."
msgstr "此外，如果 @t{IGNORE_BRACES} 选项和 @t{IGNORE_CLOSE_BRACES} 选项均未设置， `@t{@}}'可以在任何位置被识别。"

#. type: node
#: zsh.texi:1751 zsh.texi:1831 zsh.texi:1833 zsh.texi:1843
#, no-wrap
msgid "Comments"
msgstr "注释"

#. type: cindex
#: zsh.texi:1755
#, no-wrap
msgid "errors, handling of"
msgstr "errors, handling of"

#. type: Plain text
#: zsh.texi:1764
msgid ""
"Certain errors are treated as fatal by the shell: in an interactive shell, they cause control to return to the command line, and in a non-interactive shell they cause the shell to be aborted.  In older "
"versions of zsh, a non-interactive shell running a script would not abort completely, but would resume execution at the next command to be read from the script, skipping the remainder of any functions or "
"shell constructs such as loops or conditions; this somewhat illogical behaviour can be recovered by setting the option @t{CONTINUE_ON_ERROR}."
msgstr ""
"某些错误会被 shell 视为致命错误：在交互式 shell 中，它们会导致控制返回命令行，而在非交互式 shell 中，它们会导致 shell 终止。 在旧版本的 zsh 中，运行脚本的非交互式 shell 不会完全终止，而是会在从脚本读取下一"
"条命令时继续执行，跳过任何函数或 shell 结构（如循环或条件）的剩余部分；这种有点不合逻辑的行为可以通过设置选项 @t{CONTINUE_ON_ERROR} 来恢复。"

#. type: Plain text
#: zsh.texi:1767
msgid "Fatal errors found in non-interactive shells include:"
msgstr "在非交互式 shell 中发现的致命错误包括:"

#. type: itemize
#: zsh.texi:1773
msgid "Failure to parse shell options passed when invoking the shell"
msgstr "无法解析调用 shell 时传递的 shell 选项"

#. type: itemize
#: zsh.texi:1775
msgid "Failure to change options with the @t{set} builtin"
msgstr "无法使用 @t{set} 内置命令更改选项"

#. type: itemize
#: zsh.texi:1778
msgid "Parse errors of all sorts, including failures to parse mathematical expressions"
msgstr "各种解析错误，包括无法解析数学表达式"

#. type: itemize
#: zsh.texi:1781
msgid "Failures to set or modify variable behaviour with @t{typeset}, @t{local}, @t{declare}, @t{export}, @t{integer}, @t{float}"
msgstr "使用 @t{typeset}、@t{local}、@t{declare}、@t{export}、@t{integer}、@t{float} 设置或修改变量行为失败"

#. type: itemize
#: zsh.texi:1784
msgid "Execution of incorrectly positioned loop control structures (@t{continue}, @t{break})"
msgstr "执行位置不正确的循环控制结构（@t{continue}、@t{break}）。"

#. type: itemize
#: zsh.texi:1787
msgid "Attempts to use regular expression with no regular expression module available"
msgstr "尝试使用正则表达式，但没有可用的正则表达式模块"

#. type: itemize
#: zsh.texi:1789
msgid "Disallowed operations when the @t{RESTRICTED} options is set"
msgstr "设置 @t{RESTRICTED} 选项时禁止的操作"

#. type: itemize
#: zsh.texi:1791
msgid "Failure to create a pipe needed for a pipeline"
msgstr "未能创建管道所需的管道"

#. type: itemize
#: zsh.texi:1793
msgid "Failure to create a multio"
msgstr "未能建立一个multio"

#. type: itemize
#: zsh.texi:1795
msgid "Failure to autoload a module needed for a declared shell feature"
msgstr "无法自动加载已声明的 shell 功能所需的模块"

#. type: itemize
#: zsh.texi:1797
msgid "Errors creating command or process substitutions"
msgstr "创建命令或进程替换时出现错误"

#. type: itemize
#: zsh.texi:1799
msgid "Syntax errors in glob qualifiers"
msgstr "glob 限定符中的语法错误"

#. type: itemize
#: zsh.texi:1801
msgid "File generation errors where not caught by the option @t{BAD_PATTERN}"
msgstr "选项 @t{BAD_PATTERN} 无法捕捉文件生成错误"

#. type: itemize
#: zsh.texi:1803
msgid "All bad patterns used for matching within case statements"
msgstr "case语句中用于匹配的所有不良模式"

#. type: itemize
#: zsh.texi:1806
msgid "File generation failures where not caused by @t{NO_MATCH} or similar options"
msgstr "不是由 @t{NO_MATCH} 或类似选项造成的文件生成失败"

#. type: itemize
#: zsh.texi:1809
msgid "All file generation errors where the pattern was used to create a multio"
msgstr "所有文件生成错误，其中模式被用于创建multio。"

#. type: itemize
#: zsh.texi:1811
msgid "Memory errors where detected by the shell"
msgstr "shell 检测到内存错误"

#. type: itemize
#: zsh.texi:1813
msgid "Invalid subscripts to shell variables"
msgstr "shell 变量的下标无效"

#. type: itemize
#: zsh.texi:1815
msgid "Attempts to assign read-only variables"
msgstr "尝试为只读变量赋值"

#. type: itemize
#: zsh.texi:1817
msgid "Logical errors with variables such as assignment to the wrong type"
msgstr "变量逻辑错误，如赋值给错误类型"

#. type: itemize
#: zsh.texi:1819
msgid "Use of invalid variable names"
msgstr "使用无效的变量名"

#. type: itemize
#: zsh.texi:1821
msgid "Errors in variable substitution syntax"
msgstr "变量替换语法错误"

#. type: itemize
#: zsh.texi:1823
msgid "Failure to convert characters in @t{$'}...@t{'} expressions"
msgstr "无法转换 @t{$'}...@t{'}表达式中的字符"

#. type: Plain text
#: zsh.texi:1829
msgid "If the @t{POSIX_BUILTINS} option is set, more errors associated with shell builtin commands are treated as fatal, as specified by the POSIX standard."
msgstr "如果设置了 @t{POSIX_BUILTINS} 选项，根据 POSIX 标准的规定，更多与 shell 内置命令相关的错误将被视为致命错误。"

#. type: node
#: zsh.texi:1831 zsh.texi:1843 zsh.texi:1845 zsh.texi:1975
#, no-wrap
msgid "Aliasing"
msgstr "别名"

#. type: cindex
#: zsh.texi:1835
#, no-wrap
msgid "comments"
msgstr "注释"

#. type: pindex
#: zsh.texi:1836
#, no-wrap
msgid "INTERACTIVE_COMMENTS, use of"
msgstr "INTERACTIVE_COMMENTS, use of"

#. type: vindex
#: zsh.texi:1837 zsh.texi:4353
#, no-wrap
msgid "histchars, use of"
msgstr "histchars, use of"

#. type: Plain text
#: zsh.texi:1843
msgid ""
"In non-interactive shells, or in interactive shells with the @t{INTERACTIVE_COMMENTS} option set, a word beginning with the third character of the @t{histchars} parameter (`@t{#}' by default) causes that "
"word and all the following characters up to a newline to be ignored."
msgstr "在非交互式 shell 或设置了 @t{INTERACTIVE_COMMENTS} 选项的交互式 shell 中，以 @t{histchars} 参数（默认为`@t{#}' ）的第三个字符开头的单词会导致该单词以及换行符之前的所有后续字符被忽略。"

#. type: cindex
#: zsh.texi:1847
#, no-wrap
msgid "aliasing"
msgstr "别名"

#. type: Plain text
#: zsh.texi:1855
msgid ""
"Every eligible @emph{word} in the shell input is checked to see if there is an alias defined for it.  If so, it is replaced by the text of the alias if it is in command position (if it could be the first "
"word of a simple command), or if the alias is global.  If the replacement text ends with a space, the next word in the shell input is always eligible for purposes of alias expansion."
msgstr ""
"shell 输入中每一个符合条件的 @emph{word} 都会被检查，看是否为其定义了别名。 如果有的话，如果它处于命令位置（如果它可能是简单命令的第一个单词），或者如果别名是全局的，它就会被别名文本替换。 如果替换文本以空"
"格结束，则 shell 输入中的下一个单词总是可以用于别名扩展。"

#. type: Plain text
#: zsh.texi:1860
msgid ""
"It is an error for the function name, @var{word}, in the sh-compatible function definition syntax `@var{word} @t{()} ...' to be a word that resulted from alias expansion, unless the @t{ALIAS_FUNC_DEF} "
"option is set."
msgstr ""
"除非设置了 @t{ALIAS_FUNC_DEF} 选项，否则 sh 兼容函数定义语法`@var{word} @t{()} ...' 中的函数名 @var{word}, 如果是由别名扩展产生的单词，则属于错误。@uref{comments/syntax.html#syntax-alias,[译注:语法.别名]}"

#. type: findex
#: zsh.texi:1862
#, no-wrap
msgid "alias, use of"
msgstr "alias, use of"

#. type: cindex
#: zsh.texi:1863
#, no-wrap
msgid "aliases, global"
msgstr "aliases, global"

#. type: Plain text
#: zsh.texi:1866
msgid "An alias is defined using the @t{alias} builtin; global aliases may be defined using the @t{-g} option to that builtin."
msgstr "使用 @t{alias} 内置命令可定义别名；使用 @t{-g} 选项可定义全局别名。"

#. type: Plain text
#: zsh.texi:1869
msgid "A @emph{word} is defined as:"
msgstr "一个 @emph{word} 的定义是"

#. type: itemize
#: zsh.texi:1875
msgid "Any plain string or glob pattern"
msgstr "任何普通字符串或 glob 模式"

#. type: itemize
#: zsh.texi:1878
msgid "Any quoted string, using any quoting method (note that the quotes must be part of the alias definition for this to be eligible)"
msgstr "任何带引号的字符串，使用任何引号方法（注意，引号必须是别名定义的一部分，才符合条件）"

#. type: itemize
#: zsh.texi:1880
msgid "Any parameter reference or command substitution"
msgstr "任何参数引用或命令替换"

#. type: itemize
#: zsh.texi:1883
msgid "Any series of the foregoing, concatenated without whitespace or other tokens between them"
msgstr "上述任何系列，连接时中间不留空白或其他符号"

#. type: itemize
#: zsh.texi:1885
msgid "Any reserved word (@t{case}, @t{do}, @t{else}, etc.)"
msgstr "任何保留字（@t{case}、@t{do}、@t{else} 等）"

#. type: itemize
#: zsh.texi:1888
msgid "With global aliasing, any command separator, any redirection operator, and `@t{(}' or `@t{)}' when not part of a glob pattern"
msgstr "在全局别名定义下，任何命令分隔符、重定向操作符，以及不用作 glob 模式一部分时的 `@t{(}' 或 `@t{)}'"

#. type: Plain text
#: zsh.texi:1897
msgid ""
"Alias expansion is done on the shell input before any other expansion except history expansion.  Therefore, if an alias is defined for the word @t{foo}, alias expansion may be avoided by quoting part of "
"the word, e.g. @t{\\foo}.  Any form of quoting works, although there is nothing to prevent an alias being defined for the quoted form such as @t{\\foo} as well."
msgstr ""
"别名扩展是在历史扩展之后，其它扩展之前， 在 shell 输入上进行的。 因此，如果为单词 @t{foo} 定义了别名，可以通过引用(转义)单词的一部分来避免别名扩展，例如 @t{\\foo}。 任何形式的引号(转义)都可以使用，尽管没有"
"什么可以阻止为 @t{\\foo} 这样的引号(转义)形式定义别名。"

#. type: Plain text
#: zsh.texi:1901
msgid "In particular, note that quoting must be used when using @t{unalias} to remove global aliases:"
msgstr "特别要注意的是，使用 @t{unalias} 删除全局别名时必须使用引号:"

#. type: example
#: zsh.texi:1909
#, no-wrap
msgid ""
"% alias -g foo=bar\n"
"% unalias foo\n"
"unalias: no such hash table element: bar\n"
"% unalias \\foo\n"
"% \n"
msgstr ""
"% alias -g foo=bar\n"
"% unalias foo\n"
"unalias: no such hash table element: bar\n"
"% unalias \\foo\n"
"% \n"

#. type: Plain text
#: zsh.texi:1915
msgid "When @t{POSIX_ALIASES} is set, only plain unquoted strings are eligible for aliasing.  The @t{alias} builtin does not reject ineligible aliases, but they are not expanded."
msgstr ""
"设置 @t{POSIX_ALIASES} 时，只有未加引号的普通字符串才有资格使用别名。 @t{alias} 内置命令不会拒绝不符合条件的别名，但不会对其进行扩展。@uref{comments/syntax.html#syntax-alias-posixaliases,[译注:语法.alias."
"posixaliases]}"

#. type: Plain text
#: zsh.texi:1921
msgid ""
"For use with completion, which would remove an initial backslash followed by a character that isn't special, it may be more convenient to quote the word by starting with a single quote, i.e. @t{'foo}; "
"completion will automatically add the trailing single quote."
msgstr "补全会移除首部反斜线后的非特殊字符，来与补全一起使用，以单引号开头的引用可能更方便，例如 @t{'foo}；补全会自动添加尾部的单引号。"

#. type: subsection
#: zsh.texi:1924
#, no-wrap
msgid "Alias difficulties"
msgstr "别名的问题"

#. type: Plain text
#: zsh.texi:1930
msgid "Although aliases can be used in ways that bend normal shell syntax, not every string of non-white-space characters can be used as an alias."
msgstr "虽然别名的使用方式可以超越正常的 shell 语法，但并非所有非空格字符串都可以用作别名。"

#. type: Plain text
#: zsh.texi:1939
msgid ""
"Any set of characters not listed as a word above is not a word, hence no attempt is made to expand it as an alias, no matter how it is defined (i.e. via the builtin or the special parameter @t{aliases} "
"described in @ref{The zsh/parameter Module}).  However, as noted in the case of @t{POSIX_ALIASES} above, the shell does not attempt to deduce whether the string corresponds to a word at the time the alias "
"is created."
msgstr ""
"任何未被上面作为单词列出的字符集都不是单词，因此，无论如何定义（即通过内置命令或 @ref{zsh/parameter 模块} 中描述的特殊参数 @t{aliases}），都不会尝试将其扩展为别名。不过，正如上文 @t{POSIX_ALIASES} 所述，在"
"创建别名时，shell 不会尝试推断字符串是否与单词相对应。"

#. type: Plain text
#: zsh.texi:1946
msgid ""
"For example, an expression containing an @t{=} at the start of a command line is an assignment and cannot be expanded as an alias; a lone @t{=} is not an assignment but can only be set as an alias using "
"the parameter, as otherwise the @t{=} is taken part of the syntax of the builtin command."
msgstr "例如，在命令行开头包含 @t{=} 的表达式是赋值，不能扩展为别名；单独的 @t{=} 不是赋值，只能使用参数设置为别名，否则 @t{=} 将被视为内置命令语法的一部分。"

#. type: Plain text
#: zsh.texi:1955
msgid ""
"It is not presently possible to alias the `@t{((}' token that introduces arithmetic expressions, because until a full statement has been parsed, it cannot be distinguished from two consecutive `@t{(}' "
"tokens introducing nested subshells.  Also, if a separator such as @t{&&} is aliased, @t{\\&&} turns into the two tokens @t{\\&} and @t{&}, each of which may have been aliased separately.  Similarly for "
"@t{\\<<}, @t{\\>|}, etc."
msgstr ""
"目前还无法为`@t{((}' （引入算术表达式的标记）创建别名，因为在解析完整语句之前，无法将其与两个连续的引入嵌套子shell的`@t{(}'标记区分开来。 另外，如果 @t{&&} 这样的分隔符被别名，@t{\\&&} 就会变成两个标记 "
"@t{\\&} 和 @t{&}，而每个标记都可能被单独别名。 类似的还有 @t{\\<<}, @t{\\>|}等。"

#. type: Plain text
#: zsh.texi:1959
msgid "There is a commonly encountered problem with aliases illustrated by the following code:"
msgstr "下面的代码说明了一个常见的别名问题："

#. type: example
#: zsh.texi:1963
#, no-wrap
msgid "alias echobar='echo bar'; echobar\n"
msgstr "alias echobar='echo bar'; echobar\n"

#. type: Plain text
#: zsh.texi:1973
msgid ""
"This prints a message that the command @t{echobar} could not be found.  This happens because aliases are expanded when the code is read in; the entire line is read in one go, so that when @t{echobar} is "
"executed it is too late to expand the newly defined alias.  This is often a problem in shell scripts, functions, and code executed with `@t{source}' or `@t{.}'.  Consequently, use of functions rather than "
"aliases is recommended in non-interactive code."
msgstr ""
"这将打印一条信息：找不到 @t{echobar} 命令。 出现这种情况是因为别名是在读入代码时展开的；整行代码是一次性读入的，因此在执行 @t{echobar} 时，来不及展开新定义的别名。 在 shell 脚本、函数和使用 `@t{source}'或"
"`@t{.}'执行的代码中，这通常是一个问题。 因此，建议在非交互代码中使用函数而不是别名。"

#. type: t{#1}
#: zsh.texi:1979 zsh.texi:19622
#, no-wrap
msgid "quoting"
msgstr "引用"

#. type: Plain text
#: zsh.texi:1983
msgid "A character may be @emph{quoted} (that is, made to stand for itself) by preceding it with a `@t{\\}'.  `@t{\\}' followed by a newline is ignored."
msgstr "在一个字符前加上`@t{\\}'，该字符就可以被@emph{引用}（即使他表示自己）。 后跟换行符的 `@t{\\}' 将被忽略。"

#. type: Plain text
#: zsh.texi:1990
msgid ""
"A string enclosed between `@t{$'}' and `@t{'}' is processed the same way as the string arguments of the @t{print} builtin, and the resulting string is considered to be entirely quoted.  A literal `@t{'}' "
"character can be included in the string by using the `@t{\\'}' escape."
msgstr "由 `@t{$'}'  和 `@t{'}'括起来的字符串的处理方式与 @t{print} 内置函数的字符串参数相同，生成的字符串被认为是完全加引号的。 通过使用转义符 `@t{\\'}'，可以在字符串中包含一个字面的 `@t{'}'字符。"

#. type: pindex
#: zsh.texi:1992
#, no-wrap
msgid "RC_QUOTES, use of"
msgstr "RC_QUOTES, use of"

#. type: Plain text
#: zsh.texi:1997
msgid ""
"All characters enclosed between a pair of single quotes (@t{@value{dsq}}) that is not preceded by a `@t{$}' are quoted.  A single quote cannot appear within single quotes unless the option @t{RC_QUOTES} "
"is set, in which case a pair of single quotes are turned into a single quote.  For example,"
msgstr "在一对单引号（@t{@value{dsq}}）之间括起来的所有字符，如果前面没有`@t{$}'，都会被加上引号。 单引号不能出现在单引号内，除非设置了 @t{RC_QUOTES} 选项，在这种情况下，一对单引号会变成一个单引号。 例如"

#. type: example
#: zsh.texi:2001
#, no-wrap
msgid "print @value{dsq}@value{dsq}\n"
msgstr "print @value{dsq}@value{dsq}\n"

#. type: Plain text
#: zsh.texi:2006
msgid "outputs nothing apart from a newline if @t{RC_QUOTES} is not set, but one single quote if it is set."
msgstr "如果未设置 @t{RC_QUOTES}，则除了换行符外不会输出任何内容；如果设置了 @t{RC_QUOTES}，则会输出一个单引号。"

#. type: Plain text
#: zsh.texi:2014
msgid ""
"Inside double quotes (@t{\"\"}), parameter and command substitution occur, and `@t{\\}' quotes the characters `@t{\\}', `@t{`}', `@t{\"}', `@t{$}', and the first character of @t{$histchars} (default "
"`@t{!}')."
msgstr "在双引号（@t{\"\"}）内，会出现参数和命令替换， `@t{\\}' 会引用 `@t{\\}', `@t{`}', `@t{\"}', `@t{$}'和 @t{$histchars} 的第一个字符（默认为 `@t{!}'）。"

#. type: node
#: zsh.texi:2014 zsh.texi:2470 zsh.texi:2472 zsh.texi:2523
#, no-wrap
msgid "Command Execution"
msgstr "命令执行"

#. type: cindex
#: zsh.texi:2018
#, no-wrap
msgid "redirection"
msgstr "重定向"

#. type: cindex
#: zsh.texi:2019
#, no-wrap
msgid "file descriptors"
msgstr "文件描述符"

#. type: cindex
#: zsh.texi:2020
#, no-wrap
msgid "descriptors, file"
msgstr "描述符, 文件"

#. type: Plain text
#: zsh.texi:2028
msgid ""
"If a command is followed by @t{&} and job control is not active, then the default standard input for the command is the empty file @t{/dev/null}.  Otherwise, the environment for the execution of a command "
"contains the file descriptors of the invoking shell as modified by input/output specifications."
msgstr "如果命令后跟 @t{&}，且作业控制未激活，则该命令的默认标准输入为空文件 @t{/dev/null}。 否则，命令的执行环境将包含调用的 shell 的文件描述符，并根据输入/输出规范进行修改。"

#. type: Plain text
#: zsh.texi:2038
msgid ""
"The following may appear anywhere in a simple command or may precede or follow a complex command.  Expansion occurs before @var{word} or @var{digit} is used except as noted below.  If the result of "
"substitution on @var{word} produces more than one filename, redirection occurs for each separate filename in turn."
msgstr ""
"以下内容可以出现在简单命令的任何位置，也可以出现在复杂命令的前面或后面。 在使用 @var{word} 或 @var{digit} 之前，会进行扩展，以下情况除外。 如果 @var{word} 的替换结果产生一个以上的文件名，则依次对每个独立的"
"文件名进行重定向。"

#. type: item
#: zsh.texi:2041
#, no-wrap
msgid "@t{<} @var{word}"
msgstr "@t{<} @var{word}"

#. type: table
#: zsh.texi:2044
msgid "Open file @var{word} for reading as standard input.  It is an error to open a file in this fashion if it does not exist."
msgstr "打开文件 @var{word} 作为标准输入进行读取。 如果文件不存在，用这种方式打开文件是错误的。"

#. type: item
#: zsh.texi:2045
#, no-wrap
msgid "@t{<>} @var{word}"
msgstr "@t{<>} @var{word}"

#. type: table
#: zsh.texi:2048
msgid "Open file @var{word} for reading and writing as standard input.  If the file does not exist then it is created."
msgstr "打开 @var{word} 文件，作为标准输入进行读写。 如果文件不存在，则将创建该文件。"

#. type: item
#: zsh.texi:2049
#, no-wrap
msgid "@t{>} @var{word}"
msgstr "@t{>} @var{word}"

#. type: table
#: zsh.texi:2055
msgid ""
"Open file @var{word} for writing as standard output.  If the file does not exist then it is created.  If the file exists, and the @t{CLOBBER} option is unset, this causes an error; otherwise, it is "
"truncated to zero length."
msgstr "打开 @var{word} 文件，将其作为标准输出写入。 如果文件不存在，则创建该文件。 如果文件存在，且 @t{CLOBBER} 选项未设置，则会导致错误；否则，文件将被截断为零长度。"

#. type: item
#: zsh.texi:2056
#, no-wrap
msgid "@t{>|} @var{word}"
msgstr "@t{>|} @var{word}"

#. type: itemx
#: zsh.texi:2057
#, no-wrap
msgid "@t{>!} @var{word}"
msgstr "@t{>!} @var{word}"

#. type: table
#: zsh.texi:2060
msgid "Same as @t{>}, except that the file is truncated to zero length if it exists, regardless of @t{CLOBBER}."
msgstr "与 @t{>} 相同，但如果文件存在，无论 @t{CLOBBER} 如何，文件都会被截断为零长度。"

#. type: item
#: zsh.texi:2061
#, no-wrap
msgid "@t{>>} @var{word}"
msgstr "@t{>>} @var{word}"

#. type: table
#: zsh.texi:2066
msgid ""
"Open file @var{word} for writing in append mode as standard output.  If the file does not exist, and the @t{CLOBBER} and @t{APPEND_CREATE} options are both unset, this causes an error; otherwise, the file "
"is created."
msgstr "打开 @var{word} 文件，作为标准输出以追加模式写入。 如果文件不存在，且 @t{CLOBBER} 和 @t{APPEND_CREATE} 选项均未设置，则会导致错误；否则将创建文件。"

#. type: item
#: zsh.texi:2067
#, no-wrap
msgid "@t{>>|} @var{word}"
msgstr "@t{>>|} @var{word}"

#. type: itemx
#: zsh.texi:2068
#, no-wrap
msgid "@t{>>!} @var{word}"
msgstr "@t{>>!} @var{word}"

#. type: table
#: zsh.texi:2071
msgid "Same as @t{>>}, except that the file is created if it does not exist, regardless of @t{CLOBBER} and @t{APPEND_CREATE}."
msgstr "与 @t{>>} 相同，但如果文件不存在，则会创建文件，与 @t{CLOBBER} 和 @t{APPEND_CREATE} 无关。"

#. type: item
#: zsh.texi:2072
#, no-wrap
msgid "@t{<<}[@t{-}] @var{word}"
msgstr "@t{<<}[@t{-}] @var{word}"

#. type: table
#: zsh.texi:2079
msgid ""
"The shell input is read up to a line that is the same as @var{word}, or to an end-of-file.  No parameter expansion, command substitution or filename generation is performed on @var{word}.  The resulting "
"document, called a @emph{here-document}, becomes the standard input."
msgstr "shell 输入将读取至与 @var{word} 相同的行，或至文件末尾。 不会对 @var{word} 进行参数扩展、命令替换或文件名生成。 生成的文件称为 @emph{here-document}，将成为标准输入。"

#. type: table
#: zsh.texi:2088
msgid ""
"If any character of @var{word} is quoted with single or double quotes or a `@t{\\}', no interpretation is placed upon the characters of the document.  Otherwise, parameter and command substitution occurs, "
"`@t{\\}' followed by a newline is removed, and `@t{\\}' must be used to quote the characters `@t{\\}', `@t{$}', `@t{`}' and the first character of @var{word}."
msgstr ""
"如果 @var{word} 中的任何字符被单引号、双引号或`@t{\\}'引用，则不会对文件中的字符进行解释。 否则，将进行参数替换和命令替换，`@t{\\}'后面是换行，则删除`@t{\\}'，并且必须使用 `@t{\\}' 来引用`@t{\\}', "
"`@t{$}', `@t{`}'和 @var{word} 的第一个字符。"

#. type: table
#: zsh.texi:2097
msgid ""
"Note that @var{word} itself does not undergo shell expansion.  Backquotes in @var{word} do not have their usual effect; instead they behave similarly to double quotes, except that the backquotes "
"themselves are passed through unchanged.  (This information is given for completeness and it is not recommended that backquotes be used.)  Quotes in the form @t{$'}@var{...}@t{'} have their standard "
"effect of expanding backslashed references to special characters."
msgstr ""
"请注意，@var{word} 本身不进行 shell 扩充。 @var{word} 中的反引号不会产生通常的效果；相反，它们的行为与双引号类似，只是反引号本身不会被改变。 (提供这些信息只是为了完整，并不建议使用反引号）。 @t{$'}"
"@var{...}@t{'} 形式的引用具有将反斜线引用扩展为特殊字符的标准效果。"

#. type: table
#: zsh.texi:2101
msgid "If @t{<<-} is used, then all leading tabs are stripped from @var{word} and from the document."
msgstr "如果使用 @t{<<-}，则会从 @var{word} 和文档中删除所有前导制表符。"

#. type: item
#: zsh.texi:2102
#, no-wrap
msgid "@t{<<<} @var{word}"
msgstr "@t{<<<} @var{word}"

#. type: table
#: zsh.texi:2108
msgid ""
"Perform shell expansion on @var{word} and pass the result to standard input.  This is known as a @emph{here-string}.  Compare the use of @var{word} in here-documents above, where @var{word} does not "
"undergo shell expansion.  The result will have a trailing newline after it."
msgstr "对 @var{word} 执行 shell 扩展，并将结果传入标准输入。 这被称为 @emph{here-string}。 对比上述 here-documents 中 @var{word} 的使用，@var{word} 并未进行 shell 扩充。 结果后面会有一个换行符。"

#. type: item
#: zsh.texi:2109
#, no-wrap
msgid "@t{<&} @var{number}"
msgstr "@t{<&} @var{number}"

#. type: itemx
#: zsh.texi:2110
#, no-wrap
msgid "@t{>&} @var{number}"
msgstr "@t{>&} @var{number}"

#. type: table
#: zsh.texi:2113
msgid "The standard input/output is duplicated from file descriptor @var{number} (see dup2(2))."
msgstr "从文件描述符 @var{number} 复制标准输入/输出（参见 dup2(2)）。"

#. type: t{#1}
#: zsh.texi:2114
#, no-wrap
msgid "<& -"
msgstr "<& -"

#. type: t{#1}
#: zsh.texi:2115
#, no-wrap
msgid ">& -"
msgstr ">& -"

#. type: table
#: zsh.texi:2117
msgid "Close the standard input/output."
msgstr "关闭标准输入/输出。"

#. type: t{#1}
#: zsh.texi:2118
#, no-wrap
msgid "<& p"
msgstr "<& p"

#. type: t{#1}
#: zsh.texi:2119
#, no-wrap
msgid ">& p"
msgstr ">& p"

#. type: table
#: zsh.texi:2121
msgid "The input/output from/to the coprocess is moved to the standard input/output."
msgstr "协进程的输入/输出被移至标准输入/输出。"

#. type: item
#: zsh.texi:2122
#, no-wrap
msgid "@t{>&} @var{word}"
msgstr "@t{>&} @var{word}"

#. type: itemx
#: zsh.texi:2123
#, no-wrap
msgid "@t{&>} @var{word}"
msgstr "@t{&>} @var{word}"

#. type: table
#: zsh.texi:2130
msgid ""
"(Except where `@t{>&} @var{word}' matches one of the above syntaxes; `@t{&>}' can always be used to avoid this ambiguity.)  Redirects both standard output and standard error (file descriptor 2)  in the "
"manner of `@t{>} @var{word}'.  Note that this does @emph{not} have the same effect as `@t{>} @var{word} @t{2>&1}' in the presence of multios (see the section below)."
msgstr ""
"(除 `@t{>&} @var{word}'与上述语法之一相匹配；`@t{&>}' 总是可用于避免这种歧义）。 以 `@t{>} @var{word}' 的方式重定向标准输出和标准错误（文件描述符 2）。 请注意，这与存在 multios 时， `@t{>} @var{word} "
"@t{2>&1}' 的效果@emph{不同}（见下文）。"

#. type: item
#: zsh.texi:2131
#, no-wrap
msgid "@t{>&|} @var{word}"
msgstr "@t{>&|} @var{word}"

#. type: itemx
#: zsh.texi:2132
#, no-wrap
msgid "@t{>&!} @var{word}"
msgstr "@t{>&!} @var{word}"

#. type: itemx
#: zsh.texi:2133
#, no-wrap
msgid "@t{&>|} @var{word}"
msgstr "@t{&>|} @var{word}"

#. type: itemx
#: zsh.texi:2134
#, no-wrap
msgid "@t{&>!} @var{word}"
msgstr "@t{&>!} @var{word}"

#. type: table
#: zsh.texi:2137
msgid "Redirects both standard output and standard error (file descriptor 2)  in the manner of `@t{>|} @var{word}'."
msgstr "以`@t{>|} @var{word}'的方式重定向标准输出和标准错误（文件描述符 2）。"

#. type: item
#: zsh.texi:2138
#, no-wrap
msgid "@t{>>&} @var{word}"
msgstr "@t{>>&} @var{word}"

#. type: itemx
#: zsh.texi:2139
#, no-wrap
msgid "@t{&>>} @var{word}"
msgstr "@t{&>>} @var{word}"

#. type: table
#: zsh.texi:2142
msgid "Redirects both standard output and standard error (file descriptor 2)  in the manner of `@t{>>} @var{word}'."
msgstr "以 `@t{>>} @var{word}'的方式重定向标准输出和标准错误（文件描述符 2）。"

#. type: item
#: zsh.texi:2143
#, no-wrap
msgid "@t{>>&|} @var{word}"
msgstr "@t{>>&|} @var{word}"

#. type: itemx
#: zsh.texi:2144
#, no-wrap
msgid "@t{>>&!} @var{word}"
msgstr "@t{>>&!} @var{word}"

#. type: itemx
#: zsh.texi:2145
#, no-wrap
msgid "@t{&>>|} @var{word}"
msgstr "@t{&>>|} @var{word}"

#. type: itemx
#: zsh.texi:2146
#, no-wrap
msgid "@t{&>>!} @var{word}"
msgstr "@t{&>>!} @var{word}"

#. type: table
#: zsh.texi:2149
msgid "Redirects both standard output and standard error (file descriptor 2)  in the manner of `@t{>>|} @var{word}'."
msgstr "以`@t{>>|} @var{word}'的方式重定向标准输出和标准错误（文件描述符 2）。"

#. type: Plain text
#: zsh.texi:2161
msgid ""
"If one of the above is preceded by a digit, then the file descriptor referred to is that specified by the digit instead of the default 0 or 1.  The order in which redirections are specified is "
"significant.  The shell evaluates each redirection in terms of the (@emph{file descriptor}, @emph{file})  association at the time of evaluation.  For example:"
msgstr ""
"如果上述任何一项前面有一个数字，那么所指的文件描述符就是该数字指定的文件描述符，而不是默认的 0 或 1。 指定重定向的顺序很重要。 shell 在计算每个重定向时，都会根据（@emph{文件描述符}, @emph{文件}）关联进行计"
"算。 例如"

#. type: quotation
#: zsh.texi:2165
msgid "... @t{1>}@var{fname} @t{2>&1}"
msgstr "... @t{1>}@var{fname} @t{2>&1}"

#. type: Plain text
#: zsh.texi:2175
msgid ""
"first associates file descriptor 1 with file @var{fname}.  It then associates file descriptor 2 with the file associated with file descriptor 1 (that is, @var{fname}).  If the order of redirections were "
"reversed, file descriptor 2 would be associated with the terminal (assuming file descriptor 1 had been)  and then file descriptor 1 would be associated with file @var{fname}."
msgstr ""
"首先将文件描述符 1 与文件 @var{fname} 关联。 然后将文件描述符 2 和与文件描述符 1 相关联的文件（即 @var{fname}）关联起来。 如果重定向的顺序颠倒，文件描述符 2 将与终端关联（假设文件描述符 1 已经关联），然后"
"文件描述符 1 将与文件 @var{fname} 关联。@uref{comments/redirections.html#redirections-order,[译注:重定向.顺序]}"

#. type: Plain text
#: zsh.texi:2180
msgid "The `@t{|&}' command separator described in @ref{Simple Commands & Pipelines} is a shorthand for `@t{2>&1 |}'."
msgstr "@ref{简单命令和管道} 中描述的 `@t{|&}' 命令分隔符是 `@t{2>&1 |}'的简写。"

#. type: Plain text
#: zsh.texi:2189
msgid ""
"The various forms of process substitution, `@t{<(}@var{list}@t{)}', and `@t{=(}@var{list}@t{)}' for input and `@t{>(}@var{list}@t{)}' for output, are often used together with redirection.  For example, if "
"@var{word} in an output redirection is of the form `@t{>(}@var{list}@t{)}' then the output is piped to the command represented by @var{list}.  See @ref{Process Substitution}."
msgstr ""
"各种形式的进程替换，即输入的`@t{<(}@var{list}@t{)}'和 `@t{=(}@var{list}@t{)}' 以及输出的`@t{>(}@var{list}@t{)}'，经常与重定向一起使用。 例如，如果输出重定向中的 @var{word} 的形式为 `@t{>(}@var{list}"
"@t{)}' ，那么输出将被管道输送到 @var{list} 所代表的命令。 参见 @ref{进程替换}。"

#. type: section
#: zsh.texi:2190
#, no-wrap
msgid "Opening file descriptors using parameters"
msgstr "使用参数打开文件描述符"

#. type: cindex
#: zsh.texi:2192
#, no-wrap
msgid "file descriptors, use with parameters"
msgstr "文件描述符, 使用参数的"

#. type: cindex
#: zsh.texi:2193
#, no-wrap
msgid "parameters, for using file descriptors"
msgstr "参数, 用于使用文件描述符"

#. type: Plain text
#: zsh.texi:2203
msgid ""
"When the shell is parsing arguments to a command, and the shell option @t{IGNORE_BRACES} is not set, a different form of redirection is allowed: instead of a digit before the operator there is a valid "
"shell identifier enclosed in braces.  The shell will open a new file descriptor that is guaranteed to be at least 10 and set the parameter named by the identifier to the file descriptor opened.  No "
"whitespace is allowed between the closing brace and the redirection character.  For example:"
msgstr ""
"在 shell 解析命令参数时，如果未设置 shell 选项 @t{IGNORE_BRACES}，则允许使用另一种形式的重定向：用大括号括起来的有效 shell 标识符代替运算符前的数字。 shell 将打开一个新的文件描述符，该文件描述符保证至少为 "
"10，并将标识符命名的参数设置为打开的文件描述符。 在括号和重定向字符之间不允许有空白。 例如"

#. type: quotation
#: zsh.texi:2207
msgid "... @t{@{myfd@}>&1}"
msgstr "... @t{@{myfd@}>&1}"

#. type: Plain text
#: zsh.texi:2215
msgid ""
"This opens a new file descriptor that is a duplicate of file descriptor 1 and sets the parameter @t{myfd} to the number of the file descriptor, which will be at least 10.  The new file descriptor can be "
"written to using the syntax @t{>&$myfd}.  The file descriptor remains open in subshells and forked external executables."
msgstr ""
"这将打开一个与文件描述符 1 重复的新文件描述符，并将参数 @t{myfd} 设置为文件描述符的编号（至少为 10）。 可以使用 @t{>&$myfd} 语法写入新的文件描述符。 该文件描述符在子shell和分叉（forked）的外部可执行文件中"
"保持打开状态。"

#. type: Plain text
#: zsh.texi:2221
msgid ""
"The syntax @t{@{}@var{varid}@t{@}>&-}, for example @t{@{myfd@}>&-}, may be used to close a file descriptor opened in this fashion.  Note that the parameter given by @var{varid} must previously be set to a "
"file descriptor in this case."
msgstr "语法 @t{@{}@var{varid}@t{@}>&-}，例如 @t{@{myfd@}>&-}，可用于关闭以这种方式打开的文件描述符。 需要注意的是，在这种情况下，@var{varid} 给出的参数必须事先设置为文件描述符。"

#. type: Plain text
#: zsh.texi:2227
msgid ""
"It is an error to open or close a file descriptor in this fashion when the parameter is readonly.  However, it is not an error to read or write a file descriptor using @t{<&$}@var{param} or @t{>&$}"
"@var{param} if @var{param} is readonly."
msgstr ""
"当参数为只读时，以这种方式打开或关闭文件描述符是错误的。 不过，如果 @var{param} 为只读参数，则使用 @t{<&$}@var{param} 或 @t{>&$}@var{param} 读取或写入文件描述符不会出错。@uref{comments/redirections."
"html#redirections-fd-param-readonly,[译注:重定向.文件描述符.只读参数]}"

#. type: Plain text
#: zsh.texi:2233
msgid ""
"If the option @t{CLOBBER} is unset, it is an error to open a file descriptor using a parameter that is already set to an open file descriptor previously allocated by this mechanism.  Unsetting the "
"parameter before using it for allocating a file descriptor avoids the error."
msgstr "如果未设置选项 @t{CLOBBER}，如果参数是一个打开的文件描述符的（通过本机制已经分配的），通过该参数打开文件描述符是错误的。 在使用该参数分配文件描述符前取消参数设置，就不会出错。"

#. type: Plain text
#: zsh.texi:2241
msgid ""
"Note that this mechanism merely allocates or closes a file descriptor; it does not perform any redirections from or to it.  It is usually convenient to allocate a file descriptor prior to use as an "
"argument to @t{exec}.  The syntax does not in any case work when used around complex commands such as parenthesised subshells or loops, where the opening brace is interpreted as part of a command list to "
"be executed in the current shell."
msgstr ""
"请注意，这种机制只是分配或关闭文件描述符，并不执行任何重定向操作。 通常，在将文件描述符作为 @t{exec} 的参数使用之前，分配文件描述符会比较方便。 在任何情况下，该语法都不能用于复杂的命令，例如带括号的子shell"
"或循环，在这种情况下，开头的括号会被解释为要在当前 shell 中执行的命令列表的一部分。"

#. type: Plain text
#: zsh.texi:2245
msgid "The following shows a typical sequence of allocation, use, and closing of a file descriptor:"
msgstr "下面显示了分配、使用和关闭文件描述符的典型顺序："

#. type: example
#: zsh.texi:2252
#, no-wrap
msgid ""
"integer myfd\n"
"exec @{myfd@}>~/logs/mylogfile.txt\n"
"print This is a log message. >&$myfd\n"
"exec @{myfd@}>&-\n"
msgstr ""
"integer myfd\n"
"exec @{myfd@}>~/logs/mylogfile.txt\n"
"print This is a log message. >&$myfd\n"
"exec @{myfd@}>&-\n"

#. type: Plain text
#: zsh.texi:2259
msgid ""
"Note that the expansion of the variable in the expression @t{>&$myfd} occurs at the point the redirection is opened.  This is after the expansion of command arguments and after any redirections to the "
"left on the command line have been processed."
msgstr "请注意，表达式 @t{>&$myfd} 中变量的扩展是在重定向打开时进行的。 这是在扩展命令参数和处理命令行左侧的重定向之后。"

#. type: section
#: zsh.texi:2260
#, no-wrap
msgid "Multios"
msgstr "Multios"

#. type: cindex
#: zsh.texi:2262
#, no-wrap
msgid "multios"
msgstr "multios"

#. type: pindex
#: zsh.texi:2263
#, no-wrap
msgid "MULTIOS, use of"
msgstr "MULTIOS, use of"

#. type: Plain text
#: zsh.texi:2268
msgid ""
"If the user tries to open a file descriptor for writing more than once, the shell opens the file descriptor as a pipe to a process that copies its input to all the specified outputs, similar to "
"@cite{tee}, provided the @t{MULTIOS} option is set, as it is by default.  Thus:"
msgstr "如果用户尝试打开一个文件描述符进行多次写入，shell 会将该文件描述符作为管道打开到一个进程，该进程会将其输入复制到所有指定的输出，类似于 @cite{tee}，前提是设置了 @t{MULTIOS}（默认设置）选项。 因此"

#. type: example
#: zsh.texi:2272
#, no-wrap
msgid "date >foo >bar\n"
msgstr "date >foo >bar\n"

#. type: Plain text
#: zsh.texi:2277
msgid "writes the date to two files, named `@t{foo}' and `@t{bar}'.  Note that a pipe is an implicit redirection; thus"
msgstr "将日期写入两个文件，分别命名为`@t{foo}'和`@t{bar}'。 请注意，管道是一种隐式重定向；因此"

#. type: example
#: zsh.texi:2281
#, no-wrap
msgid "date >foo | cat\n"
msgstr "date >foo | cat\n"

#. type: Plain text
#: zsh.texi:2285
msgid "writes the date to the file `@t{foo}', and also pipes it to cat."
msgstr "将日期写入文件`@t{foo}'，并将其导入 cat。"

#. type: Plain text
#: zsh.texi:2289
msgid "Note that the shell opens all the files to be used in the multio process immediately, not at the point they are about to be written."
msgstr "请注意，shell 会立即打开所有要在 multio 进程中使用的文件，而不是在即将写入这些文件时才打开。"

#. type: Plain text
#: zsh.texi:2296
msgid ""
"Note also that redirections are always expanded in order.  This happens regardless of the setting of the @t{MULTIOS} option, but with the option in effect there are additional consequences. For example, "
"the meaning of the expression @t{>&1} will change after a previous redirection:"
msgstr "还要注意的是，重定向总是按顺序展开的。 这与 @t{MULTIOS} 选项的设置无关，但如果该选项生效，则会产生额外的后果。例如，表达式 @t{>&1} 的含义会在前一次重定向后发生变化："

#. type: example
#: zsh.texi:2300
#, no-wrap
msgid "date >&1 >output\n"
msgstr "date >&1 >output\n"

#. type: Plain text
#: zsh.texi:2306
msgid "In the case above, the @t{>&1} refers to the standard output at the start of the line; the result is similar to the @t{tee} command.  However, consider:"
msgstr "在上面的例子中，@t{>&1} 指的是行首的标准输出；结果与 @t{tee} 命令类似。 不过，请注意"

#. type: example
#: zsh.texi:2310
#, no-wrap
msgid "date >output >&1\n"
msgstr "date >output >&1\n"

#. type: Plain text
#: zsh.texi:2317
msgid ""
"As redirections are evaluated in order, when the @t{>&1} is encountered the standard output is set to the file @t{output} and another copy of the output is therefore sent to that file.  This is unlikely "
"to be what is intended."
msgstr "由于重定向是按顺序计算的，当遇到 @t{>&1} 时，标准输出会被设置为 @t{output} 文件，因此另一份输出会被发送到该文件。 这可能不是我们想要的结果。"

#. type: Plain text
#: zsh.texi:2322
msgid "If the @t{MULTIOS} option is set, the word after a redirection operator is also subjected to filename generation (globbing).  Thus"
msgstr "如果设置了 @t{MULTIOS} 选项，重定向运算符后的字也会执行文件名生成（通配）。 因此"

#. type: example
#: zsh.texi:2326
#, no-wrap
msgid ": > *\n"
msgstr ": > *\n"

#. type: Plain text
#: zsh.texi:2333
msgid "will truncate all files in the current directory, assuming there's at least one.  (Without the @t{MULTIOS} option, it would create an empty file called `@t{*}'.)  Similarly, you can do"
msgstr "将截断当前目录下的所有文件，前提是至少有一个文件。 (如果没有 @t{MULTIOS} 选项，它将创建一个名为`@t{*}'的空文件）。 类似地，可以执行"

#. type: example
#: zsh.texi:2337
#, no-wrap
msgid "echo exit 0 >> *.sh\n"
msgstr "echo exit 0 >> *.sh\n"

#. type: Plain text
#: zsh.texi:2347
msgid ""
"If the user tries to open a file descriptor for reading more than once, the shell opens the file descriptor as a pipe to a process that copies all the specified inputs to its output in the order "
"specified, provided the @t{MULTIOS} option is set.  It should be noted that each file is opened immediately, not at the point where it is about to be read: this behaviour differs from @t{cat}, so if "
"strictly standard behaviour is needed, @t{cat} should be used instead."
msgstr ""
"如果用户尝试打开一个文件描述符进行多次读取，shell 会将该文件描述符作为管道打开到一个进程，该进程会按照指定的顺序将所有指定的输入复制到输出，前提是设置了 @t{MULTIOS} 选项。 需要注意的是，每个文件都是立即打"
"开的，而不是在即将读取时打开：这种行为与 @t{cat} 不同，因此如果需要严格的标准行为，应使用 @t{cat} 代替。"

#. type: Plain text
#: zsh.texi:2350
msgid "Thus"
msgstr "因此"

#. type: example
#: zsh.texi:2354
#, no-wrap
msgid "sort <foo <fubar\n"
msgstr "sort <foo <fubar\n"

#. type: Plain text
#: zsh.texi:2358
msgid "or even"
msgstr "甚至"

#. type: example
#: zsh.texi:2362
#, no-wrap
msgid "sort <f@{oo,ubar@}\n"
msgstr "sort <f@{oo,ubar@}\n"

#. type: Plain text
#: zsh.texi:2366
msgid "is equivalent to `@t{cat foo fubar | sort}'."
msgstr "等价于 `@t{cat foo fubar | sort}'."

#. type: Plain text
#: zsh.texi:2371
msgid "Expansion of the redirection argument occurs at the point the redirection is opened, at the point described above for the expansion of the variable in @t{>&$myfd}."
msgstr "重定向参数的扩展发生在重定向打开时，也就是上述 @t{>&$myfd} 中变量扩展时。"

#. type: Plain text
#: zsh.texi:2374
msgid "Note that a pipe is an implicit redirection; thus"
msgstr "请注意，管道是一种隐式重定向，因此"

#. type: example
#: zsh.texi:2378
#, no-wrap
msgid "cat bar | sort <foo\n"
msgstr "cat bar | sort <foo\n"

#. type: Plain text
#: zsh.texi:2382
msgid "is equivalent to `@t{cat bar foo | sort}' (note the order of the inputs)."
msgstr "等价于 `@t{cat bar foo | sort}'（注意输入的顺序）。"

#. type: Plain text
#: zsh.texi:2387
msgid "If the @t{MULTIOS} option is @emph{un}set, each redirection replaces the previous redirection for that file descriptor.  However, all files redirected to are actually opened, so"
msgstr "如果 @t{MULTIOS} 选项为 @emph{未设置}，则每次重定向都会替换之前针对该文件描述符的重定向。 不过，所有重定向到的文件实际上都会被打开，因此"

#. type: example
#: zsh.texi:2391
#, no-wrap
msgid "echo Hello > bar > baz\n"
msgstr "echo Hello > bar > baz\n"

#. type: Plain text
#: zsh.texi:2396
msgid "when @t{MULTIOS} is unset will truncate `@t{bar}', and write `@t{Hello}' into `@t{baz}'."
msgstr "当 @t{MULTIOS} 未设置时，将截断`@t{bar}'，并将 `@t{Hello}' 写入`@t{baz}'。"

#. type: Plain text
#: zsh.texi:2400
msgid "There is a problem when an output multio is attached to an external program.  A simple example shows this:"
msgstr "当输出multio连接到外部程序时会出现一个问题。 一个简单的例子就能说明问题："

#. type: example
#: zsh.texi:2405
#, no-wrap
msgid ""
"cat file >file1 >file2\n"
"cat file1 file2\n"
msgstr ""
"cat file >file1 >file2\n"
"cat file1 file2\n"

#. type: Plain text
#: zsh.texi:2411
msgid "Here, it is possible that the second `@t{cat}' will not display the full contents of @t{file1} and @t{file2} (i.e. the original contents of @t{file} repeated twice)."
msgstr "在这里，第二个 `@t{cat}'可能不会显示 @t{file1} 和 @t{file2} 的全部内容（即 @t{file} 的原始内容重复了两次）。"

#. type: Plain text
#: zsh.texi:2419
msgid ""
"The reason for this is that the multios are spawned after the @t{cat} process is forked from the parent shell, so the parent shell does not wait for the multios to finish writing data.  This means the "
"command as shown can exit before @t{file1} and @t{file2} are completely written.  As a workaround, it is possible to run the @t{cat} process as part of a job in the current shell:"
msgstr ""
"原因是multios是在 @t{cat} 进程从父 shell 分支出来后才生成的，因此父 shell 不会等待multios完成数据写入。 这意味着所示命令可能会在 @t{file1} 和 @t{file2} 完全写完之前退出。 作为一种解决方法，可以将 @t{cat} "
"进程作为当前 shell 中作业的一部分运行："

#. type: example
#: zsh.texi:2423
#, no-wrap
msgid "@{ cat file @} >file >file2\n"
msgstr "@{ cat file @} >file >file2\n"

#. type: Plain text
#: zsh.texi:2428
msgid "Here, the @t{@{}@var{...}@t{@}} job will pause to wait for both files to be written."
msgstr "在此，@t{@{}@var{...}@t{@}}  作业将暂停，等待两个文件都被写入。"

#. type: section
#: zsh.texi:2431
#, no-wrap
msgid "Redirections with no command"
msgstr "没有命令的重定向"

#. type: Plain text
#: zsh.texi:2436
msgid "When a simple command consists of one or more redirection operators and zero or more parameter assignments, but no command name, zsh can behave in several ways."
msgstr "当一条简单的命令由一个或多个重定向操作符和零个或多个参数赋值组成，但没有命令名称时，zsh 会以几种方式执行。"

#. type: vindex
#: zsh.texi:2438
#, no-wrap
msgid "NULLCMD, use of"
msgstr "NULLCMD, use of"

#. type: pindex
#: zsh.texi:2439
#, no-wrap
msgid "CSH_NULLCMD, use of"
msgstr "CSH_NULLCMD, use of"

#. type: Plain text
#: zsh.texi:2443
msgid "If the parameter @t{NULLCMD} is not set or the option @t{CSH_NULLCMD} is set, an error is caused.  This is the @cite{csh} behavior and @t{CSH_NULLCMD} is set by default when emulating @cite{csh}."
msgstr "如果未设置参数 @t{NULLCMD}，或设置了选项 @t{CSH_NULLCMD}，则会导致错误。 这是 @cite{csh} 的行为，在模拟 @cite{csh} 时，@t{CSH_NULLCMD} 默认会被设置。"

#. type: pindex
#: zsh.texi:2445
#, no-wrap
msgid "SH_NULLCMD, use of"
msgstr "SH_NULLCMD, use of"

#. type: Plain text
#: zsh.texi:2449
msgid "If the option @t{SH_NULLCMD} is set, the builtin `@t{:}' is inserted as a command with the given redirections.  This is the default when emulating @cite{sh} or @cite{ksh}."
msgstr "如果设置了选项 @t{SH_NULLCMD}，内置的\"@t{:}\"将作为命令插入，并带有给定的重定向。 这是模拟 @cite{sh} 或 @cite{ksh} 时的默认值。"

#. type: vindex
#: zsh.texi:2451
#, no-wrap
msgid "READNULLCMD, use of"
msgstr "READNULLCMD, use of"

#. type: Plain text
#: zsh.texi:2457
msgid ""
"Otherwise, if the parameter @t{NULLCMD} is set, its value will be used as a command with the given redirections.  If both @t{NULLCMD} and @t{READNULLCMD} are set, then the value of the latter will be used "
"instead of that of the former when the redirection is an input.  The default for @t{NULLCMD} is `@t{cat}' and for @t{READNULLCMD} is `@t{more}'. Thus"
msgstr ""
"否则，如果设置了参数 @t{NULLCMD}，其值将被用作带有给定重定向的命令。 如果同时设置了 @t{NULLCMD} 和 @t{READNULLCMD}，那么当重定向为输入时，将使用后者的值，而不是前者的值。 @t{NULLCMD} 的默认值是 "
"`@t{cat}' ，而 @t{READNULLCMD} 的默认值是`@t{more}'。因此"

#. type: example
#: zsh.texi:2461
#, no-wrap
msgid "< file\n"
msgstr "< file\n"

#. type: Plain text
#: zsh.texi:2466
msgid "shows the contents of @t{file} on standard output, with paging if that is a terminal.  @t{NULLCMD} and @t{READNULLCMD} may refer to shell functions."
msgstr "将 @t{file} 的内容显示在标准输出上，如果是终端，还将分页显示。 @t{NULLCMD} 和 @t{READNULLCMD} 可指 shell 函数。"

#. type: section
#: zsh.texi:2470 zsh.texi:2523 zsh.texi:2525 zsh.texi:3018 zsh.texi:21061 zsh.texi:31751 zsh.texi:34770
#, no-wrap
msgid "Functions"
msgstr "函数"

#. type: cindex
#: zsh.texi:2474
#, no-wrap
msgid "command execution"
msgstr "命令执行"

#. type: cindex
#: zsh.texi:2475
#, no-wrap
msgid "execution, of commands"
msgstr "执行, of commands"

#. type: cindex
#: zsh.texi:2476
#, no-wrap
msgid "command not found, handling of"
msgstr "找不到命令, handling of"

#. type: findex
#: zsh.texi:2477
#, no-wrap
msgid "command_not_found_handler"
msgstr "command_not_found_handler"

#. type: Plain text
#: zsh.texi:2482
msgid ""
"If a command name contains no slashes, the shell attempts to locate it.  If there exists a shell function by that name, the function is invoked as described in @ref{Functions}.  If there exists a shell "
"builtin by that name, the builtin is invoked."
msgstr "如果命令名不包含斜线，shell 会尝试查找它。 如果该命令名下存在 shell 函数，则按照 @ref{函数} 中的说明调用该函数。 如果存在以该命令名命名的 shell 内置命令，则调用该内置命令。"

#. type: vindex
#: zsh.texi:2484
#, no-wrap
msgid "path, use of"
msgstr "path, use of"

#. type: Plain text
#: zsh.texi:2487
msgid "Otherwise, the shell searches each element of @t{$path} for a directory containing an executable file by that name."
msgstr "否则，shell 会搜索 @t{$path} 的每个元素，查找包含该名称可执行文件的目录。"

#. type: Plain text
#: zsh.texi:2491
msgid "If execution fails: an error message is printed, and one of the following values is returned."
msgstr "如果执行失败：则打印错误信息，并返回以下值之一。"

#. type: item
#: zsh.texi:2494
#, no-wrap
msgid "127"
msgstr "127"

#. type: table
#: zsh.texi:2497
msgid "The search was unsuccessful.  The error message is `@t{command not found:} @var{cmd}'."
msgstr "搜索不成功。 错误信息为  `@t{command not found:} @var{cmd}'。"

#. type: item
#: zsh.texi:2497
#, no-wrap
msgid "126"
msgstr "126"

#. type: table
#: zsh.texi:2503
msgid ""
"The executable file has insufficient permissions, is a directory or special file, or is not a script and is in a format unrecognized by the operating system.  The exact conditions and error message are "
"operating system-dependent; see execve(2)."
msgstr "可执行文件的权限不足、是目录或特殊文件、不是脚本和格式未被操作系统识别。 具体条件和错误信息取决于操作系统；请参阅 execve(2)。"

#. type: Plain text
#: zsh.texi:2513
msgid ""
"If execution fails because the file is not in executable format, and the file is not a directory, it is assumed to be a shell script.  @t{/bin/sh} is spawned to execute it.  If the program is a file "
"beginning with `@t{#!}', the remainder of the first line specifies an interpreter for the program.  The shell will execute the specified interpreter on operating systems that do not handle this executable "
"format in the kernel."
msgstr ""
"如果执行失败是因为文件不是可执行格式，且文件不是目录，则假定该文件是 shell 脚本。 @t{/bin/sh} 将被生成并执行。 如果程序是以`@t{#!}'开头的文件，第一行的其余部分将指定程序的解释器。 在内核不处理这种可执行文"
"件格式的操作系统上，shell 将执行指定的解释器。"

#. type: Plain text
#: zsh.texi:2523
msgid ""
"If no external command is found but a function @t{command_not_found_handler} exists the shell executes this function with all command line arguments.  The return status of the function becomes the status "
"of the command.  Note that the handler is executed in a subshell forked to execute an external command, hence changes to directories, shell parameters, etc. have no effect on the main shell."
msgstr ""
"如果没有找到外部命令，但存在函数 @t{command_not_found_handler}，shell 就会使用所有命令行参数执行该函数。 函数的返回状态将成为命令的状态。 请注意，处理程序是在执行外部命令的子 shell 中执行的，因此目录、"
"shell 参数等的更改不会影响主 shell。"

#. type: node
#: zsh.texi:2523 zsh.texi:3018 zsh.texi:3020 zsh.texi:3186
#, no-wrap
msgid "Jobs & Signals"
msgstr "作业和信号"

#. type: t{#1}
#: zsh.texi:2527 zsh.texi:13687 zsh.texi:21555 zsh.texi:29633 zsh.texi:29634 zsh.texi:35798
#, no-wrap
msgid "functions"
msgstr "函数"

#. type: findex
#: zsh.texi:2528
#, no-wrap
msgid "function, use of"
msgstr "函数, use of"

#. type: Plain text
#: zsh.texi:2536
msgid ""
"Shell functions are defined with the @t{function} reserved word or the special syntax `@var{funcname} @t{()}'.  Shell functions are read in and stored internally.  Alias names are resolved when the "
"function is read.  Functions are executed like commands with the arguments passed as positional parameters.  (See @ref{Command Execution}.)"
msgstr "Shell 函数是用 @t{function} 保留字或特殊语法`@var{funcname} @t{()}'定义的。 Shell 函数在内部读取和存储。 读取函数时会解析别名。 函数像命令一样执行，参数作为位置参数传递。 (请参阅 @ref{命令执行}）。"

#. type: Plain text
#: zsh.texi:2544
msgid ""
"Functions execute in the same process as the caller and share all files and present working directory with the caller.  A trap on @t{EXIT} set inside a function is executed after the function completes in "
"the environment of the caller."
msgstr "函数在与调用者相同的进程中执行，并与调用者共享所有文件和当前工作目录。 在函数内部设置的 @t{EXIT} 陷阱会在函数完成后在调用者的环境中执行。"

#. type: findex
#: zsh.texi:2546
#, no-wrap
msgid "return, use of"
msgstr "return, use of"

#. type: Plain text
#: zsh.texi:2548
msgid "The @t{return} builtin is used to return from function calls."
msgstr "@t{return} 内置命令用于从函数调用中返回。"

#. type: findex
#: zsh.texi:2550
#, no-wrap
msgid "functions, use of"
msgstr "functions, use of"

#. type: Plain text
#: zsh.texi:2552
msgid "Function identifiers can be listed with the @t{functions} builtin."
msgstr "可以使用 @t{functions} 内置命令列出函数标识符。"

#. type: findex
#: zsh.texi:2552
#, no-wrap
msgid "unfunction, use of"
msgstr "unfunction, use of"

#. type: Plain text
#: zsh.texi:2554
msgid "Functions can be undefined with the @t{unfunction} builtin."
msgstr "函数可以使用 @t{unfunction} 内置命令清除定义。"

#. type: section
#: zsh.texi:2555
#, no-wrap
msgid "Autoloading Functions"
msgstr "自动加载函数"

#. type: cindex
#: zsh.texi:2557 zsh.texi:12861
#, no-wrap
msgid "autoloading functions"
msgstr "自动加载函数"

#. type: cindex
#: zsh.texi:2558 zsh.texi:12860
#, no-wrap
msgid "functions, autoloading"
msgstr "函数, 自动加载"

#. type: findex
#: zsh.texi:2561
#, no-wrap
msgid "autoload, use of"
msgstr "autoload, use of"

#. type: vindex
#: zsh.texi:2562
#, no-wrap
msgid "fpath, use of"
msgstr "fpath, use of"

#. type: Plain text
#: zsh.texi:2568
msgid ""
"A function can be marked as @emph{undefined} using the @t{autoload} builtin (or `@t{functions -u}' or `@t{typeset -fu}').  Such a function has no body.  When the function is first executed, the shell "
"searches for its definition using the elements of the @t{fpath} variable.  Thus to define functions for autoloading, a typical sequence is:"
msgstr ""
"可以使用 @t{autoload} 内置命令（或 `@t{functions -u}' 或 `@t{typeset -fu}'）将函数标记为 @emph{未定义的} @uref{comments/functions.html#function-autoload-undefined, [译注:函数.自动加载.未定义的]}。 这样的函"
"数没有主体。 第一次执行函数时，shell 会使用 @t{fpath} 变量的元素搜索函数的定义。 因此，定义自动加载函数的典型顺序是"

#. type: example
#: zsh.texi:2573
#, no-wrap
msgid ""
"fpath=(~/myfuncs $fpath)\n"
"autoload myfunc1 myfunc2 ...\n"
msgstr ""
"fpath=(~/myfuncs $fpath)\n"
"autoload myfunc1 myfunc2 ...\n"

#. type: Plain text
#: zsh.texi:2579
msgid ""
"The usual alias expansion during reading will be suppressed if the @t{autoload} builtin or its equivalent is given the option @t{-U}. This is recommended for the use of functions supplied with the zsh "
"distribution."
msgstr "如果 @t{autoload} 内置命令或其等效命令的选项为 @t{-U}，读取过程中通常的别名扩展将被抑制。建议使用 zsh 发行版提供的函数。"

#. type: findex
#: zsh.texi:2579
#, no-wrap
msgid "zcompile, use of"
msgstr "zcompile, use of"

#. type: Plain text
#: zsh.texi:2583
msgid ""
"Note that for functions precompiled with the @t{zcompile} builtin command the flag @t{-U} must be provided when the @t{.zwc} file is created, as the corresponding information is compiled into the latter."
msgstr "请注意，对于使用 @t{zcompile} 内置命令预编译的函数，必须在创建 @t{.zwc} 文件时提供 @t{-U} 标记，因为相应的信息会编译到 @t{.zwc} 文件中。"

#. type: Plain text
#: zsh.texi:2587
msgid "For each @var{element} in @t{fpath}, the shell looks for three possible files, the newest of which is used to load the definition for the function:"
msgstr "对于 @t{fpath} 中的每个 @var{element}，shell 会查找三个可能的文件，其中最新的文件用于加载函数的定义："

#. type: item
#: zsh.texi:2590
#, no-wrap
msgid "@var{element}@t{.zwc}"
msgstr "@var{element}@t{.zwc}"

#. type: table
#: zsh.texi:2597
msgid ""
"A file created with the @t{zcompile} builtin command, which is expected to contain the definitions for all functions in the directory named @var{element}.  The file is treated in the same manner as a "
"directory containing files for functions and is searched for the definition of the function.  If the definition is not found, the search for a definition proceeds with the other two possibilities "
"described below."
msgstr ""
"使用 @t{zcompile} 内置命令创建的文件，预计将包含名为 @var{element} 的目录中所有函数的定义。 该文件的处理方式与包含函数文件的目录相同，并搜索函数的定义。 如果未找到定义，则按下面描述的其他两种可能性搜索定"
"义。"

#. type: table
#: zsh.texi:2607
msgid ""
"If @var{element} already includes a @t{.zwc} extension (i.e. the extension was explicitly given by the user), @var{element} is searched for the definition of the function without comparing its age to that "
"of other files; in fact, there does not need to be any directory named @var{element} without the suffix.  Thus including an element such as `@t{/usr/local/funcs.zwc}' in @t{fpath} will speed up the search "
"for functions, with the disadvantage that functions included must be explicitly recompiled by hand before the shell notices any changes."
msgstr ""
"如果 @var{element} 已经包含 @t{.zwc} 扩展名（即用户明确给出了扩展名），则 @var{element} 将搜索函数的定义，而不会将其与其他文件的时间进行比较；事实上，不需要有任何名为 @var{element} 而不带后缀的目录。 因"
"此，在 @t{fpath} 中加入诸如 `@t{/usr/local/funcs.zwc}'这样的元素会加快搜索函数的速度，但缺点是在 shell 发现任何变化之前，必须明确地手工重新编译所包含的函数。"

#. type: item
#: zsh.texi:2608
#, no-wrap
msgid "@var{element}@t{/}@var{function}@t{.zwc}"
msgstr "@var{element}@t{/}@var{function}@t{.zwc}"

#. type: table
#: zsh.texi:2613
msgid ""
"A file created with @t{zcompile}, which is expected to contain the definition for @var{function}.  It may include other function definitions as well, but those are neither loaded nor executed; a file "
"found in this way is searched @emph{only} for the definition of @var{function}."
msgstr "使用 @t{zcompile} 创建的文件，预计包含 @var{function} 的定义。 它也可能包含其他函数定义，但这些定义既不会被加载，也不会被执行；以这种方式找到的文件@emph{只} 搜索 @var{function} 的定义。"

#. type: item
#: zsh.texi:2614
#, no-wrap
msgid "@var{element}@t{/}@var{function}"
msgstr "@var{element}@t{/}@var{function}"

#. type: table
#: zsh.texi:2616
msgid "A file of zsh command text, taken to be the definition for @var{function}."
msgstr "（含）zsh 命令（的）文本文件，被视为 @var{function} 的定义。"

#. type: Plain text
#: zsh.texi:2626
msgid ""
"In summary, the order of searching is, first, in the @emph{parents of} directories in @t{fpath} for the newer of either a compiled directory or a directory in @t{fpath}; second, if more than one of these "
"contains a definition for the function that is sought, the leftmost in the @t{fpath} is chosen; and third, within a directory, the newer of either a compiled function or an ordinary function definition is "
"used."
msgstr ""
"总之，搜索的顺序是：首先，在 @t{fpath} 中的 @emph{父} 目录中搜索-编译的目录或 @t{fpath} 目录中-的较新目录；其次，如果其中有多个目录包含所搜索函数的定义，则选择 @t{fpath} 中最左边的目录；第三，在一个目录"
"中，使用编译函数或普通函数定义中的较新一个。"

#. type: pindex
#: zsh.texi:2628
#, no-wrap
msgid "KSH_AUTOLOAD, use of"
msgstr "KSH_AUTOLOAD, use of"

#. type: Plain text
#: zsh.texi:2635
msgid ""
"If the @t{KSH_AUTOLOAD} option is set, or the file contains only a simple definition of the function, the file's contents will be executed.  This will normally define the function in question, but may "
"also perform initialization, which is executed in the context of the function execution, and may therefore define local parameters.  It is an error if the function is not defined by loading the file."
msgstr ""
"如果设置了 @t{KSH_AUTOLOAD}选项，或者文件只包含函数的简单定义，文件内容将被执行。 这通常会定义相关函数，但也可能执行初始化，初始化是在函数执行的上下文中执行的，因此可能会定义本地参数。 如果加载文件时，没有"
"定义函数，则会出错。"

#. type: Plain text
#: zsh.texi:2647
msgid ""
"Otherwise, the function body (with no surrounding `@var{funcname}@t{()  @{}@var{...}@t{@}}') is taken to be the complete contents of the file.  This form allows the file to be used directly as an "
"executable shell script.  If processing of the file results in the function being re-defined, the function itself is not re-executed.  To force the shell to perform initialization and then call the "
"function defined, the file should contain initialization code (which will be executed then discarded) in addition to a complete function definition (which will be retained for subsequent calls to the "
"function), and a call to the shell function, including any arguments, at the end."
msgstr ""
"否则，函数体（周围没有`@var{funcname}@t{()  @{}@var{...}@t{@}}'）将被视为文件的完整内容。这种形式允许将文件直接用作可执行 shell 脚本。 如果对文件的处理导致函数被重新定义，函数本身不会被重新执行。要强制 "
"shell 执行初始化，然后调用所定义的函数，文件除了包含初始化代码（执行后丢弃）外，还应包含完整的函数定义（保留用于后续函数调用），以及对 shell 函数的调用，包括最后的参数。"

#. type: Plain text
#: zsh.texi:2650
msgid "For example, suppose the autoload file @t{func} contains"
msgstr "For example, suppose the autoload file @t{func} contains"

#. type: example
#: zsh.texi:2655
#, no-wrap
msgid ""
"func() @{ print This is func; @}\n"
"print func is initialized\n"
msgstr ""
"func() @{ print This is func; @}\n"
"输出 func is initialized\n"

#. type: Plain text
#: zsh.texi:2663
msgid ""
"then `@t{func; func}' with @t{KSH_AUTOLOAD} set will produce both messages on the first call, but only the message `@t{This is func}' on the second and subsequent calls.  Without @t{KSH_AUTOLOAD} set, it "
"will produce the initialization message on the first call, and the other message on the second and subsequent calls."
msgstr ""
"那么，如果设置了 @t{KSH_AUTOLOAD}，`@t{func; func}' 将在第一次调用时产生两条信息，但在第二次及其后的调用中只产生`@t{This is func}' 信息。 如果未设置 @t{KSH_AUTOLOAD}，则第一次调用时将产生初始化信息，第二次"
"及后续调用时将产生其他信息。"

#. type: Plain text
#: zsh.texi:2669
msgid ""
"It is also possible to create a function that is not marked as autoloaded, but which loads its own definition by searching @t{fpath}, by using `@t{autoload -X}' within a shell function.  For example, the "
"following are equivalent:"
msgstr "通过在 shell 函数中使用 `@t{autoload -X}'，也可以创建一个未标记为自动加载的函数，但它可以通过搜索 @t{fpath} 加载自己的定义。 例如，以下是等价的:"

#. type: example
#: zsh.texi:2676
#, no-wrap
msgid ""
"myfunc() @{\n"
"  autoload -X\n"
"@}\n"
"myfunc args...\n"
msgstr ""
"myfunc() @{\n"
"  autoload -X\n"
"@}\n"
"myfunc args...\n"

#. type: Plain text
#: zsh.texi:2680
msgid "and"
msgstr "与"

#. type: example
#: zsh.texi:2686
#, no-wrap
msgid ""
"unfunction myfunc   # if myfunc was defined\n"
"autoload myfunc\n"
"myfunc args...\n"
msgstr ""
"unfunction myfunc   # if myfunc was defined\n"
"autoload myfunc\n"
"myfunc args...\n"

#. type: Plain text
#: zsh.texi:2691
msgid "In fact, the @t{functions} command outputs `@t{builtin autoload -X}' as the body of an autoloaded function.  This is done so that"
msgstr "事实上，@t{functions} 命令会输出`@t{builtin autoload -X}' 作为自动加载函数的主体。 这样做是为了"

#. type: example
#: zsh.texi:2695
#, no-wrap
msgid "eval \"$(functions)\"\n"
msgstr "eval \"$(functions)\"\n"

#. type: Plain text
#: zsh.texi:2701
msgid "produces a reasonable result.  A true autoloaded function can be identified by the presence of the comment `@t{# undefined}' in the body, because all comments are discarded from defined functions."
msgstr "会产生一个合理的结果。 一个真正的自动加载函数可以通过正文中的注释`@t{# undefined}'来识别，因为定义函数中的所有注释都会被丢弃。"

#. type: Plain text
#: zsh.texi:2705
msgid "To load the definition of an autoloaded function @t{myfunc} without executing @t{myfunc}, use:"
msgstr "要在不执行 @t{myfunc} 的情况下加载自动加载函数 @t{myfunc} 的定义，请使用"

#. type: example
#: zsh.texi:2709
#, no-wrap
msgid "autoload +X myfunc\n"
msgstr "autoload +X myfunc\n"

#. type: section
#: zsh.texi:2713
#, no-wrap
msgid "Anonymous Functions"
msgstr "匿名函数"

#. type: cindex
#: zsh.texi:2715
#, no-wrap
msgid "anonymous functions"
msgstr "匿名函数"

#. type: cindex
#: zsh.texi:2716
#, no-wrap
msgid "functions, anonymous"
msgstr "函数, 匿名"

#. type: Plain text
#: zsh.texi:2724
msgid ""
"If no name is given for a function, it is `anonymous' and is handled specially.  Either form of function definition may be used: a `@t{()}' with no preceding name, or a `@t{function}' with an immediately "
"following open brace.  The function is executed immediately at the point of definition and is not stored for future use.  The function name is set to `@t{(anon)}'."
msgstr ""
"如果没有给出函数名称，则该函数为 \"匿名 \"函数，将被特殊处理。 可以使用两种形式的函数定义：一种是前面没有名称的`@t{()}' ，另一种是后面紧跟一个大括号的`@t{function}' 。 函数在定义时立即执行，不会存储起来供"
"将来使用。 函数名称设置为`@t{(anon)}'。"

#. type: Plain text
#: zsh.texi:2733
msgid ""
"Arguments to the function may be specified as words following the closing brace defining the function, hence if there are none no arguments (other than @t{$0}) are set.  This is a difference from the way "
"other functions are parsed: normal function definitions may be followed by certain keywords such as `@t{else}' or `@t{fi}', which will be treated as arguments to anonymous functions, so that a newline or "
"semicolon is needed to force keyword interpretation."
msgstr ""
"函数的参数可以指定为定义函数的收尾括号后的单词，因此如果没有参数，则不会设置参数（@t{$0} 除外）。 这与其他函数的解析方式不同：普通函数定义后可能会出现某些关键字，如`@t{else}' 或`@t{fi}'，这些关键字将被视为"
"匿名函数的参数，因此需要换行或分号来强制解释关键字。"

#. type: Plain text
#: zsh.texi:2738
msgid "Note also that the argument list of any enclosing script or function is hidden (as would be the case for any other function called at this point)."
msgstr "还要注意的是，任何外层脚本或函数的参数列表都是隐藏的（此时调用的任何其他函数也是如此）。"

#. type: Plain text
#: zsh.texi:2745
msgid ""
"Redirections may be applied to the anonymous function in the same manner as to a current-shell structure enclosed in braces.  The main use of anonymous functions is to provide a scope for local "
"variables.  This is particularly convenient in start-up files as these do not provide their own local variable scope."
msgstr "对匿名函数进行重定向的方式与对大括号中的当前shell结构进行重定向的方式相同。 匿名函数的主要用途是为局部变量提供作用域。 这在启动文件中尤其方便，因为这些文件不提供自己的局部变量作用域。"

#. type: Plain text
#: zsh.texi:2748 zsh.texi:3768 zsh.texi:5232 zsh.texi:5715 zsh.texi:6903 zsh.texi:6979 zsh.texi:13989 zsh.texi:17242 zsh.texi:23330 zsh.texi:23731 zsh.texi:29972 zsh.texi:30131 zsh.texi:31405 zsh.texi:32545
#: zsh.texi:33162 zsh.texi:36379
msgid "For example,"
msgstr "例如,"

#. type: example
#: zsh.texi:2757
#, no-wrap
msgid ""
"variable=outside\n"
"function @{\n"
"  local variable=inside\n"
"  print \"I am $variable with arguments $*\"\n"
"@} this and that\n"
"print \"I am $variable\"\n"
msgstr ""
"variable=outside\n"
"function @{\n"
"  local variable=inside\n"
"  print \"I am $variable with arguments $*\"\n"
"@} this and that\n"
"print \"I am $variable\"\n"

#. type: Plain text
#: zsh.texi:2761
msgid "outputs the following:"
msgstr "输出如下:"

#. type: example
#: zsh.texi:2766
#, no-wrap
msgid ""
"I am inside with arguments this and that\n"
"I am outside\n"
msgstr ""
"我在里面争论这个争论那个\n"
"我在外面\n"

#. type: Plain text
#: zsh.texi:2773
msgid ""
"Note that function definitions with arguments that expand to nothing, for example `@t{name=; function $name @{ }@var{...}@t{ @}}', are not treated as anonymous functions.  Instead, they are treated as "
"normal function definitions where the definition is silently discarded."
msgstr "需要注意的是，如果函数定义的参数扩展为空值，例如 `@t{name=; function $name @{ }@var{...}@t{ @}}'，则不会被视为匿名函数。 相反，它们被视为普通的函数定义，其中的定义会被默默丢弃。"

#. type: section
#: zsh.texi:2776
#, no-wrap
msgid "Special Functions"
msgstr "特殊函数"

#. type: Plain text
#: zsh.texi:2779
msgid "Certain functions, if defined, have special meaning to the shell."
msgstr "特殊函数（如果已定义）对 shell 有特殊意义。"

#. type: subsection
#: zsh.texi:2782
#, no-wrap
msgid "Hook Functions"
msgstr "钩子函数"

#. type: findex
#: zsh.texi:2784
#, no-wrap
msgid "functions, hook"
msgstr "函数, 钩子"

#. type: findex
#: zsh.texi:2785
#, no-wrap
msgid "hook functions"
msgstr "钩子函数"

#. type: Plain text
#: zsh.texi:2802
msgid ""
"For the functions below, it is possible to define an array that has the same name as the function with `@t{_functions}' appended.  Any element in such an array is taken as the name of a function to "
"execute; it is executed in the same context and with the same arguments and same initial value of @t{$?} as the basic function.  For example, if @t{$chpwd_functions} is an array containing the values "
"`@t{mychpwd}', `@t{chpwd_save_dirstack}', then the shell attempts to execute the functions `@t{chpwd}', `@t{mychpwd}' and `@t{chpwd_save_dirstack}', in that order.  Any function that does not exist is "
"silently ignored.  A function found by this mechanism is referred to elsewhere as a @emph{hook function}.  An error in any function causes subsequent functions not to be run.  Note further that an error "
"in a @t{precmd} hook causes an immediately following @t{periodic} function not to run (though it may run at the next opportunity)."
msgstr ""
"对于下面的函数，可以定义一个数组，该数组的名称与附加了`@t{_functions}'的函数相同。 数组中的任何元素都将作为要执行的函数名称；它将在与基本函数相同的上下文、相同的参数和相同的 @t{$?} 初始值下执行。 例如，如"
"果 @t{$chpwd_functions} 是一个包含 `@t{mychpwd}', `@t{chpwd_save_dirstack}'值的数组，那么 shell 会尝试依次执行函数 `@t{chpwd}', `@t{mychpwd}'和`@t{chpwd_save_dirstack}'。 任何不存在的函数都会被静默忽略。 "
"通过此机制找到的函数在其他地方被称为 @emph{钩子函数}。 任何函数中的错误都会导致后续函数无法运行。 请进一步注意，如果 @t{precmd} 钩子中出现错误，则紧随其后的 @t{periodic} 函数将不会运行（尽管它可能会在下一"
"次机会中运行）。"

#. type: t{#1}
#: zsh.texi:2805 zsh.texi:2807 zsh.texi:35339
#, no-wrap
msgid "chpwd"
msgstr "chpwd"

#. type: vindex
#: zsh.texi:2806
#, no-wrap
msgid "chpwd_functions"
msgstr "chpwd_functions"

#. type: table
#: zsh.texi:2809
msgid "Executed whenever the current working directory is changed."
msgstr "每当更改当前工作目录时执行。"

#. type: t{#1}
#: zsh.texi:2810 zsh.texi:2812
#, no-wrap
msgid "periodic"
msgstr "periodic"

#. type: vindex
#: zsh.texi:2811
#, no-wrap
msgid "periodic_functions"
msgstr "periodic_functions"

#. type: vindex
#: zsh.texi:2813
#, no-wrap
msgid "PERIOD"
msgstr "PERIOD"

#. type: table
#: zsh.texi:2821
msgid ""
"If the parameter @t{PERIOD} is set, this function is executed every @t{$PERIOD} seconds, just before a prompt.  Note that if multiple functions are defined using the array @t{periodic_functions} only one "
"period is applied to the complete set of functions, and the scheduled time is not reset if the list of functions is altered.  Hence the set of functions is always called together."
msgstr ""
"如果设置了参数 @t{PERIOD}，该函数将每隔 @t{$PERIOD} 秒执行一次，就在提示符之前。 需要注意的是，如果使用数组 @t{periodic_functions} 定义了多个函数，则整个函数集只适用一个周期，如果函数列表被更改，计划时间也"
"不会重置。 因此，函数集总是一起被调用。"

#. type: t{#1}
#: zsh.texi:2822 zsh.texi:2824
#, no-wrap
msgid "precmd"
msgstr "precmd"

#. type: vindex
#: zsh.texi:2823
#, no-wrap
msgid "precmd_functions"
msgstr "precmd_functions"

#. type: table
#: zsh.texi:2828
msgid ""
"Executed before each prompt.  Note that precommand functions are not re-executed simply because the command line is redrawn, as happens, for example, when a notification about an exiting job is displayed."
msgstr "在每次（打印）提示符前执行。请注意，命令前函数不会因为命令行重绘而被重新执行，例如，在显示-任务退出通知时-就会发生这种情况。"

#. type: t{#1}
#: zsh.texi:2829 zsh.texi:2831
#, no-wrap
msgid "preexec"
msgstr "preexec"

#. type: vindex
#: zsh.texi:2830
#, no-wrap
msgid "preexec_functions"
msgstr "preexec_functions"

#. type: table
#: zsh.texi:2841
msgid ""
"Executed just after a command has been read and is about to be executed.  If the history mechanism is active (regardless of whether the line was discarded from the history buffer), the string that the "
"user typed is passed as the first argument, otherwise it is an empty string.  The actual command that will be executed (including expanded aliases) is passed in two different forms: the second argument is "
"a single-line, size-limited version of the command (with things like function bodies elided); the third argument contains the full text that is being executed."
msgstr ""
"在命令被读取后并即将执行时执行。 如果历史记录机制处于激活状态（无论该行是否已从历史记录缓冲区中丢弃），用户输入的字符串将作为第一个参数传递，否则就是空字符串。 将被执行的实际命令（包括扩展的别名）以两种不"
"同的形式传递：第二个参数是单行、大小受限的命令版本（省略了函数体等内容）；第三个参数包含正在执行的完整文本。"

#. type: t{#1}
#: zsh.texi:2842 zsh.texi:2844
#, no-wrap
msgid "zshaddhistory"
msgstr "zshaddhistory"

#. type: vindex
#: zsh.texi:2843
#, no-wrap
msgid "zshaddhistory_functions"
msgstr "zshaddhistory_functions"

#. type: cindex
#: zsh.texi:2845
#, no-wrap
msgid "history, hook when line is saved"
msgstr "历史, 行保存时挂勾"

#. type: table
#: zsh.texi:2849
msgid "Executed when a history line has been read interactively, but before it is executed.  The sole argument is the complete history line (so that any terminating newline will still be present)."
msgstr "在交互式读取历史行后，但在它执行前执行。 唯一的参数是完整的历史记录行（因此任何终止换行仍将存在）。"

#. type: table
#: zsh.texi:2856
msgid ""
"If any of the hook functions returns status 1 (or any non-zero value other than 2, though this is not guaranteed for future versions of the shell) the history line will not be saved, although it lingers "
"in the history until the next line is executed, allowing you to reuse or edit it immediately."
msgstr "如果任何钩子函数返回状态 1（或除 2 之外的任何非零值，但未来版本的 shell 并不保证这一点），历史行将不会被保存，但它会在历史行中停留，直到下一行被执行，从而允许您立即重新使用或编辑它。"

#. type: table
#: zsh.texi:2862
msgid ""
"If any of the hook functions returns status 2 the history line will be saved on the internal history list, but not written to the history file.  In case of a conflict, the first non-zero status value is "
"taken."
msgstr "如果任何钩子函数返回状态 2，历史行将保存在内部历史列表中，但不会写入历史文件。 如果出现冲突，则取第一个非零状态值。"

#. type: table
#: zsh.texi:2869
msgid ""
"A hook function may call `@t{fc -p} @var{...}' to switch the history context so that the history is saved in a different file from that in the global @t{HISTFILE} parameter.  This is handled specially: "
"the history context is automatically restored after the processing of the history line is finished."
msgstr "钩子函数可以调用 `@t{fc -p} @var{...}' 来切换历史上下文，使历史记录保存在与全局 @t{HISTFILE} 参数不同的文件中。 这种情况会得到特殊处理：历史行处理完成后，历史上下文会自动恢复。"

#. type: table
#: zsh.texi:2878
msgid ""
"The following example function works with one of the options @t{INC_APPEND_HISTORY} or @t{SHARE_HISTORY} set, in order that the line is written out immediately after the history entry is added.  It first "
"adds the history line to the normal history with the newline stripped, which is usually the correct behaviour.  Then it switches the history context so that the line will be written to a history file in "
"the current directory."
msgstr ""
"下面的示例函数使用 @t{INC_APPEND_HISTORY} 或 @t{SHARE_HISTORY} 选项之一，以便在添加历史条目后立即写出该行。 首先，它会将历史行添加到正常的历史记录中，并去掉换行符，这通常是正确的行为。 然后切换历史上下文，"
"将该行写入当前目录下的历史文件。"

#. type: example
#: zsh.texi:2885
#, no-wrap
msgid ""
"zshaddhistory() @{\n"
"  print -sr -- $@{1%%$'\\n'@}\n"
"  fc -p .zsh_local_history\n"
"@}\n"
msgstr ""
"zshaddhistory() @{\n"
"  print -sr -- $@{1%%$'\\n'@}\n"
"  fc -p .zsh_local_history\n"
"@}\n"

#. type: t{#1}
#: zsh.texi:2887 zsh.texi:2889
#, no-wrap
msgid "zshexit"
msgstr "zshexit"

#. type: vindex
#: zsh.texi:2888
#, no-wrap
msgid "zshexit_functions"
msgstr "zshexit_functions"

#. type: table
#: zsh.texi:2894
msgid ""
"Executed at the point where the main shell is about to exit normally.  This is not called by exiting subshells, nor when the @t{exec} precommand modifier is used before an external command.  Also, unlike "
"@t{TRAPEXIT}, it is not called when functions exit."
msgstr "在主 shell 即将正常退出时执行。 子shell退出或外部命令前使用 @t{exec} 前置命令修饰符时，不会调用该命令。 此外，与 @t{TRAPEXIT} 不同，函数退出时也不会调用该命令。"

#. type: subsection
#: zsh.texi:2899
#, no-wrap
msgid "Trap Functions"
msgstr "陷阱函数"

#. type: Plain text
#: zsh.texi:2905
msgid "The functions below are treated specially but do not have corresponding hook arrays."
msgstr "以下函数受到特殊处理，但没有相应的钩子数组。"

#. type: item
#: zsh.texi:2908
#, no-wrap
msgid "@t{TRAP}@var{NAL}"
msgstr "@t{TRAP}@var{NAL}"

#. type: cindex
#: zsh.texi:2909 zsh.texi:14743
#, no-wrap
msgid "signals, trapping"
msgstr "信号, 捕获"

#. type: cindex
#: zsh.texi:2910 zsh.texi:14744
#, no-wrap
msgid "trapping signals"
msgstr "捕获信号"

#. type: table
#: zsh.texi:2916
msgid ""
"If defined and non-null, this function will be executed whenever the shell catches a signal @t{SIG}@var{NAL}, where @var{NAL} is a signal name as specified for the @t{kill} builtin.  The signal number "
"will be passed as the first parameter to the function."
msgstr "如果已定义且非空，每当 shell 捕捉到 @t{SIG}@var{NAL}（其中 @var{NAL} 是为 @t{kill} 内置命令指定的信号名）信号时，就会执行该函数。 信号编号将作为第一个参数传递给函数。"

#. type: table
#: zsh.texi:2920
msgid "If a function of this form is defined and null, the shell and processes spawned by it will ignore @t{SIG}@var{NAL}."
msgstr "如果定义了这种形式的函数，但其值为空，则 shell 和由其产生的进程将忽略 @t{SIG}@var{NAL}。"

#. type: table
#: zsh.texi:2926
msgid ""
"The return status from the function is handled specially.  If it is zero, the signal is assumed to have been handled, and execution continues normally.  Otherwise, the shell will behave as interrupted "
"except that the return status of the trap is retained."
msgstr "函数的返回状态会被特别处理。 如果为零，则假定信号已被处理，并继续正常执行。 否则，除了保留陷阱的返回状态外，shell 的行为与中断时一样。"

#. type: table
#: zsh.texi:2931
msgid ""
"Programs terminated by uncaught signals typically return the status 128 plus the signal number.  Hence the following causes the handler for @t{SIGINT} to print a message, then mimic the usual effect of "
"the signal."
msgstr "由未捕获信号终止的程序通常会返回状态 128 +信号编号。 因此，下面的代码会使 @t{SIGINT} 的处理程序打印一条信息，然后模仿信号的通常效果。"

#. type: example
#: zsh.texi:2938
#, no-wrap
msgid ""
"TRAPINT() @{\n"
"  print \"Caught SIGINT, aborting.\"\n"
"  return $(( 128 + $1 ))\n"
"@}\n"
msgstr ""
"TRAPINT() @{\n"
"  print \"Caught SIGINT, aborting.\"\n"
"  return $(( 128 + $1 ))\n"
"@}\n"

#. type: table
#: zsh.texi:2943
msgid "The functions @t{TRAPZERR}, @t{TRAPDEBUG} and @t{TRAPEXIT} are never executed inside other traps."
msgstr "函数 @t{TRAPZERR}、@t{TRAPDEBUG} 和 @t{TRAPEXIT} 绝不会在其他陷阱中执行。"

#. type: t{#1}
#: zsh.texi:2944 zsh.texi:2945
#, no-wrap
msgid "TRAPDEBUG"
msgstr "TRAPDEBUG"

#. type: table
#: zsh.texi:2951
msgid ""
"If the option @t{DEBUG_BEFORE_CMD} is set (as it is by default), executed before each command; otherwise executed after each command.  See the description of the @t{trap} builtin in @ref{Shell Builtin "
"Commands} for details of additional features provided in debug traps."
msgstr "如果设置了选项 @t{DEBUG_BEFORE_CMD}（默认情况），则在每条命令之前执行；否则在每条命令之后执行。 有关调试陷阱提供的其他功能，请参阅 @ref{Shell 内置命令} 中 @t{trap} 内置命令的描述。"

#. type: t{#1}
#: zsh.texi:2952 zsh.texi:2953
#, no-wrap
msgid "TRAPEXIT"
msgstr "TRAPEXIT"

#. type: table
#: zsh.texi:2958
msgid ""
"Executed when the shell exits, or when the current function exits if defined inside a function.  The value of @t{$?} at the start of execution is the exit status of the shell or the return status of the "
"function exiting."
msgstr "在 shell 退出时执行，如果在函数内部定义，则在当前函数退出时执行。 开始执行时 @t{$?} 的值是 shell 的退出状态或函数退出时的返回状态。"

#. type: t{#1}
#: zsh.texi:2959 zsh.texi:2961
#, no-wrap
msgid "TRAPZERR"
msgstr "TRAPZERR"

#. type: findex
#: zsh.texi:2960
#, no-wrap
msgid "TRAPERR"
msgstr "TRAPERR"

#. type: table
#: zsh.texi:2968
msgid ""
"Executed whenever a command has a non-zero exit status.  However, the function is not executed if the command occurred in a sublist followed by `@t{&&}' or `@t{||}'; only the final command in a sublist of "
"this type causes the trap to be executed.  The function @t{TRAPERR} acts the same as @t{TRAPZERR} on systems where there is no @t{SIGERR} (this is the usual case)."
msgstr ""
"当命令的退出状态为非零时执行。 但是，如果命令出现在子列表中，且后面跟有`@t{&&}'或 `@t{||}'，则不执行该函数；只有这种类型的子列表中的最后一条命令才会导致陷阱被执行。 在没有 @t{SIGERR} 的系统中，函数 "
"@t{TRAPERR} 的作用与 @t{TRAPZERR} 相同（这是通常情况）。"

#. type: findex
#: zsh.texi:2972
#, no-wrap
msgid "trap, use of"
msgstr "trap, use of"

#. type: Plain text
#: zsh.texi:2978
msgid ""
"The functions beginning `@t{TRAP}' may alternatively be defined with the @t{trap} builtin: this may be preferable for some uses.  Setting a trap with one form removes any trap of the other form for the "
"same signal; removing a trap in either form removes all traps for the same signal.  The forms"
msgstr ""
"以 `@t{TRAP}' 开头的函数也可以用 @t{trap} 内置命令来定义：这在某些情况下可能更合适。 使用其中一种形式设置陷阱，会移除另一种形式针对同一信号的陷阱；使用其中任何一种形式移除陷阱，都会移除针对同一信号的所有陷"
"阱。 形式"

#. type: example
#: zsh.texi:2984
#, no-wrap
msgid ""
"TRAPNAL() @{ \n"
" # code\n"
"@}\n"
msgstr ""
"TRAPNAL() @{ \n"
" # code\n"
"@}\n"

#. type: Plain text
#: zsh.texi:2988
msgid "('function traps') and"
msgstr "('function traps') 和"

#. type: example
#: zsh.texi:2994
#, no-wrap
msgid ""
"trap '\n"
" # code\n"
"' NAL\n"
msgstr ""
"trap '\n"
" # code\n"
"' NAL\n"

#. type: Plain text
#: zsh.texi:2999
msgid "('list traps') are equivalent in most ways, the exceptions being the following:"
msgstr "('list traps') 在大多数方面是等价的，但以下情况除外:"

#. type: itemize
#: zsh.texi:3007
msgid "Function traps have all the properties of normal functions, appearing in the list of functions and being called with their own function context rather than the context where the trap was triggered."
msgstr "函数陷阱具有普通函数的所有属性，会出现在函数列表中，并以自己的函数上下文而不是触发陷阱的上下文被调用。"

#. type: itemize
#: zsh.texi:3011
msgid "The return status from function traps is special, whereas a return from a list trap causes the surrounding context to return with the given status."
msgstr "函数陷阱的返回状态是特殊的，而列表陷阱的返回会导致周围的上下文以给定的状态返回。"

#. type: itemize
#: zsh.texi:3015
msgid "Function traps are not reset within subshells, in accordance with zsh behaviour; list traps are reset, in accordance with POSIX behaviour."
msgstr "根据 zsh 行为，函数陷阱不会在子shell中重置；根据 POSIX 行为，list的陷阱会重置。"

#. type: node
#: zsh.texi:3018 zsh.texi:3186 zsh.texi:3188 zsh.texi:3535
#, no-wrap
msgid "Arithmetic Evaluation"
msgstr "算术求值"

#. type: section
#: zsh.texi:3023
#, no-wrap
msgid "Jobs"
msgstr "作业"

#. type: t{#1}
#: zsh.texi:3025 zsh.texi:13959 zsh.texi:21584
#, no-wrap
msgid "jobs"
msgstr "算术求值"

#. type: pindex
#: zsh.texi:3026
#, no-wrap
msgid "MONITOR, use of"
msgstr "MONITOR, use of"

#. type: Plain text
#: zsh.texi:3033
msgid ""
"If the @t{MONITOR} option is set, an interactive shell associates a @emph{job} with each pipeline.  It keeps a table of current jobs, printed by the @t{jobs} command, and assigns them small integer "
"numbers.  When a job is started asynchronously with `@t{&}', the shell prints a line to standard error which looks like:"
msgstr ""
"如果设置了 @t{MONITOR} 选项，交互式 shell 就会为每个管道关联一个 @emph{作业}。 它保存了一个由 @t{jobs} 命令打印的当前作业表，并为这些作业分配了小整数编号。 当使用`@t{&}'异步启动一个作业时，shell 会在标准错"
"误中打印一行类似下面的内容："

#. type: example
#: zsh.texi:3037
#, no-wrap
msgid "[1] 1234\n"
msgstr "[1] 1234\n"

#. type: Plain text
#: zsh.texi:3042
msgid "indicating that the job which was started asynchronously was job number 1 and had one (top-level) process, whose process ID was 1234."
msgstr "表明异步启动的任务是任务编号 1，有一个（顶级）进程，其进程 ID 是 1234。"

#. type: Plain text
#: zsh.texi:3048
msgid ""
"If a job is started with `@t{&|}' or `@t{&!}', then that job is immediately disowned.  After startup, it does not have a place in the job table, and is not subject to the job control features described "
"here."
msgstr "如果作业以 `@t{&|}'或 `@t{&!}'启动，则该作业会立即被取消（disowned,可能指放弃所有权）。 启动后，它在作业表中没有位置，也不受此处描述的作业控制功能的约束。"

#. type: Plain text
#: zsh.texi:3053
msgid ""
"If you are running a job and wish to do something else you may hit the key ^Z (control-Z) which sends a @t{TSTP} signal to the current job: this key may be redefined by the @t{susp} option of the external "
"@t{stty} command."
msgstr "如果您正在运行一项作业，并希望做其他事情，可以按 ^Z 键（control-Z），向当前作业发送 @t{TSTP} 信号：该键可以通过外部 @t{stty} 命令的 @t{susp} 选项重新定义。"

#. type: cindex
#: zsh.texi:3053
#, no-wrap
msgid "jobs, suspending"
msgstr "作业, 暂停"

#. type: cindex
#: zsh.texi:3054
#, no-wrap
msgid "suspending jobs"
msgstr "暂停作业"

#. type: Plain text
#: zsh.texi:3057
msgid "The shell will then normally indicate that the job has been `suspended', and print another prompt.  You can then manipulate the state of this job,"
msgstr "shell 通常会提示作业已被 `暂停'，并打印另一个提示符。 然后，您就可以操作该作业的状态了"

#. type: findex
#: zsh.texi:3057
#, no-wrap
msgid "bg, use of"
msgstr "bg, use of"

#. type: Plain text
#: zsh.texi:3060
msgid "putting it in the background with the @t{bg} command, or run some other commands and then eventually bring the job back into the foreground with"
msgstr "使用 @t{bg} 命令将其置于后台，或运行一些其他命令，最后将作业带回前台（用"

#. type: findex
#: zsh.texi:3060
#, no-wrap
msgid "fg, use of"
msgstr "fg, use of"

#. type: Plain text
#: zsh.texi:3064
msgid "the foreground command @t{fg}.  A ^Z takes effect immediately and is like an interrupt in that pending output and unread input are discarded when it is typed."
msgstr "前台命令 @t{fg}）。 ^Z 立即生效，就像中断一样，输入时会丢弃待处理输出和未读输入。"

#. type: Plain text
#: zsh.texi:3068
msgid "A job being run in the background will suspend if it tries to read from the terminal."
msgstr "在后台运行的作业如果试图从终端读取数据，就会暂停。"

#. type: Plain text
#: zsh.texi:3080
msgid ""
"Note that if the job running in the foreground is a shell function, then suspending it will have the effect of causing the shell to fork.  This is necessary to separate the function's state from that of "
"the parent shell performing the job control, so that the latter can return to the command line prompt.  As a result, even if @t{fg} is used to continue the job the function will no longer be part of the "
"parent shell, and any variables set by the function will not be visible in the parent shell.  Thus the behaviour is different from the case where the function was never suspended.  Zsh is different from "
"many other shells in this regard."
msgstr ""
"请注意，如果前台运行的作业是 shell 函数，则暂停作业会导致 shell 分叉。 这是为了将函数的状态与执行作业控制的父 shell 的状态分开，以便后者能返回命令行提示符。 因此，即使 @t{fg} 被用来继续执行作业，该函数也不"
"再是父 shell 的一部分，父 shell 中也看不到该函数设置的任何变量。 因此，这种行为与函数从未被暂停的情况不同。 在这一点上，Zsh 与许多其他 shell 不同。"

#. type: Plain text
#: zsh.texi:3087
msgid ""
"One additional side effect is that use of @t{disown} with a job created by suspending shell code in this fashion is delayed: the job can only be disowned once any process started from the parent shell has "
"terminated.  At that point, the disowned job disappears silently from the job list."
msgstr "一个额外的副作用是:如果作业是通过暂停 shell 代码的方式创建的，那么使用 @t{disown} 时就会出现延迟：只有在父 shell 启动的进程结束后，作业才能被放弃所有权。 此时，该作业会从作业列表中悄然消失。"

#. type: Plain text
#: zsh.texi:3093
msgid ""
"The same behaviour is found when the shell is executing code as the right hand side of a pipeline or any complex shell construct such as @t{if}, @t{for}, etc., in order that the entire block of code can "
"be managed as a single job."
msgstr "当 shell 作为管道的右侧执行代码或任何复杂 shell 结构（如 @t{if}、@t{for} 等）时，也会出现同样的行为，以便将整个代码块作为单个作业管理。"

#. type: cindex
#: zsh.texi:3093
#, no-wrap
msgid "background jobs, I/O"
msgstr "后台作业, I/O"

#. type: cindex
#: zsh.texi:3094
#, no-wrap
msgid "jobs, background, I/O"
msgstr "作业, 后台, I/O"

#. type: Plain text
#: zsh.texi:3100
msgid ""
"Background jobs are normally allowed to produce output, but this can be disabled by giving the command `@t{stty tostop}'.  If you set this tty option, then background jobs will suspend when they try to "
"produce output like they do when they try to read input."
msgstr "后台作业通常允许产生输出，但可以通过命令`@t{stty tostop}'禁用。 如果设置了这个 tty 选项，那么后台作业在试图产生输出时就会暂停，就像试图读取输入时一样。"

#. type: Plain text
#: zsh.texi:3106
msgid ""
"When a command is suspended and continued later with the @t{fg} or @t{wait} builtins, zsh restores tty modes that were in effect when it was suspended.  This (intentionally) does not apply if the command "
"is continued via `@t{kill -CONT}', nor when it is continued with @t{bg}."
msgstr "当命令被挂起并在之后使用 @t{fg} 或 @t{wait} 内置命令继续执行时，zsh 会恢复挂起时有效的 tty 模式。 如果通过`@t{kill -CONT}'继续执行命令，或使用 @t{bg} 继续执行命令，则（故意）不适用此规定。"

#. type: cindex
#: zsh.texi:3108
#, no-wrap
msgid "jobs, referring to"
msgstr "作业, 引用"

#. type: cindex
#: zsh.texi:3109
#, no-wrap
msgid "referring to jobs"
msgstr "引用作业"

#. type: Plain text
#: zsh.texi:3113
msgid "There are several ways to refer to jobs in the shell.  A job can be referred to by the process ID of any process of the job or by one of the following:"
msgstr "有几种方法可以在 shell 中引用作业。 可以通过作业中任何进程的进程 ID 或以下方式之一来引用作业："

#. type: item
#: zsh.texi:3116
#, no-wrap
msgid "@t{%}@var{number}"
msgstr "@t{%}@var{number}"

#. type: table
#: zsh.texi:3118
msgid "The job with the given number."
msgstr "具有给定编号的作业。"

#. type: item
#: zsh.texi:3118
#, no-wrap
msgid "@t{%}@var{string}"
msgstr "@t{%}@var{string}"

#. type: table
#: zsh.texi:3120
msgid "The last job whose command line begins with @var{string}."
msgstr "命令行以 @var{string} 开头的最后一个作业。"

#. type: item
#: zsh.texi:3120
#, no-wrap
msgid "@t{%?}@var{string}"
msgstr "@t{%?}@var{string}"

#. type: table
#: zsh.texi:3122
msgid "The last job whose command line contains @var{string}."
msgstr "命令行包含 @var{string} 的最后一个作业。"

#. type: t{#1}
#: zsh.texi:3122 zsh.texi:3864 zsh.texi:9488 zsh.texi:34386
#, no-wrap
msgid "%%"
msgstr "%%"

#. type: table
#: zsh.texi:3124
msgid "Current job."
msgstr "当前作业。"

#. type: t{#1}
#: zsh.texi:3124
#, no-wrap
msgid "%+"
msgstr "%+"

#. type: table
#: zsh.texi:3126
msgid "Equivalent to `@t{%%}'."
msgstr "等价于 `@t{%%}'."

#. type: t{#1}
#: zsh.texi:3126
#, no-wrap
msgid "%-"
msgstr "%-"

#. type: table
#: zsh.texi:3128
msgid "Previous job."
msgstr "上一个作业。"

#. type: Plain text
#: zsh.texi:3132
msgid "The shell learns immediately whenever a process changes state."
msgstr "每当进程改变状态，shell 就会立即学习。"

#. type: pindex
#: zsh.texi:3132
#, no-wrap
msgid "NOTIFY, use of"
msgstr "NOTIFY, use of"

#. type: Plain text
#: zsh.texi:3138
msgid ""
"It normally informs you whenever a job becomes blocked so that no further progress is possible.  If the @t{NOTIFY} option is not set, it waits until just before it prints a prompt before it informs you.  "
"All such notifications are sent directly to the terminal, not to the standard output or standard error."
msgstr "通常情况下，每当作业被阻塞，无法继续执行时，它都会通知您。 如果未设置 @t{NOTIFY} 选项，程序会等到打印提示之前才通知你。 所有此类通知都会直接发送到终端，而不是标准输出或标准错误。"

#. type: Plain text
#: zsh.texi:3142
msgid "When the monitor mode is on, each background job that completes triggers any trap set for @t{CHLD}."
msgstr "开启监控模式后，每个完成的后台任务都会触发为 @t{CHLD} 设置的陷阱。"

#. type: Plain text
#: zsh.texi:3151
msgid ""
"When you try to leave the shell while jobs are running or suspended, you will be warned that `You have suspended (running) jobs'.  You may use the @t{jobs} command to see what they are.  If you do this or "
"immediately try to exit again, the shell will not warn you a second time; the suspended jobs will be terminated, and the running jobs will be sent a @t{SIGHUP} signal, if the @t{HUP} option is set."
msgstr ""
"当作业正在运行或暂停时，如果尝试离开 shell，系统会警告您 `You have suspended (running) jobs'。 您可以使用 @t{jobs} 命令查看这些作业。 如果这样做或立即再次尝试退出，shell 不会再发出警告；暂停的作业将被终"
"止，如果设置了 @t{HUP} 选项，正在运行的作业将被发送 @t{SIGHUP} 信号。"

#. type: pindex
#: zsh.texi:3151
#, no-wrap
msgid "HUP, use of"
msgstr "HUP, use of"

#. type: cindex
#: zsh.texi:3154 zsh.texi:13238
#, no-wrap
msgid "jobs, disowning"
msgstr "jobs, disowning"

#. type: cindex
#: zsh.texi:3155
#, no-wrap
msgid "disowning jobs"
msgstr "disowning jobs"

#. type: findex
#: zsh.texi:3156
#, no-wrap
msgid "disown, use of"
msgstr "disown, use of"

#. type: Plain text
#: zsh.texi:3160
msgid "To avoid having the shell terminate the running jobs, either use the nohup(1) command or the @t{disown} builtin."
msgstr "要避免 shell 终止正在运行的作业，可以使用 nohup(1) 命令或 @t{disown} 内置命令。"

#. type: section
#: zsh.texi:3161
#, no-wrap
msgid "Signals"
msgstr "信号"

#. type: Plain text
#: zsh.texi:3170
msgid ""
"The @t{INT} and @t{QUIT} signals for an invoked command are ignored if the command is followed by `@t{&}' and the @t{MONITOR} option is not active.  The shell itself always ignores the @t{QUIT} signal.  "
"Otherwise, signals have the values inherited by the shell from its parent (but see the @t{TRAP}@var{NAL} special functions in @ref{Functions})."
msgstr ""
"如果命令后跟有`@t{&}'，且 @t{MONITOR} 选项未激活，则调用命令的 @t{INT} 和 @t{QUIT} 信号将被忽略。 shell 本身始终会忽略 @t{QUIT} 信号。 否则，信号值将由 shell 从其父级继承（但请参阅 @ref{函数} 中的 @t{TRAP}"
"@var{NAL} 特殊函数）。"

#. type: cindex
#: zsh.texi:3172
#, no-wrap
msgid "exiting shell, and asynchronous jobs"
msgstr "退出 shell, 异步作业"

#. type: cindex
#: zsh.texi:3173
#, no-wrap
msgid "asynchronous jobs, and exiting shell"
msgstr "异步作业, 退出 shell"

#. type: cindex
#: zsh.texi:3174
#, no-wrap
msgid "jobs, asynchronous, and exiting shell"
msgstr "作业, 异步, 退出 shell"

#. type: Plain text
#: zsh.texi:3186
msgid ""
"Certain jobs are run asynchronously by the shell other than those explicitly put into the background; even in cases where the shell would usually wait for such jobs, an explicit @t{exit} command or exit "
"due to the option @t{ERR_EXIT} will cause the shell to exit without waiting.  Examples of such asynchronous jobs are process substitution, see @ref{Process Substitution}, and the handler processes for "
"multios, see the section @emph{Multios} in @ref{Redirection}."
msgstr ""
"除了那些显式放入后台的工作外，shell 还会异步运行某些工作；即使在 shell 通常会等待这些工作的情况下，显式 @t{exit} 命令或选项 @t{ERR_EXIT} 导致的退出也会使 shell 不经等待而退出。 此类异步任务的例子包括进程替"
"换（参见 @ref{进程替换}）和multios的处理进程（参见 @ref{重定向} 中的 @emph{Multios} 部分）。"

#. type: node
#: zsh.texi:3186 zsh.texi:3535 zsh.texi:3537 zsh.texi:3814
#, no-wrap
msgid "Conditional Expressions"
msgstr "条件表达式"

#. type: cindex
#: zsh.texi:3190
#, no-wrap
msgid "arithmetic evaluation"
msgstr "算术求值"

#. type: cindex
#: zsh.texi:3191
#, no-wrap
msgid "evaluation, arithmetic"
msgstr "求值, 算术"

#. type: findex
#: zsh.texi:3192
#, no-wrap
msgid "let, use of"
msgstr "let, use of"

#. type: Plain text
#: zsh.texi:3202
msgid ""
"The shell can perform integer and floating point arithmetic, either using the builtin @t{let}, or via a substitution of the form @t{$((}@var{...}@t{))}.  For integers, the shell is usually compiled to use "
"8-byte precision where this is available, otherwise precision is 4 bytes.  This can be tested, for example, by giving the command `@t{print - $(( 12345678901 ))}'; if the number appears unchanged, the "
"precision is at least 8 bytes.  Floating point arithmetic always uses the `double' type with whatever corresponding precision is provided by the compiler and the library."
msgstr ""
"shell 可以使用内置的 @t{let} 或  @t{$((}@var{...}@t{))}形式的替代方法，执行整数和浮点运算。 对于整数，通常在编译时使用 8 字节精度，否则精度为 4 字节。 例如，可以通过命令`@t{print - $(( 12345678901 ))}'来测"
"试；如果数字显示不变，则精度至少为 8 字节。 浮点运算始终使用 `double'类型，其精度由编译器和库提供。"

#. type: Plain text
#: zsh.texi:3213
msgid ""
"The @t{let} builtin command takes arithmetic expressions as arguments; each is evaluated separately.  Since many of the arithmetic operators, as well as spaces, require quoting, an alternative form is "
"provided: for any command which begins with a `@t{((}', all the characters until a matching `@t{))}' are treated as a double-quoted expression and arithmetic expansion performed as for an argument of "
"@t{let}.  More precisely, `@t{((}@var{...}@t{))}' is equivalent to `@t{let \"}@var{...}@t{\"}'.  The return status is 0 if the arithmetic value of the expression is non-zero, 1 if it is zero, and 2 if an "
"error occurred."
msgstr ""
"@t{let} 内置命令将算术表达式作为参数，每个参数都要单独求值。 由于许多算术运算符和空格都需要加引号，因此提供了另一种形式：对于任何以 `@t{((}'开头的命令，在匹配的`@t{))}' 之前的所有字符都被视为双引号表达式，"
"并像 @t{let} 的参数一样执行算术扩展。 更确切地说， `@t{((}@var{...}@t{))}' 等同于`@t{let \"}@var{...}@t{\"}'。 如果表达式的算术值不为零，返回状态为 0，如果为零，返回状态为 1，如果出现错误，返回状态为 2。"

#. type: Plain text
#: zsh.texi:3216
msgid "For example, the following statement"
msgstr "例如，以下语句"

#. type: example
#: zsh.texi:3220
#, no-wrap
msgid "(( val = 2 + 1 ))\n"
msgstr "(( val = 2 + 1 ))\n"

#. type: Plain text
#: zsh.texi:3224 zsh.texi:7203
msgid "is equivalent to"
msgstr "等价于"

#. type: example
#: zsh.texi:3228
#, no-wrap
msgid "let \"val = 2 + 1\"\n"
msgstr "let \"val = 2 + 1\"\n"

#. type: Plain text
#: zsh.texi:3233
msgid "both assigning the value 3 to the shell variable @t{val} and returning a zero status."
msgstr "都会将值 3 赋给 shell 变量 @t{val}，并返回 0 状态。"

#. type: cindex
#: zsh.texi:3235
#, no-wrap
msgid "arithmetic base"
msgstr "算术基数"

#. type: cindex
#: zsh.texi:3236
#, no-wrap
msgid "bases, in arithmetic"
msgstr "基数, 算术"

#. type: Plain text
#: zsh.texi:3247
msgid ""
"Integers can be in bases other than 10.  A leading `@t{0x}' or `@t{0X}' denotes hexadecimal and a leading `@t{0b}' or `@t{0B}' binary.  Integers may also be of the form `@var{base}@t{#}@var{n}', where "
"@var{base} is a decimal number between two and thirty-six representing the arithmetic base and @var{n} is a number in that base (for example, `@t{16#ff}' is 255 in hexadecimal).  The @var{base}@t{#} may "
"also be omitted, in which case base 10 is used.  For backwards compatibility the form `@t{[}@var{base}@t{]}@var{n}' is also accepted."
msgstr ""
"整数的进制可以不是 10。 前导`@t{0x}' 或`@t{0X}' 表示十六进制，前导 `@t{0b}' 或`@t{0B}'表示二进制。 整数也可以是`@var{base}@t{#}@var{n}'的形式，其中 @var{base} 是一个介于 2 和 36 之间的十进制数，代表算术基"
"数，@var{n} 是该基数中的一个数字（例如，`@t{16#ff}'是十六进制的 255）。 @var{base}@t{#}也可以省略，在这种情况下使用基数 10。 为了向后兼容，也可以使用`@t{[}@var{base}@t{]}@var{n}' 的形式。"

#. type: Plain text
#: zsh.texi:3254
msgid ""
"An integer expression or a base given in the form `@var{base}@t{#}@var{n}' may contain underscores (`@t{_}') after the leading digit for visual guidance; these are ignored in computation.  Examples are "
"@t{1_000_000} or @t{0xffff_ffff} which are equivalent to @t{1000000} and @t{0xffffffff} respectively."
msgstr ""
"以`@var{base}@t{#}@var{n}' 形式给出的整数表达式或基数，可以在前导数字后包含下划线（`@t{_}'），以起到视觉引导作用；但在计算中这些下划线将被忽略。 例如 @t{1_000_000} 或 @t{0xffff_ffff}，它们分别等价于 "
"@t{1000000} 和 @t{0xffffffff}。"

#. type: Plain text
#: zsh.texi:3267
msgid ""
"It is also possible to specify a base to be used for output in the form `@t{[#}@var{base}@t{]}', for example `@t{[#16]}'.  This is used when outputting arithmetical substitutions or when assigning to "
"scalar parameters, but an explicitly defined integer or floating point parameter will not be affected.  If an integer variable is implicitly defined by an arithmetic expression, any base specified in this "
"way will be set as the variable's output arithmetic base as if the option `@t{-i} @var{base}' to the @t{typeset} builtin had been used.  The expression has no precedence and if it occurs more than once in "
"a mathematical expression, the last encountered is used.  For clarity it is recommended that it appear at the beginning of an expression.  As an example:"
msgstr ""
"也可以指定一个用于输出的基数，形式为`@t{[#}@var{base}@t{]}'，例如`@t{[#16]}'。 这在输出算术替换或赋值给标量参数时使用，但显式定义的整数或浮点参数不受影响。 如果一个整数变量是由一个算术表达式隐式定义的，那"
"么以这种方式指定的任何基数都将被设置为变量的输出算术基数，就好像@t{typeset}内置命令的 `@t{-i} @var{base}' 选项一样。 表达式没有优先级，如果在数学表达式中出现多次，则使用最后出现的表达式。 为清晰起见，建议"
"将其放在表达式的开头。 例如"

#. type: example
#: zsh.texi:3273
#, no-wrap
msgid ""
"typeset -i 16 y\n"
"print $(( [#8] x = 32, y = 32 ))\n"
"print $x $y\n"
msgstr ""
"typeset -i 16 y\n"
"print $(( [#8] x = 32, y = 32 ))\n"
"print $x $y\n"

#. type: Plain text
#: zsh.texi:3281
msgid ""
"outputs first `@t{8#40}', the rightmost value in the given output base, and then `@t{8#40 16#20}', because @t{y} has been explicitly declared to have output base 16, while @t{x} (assuming it does not "
"already exist) is implicitly typed by the arithmetic evaluation, where it acquires the output base 8."
msgstr "首先输出`@t{8#40}'，即给定输出基数中最右边的值，然后输出 `@t{8#40 16#20}'，因为 @t{y} 已明确声明输出基数为 16，而 @t{x}（假设它不存在）是通过算术运算隐式键入的，在算术运算中它获得输出基数为 8。"

#. type: Plain text
#: zsh.texi:3288
msgid ""
"The @var{base} may be replaced or followed by an underscore, which may itself be followed by a positive integer (if it is missing the value 3 is used).  This indicates that underscores should be inserted "
"into the output string, grouping the number for visual clarity.  The following integer specifies the number of digits to group together.  For example:"
msgstr ""
"@var{base} 可以用下划线代替或跟在下划线后面，下划线后面可以是一个正整数（如果没有下划线，则使用值 3）。 这表示应在输出字符串中插入下划线，对数字进行分组，以便视觉清晰。 下面的整数指定了要组合在一起的数字个"
"数。 例如"

#. type: example
#: zsh.texi:3293
#, no-wrap
msgid ""
"setopt cbases\n"
"print $(( [#16_4] 65536 ** 2 ))\n"
msgstr ""
"setopt cbases\n"
"print $(( [#16_4] 65536 ** 2 ))\n"

#. type: Plain text
#: zsh.texi:3297
msgid "outputs `@t{0x1_0000_0000}'."
msgstr "输出 `@t{0x1_0000_0000}'."

#. type: Plain text
#: zsh.texi:3302
msgid "The feature can be used with floating point numbers, in which case the base must be omitted; grouping is away from the decimal point.  For example,"
msgstr "该功能可用于浮点数，在这种情况下，必须省略基数；分组远离小数点。 例如"

#. type: example
#: zsh.texi:3307
#, no-wrap
msgid ""
"zmodload zsh/mathfunc\n"
"print $(( [#_] sqrt(1e7) ))\n"
msgstr ""
"zmodload zsh/mathfunc\n"
"print $(( [#_] sqrt(1e7) ))\n"

#. type: Plain text
#: zsh.texi:3312
msgid "outputs `@t{3_162.277_660_168_379_5}' (the number of decimal places shown may vary)."
msgstr "输出`@t{3_162.277_660_168_379_5}'（显示的小数位数可能有所不同）。"

#. type: pindex
#: zsh.texi:3314
#, no-wrap
msgid "C_BASES, use of"
msgstr "C_BASES, use of"

#. type: pindex
#: zsh.texi:3315
#, no-wrap
msgid "OCTAL_ZEROES, use of"
msgstr "OCTAL_ZEROES, use of"

#. type: Plain text
#: zsh.texi:3322
msgid ""
"If the @t{C_BASES} option is set, hexadecimal numbers are output in the standard C format, for example `@t{0xFF}' instead of the usual `@t{16#FF}'.  If the option @t{OCTAL_ZEROES} is also set (it is not "
"by default), octal numbers will be treated similarly and hence appear as `@t{077}' instead of `@t{8#77}'.  This option has no effect on the output of bases other than hexadecimal and octal, and these "
"formats are always understood on input."
msgstr ""
"如果设置了 @t{C_BASES} 选项，十六进制数将以标准 C 格式输出，例如`@t{0xFF}' ，而不是通常的`@t{16#FF}'。 如果同时设置了选项 @t{OCTAL_ZEROES}（默认情况下没有设置），八进制数也会被类似处理，因此会显示为 "
"`@t{077}' ，而不是`@t{8#77}'。 该选项对十六进制和八进制以外的其他基数的输出没有影响，这些格式在输入时总是可以理解的。"

#. type: Plain text
#: zsh.texi:3328
msgid ""
"When an output base is specified using the `@t{[#}@var{base}@t{]}' syntax, an appropriate base prefix will be output if necessary, so that the value output is valid syntax for input.  If the @t{#} is "
"doubled, for example `@t{[##16]}', then no base prefix is output."
msgstr "当使用`@t{[#}@var{base}@t{]}' 语法指定输出基数时，如有必要，将输出适当的基数前缀，以便输出的值是有效的输入语法。 如果双写 @t{#} ，例如`@t{[##16]}'，则不会输出基数前缀。"

#. type: Plain text
#: zsh.texi:3336
msgid ""
"Floating point constants are recognized by the presence of a decimal point or an exponent.  The decimal point may be the first character of the constant, but the exponent character @t{e} or @t{E} may not, "
"as it will be taken for a parameter name.  All numeric parts (before and after the decimal point and in the exponent) may contain underscores after the leading digit for visual guidance; these are ignored "
"in computation."
msgstr ""
"浮点常量可以通过小数点或指数来识别。 小数点可以是常数的第一个字符，但指数字符 @t{e} 或 @t{E} 则不可以，因为它会被当作参数名。 所有数字部分（小数点前后和指数部分）的前导数字后都可以包含下划线，以起到视觉引"
"导作用；在计算中这些下划线将被忽略。"

#. type: cindex
#: zsh.texi:3338
#, no-wrap
msgid "arithmetic operators"
msgstr "算术运算符"

#. type: cindex
#: zsh.texi:3339
#, no-wrap
msgid "operators, arithmetic"
msgstr "运算符, 算术"

#. type: Plain text
#: zsh.texi:3342
msgid "An arithmetic expression uses nearly the same syntax and associativity of expressions as in C."
msgstr "算术表达式使用的语法和表达式的结合性与 C 语言几乎相同。"

#. type: Plain text
#: zsh.texi:3346
msgid "In the native mode of operation, the following operators are supported (listed in decreasing order of precedence):"
msgstr "在原生运算模式下，支持以下运算符（按优先级递减顺序排列）："

#. type: t{#1}
#: zsh.texi:3349 zsh.texi:3394
#, no-wrap
msgid "+ - ! ~ ++ --"
msgstr "+ - ! ~ ++ --"

#. type: table
#: zsh.texi:3351 zsh.texi:3396
msgid "unary plus/minus, logical NOT, complement, @{pre,post@}@{in,de@}crement"
msgstr "一元加/减、逻辑 NOT、补码、@{pre,post@}@{in,de@}crement"

#. type: t{#1}
#: zsh.texi:3351 zsh.texi:3402
#, no-wrap
msgid "<< >>"
msgstr "<< >>"

#. type: table
#: zsh.texi:3353 zsh.texi:3404
msgid "bitwise shift left, right"
msgstr "向左、向右位移"

#. type: t{#1}
#: zsh.texi:3353 zsh.texi:3408 zsh.texi:4630
#, no-wrap
msgid "&"
msgstr "&"

#. type: table
#: zsh.texi:3355 zsh.texi:3410
msgid "bitwise AND"
msgstr "按位与"

#. type: t{#1}
#: zsh.texi:3355 zsh.texi:3410 zsh.texi:4482 zsh.texi:7490
#, no-wrap
msgid "^"
msgstr "^"

#. type: table
#: zsh.texi:3357 zsh.texi:3412
msgid "bitwise XOR"
msgstr "按位异或"

#. type: table
#: zsh.texi:3359 zsh.texi:3414
msgid "bitwise OR"
msgstr "按位或"

#. type: table
#: zsh.texi:3361 zsh.texi:3398
msgid "exponentiation"
msgstr "乘幂"

#. type: t{#1}
#: zsh.texi:3361 zsh.texi:3398
#, no-wrap
msgid "* / %"
msgstr "* / %"

#. type: table
#: zsh.texi:3363 zsh.texi:3400
msgid "multiplication, division, modulus (remainder)"
msgstr "乘法、除法、模数（余数）"

#. type: t{#1}
#: zsh.texi:3363 zsh.texi:3400
#, no-wrap
msgid "+ -"
msgstr "+ -"

#. type: table
#: zsh.texi:3365 zsh.texi:3402
msgid "addition, subtraction"
msgstr "加法、减法"

#. type: t{#1}
#: zsh.texi:3365 zsh.texi:3404
#, no-wrap
msgid "< > <= >="
msgstr "< > <= >="

#. type: table
#: zsh.texi:3367 zsh.texi:3406
msgid "comparison"
msgstr "比较"

#. type: t{#1}
#: zsh.texi:3367 zsh.texi:3406
#, no-wrap
msgid "== !="
msgstr "== !="

#. type: table
#: zsh.texi:3369 zsh.texi:3408
msgid "equality and inequality"
msgstr "等于，不等于"

#. type: t{#1}
#: zsh.texi:3369 zsh.texi:3414
#, no-wrap
msgid "&&"
msgstr "&&"

#. type: table
#: zsh.texi:3371 zsh.texi:3416
msgid "logical AND"
msgstr "逻辑与"

#. type: t{#1}
#: zsh.texi:3371
#, no-wrap
msgid "|| ^^"
msgstr "|| ^^"

#. type: table
#: zsh.texi:3373
msgid "logical OR, XOR"
msgstr "逻辑或，逻辑异或"

#. type: t{#1}
#: zsh.texi:3373 zsh.texi:3420
#, no-wrap
msgid "? :"
msgstr "? :"

#. type: table
#: zsh.texi:3375 zsh.texi:3422
msgid "ternary operator"
msgstr "三元运算符"

#. type: t{#1}
#: zsh.texi:3375 zsh.texi:3422
#, no-wrap
msgid "= += -= *= /= %= &= ^= |= <<= >>= &&= ||= ^^= **="
msgstr "= += -= *= /= %= &= ^= |= <<= >>= &&= ||= ^^= **="

#. type: cindex
#: zsh.texi:3377 zsh.texi:3424 zsh.texi:7761
#, no-wrap
msgid "assignment"
msgstr "赋值"

#. type: t{#1}
#: zsh.texi:3377 zsh.texi:3424
#, no-wrap
msgid ","
msgstr ","

#. type: table
#: zsh.texi:3379 zsh.texi:3426
msgid "comma operator"
msgstr "逗号运算符"

#. type: Plain text
#: zsh.texi:3386
msgid ""
"The operators `@t{&&}', `@t{||}', `@t{&&=}', and `@t{||=}' are short-circuiting, and only one of the latter two expressions in a ternary operator is evaluated.  Note the precedence of the bitwise AND, OR, "
"and XOR operators."
msgstr "运算符 `@t{&&}', `@t{||}', `@t{&&=}', 和`@t{||=}' 是短路运算符，三元运算符中后两个表达式中只有一个会被求值。 请注意按位 AND、OR 和 XOR 运算符的优先级。"

#. type: Plain text
#: zsh.texi:3391
msgid "With the option @t{C_PRECEDENCES} the precedences (but no other properties) of the operators are altered to be the same as those in most other languages that support the relevant operators:"
msgstr "如果使用选项 @t{C_PRECEDENCES}，运算符的优先级（但不包括其他属性）将被修改为与支持相关运算符的大多数其他语言中的运算符相同："

#. type: t{#1}
#: zsh.texi:3416
#, no-wrap
msgid "^^"
msgstr "^^"

#. type: table
#: zsh.texi:3418
msgid "logical XOR"
msgstr "逻辑异或"

#. type: t{#1}
#: zsh.texi:3418
#, no-wrap
msgid "||"
msgstr "||"

#. type: table
#: zsh.texi:3420
msgid "logical OR"
msgstr "逻辑或"

#. type: Plain text
#: zsh.texi:3433
msgid ""
"Note the precedence of exponentiation in both cases is below that of unary operators, hence `@t{-3**2}' evaluates as `@t{9}', not `@t{-9}'.  Use parentheses where necessary: `@t{-(3**2)}'.  This is for "
"compatibility with other shells."
msgstr "注意这两种情况下指数运算的优先级都低于一元运算符，因此`@t{-3**2}'的运算结果是`@t{9}'，而不是`@t{-9}'。 必要时使用括号： `@t{-(3**2)}'.  这是为了与其他 shell 兼容。"

#. type: cindex
#: zsh.texi:3435
#, no-wrap
msgid "mathematical functions, use of"
msgstr "数学函数, use of"

#. type: cindex
#: zsh.texi:3436
#, no-wrap
msgid "functions, math, use of"
msgstr "函数, 数学, use of"

#. type: Plain text
#: zsh.texi:3444
msgid ""
"Mathematical functions can be called with the syntax `@var{func}@t{(}@var{args}@t{)}', where the function decides if the @var{args} is used as a string or a comma-separated list of arithmetic expressions. "
"The shell currently defines no mathematical functions by default, but the module @t{zsh/mathfunc} may be loaded with the @t{zmodload} builtin to provide standard floating point mathematical functions."
msgstr ""
"数学函数的调用语法为 `@var{func}@t{(}@var{args}@t{)}'，其中函数决定 @var{args} 是用作字符串还是逗号分隔的算术表达式列表。shell 目前默认不定义数学函数，但可以使用 @t{zmodload} 内置命令加载 @t{zsh/mathfunc} "
"模块，以提供标准浮点数学函数。"

#. type: Plain text
#: zsh.texi:3455
msgid ""
"An expression of the form `@t{##}@var{x}' where @var{x} is any character sequence such as `@t{a}', `@t{^A}', or `@t{\\M-\\C-x}' gives the value of this character and an expression of the form `@t{#}"
"@var{name}' gives the value of the first character of the contents of the parameter @var{name}.  Character values are according to the character set used in the current locale; for multibyte character "
"handling the option @t{MULTIBYTE} must be set.  Note that this form is different from `@t{$#}@var{name}', a standard parameter substitution which gives the length of the parameter @var{name}.  `@t{#\\}' "
"is accepted instead of `@t{##}', but its use is deprecated."
msgstr ""
"形式为 `@t{##}@var{x}' 的表达式（其中 @var{x} 是任何字符序列，如 `@t{a}'、`@t{^A}'或`@t{\\M-\\C-x}' ）给出了该字符的值，形式为`@t{#}@var{name}'的表达式给出了参数 @var{name} 内容中第一个字符的值。 字符值是"
"根据当前本地使用的字符集确定的；要处理多字节字符，必须设置选项 @t{MULTIBYTE}。 需要注意的是，这种形式不同于 `@t{$#}@var{name}'，后者是一种标准的参数替换形式，会给出参数 @var{name} 的长度。`@t{#\\}'可以代"
"替 `@t{##}'，但已被弃用。"

#. type: Plain text
#: zsh.texi:3460
msgid "Named parameters and subscripted arrays can be referenced by name within an arithmetic expression without using the parameter expansion syntax.  For example,"
msgstr "命名参数和下标数组可以在算术表达式中通过名称引用，而无需使用参数扩展语法。 例如"

#. type: example
#: zsh.texi:3464
#, no-wrap
msgid "((val2 = val1 * 2))\n"
msgstr "((val2 = val1 * 2))\n"

#. type: Plain text
#: zsh.texi:3468
msgid "assigns twice the value of @t{$val1} to the parameter named @t{val2}."
msgstr "会将 @t{$val1} 值的两倍赋值给名为 @t{val2} 的参数。"

#. type: Plain text
#: zsh.texi:3472
msgid "An internal integer representation of a named parameter can be specified with the @t{integer} builtin."
msgstr "可以使用 @t{integer} 内置命令指定已命名参数的内部整数表示。"

#. type: cindex
#: zsh.texi:3472
#, no-wrap
msgid "parameters, integer"
msgstr "参数, 整形"

#. type: cindex
#: zsh.texi:3473
#, no-wrap
msgid "integer parameters"
msgstr "整形参数"

#. type: findex
#: zsh.texi:3474
#, no-wrap
msgid "integer, use of"
msgstr "integer, use of"

#. type: Plain text
#: zsh.texi:3479
msgid ""
"Arithmetic evaluation is performed on the value of each assignment to a named parameter declared integer in this manner.  Assigning a floating point number to an integer results in rounding towards zero."
msgstr "以这种方式对声明的整数型的命名参数，每次赋值都进行算术运算。 将浮点数赋值给整数会导致四舍五入为零。(?)"

#. type: cindex
#: zsh.texi:3481
#, no-wrap
msgid "parameters, floating point"
msgstr "参数, 浮点"

#. type: cindex
#: zsh.texi:3482
#, no-wrap
msgid "floating point parameters"
msgstr "浮点参数"

#. type: findex
#: zsh.texi:3483
#, no-wrap
msgid "float, use of"
msgstr "float, use of"

#. type: Plain text
#: zsh.texi:3491
msgid ""
"Likewise, floating point numbers can be declared with the @t{float} builtin; there are two types, differing only in their output format, as described for the @t{typeset} builtin.  The output format can be "
"bypassed by using arithmetic substitution instead of the parameter substitution, i.e. `@t{$@{}@var{float}@t{@}}' uses the defined format, but `@t{$((}@var{float}@t{))}' uses a generic floating point "
"format."
msgstr ""
"同样，浮点数也可以使用 @t{float} 内置命令来声明；浮点数有两种类型，它们的区别仅在于输出格式，正如 @t{typeset} 内置命令所描述的那样。 输出格式可以通过使用算术替换代替参数替换来绕过，即`@t{$@{}@var{float}"
"@t{@}}'使用定义的格式，而`@t{$((}@var{float}@t{))}'使用通用浮点格式。"

#. type: Plain text
#: zsh.texi:3498
msgid ""
"Promotion of integer to floating point values is performed where necessary.  In addition, if any operator which requires an integer (`@t{&}', `@t{|}', `@t{^}', `@t{<<}', `@t{>>}' and their equivalents "
"with assignment) is given a floating point argument, it will be silently rounded towards zero except for `@t{~}' which rounds down."
msgstr ""
"必要时会将整数值提升为浮点数。 此外，如果任何需要整数参数的运算符（`@t{&}', `@t{|}', `@t{^}', `@t{<<}', `@t{>>}'及其等价赋值运算符）被赋予浮点参数，除了`@t{~}' 会向下舍入外，其他运算符都会被默默地舍入为"
"零。"

#. type: Plain text
#: zsh.texi:3508
msgid ""
"Users should beware that, in common with many other programming languages but not software designed for calculation, the evaluation of an expression in zsh is taken a term at a time and promotion of "
"integers to floating point does not occur in terms only containing integers.  A typical result of this is that a division such as @t{6/8} is truncated, in this being rounded towards 0.  The "
"@t{FORCE_FLOAT} shell option can be used in scripts or functions where floating point evaluation is required throughout."
msgstr ""
"用户需要注意的是，与许多其他编程语言（但不是为计算而设计的软件）一样，在 zsh 中对表达式的计算是一次一个项进行的，在仅包含整数的项中不会将整数提升为浮点数。 @t{FORCE_FLOAT} shell 选项可用于需要浮点运算的脚"
"本或函数中。"

#. type: Plain text
#: zsh.texi:3512
msgid "Scalar variables can hold integer or floating point values at different times; there is no memory of the numeric type in this case."
msgstr "标量变量可以在不同时间保存整数或浮点数值；在这种情况下，没有数值类型的内存。"

#. type: Plain text
#: zsh.texi:3519
msgid ""
"If a variable is first assigned in a numeric context without previously being declared, it will be implicitly typed as @t{integer} or @t{float} and retain that type either until the type is explicitly "
"changed or until the end of the scope.  This can have unforeseen consequences.  For example, in the loop"
msgstr "如果一个变量在数值上下文中首次赋值时没有事先声明，那么它将被隐式地类型化为 @t{integer} 或 @t{float}，并保持这种类型直到类型被显式地更改或作用域结束。 这可能会产生意想不到的后果。 例如，在循环"

#. type: example
#: zsh.texi:3525
#, no-wrap
msgid ""
"for (( f = 0; f < 1; f += 0.1 )); do\n"
"# use $f\n"
"done\n"
msgstr ""
"for (( f = 0; f < 1; f += 0.1 )); do\n"
"# use $f\n"
"done\n"

#. type: Plain text
#: zsh.texi:3535
msgid ""
"if @t{f} has not already been declared, the first assignment will cause it to be created as an integer, and consequently the operation `@t{f += 0.1}' will always cause the result to be truncated to zero, "
"so that the loop will fail.  A simple fix would be to turn the initialization into `@t{f = 0.0}'.  It is therefore best to declare numeric variables with explicit types."
msgstr ""
"如果 @t{f} 尚未被声明，第一次赋值将导致它被创建为一个整数，因此操作 `@t{f += 0.1}' 将始终导致结果被截断为零，从而导致循环失败。 一个简单的解决方法是将初始化变成 `@t{f = 0.0}'。 因此，最好使用显式类型声明数"
"值变量。"

#. type: node
#: zsh.texi:3535 zsh.texi:3814 zsh.texi:3816 zsh.texi:4264
#, no-wrap
msgid "Prompt Expansion"
msgstr "提示符扩展"

#. type: cindex
#: zsh.texi:3539
#, no-wrap
msgid "conditional expressions"
msgstr "条件表达式"

#. type: cindex
#: zsh.texi:3540
#, no-wrap
msgid "expressions, conditional"
msgstr "表达式, 条件"

#. type: Plain text
#: zsh.texi:3545
msgid ""
"A @emph{conditional expression} is used with the @t{[[} compound command to test attributes of files and to compare strings.  Each expression can be constructed from one or more of the following unary or "
"binary expressions:"
msgstr "@emph{条件表达示} 与 @t{[[} 复合命令配合使用，可用于测试文件属性和比较字符串。 每个表达式可以由以下一个或多个一元或二元表达式构成："

#. type: item
#: zsh.texi:3548
#, no-wrap
msgid "@t{-a} @var{file}"
msgstr "@t{-a} @var{file}"

#. type: table
#: zsh.texi:3550 zsh.texi:3562
msgid "true if @var{file} exists."
msgstr "如果 @var{file} 存在，则为 true。"

#. type: item
#: zsh.texi:3551
#, no-wrap
msgid "@t{-b} @var{file}"
msgstr "@t{-b} @var{file}"

#. type: table
#: zsh.texi:3553
msgid "true if @var{file} exists and is a block special file."
msgstr "如果 @var{file} 已存在且是块专用文件，则为 true。"

#. type: item
#: zsh.texi:3554
#, no-wrap
msgid "@t{-c} @var{file}"
msgstr "@t{-c} @var{file}"

#. type: table
#: zsh.texi:3556
msgid "true if @var{file} exists and is a character special file."
msgstr "如果 @var{file} 存在且是字符特殊文件，则为 true。"

#. type: item
#: zsh.texi:3557
#, no-wrap
msgid "@t{-d} @var{file}"
msgstr "@t{-d} @var{file}"

#. type: table
#: zsh.texi:3559
msgid "true if @var{file} exists and is a directory."
msgstr "如果 @var{file} 存在且是一个目录，则为 true。"

#. type: item
#: zsh.texi:3560
#, no-wrap
msgid "@t{-e} @var{file}"
msgstr "@t{-e} @var{file}"

#. type: item
#: zsh.texi:3563
#, no-wrap
msgid "@t{-f} @var{file}"
msgstr "@t{-f} @var{file}"

#. type: table
#: zsh.texi:3565
msgid "true if @var{file} exists and is a regular file."
msgstr "如果 @var{file} 存在且是普通文件，则为 true。"

#. type: item
#: zsh.texi:3566
#, no-wrap
msgid "@t{-g} @var{file}"
msgstr "@t{-g} @var{file}"

#. type: table
#: zsh.texi:3568
msgid "true if @var{file} exists and has its setgid bit set."
msgstr "如果 @var{file} 已存在且设置了 setgid 位，则为 true。"

#. type: item
#: zsh.texi:3569
#, no-wrap
msgid "@t{-h} @var{file}"
msgstr "@t{-h} @var{file}"

#. type: table
#: zsh.texi:3571 zsh.texi:3621
msgid "true if @var{file} exists and is a symbolic link."
msgstr "如果 @var{file} 存在且是符号链接，则为 true。"

#. type: item
#: zsh.texi:3572
#, no-wrap
msgid "@t{-k} @var{file}"
msgstr "@t{-k} @var{file}"

#. type: table
#: zsh.texi:3574
msgid "true if @var{file} exists and has its sticky bit set."
msgstr "如果 @var{file} 存在且设置了粘性位，则为 true。"

#. type: item
#: zsh.texi:3575
#, no-wrap
msgid "@t{-n} @var{string}"
msgstr "@t{-n} @var{string}"

#. type: table
#: zsh.texi:3577
msgid "true if length of @var{string} is non-zero."
msgstr "如果 @var{string} 的长度非零，则为 true。"

#. type: item
#: zsh.texi:3578
#, no-wrap
msgid "@t{-o} @var{option}"
msgstr "@t{-o} @var{option}"

#. type: table
#: zsh.texi:3582
msgid "true if option named @var{option} is on.  @var{option} may be a single character, in which case it is a single letter option name.  (See @ref{Specifying Options}.)"
msgstr "如果名为 @var{option} 的选项已开启，则为 true。 @var{option} 可以是单字符，在这种情况下就是单字母选项名称。 (参见 @ref{指定选项}）。"

#. type: table
#: zsh.texi:3587
msgid "When no option named @var{option} exists, and the @t{POSIX_BUILTINS} option hasn't been set, return 3 with a warning.  If that option is set, return 1 with no warning."
msgstr "如果不存在名为 @var{option} 的选项，且 @t{POSIX_BUILTINS} 选项尚未设置，则返回 3 并发出警告。 如果设置了该选项，则返回 1，不带警告。"

#. type: item
#: zsh.texi:3588
#, no-wrap
msgid "@t{-p} @var{file}"
msgstr "@t{-p} @var{file}"

#. type: table
#: zsh.texi:3590
msgid "true if @var{file} exists and is a FIFO special file (named pipe)."
msgstr "如果 @var{file} 存在且是 FIFO 特殊文件（命名为管道），则为 true。"

#. type: item
#: zsh.texi:3591
#, no-wrap
msgid "@t{-r} @var{file}"
msgstr "@t{-r} @var{file}"

#. type: table
#: zsh.texi:3593
msgid "true if @var{file} exists and is readable by current process."
msgstr "如果 @var{file} 存在且当前进程可读取，则为 true。"

#. type: item
#: zsh.texi:3594
#, no-wrap
msgid "@t{-s} @var{file}"
msgstr "@t{-s} @var{file}"

#. type: table
#: zsh.texi:3596
msgid "true if @var{file} exists and has size greater than zero."
msgstr "如果 @var{file} 存在且大小大于零，则为 true。"

#. type: item
#: zsh.texi:3597
#, no-wrap
msgid "@t{-t} @var{fd}"
msgstr "@t{-t} @var{fd}"

#. type: table
#: zsh.texi:3601
msgid "true if file descriptor number @var{fd} is open and associated with a terminal device.  (note: @var{fd} is not optional)"
msgstr "如果文件描述符编号 @var{fd} 已打开并与终端设备关联，则为 true。 (注意：@var{fd} 不是可选项）"

#. type: item
#: zsh.texi:3602
#, no-wrap
msgid "@t{-u} @var{file}"
msgstr "@t{-u} @var{file}"

#. type: table
#: zsh.texi:3604
msgid "true if @var{file} exists and has its setuid bit set."
msgstr "如果 @var{file} 已存在且设置了 setuid 位，则为 true。"

#. type: item
#: zsh.texi:3605
#, no-wrap
msgid "@t{-v} @var{varname}"
msgstr "@t{-v} @var{varname}"

#. type: table
#: zsh.texi:3607
msgid "true if shell variable @var{varname} is set."
msgstr "如果 shell 变量 @var{varname} 已设置，则为 true。"

#. type: item
#: zsh.texi:3608
#, no-wrap
msgid "@t{-w} @var{file}"
msgstr "@t{-w} @var{file}"

#. type: table
#: zsh.texi:3610
msgid "true if @var{file} exists and is writable by current process."
msgstr "如果 @var{file} 存在且当前进程可写，则为 true。"

#. type: item
#: zsh.texi:3611
#, no-wrap
msgid "@t{-x} @var{file}"
msgstr "@t{-x} @var{file}"

#. type: table
#: zsh.texi:3615
msgid "true if @var{file} exists and is executable by current process.  If @var{file} exists and is a directory, then the current process has permission to search in the directory."
msgstr "如果 @var{file} 存在且当前进程可执行，则为 true。 如果 @var{file} 存在且是一个目录，则当前进程有权限在该目录中搜索。"

#. type: item
#: zsh.texi:3616
#, no-wrap
msgid "@t{-z} @var{string}"
msgstr "@t{-z} @var{string}"

#. type: table
#: zsh.texi:3618
msgid "true if length of @var{string} is zero."
msgstr "如果 @var{string} 的长度为零，则为 true。"

#. type: item
#: zsh.texi:3619
#, no-wrap
msgid "@t{-L} @var{file}"
msgstr "@t{-L} @var{file}"

#. type: item
#: zsh.texi:3622
#, no-wrap
msgid "@t{-O} @var{file}"
msgstr "@t{-O} @var{file}"

#. type: table
#: zsh.texi:3624
msgid "true if @var{file} exists and is owned by the effective user ID of this process."
msgstr "如果 @var{file} 存在且为该进程的有效用户 ID 所有，则为 true。"

#. type: item
#: zsh.texi:3625
#, no-wrap
msgid "@t{-G} @var{file}"
msgstr "@t{-G} @var{file}"

#. type: table
#: zsh.texi:3628
msgid "true if @var{file} exists and its group matches the effective group ID of this process."
msgstr "如果 @var{file} 存在，且其组群与此进程的有效组群 ID 一致，则为 true。"

#. type: item
#: zsh.texi:3629
#, no-wrap
msgid "@t{-S} @var{file}"
msgstr "@t{-S} @var{file}"

#. type: table
#: zsh.texi:3631
msgid "true if @var{file} exists and is a socket."
msgstr "如果 @var{file} 存在且是套接字，则为 true。"

#. type: item
#: zsh.texi:3632
#, no-wrap
msgid "@t{-N} @var{file}"
msgstr "@t{-N} @var{file}"

#. type: table
#: zsh.texi:3635
msgid "true if @var{file} exists and its access time is not newer than its modification time."
msgstr "如果 @var{file} 存在，且其访问时间不新于修改时间，则为 true。"

#. type: item
#: zsh.texi:3636
#, no-wrap
msgid "@var{file1} @t{-nt} @var{file2}"
msgstr "@var{file1} @t{-nt} @var{file2}"

#. type: table
#: zsh.texi:3638
msgid "true if @var{file1} exists and is newer than @var{file2}."
msgstr "如果 @var{file1} 存在且比 @var{file2} 新，则为 true。"

#. type: item
#: zsh.texi:3639
#, no-wrap
msgid "@var{file1} @t{-ot} @var{file2}"
msgstr "@var{file1} @t{-ot} @var{file2}"

#. type: table
#: zsh.texi:3641
msgid "true if @var{file1} exists and is older than @var{file2}."
msgstr "如果 @var{file1} 存在且比 @var{file2} 早，则为 true。"

#. type: item
#: zsh.texi:3642
#, no-wrap
msgid "@var{file1} @t{-ef} @var{file2}"
msgstr "@var{file1} @t{-ef} @var{file2}"

#. type: table
#: zsh.texi:3644
msgid "true if @var{file1} and @var{file2} exist and refer to the same file."
msgstr "如果 @var{file1} 和 @var{file2} 存在并指向同一文件，则为 true。"

#. type: item
#: zsh.texi:3645
#, no-wrap
msgid "@var{string} @t{=} @var{pattern}"
msgstr "@var{string} @t{=} @var{pattern}"

#. type: itemx
#: zsh.texi:3646
#, no-wrap
msgid "@var{string} @t{==} @var{pattern}"
msgstr "@var{string} @t{==} @var{pattern}"

#. type: table
#: zsh.texi:3652
msgid ""
"true if @var{string} matches @var{pattern}.  The two forms are exactly equivalent.  The `@t{=}' form is the traditional shell syntax (and hence the only one generally used with the @t{test} and @t{[} "
"builtins); the `@t{==}' form provides compatibility with other sorts of computer language."
msgstr ""
"如果 @var{string} 与 @var{pattern} 匹配，则为 true。 这两种形式完全等价。 `@t{=}' 形式是传统的 shell 语法（因此也是 @t{test} 和 @t{[} 内置命令中唯一常用的语法）； `@t{==}'形式提供了与其他计算机语言的兼容"
"性。"

#. type: item
#: zsh.texi:3653
#, no-wrap
msgid "@var{string} @t{!=} @var{pattern}"
msgstr "@var{string} @t{!=} @var{pattern}"

#. type: table
#: zsh.texi:3655
msgid "true if @var{string} does not match @var{pattern}."
msgstr "如果 @var{string} 与 @var{pattern} 不匹配，则为 true。"

#. type: item
#: zsh.texi:3656
#, no-wrap
msgid "@var{string} @t{=~} @var{regexp}"
msgstr "@var{string} @t{=~} @var{regexp}"

#. type: table
#: zsh.texi:3664
msgid ""
"true if @var{string} matches the regular expression @var{regexp}.  If the option @t{RE_MATCH_PCRE} is set @var{regexp} is tested as a PCRE regular expression using the @t{zsh/pcre} module, else it is "
"tested as a POSIX extended regular expression using the @t{zsh/regex} module.  Upon successful match, some variables will be updated; no variables are changed if the matching fails."
msgstr ""
"如果 @var{string} 与正则表达式 @var{regexp} 匹配，则为 true。 如果设置了 @t{RE_MATCH_PCRE} 选项，@var{regexp} 将使用 @t{zsh/pcre} 模块作为 PCRE 正则表达式进行测试，否则将使用 @t{zsh/regex} 模块作为 POSIX "
"扩展正则表达式进行测试。 匹配成功后，某些变量将被更新；匹配失败时，变量不会发生变化。"

#. type: table
#: zsh.texi:3683
msgid ""
"If the option @t{BASH_REMATCH} is not set the scalar parameter @t{MATCH} is set to the substring that matched the pattern and the integer parameters @t{MBEGIN} and @t{MEND} to the index of the start and "
"end, respectively, of the match in @var{string}, such that if @var{string} is contained in variable @t{var} the expression `@t{$@{var[$MBEGIN,$MEND]@}}' is identical to `@t{$MATCH}'.  The setting of the "
"option @t{KSH_ARRAYS} is respected.  Likewise, the array @t{match} is set to the substrings that matched parenthesised subexpressions and the arrays @t{mbegin} and @t{mend} to the indices of the start and "
"end positions, respectively, of the substrings within @var{string}.  The arrays are not set if there were no parenthesised subexpressions.  For example, if the string `@t{a short string}' is matched "
"against the regular expression `@t{s(...)t}', then (assuming the option @t{KSH_ARRAYS} is not set) @t{MATCH}, @t{MBEGIN} and @t{MEND} are `@t{short}', @t{3} and @t{7}, respectively, while @t{match}, "
"@t{mbegin} and @t{mend} are single entry arrays containing the strings `@t{hor}', `@t{4}' and `@t{6}', respectively."
msgstr ""
"如果未设置选项 @t{BASH_REMATCH}，标量参数 @t{MATCH} 将设置为与模式匹配的子串，整数参数 @t{MBEGIN} 和 @t{MEND} 将分别设置为 @var{string} 中匹配开始和结束的索引， 这样，如果 @var{string} 包含在变量 @t{var} "
"中，表达式 `@t{$@{var[$MBEGIN,$MEND]@}}' 与  `@t{$MATCH}'相同。这遵守选项 @t{KSH_ARRAYS} 的设置。同样，数组 @t{match} 会被设置为与带括号的子表达式相匹配的子串，数组 @t{mbegin} 和 @t{mend} 会被分别设置为 "
"@var{string} 中子串的开始和结束位置的索引。 如果没有带括号的子表达式，则不会设置数组。 例如，如果字符串`@t{a short string}' 与正则表达式`@t{s(...)t}'相匹配,那么（假设未设置 @t{KSH_ARRAYS} 选项），"
"@t{MATCH}、@t{MBEGIN} 和 @t{MEND} 分别是`@t{short}'、@t{3}和 @t{7}，而 @t{match}、@t{mbegin} 和 @t{mend} 则是分别包含字符串`@t{hor}', `@t{4}'和`@t{6}'的单条目数组。"

#. type: table
#: zsh.texi:3689
msgid ""
"If the option @t{BASH_REMATCH} is set the array @t{BASH_REMATCH} is set to the substring that matched the pattern followed by the substrings that matched parenthesised subexpressions within the pattern."
msgstr "如果设置了选项 @t{BASH_REMATCH}，数组 @t{BASH_REMATCH} 将被设置为与模式匹配的子串，然后是与模式内带括号子表达式匹配的子串。"

#. type: item
#: zsh.texi:3690
#, no-wrap
msgid "@var{string1} @t{<} @var{string2}"
msgstr "@var{string1} @t{<} @var{string2}"

#. type: table
#: zsh.texi:3693
msgid "true if @var{string1} comes before @var{string2} based on ASCII value of their characters."
msgstr "根据 @var{string1} 和 @var{string2} 字符的 ASCII 值，如果 @var{string1} 在 @var{string2} 之前，则为 true。"

#. type: item
#: zsh.texi:3694
#, no-wrap
msgid "@var{string1} @t{>} @var{string2}"
msgstr "@var{string1} @t{>} @var{string2}"

#. type: table
#: zsh.texi:3697
msgid "true if @var{string1} comes after @var{string2} based on ASCII value of their characters."
msgstr "根据 @var{string1} 和 @var{string2} 的 ASCII 码值，如果 @var{string1} 在 @var{string2} 之后，则为 true。"

#. type: item
#: zsh.texi:3698
#, no-wrap
msgid "@var{exp1} @t{-eq} @var{exp2}"
msgstr "@var{exp1} @t{-eq} @var{exp2}"

#. type: table
#: zsh.texi:3704
msgid ""
"true if @var{exp1} is numerically equal to @var{exp2}.  Note that for purely numeric comparisons use of the @t{((}@var{...}@t{))} builtin described in @ref{Arithmetic Evaluation} is more convenient than "
"conditional expressions."
msgstr "如果 @var{exp1} 在数值上等于 @var{exp2}，则为 true。 请注意，对于纯粹的数值比较，使用 @t{((}@var{...}@t{))}  内置命令 @ref{算术求值} 比条件表达式更方便。"

#. type: item
#: zsh.texi:3705
#, no-wrap
msgid "@var{exp1} @t{-ne} @var{exp2}"
msgstr "@var{exp1} @t{-ne} @var{exp2}"

#. type: table
#: zsh.texi:3707
msgid "true if @var{exp1} is numerically not equal to @var{exp2}."
msgstr "如果 @var{exp1} 在数值上不等于 @var{exp2}，则为 true。"

#. type: item
#: zsh.texi:3708
#, no-wrap
msgid "@var{exp1} @t{-lt} @var{exp2}"
msgstr "@var{exp1} @t{-lt} @var{exp2}"

#. type: table
#: zsh.texi:3710
msgid "true if @var{exp1} is numerically less than @var{exp2}."
msgstr "如果 @var{exp1} 在数值上小于 @var{exp2}，则为 true。"

#. type: item
#: zsh.texi:3711
#, no-wrap
msgid "@var{exp1} @t{-gt} @var{exp2}"
msgstr "@var{exp1} @t{-gt} @var{exp2}"

#. type: table
#: zsh.texi:3713
msgid "true if @var{exp1} is numerically greater than @var{exp2}."
msgstr "如果 @var{exp1} 在数值上大于 @var{exp2}，则为 true。"

#. type: item
#: zsh.texi:3714
#, no-wrap
msgid "@var{exp1} @t{-le} @var{exp2}"
msgstr "@var{exp1} @t{-le} @var{exp2}"

#. type: table
#: zsh.texi:3716
msgid "true if @var{exp1} is numerically less than or equal to @var{exp2}."
msgstr "如果 @var{exp1} 在数值上小于或等于 @var{exp2}，则为 true。"

#. type: item
#: zsh.texi:3717
#, no-wrap
msgid "@var{exp1} @t{-ge} @var{exp2}"
msgstr "@var{exp1} @t{-ge} @var{exp2}"

#. type: table
#: zsh.texi:3719
msgid "true if @var{exp1} is numerically greater than or equal to @var{exp2}."
msgstr "如果 @var{exp1} 在数值上大于或等于 @var{exp2}，则为 true。"

#. type: item
#: zsh.texi:3720
#, no-wrap
msgid "@t{(} @var{exp} @t{)}"
msgstr "@t{(} @var{exp} @t{)}"

#. type: table
#: zsh.texi:3722
msgid "true if @var{exp} is true."
msgstr "如果 @var{exp} 为 true，则为 true。"

#. type: item
#: zsh.texi:3723
#, no-wrap
msgid "@t{!} @var{exp}"
msgstr "@t{!} @var{exp}"

#. type: table
#: zsh.texi:3725
msgid "true if @var{exp} is false."
msgstr "如果 @var{exp} 为 false，则为 true。"

#. type: item
#: zsh.texi:3726
#, no-wrap
msgid "@var{exp1} @t{&&} @var{exp2}"
msgstr "@var{exp1} @t{&&} @var{exp2}"

#. type: table
#: zsh.texi:3728
msgid "true if @var{exp1} and @var{exp2} are both true."
msgstr "如果 @var{exp1} 和 @var{exp2} 均为 true，则为 true。"

#. type: item
#: zsh.texi:3729
#, no-wrap
msgid "@var{exp1} @t{||} @var{exp2}"
msgstr "@var{exp1} @t{||} @var{exp2}"

#. type: table
#: zsh.texi:3731
msgid "true if either @var{exp1} or @var{exp2} is true."
msgstr "如果 @var{exp1} 或 @var{exp2} 为 true，则为 true。"

#. type: Plain text
#: zsh.texi:3741
msgid ""
"For compatibility, if there is a single argument that is not syntactically significant, typically a variable, the condition is treated as a test for whether the expression expands as a string of non-zero "
"length.  In other words, @t{[[ $var ]]} is the same as @t{[[ -n $var ]]}.  It is recommended that the second, explicit, form be used where possible."
msgstr ""
"为兼容起见，如果有一个在语法上不重要的参数，通常是一个变量，那么该条件将被视为对表达式是否扩展为长度不为零的字符串的测试。 换句话说，@t{[[ $var ]]} 与 @t{[[ -n $var ]]} 相同。 建议尽可能使用第二种显式形"
"式。"

#. type: Plain text
#: zsh.texi:3746
msgid ""
"Normal shell expansion is performed on the @var{file}, @var{string} and @var{pattern} arguments, but the result of each expansion is constrained to be a single word, similar to the effect of double quotes."
msgstr "对 @var{file}、@var{string} 和 @var{pattern} 参数执行正常的 shell 扩展，但每次扩展的结果都限制为一个单词，类似于双引号的效果。"

#. type: Plain text
#: zsh.texi:3757
msgid ""
"Filename generation is not performed on any form of argument to conditions.  However, it can be forced in any case where normal shell expansion is valid and when the option @t{EXTENDED_GLOB} is in effect "
"by using an explicit glob qualifier of the form @t{(#q)} at the end of the string.  A normal glob qualifier expression may appear between the `@t{q}' and the closing parenthesis; if none appears the "
"expression has no effect beyond causing filename generation.  The results of filename generation are joined together to form a single word, as with the results of other forms of expansion."
msgstr ""
"文件名生成不会在任何形式的条件参数中执行。 不过，在正常 shell 扩展有效的情况下，以及在选项 @t{EXTENDED_GLOB} 有效的情况下，可以通过在字符串末尾使用 @t{(#q)} 形式的显式 glob 限定符来强制生成文件名。 在 "
"`@t{q}' 和结尾括号之间可能会出现一个普通的 glob 限定符表达式；如果没有出现，该表达式除了生成文件名外没有任何作用。 与其他形式的扩展结果一样，文件名生成的结果会连接在一起形成一个单词。"

#. type: Plain text
#: zsh.texi:3765
msgid ""
"This special use of filename generation is only available with the @t{[[} syntax.  If the condition occurs within the @t{[} or @t{test} builtin commands then globbing occurs instead as part of normal "
"command line expansion before the condition is evaluated.  In this case it may generate multiple words which are likely to confuse the syntax of the test command."
msgstr ""
"只有在使用 @t{[[} 语法时，才能使用这种特殊的文件名生成方式。 如果条件出现在 @t{[} 或 @t{test} 内置命令中，则在条件求值之前，会作为正常命令行扩展的一部分进行套选。 在这种情况下，可能会产生多个单词，从而混淆"
"测试命令的语法。"

#. type: example
#: zsh.texi:3772
#, no-wrap
msgid "[[ -n file*(#qN) ]]\n"
msgstr "[[ -n file*(#qN) ]]\n"

#. type: Plain text
#: zsh.texi:3779
msgid ""
"produces status zero if and only if there is at least one file in the current directory beginning with the string `@t{file}'.  The globbing qualifier @t{N} ensures that the expression is empty if there is "
"no matching file."
msgstr "如果当且仅当当前目录中至少有一个以字符串`@t{file}'开头的文件时，才会产生状态 0。 全局(globbing)限定符 @t{N} 确保在没有匹配文件的情况下表达式为空。"

#. type: Plain text
#: zsh.texi:3785
msgid ""
"Pattern metacharacters are active for the @var{pattern} arguments; the patterns are the same as those used for filename generation, see @ref{Filename Generation}, but there is no special behaviour of "
"`@t{/}' nor initial dots, and no glob qualifiers are allowed."
msgstr "模式元字符对 @var{pattern} 参数有效；模式与用于文件名生成的模式相同，请参阅 @ref{文件名生成}，但不使用 `@t{/}'或前导点（initial dots），也不允许使用 glob 限定符。"

#. type: Plain text
#: zsh.texi:3794
msgid ""
"In each of the above expressions, if @var{file} is of the form `@t{/dev/fd/}@var{n}', where @var{n} is an integer, then the test applied to the open file whose descriptor number is @var{n}, even if the "
"underlying system does not support the @t{/dev/fd} directory."
msgstr "在上述每个表达式中，如果 @var{file} 的形式为 `@t{/dev/fd/}@var{n}'，其中 @var{n} 为整数，那么即使底层系统不支持 @t{/dev/fd} 目录，测试也会应用于描述符编号为 @var{n} 的打开的文件。"

#. type: Plain text
#: zsh.texi:3799
msgid "In the forms which do numeric comparison, the expressions @var{exp} undergo arithmetic expansion as if they were enclosed in @t{$((}@var{...}@t{))}."
msgstr "在进行数字比较的表格中，表达式 @var{exp} 会进行算术扩展，就像它们被括入 @t{$((}@var{...}@t{))} 中一样。"

#. type: Plain text
#: zsh.texi:3802
msgid "For example, the following:"
msgstr "例如，以下内容："

#. type: example
#: zsh.texi:3806
#, no-wrap
msgid "[[ ( -f foo || -f bar ) && $report = y* ]] && print File exists.\n"
msgstr "[[ ( -f foo || -f bar ) && $report = y* ]] && print File exists.\n"

#. type: Plain text
#: zsh.texi:3814
msgid ""
"tests if either file @t{foo} or file @t{bar} exists, and if so, if the value of the parameter @t{report} begins with `@t{y}'; if the complete condition is true, the message `@t{File exists.}' is printed."
msgstr "测试文件 @t{foo} 或文件 @t{bar} 是否存在，如果存在，则测试参数 @t{report} 的值是否以`@t{y}'开头；如果整个条件为真，则打印信息`@t{File exists.}'。"

#. type: section
#: zsh.texi:3819
#, no-wrap
msgid "Expansion of Prompt Sequences"
msgstr "扩展提示符序列"

#. type: cindex
#: zsh.texi:3821
#, no-wrap
msgid "prompt expansion"
msgstr "提示符扩展"

#. type: cindex
#: zsh.texi:3822
#, no-wrap
msgid "expansion, prompt"
msgstr "扩展, 提示符"

#. type: Plain text
#: zsh.texi:3825
msgid "Prompt sequences undergo a special form of expansion.  This type of expansion is also available using the @t{-P} option to the @t{print} builtin."
msgstr "提示符序列会经过一种特殊形式的扩展。 使用 @t{print} 内置程序的 @t{-P} 选项也可以进行这种扩展。"

#. type: pindex
#: zsh.texi:3827
#, no-wrap
msgid "PROMPT_SUBST, use of"
msgstr "PROMPT_SUBST, use of"

#. type: Plain text
#: zsh.texi:3834
msgid "If the @t{PROMPT_SUBST} option is set, the prompt string is first subjected to @emph{parameter expansion}, @emph{command substitution} and @emph{arithmetic expansion}.  See @ref{Expansion}."
msgstr "如果设置了 @t{PROMPT_SUBST} 选项，提示符字符串将首先进行 @emph{参数扩展}、@emph{命令替换} 和 @emph{算术扩展}。 参见 @ref{扩展}。"

#. type: Plain text
#: zsh.texi:3837
msgid "Certain escape sequences may be recognised in the prompt string."
msgstr "提示符字符串中可以识别某些转义序列。"

#. type: pindex
#: zsh.texi:3839
#, no-wrap
msgid "PROMPT_BANG, use of"
msgstr "PROMPT_BANG, use of"

#. type: Plain text
#: zsh.texi:3843
msgid "If the @t{PROMPT_BANG} option is set, a `@t{!}' in the prompt is replaced by the current history event number.  A literal `@t{!}' may then be represented as `@t{!!}'."
msgstr "如果设置了 @t{PROMPT_BANG} 选项，提示符中的 `@t{!}' 将被当前历史事件编号取代。 字面的 `@t{!}' 可以表示为`@t{!!}'。"

#. type: pindex
#: zsh.texi:3845
#, no-wrap
msgid "PROMPT_PERCENT, use of"
msgstr "PROMPT_PERCENT, use of"

#. type: Plain text
#: zsh.texi:3853
msgid ""
"If the @t{PROMPT_PERCENT} option is set, certain escape sequences that start with `@t{%}' are expanded.  Many escapes are followed by a single character, although some of these take an optional integer "
"argument that should appear between the `@t{%}' and the next character of the sequence.  More complicated escape sequences are available to provide conditional expansion."
msgstr ""
"如果设置了 @t{PROMPT_PERCENT} 选项，某些以`@t{%}'开头的转义序列将被扩展。 许多转义字符后面只有一个字符，但其中一些转义字符还包含一个可选的整数参数，该参数应出现在 `@t{%}'和序列的下一个字符之间。 还有更复杂"
"的转义序列可用于提供条件扩展。"

#. type: section
#: zsh.texi:3856
#, no-wrap
msgid "Simple Prompt Escapes"
msgstr "简单的提示符转义"

#. type: subsection
#: zsh.texi:3861
#, no-wrap
msgid "Special characters"
msgstr "特殊字符"

#. type: table
#: zsh.texi:3866 zsh.texi:9490
msgid "A `@t{%}'."
msgstr "一个 `@t{%}'."

#. type: t{#1}
#: zsh.texi:3867
#, no-wrap
msgid "%)"
msgstr "%)"

#. type: table
#: zsh.texi:3869
msgid "A `@t{)}'."
msgstr "一个 `@t{)}'."

#. type: subsection
#: zsh.texi:3874
#, no-wrap
msgid "Login information"
msgstr "登录信息"

#. type: t{#1}
#: zsh.texi:3877 zsh.texi:31191 zsh.texi:39738
#, no-wrap
msgid "%l"
msgstr "%l"

#. type: table
#: zsh.texi:3880
msgid "The line (tty) the user is logged in on, without `@t{/dev/}' prefix.  If the name starts with `@t{/dev/tty}', that prefix is stripped."
msgstr "用户登录的线路（tty），不含前缀 `@t{/dev/}'。 如果名称以 `@t{/dev/tty}' 开头，则去掉前缀。"

#. type: t{#1}
#: zsh.texi:3881 zsh.texi:9508 zsh.texi:31194
#, no-wrap
msgid "%M"
msgstr "%M"

#. type: table
#: zsh.texi:3883
msgid "The full machine hostname."
msgstr "完整的计算机主机名。"

#. type: t{#1}
#: zsh.texi:3884 zsh.texi:31197 zsh.texi:37086
#, no-wrap
msgid "%m"
msgstr "%m"

#. type: table
#: zsh.texi:3889
msgid ""
"The hostname up to the first `@t{.}'.  An integer may follow the `@t{%}' to specify how many components of the hostname are desired.  With a negative integer, trailing components of the hostname are shown."
msgstr "直至第一个`@t{.}' 的主机名。 在`@t{%}' 后面可以加上一个整数，以指定需要主机名的多少个分量。 如果是负整数，则显示主机名的尾部。"

#. type: t{#1}
#: zsh.texi:3890 zsh.texi:31185 zsh.texi:37153 zsh.texi:39744
#, no-wrap
msgid "%n"
msgstr "%n"

#. type: table
#: zsh.texi:3892
msgid "@t{$USERNAME}."
msgstr "@t{$USERNAME}."

#. type: t{#1}
#: zsh.texi:3893
#, no-wrap
msgid "%y"
msgstr "%y"

#. type: table
#: zsh.texi:3896
msgid "The line (tty) the user is logged in on, without `@t{/dev/}' prefix.  This does not treat `@t{/dev/tty}' names specially."
msgstr "用户登录的线路（tty），不含前缀 `@t{/dev/}' 。 这不会特别处理 `@t{/dev/tty}' 名称。"

#. type: subsection
#: zsh.texi:3901
#, no-wrap
msgid "Shell state"
msgstr "shell 状态"

#. type: t{#1}
#: zsh.texi:3904
#, no-wrap
msgid "%#"
msgstr "%#"

#. type: table
#: zsh.texi:3911
msgid ""
"A `@t{#}' if the shell is running with privileges, a `@t{%}' if not.  Equivalent to `@t{%(!.#.%%)}'.  The definition of `privileged', for these purposes, is that either the effective user ID is zero, or, "
"if POSIX.1e capabilities are supported, that at least one capability is raised in either the Effective or Inheritable capability vectors."
msgstr ""
"如果 shell 以特权运行，则为 `@t{#}'；如果不是，则为 `@t{%}'。 等同于 `@t{%(!.#.%%)}'。 就这些目的而言，`特权' 的定义是有效用户 ID 为零，或者，如果如果支持 POSIX.1e 功能（capabilities），则在有效功能向量或"
"可继承功能向量（capability vectors）中至少有一种功能被提出。"

#. type: t{#1}
#: zsh.texi:3912
#, no-wrap
msgid "%?"
msgstr "%?"

#. type: table
#: zsh.texi:3914
msgid "The return status of the last command executed just before the prompt."
msgstr "提示符前执行的最后一条命令的返回状态。"

#. type: t{#1}
#: zsh.texi:3915
#, no-wrap
msgid "%_"
msgstr "%_"

#. type: table
#: zsh.texi:3922
msgid ""
"The status of the parser, i.e. the shell constructs (like `@t{if}' and `@t{for}') that have been started on the command line. If given an integer number that many strings will be printed; zero or negative "
"or no integer means print as many as there are.  This is most useful in prompts @t{PS2} for continuation lines and @t{PS4} for debugging with the @t{XTRACE} option; in the latter case it will also work "
"non-interactively."
msgstr ""
"解析器的状态，即已在命令行启动的 shell 结构（如`@t{if}'和 `@t{for}' ）。如果给定的是整数，那么打印的字符串数就是这个数；如果是零、负数或无整数，那么打印所有的字符串。 这在 @t{PS2} 续行提示符和 使用 "
"@t{XTRACE} 选项调试的@t{PS4} 提示符中最有用；在后一种情况下，它也可以非交互式地工作。"

#. type: t{#1}
#: zsh.texi:3923
#, no-wrap
msgid "%^"
msgstr "%^"

#. type: table
#: zsh.texi:3926
msgid "The status of the parser in reverse. This is the same as `@t{%_}' other than the order of strings.  It is often used in @t{RPS2}."
msgstr "解析器的状态（反向）。除了字符串的顺序外，它与 `@t{%_}'相同。 它常用于 @t{RPS2}。"

#. type: t{#1}
#: zsh.texi:3927
#, no-wrap
msgid "%d"
msgstr "%d"

#. type: t{#1}
#: zsh.texi:3928
#, no-wrap
msgid "%/"
msgstr "%/"

#. type: table
#: zsh.texi:3933
msgid ""
"Current working directory.  If an integer follows the `@t{%}', it specifies a number of trailing components of the current working directory to show; zero means the whole path.  A negative integer "
"specifies leading components, i.e. @t{%-1d} specifies the first component."
msgstr "当前工作目录。 如果在 `@t{%}'后面加上一个整数，则表示要显示的当前工作目录的尾部组件数；0 表示整个路径。 负整数表示前导部分，即 @t{%-1d} 表示第一个部分。"

#. type: t{#1}
#: zsh.texi:3934
#, no-wrap
msgid "%~"
msgstr "%~"

#. type: table
#: zsh.texi:3941
msgid ""
"As @t{%d} and @t{%/}, but if the current working directory starts with @t{$HOME}, that part is replaced by a `@t{~}'. Furthermore, if it has a named directory as its prefix, that part is replaced by a "
"`@t{~}' followed by the name of the directory, but only if the result is shorter than the full path; @ref{Filename Expansion}."
msgstr ""
"与 @t{%d} 和 @t{%/} 相同，但如果当前工作目录以 @t{$HOME} 开头，则该部分会被`@t{~}'替换。此外，如果它的前缀是一个已命名的目录，那么这部分内容会被`@t{~}'紧跟目录名的形式所取代，但前提是结果比完整路径短；"
"@ref{文件名扩展}。"

#. type: t{#1}
#: zsh.texi:3942
#, no-wrap
msgid "%e"
msgstr "%e"

#. type: table
#: zsh.texi:3947
msgid ""
"Evaluation depth of the current sourced file, shell function, or @t{eval}.  This is incremented or decremented every time the value of @t{%N} is set or reverted to a previous value, respectively.  This is "
"most useful for debugging as part of @t{$PS4}."
msgstr "当前引入的（sourced）文件、shell 函数或 @t{eval} 的求值深度。 每次 @t{%N} 的值被设置或恢复到之前的值时，该值都会递增或递减。 作为 @t{$PS4} 的一部分，它在调试时最为有用。"

#. type: t{#1}
#: zsh.texi:3948 zsh.texi:37140
#, no-wrap
msgid "%h"
msgstr "%h"

#. type: t{#1}
#: zsh.texi:3949
#, no-wrap
msgid "%!"
msgstr "%!"

#. type: table
#: zsh.texi:3951
msgid "Current history event number."
msgstr "当前历史事件编号。"

#. type: t{#1}
#: zsh.texi:3952 zsh.texi:37067
#, no-wrap
msgid "%i"
msgstr "%i"

#. type: table
#: zsh.texi:3956
msgid "The line number currently being executed in the script, sourced file, or shell function given by @t{%N}.  This is most useful for debugging as part of @t{$PS4}."
msgstr "@t{%N} 给出的脚本、引入的（sourced）文件或 shell 函数中当前正在执行的行号。 作为 @t{$PS4} 的一部分，它对调试最有用。"

#. type: t{#1}
#: zsh.texi:3957 zsh.texi:9516
#, no-wrap
msgid "%I"
msgstr "%I"

#. type: table
#: zsh.texi:3961
msgid ""
"The line number currently being executed in the file @t{%x}.  This is similar to @t{%i}, but the line number is always a line number in the file where the code was defined, even if the code is a shell "
"function."
msgstr "文件 @t{%x} 中当前正在执行的行号。 这与 @t{%i} 类似，但行号始终是定义代码的文件中的行号，即使代码是 shell 函数。"

#. type: t{#1}
#: zsh.texi:3962
#, no-wrap
msgid "%j"
msgstr "%j"

#. type: table
#: zsh.texi:3964
msgid "The number of jobs."
msgstr "作业数量。"

#. type: t{#1}
#: zsh.texi:3965 zsh.texi:4028
#, no-wrap
msgid "%L"
msgstr "%L"

#. type: table
#: zsh.texi:3967
msgid "The current value of @t{$SHLVL}."
msgstr "@t{$SHLVL} 的当前值。"

#. type: t{#1}
#: zsh.texi:3968
#, no-wrap
msgid "%N"
msgstr "%N"

#. type: table
#: zsh.texi:3974
msgid ""
"The name of the script, sourced file, or shell function that zsh is currently executing, whichever was started most recently.  If there is none, this is equivalent to the parameter @t{$0}.  An integer may "
"follow the `@t{%}' to specify a number of trailing path components to show; zero means the full path.  A negative integer specifies leading components."
msgstr ""
"zsh 当前执行的脚本、引入的（sourced）文件或 shell 函数的名称，以最近启动者为准。 如果没有，则等同于参数 @t{$0}。 `@t{%}' 后面可以跟一个整数，用于指定要显示的尾部路径成分的数量；0 表示完整路径。 负整数表示"
"前导成分。"

#. type: t{#1}
#: zsh.texi:3975
#, no-wrap
msgid "%x"
msgstr "%x"

#. type: table
#: zsh.texi:3979
msgid "The name of the file containing the source code currently being executed.  This behaves as @t{%N} except that function and eval command names are not shown, instead the file where they were defined."
msgstr "包含当前正在执行的源代码的文件名。 与 @t{%N} 相同，但不显示函数名和计算（eval）命令名，而是显示定义这些函数和命令的文件名。"

#. type: t{#1}
#: zsh.texi:3980 zsh.texi:7285 zsh.texi:9528 zsh.texi:34375 zsh.texi:37070 zsh.texi:37155 zsh.texi:39734
#, no-wrap
msgid "%c"
msgstr "%c"

#. type: t{#1}
#: zsh.texi:3981
#, no-wrap
msgid "%."
msgstr "%."

#. type: t{#1}
#: zsh.texi:3982
#, no-wrap
msgid "%C"
msgstr "%C"

#. type: table
#: zsh.texi:3989
msgid ""
"Trailing component of the current working directory.  An integer may follow the `@t{%}' to get more than one component.  Unless `@t{%C}' is used, tilde contraction is performed first.  These are "
"deprecated as @t{%c} and @t{%C} are equivalent to @t{%1~} and @t{%1/}, respectively, while explicit positive integers have the same effect as for the latter two sequences."
msgstr ""
"当前工作目录的尾部分量。 `@t{%}'后面可以跟一个整数，以获取多个分量。 除非使用了`@t{%C}' ，否则会先执行转折号收缩。 由于 @t{%c} 和 @t{%C} 分别等同于 @t{%1~} 和 @t{%1/}，而显式正整数与后两个序列的效果相同，"
"因此已被弃用。"

#. type: subsection
#: zsh.texi:3994
#, no-wrap
msgid "Date and time"
msgstr "日期和时间"

#. type: t{#1}
#: zsh.texi:3997 zsh.texi:9503 zsh.texi:31236
#, no-wrap
msgid "%D"
msgstr "%D"

#. type: table
#: zsh.texi:3999
msgid "The date in @var{yy}@t{-}@var{mm}@t{-}@var{dd} format."
msgstr "日期，格式为 @var{yy}@t{-}@var{mm}@t{-}@var{dd}"

#. type: t{#1}
#: zsh.texi:4000 zsh.texi:31227
#, no-wrap
msgid "%T"
msgstr "%T"

#. type: table
#: zsh.texi:4002
msgid "Current time of day, in 24-hour format."
msgstr "当前时间（24 小时制）。"

#. type: t{#1}
#: zsh.texi:4003 zsh.texi:31223
#, no-wrap
msgid "%t"
msgstr "%t"

#. type: t{#1}
#: zsh.texi:4004 zsh.texi:31224
#, no-wrap
msgid "%@@"
msgstr "%@@"

#. type: table
#: zsh.texi:4006
msgid "Current time of day, in 12-hour, am/pm format."
msgstr "当前时间（12 小时制，上午/下午格式）。"

#. type: t{#1}
#: zsh.texi:4007
#, no-wrap
msgid "%*"
msgstr "%*"

#. type: table
#: zsh.texi:4009
msgid "Current time of day in 24-hour format, with seconds."
msgstr "当前时间（24 小时制，含秒）。"

#. type: t{#1}
#: zsh.texi:4010 zsh.texi:9526 zsh.texi:31230
#, no-wrap
msgid "%w"
msgstr "%w"

#. type: table
#: zsh.texi:4012
msgid "The date in @var{day}@t{-}@var{dd} format."
msgstr "日期，格式为 @var{day}@t{-}@var{dd}。"

#. type: t{#1}
#: zsh.texi:4013 zsh.texi:9499 zsh.texi:31233
#, no-wrap
msgid "%W"
msgstr "%W"

#. type: table
#: zsh.texi:4015
msgid "The date in @var{mm}@t{/}@var{dd}@t{/}@var{yy} format."
msgstr "日期，格式为 @var{mm}@t{/}@var{dd}@t{/}@var{yy}。"

#. type: item
#: zsh.texi:4016 zsh.texi:31239
#, no-wrap
msgid "@t{%D@{}@var{string}@t{@}}"
msgstr "@t{%D@{}@var{string}@t{@}}"

#. type: table
#: zsh.texi:4021
msgid "@var{string} is formatted using the @t{strftime} function.  See strftime(3) for more details.  Various zsh extensions provide numbers with no leading zero or space if the number is a single digit:"
msgstr "@var{string} 使用 @t{strftime} 函数格式化。 详情请参阅 strftime(3)。 如果数字是个位数，各种 zsh 扩展会提供不带前导零或空格的数字："

#. type: t{#1}
#: zsh.texi:4024 zsh.texi:34380
#, no-wrap
msgid "%f"
msgstr "%f"

#. type: table
#: zsh.texi:4026
msgid "a day of the month"
msgstr "月中的一日"

#. type: t{#1}
#: zsh.texi:4026 zsh.texi:9506
#, no-wrap
msgid "%K"
msgstr "%K"

#. type: table
#: zsh.texi:4028
msgid "the hour of the day on the 24-hour clock"
msgstr "24小时制中的小时"

#. type: table
#: zsh.texi:4030
msgid "the hour of the day on the 12-hour clock"
msgstr "12小时制中的小时"

#. type: table
#: zsh.texi:4041
msgid ""
"In addition, if the system supports the POSIX @t{gettimeofday} system call, @t{%.} provides decimal fractions of a second since the epoch with leading zeroes.  By default three decimal places are "
"provided, but a number of digits up to 9 may be given following the @t{%}; hence @t{%6.} outputs microseconds, and @t{%9.} outputs nanoseconds.  (The latter requires a nanosecond-precision "
"@t{clock_gettime}; systems lacking this will return a value multiplied by the appropriate power of 10.)  A typical example of this is the format `@t{%D@{%H:%M:%S.%.@}}'."
msgstr ""
"此外，如果系统支持 POSIX 的@t{gettimeofday} 系统调用，@t{%.} 将提供自纪元（epoch）起的秒数（带前导零的小数）。 默认情况下提供三位小数，但也可以在 @t{%} 后面提供不超过 9 位的数字；因此 @t{%6.} 输出微秒，而 "
"@t{%9.} 输出纳秒。 (后者需要纳秒精度的 @t{clock_gettime}；缺少@t{clock_gettime}的系统将返回一个乘以相应 10的 次方的值）。 一个典型的例子是格式`@t{%D@{%H:%M:%S.%.@}}'。"

#. type: table
#: zsh.texi:4044
msgid "The GNU extension @t{%N} is handled as a synonym for @t{%9.}."
msgstr "GNU 扩展名 @t{%N} 作为 @t{%9.} 的同义词处理。"

#. type: table
#: zsh.texi:4054
msgid ""
"Additionally, the GNU extension that a `@t{-}' between the @t{%} and the format character causes a leading zero or space to be stripped is handled directly by the shell for the format characters @t{d}, "
"@t{f}, @t{H}, @t{k}, @t{l}, @t{m}, @t{M}, @t{S} and @t{y}; any other format characters are provided to the system's strftime(3)  with any leading `@t{-}' present, so the handling is system dependent.  "
"Further GNU (or other) extensions are also passed to strftime(3)  and may work if the system supports them."
msgstr ""
"此外，对于 @t{d}, @t{f}, @t{H}, @t{k}, @t{l}, @t{m}, @t{M}, @t{S} and @t{y}格式字符，GNU 扩展（ @t{%}  和 格式字符之间有一个 `@t{-}'  ）会导致前导零或空格被删除，这会直接由shell处理； 任何其他格式字符都将"
"提供给系统的 strftime(3)，并带有前导`@t{-}'，因此处理方法取决于系统。 其他 GNU（或其他）扩展字符也会传递给 strftime(3)，如果系统支持这些扩展字符，它们也可以正常工作。"

#. type: subsection
#: zsh.texi:4059
#, no-wrap
msgid "Visual effects"
msgstr "视觉效果"

#. type: item
#: zsh.texi:4062 zsh.texi:31220
#, no-wrap
msgid "@t{%B} (@t{%b})"
msgstr "@t{%B} (@t{%b})"

#. type: table
#: zsh.texi:4064 zsh.texi:31222
msgid "Start (stop) boldface mode."
msgstr "启动（停止）粗体模式。"

#. type: t{#1}
#: zsh.texi:4065 zsh.texi:9494
#, no-wrap
msgid "%E"
msgstr "%E"

#. type: table
#: zsh.texi:4067
msgid "Clear to end of line."
msgstr "清除到行尾。"

#. type: item
#: zsh.texi:4068 zsh.texi:31217
#, no-wrap
msgid "@t{%U} (@t{%u})"
msgstr "@t{%U} (@t{%u})"

#. type: table
#: zsh.texi:4070 zsh.texi:31219
msgid "Start (stop) underline mode."
msgstr "启动（停止）下划线模式。"

#. type: item
#: zsh.texi:4071 zsh.texi:31214
#, no-wrap
msgid "@t{%S} (@t{%s})"
msgstr "@t{%S} (@t{%s})"

#. type: table
#: zsh.texi:4073 zsh.texi:31216
msgid "Start (stop) standout mode."
msgstr "启动（停止）突出模式。"

#. type: item
#: zsh.texi:4074
#, no-wrap
msgid "@t{%F} (@t{%f})"
msgstr "@t{%F} (@t{%f})"

#. type: table
#: zsh.texi:4083
msgid ""
"Start (stop) using a different foreground colour, if supported by the terminal.  The colour may be specified two ways: either as a numeric argument, as normal, or by a sequence in braces following the "
"@t{%F}, for example @t{%F@{red@}}.  In the latter case the values allowed are as described for the @t{fg} @t{zle_highlight} attribute; @ref{Character Highlighting}.  This means that numeric colours are "
"allowed in the second format also."
msgstr ""
"开始（停止）使用不同的前景色（如果终端支持）。 颜色有两种指定方式：一种是以数字参数的形式指定，如正常情况；另一种是在 @t{%F} 后用大括号指定，如 @t{%F@{red@}}。 在后一种情况下，所允许的值与 @t{fg} "
"@t{zle_highlight} 属性所描述的一样；@ref{字符高亮}。 这意味着第二种格式也允许使用数字颜色。"

#. type: item
#: zsh.texi:4084
#, no-wrap
msgid "@t{%K} (@t{%k})"
msgstr "@t{%K} (@t{%k})"

#. type: table
#: zsh.texi:4087
msgid "Start (stop) using a different bacKground colour.  The syntax is identical to that for @t{%F} and @t{%f}."
msgstr "开始（停止）使用不同的背景颜色。 语法与 @t{%F} 和 @t{%f} 相同。"

#. type: item
#: zsh.texi:4088
#, no-wrap
msgid "@t{%@{}...@t{%@}}"
msgstr "@t{%@{}...@t{%@}}"

#. type: table
#: zsh.texi:4092
msgid "Include a string as a literal escape sequence.  The string within the braces should not change the cursor position.  Brace pairs can nest."
msgstr "包含一个字符串作为字面转义序列。 括号内的字符串不应改变光标位置。 括号对可以嵌套。"

#. type: table
#: zsh.texi:4096
msgid "A positive numeric argument between the @t{%} and the @t{@{} is treated as described for @t{%G} below."
msgstr "在 @t{%} 和 @t{@{} 之间的正数参数的处理方法与下面的 @t{%G} 相同。"

#. type: t{#1}
#: zsh.texi:4097 zsh.texi:37161
#, no-wrap
msgid "%G"
msgstr "%G"

#. type: table
#: zsh.texi:4108
msgid ""
"Within a @t{%@{}...@t{%@}} sequence, include a `glitch': that is, assume that a single character width will be output.  This is useful when outputting characters that otherwise cannot be correctly handled "
"by the shell, such as the alternate character set on some terminals.  The characters in question can be included within a @t{%@{}...@t{%@}} sequence together with the appropriate number of @t{%G} "
"sequences to indicate the correct width.  An integer between the `@t{%}' and `@t{G}' indicates a character width other than one.  Hence @t{%@{}@var{seq}@t{%2G%@}} outputs @var{seq} and assumes it takes up "
"the width of two standard characters."
msgstr ""
"在@t{%@{}...@t{%@}}序列中，包含一个 `间隙'：即假定只输出一个字符宽度。 这在输出 shell 无法正确处理的字符时非常有用，例如某些终端上的备用字符集。 有关字符可以包含在 @t{%@{}...@t{%@}}  序列中，并与适当数量"
"的 @t{%G} 序列一起表示正确的宽度。 `@t{%}'和`@t{G}' 之间的整数表示 1以外的字符宽度。 因此 @t{%@{}@var{seq}@t{%2G%@}} 输出 @var{seq} 并假定它占两个标准字符的宽度。"

#. type: table
#: zsh.texi:4112
msgid "Multiple uses of @t{%G} accumulate in the obvious fashion; the position of the @t{%G} is unimportant.  Negative integers are not handled."
msgstr "@t{%G} 的多次使用会以显而易见的方式累加；@t{%G} 的位置并不重要。 负整数不作处理。"

#. type: table
#: zsh.texi:4117
msgid "Note that when prompt truncation is in use it is advisable to divide up output into single characters within each @t{%@{}...@t{%@}} group so that the correct truncation point can be found."
msgstr "请注意，在使用提示符截断功能时，最好将每个 @t{%@{}...@t{%@}} 组内的输出划分为单个字符，以便找到正确的截断点。"

#. type: section
#: zsh.texi:4122
#, no-wrap
msgid "Conditional Substrings in Prompts"
msgstr "提示符中的条件子字符串"

#. type: t{#1}
#: zsh.texi:4125
#, no-wrap
msgid "%v"
msgstr "%v"

#. type: vindex
#: zsh.texi:4126
#, no-wrap
msgid "psvar, use of"
msgstr "psvar, use of"

#. type: table
#: zsh.texi:4130
msgid "The value of the first element of the @t{psvar} array parameter.  Following the `@t{%}' with an integer gives that element of the array.  Negative integers count from the end of the array."
msgstr "@t{psvar} 数组参数第一个元素的值。 在`@t{%}'后跟一个整数，表示数组中的该元素。 负整数从数组末尾开始计数。"

#. type: item
#: zsh.texi:4131
#, no-wrap
msgid "@t{%(}@var{x}@t{.}@var{true-text}@t{.}@var{false-text}@t{)}"
msgstr "@t{%(}@var{x}@t{.}@var{true-text}@t{.}@var{false-text}@t{)}"

#. type: table
#: zsh.texi:4141
msgid ""
"Specifies a ternary expression.  The character following the @var{x} is arbitrary; the same character is used to separate the text for the `true' result from that for the `false' result.  This separator "
"may not appear in the @var{true-text}, except as part of a %-escape sequence.  A `@t{)}' may appear in the @var{false-text} as `@t{%)}'.  @var{true-text} and @var{false-text} may both contain arbitrarily-"
"nested escape sequences, including further ternary expressions."
msgstr ""
"指定一个三元表达式。 @var{x} 后面的字符是任意的；`true' 结果和`false'结果的文本是用同一个字符分隔的。 除了作为 %-escape 序列的一部分，该分隔符不得出现在 @var{true-text} 中。 `@t{)}'可以以`@t{%)}'的形式出现"
"在 @var{false-text} 中。 @var{true-text} 和 @var{false-text} 都可以包含任意嵌套的转义序列，包括进一步的三元表达式。"

#. type: table
#: zsh.texi:4147
msgid ""
"The left parenthesis may be preceded or followed by a positive integer @var{n}, which defaults to zero.  A negative integer will be multiplied by -1, except as noted below for `@t{l}'.  The test character "
"@var{x} may be any of the following:"
msgstr "左括号前后可以是正整数 @var{n}，默认值为 0。 负整数将乘以-1，下文中的 `@t{l}'除外。 测试字符 @var{x} 可以是以下任何一种字符："

#. type: t{#1}
#: zsh.texi:4150 zsh.texi:4429 zsh.texi:8490 zsh.texi:38774
#, no-wrap
msgid "!"
msgstr "!"

#. type: table
#: zsh.texi:4152
msgid "True if the shell is running with privileges."
msgstr "如果 shell 以特权运行，则为 True。"

#. type: vindex
#: zsh.texi:4152 zsh.texi:5368 zsh.texi:8495
#, no-wrap
msgid "#"
msgstr "#"

#. type: table
#: zsh.texi:4154
msgid "True if the effective uid of the current process is @var{n}."
msgstr "如果当前进程的有效 uid 为 @var{n}，则为 True。"

#. type: t{#1}
#: zsh.texi:4154 zsh.texi:6624 zsh.texi:8536 zsh.texi:38780
#, no-wrap
msgid "?"
msgstr "?"

#. type: table
#: zsh.texi:4156
msgid "True if the exit status of the last command was @var{n}."
msgstr "如果最后一条命令的退出状态为 @var{n}，则为 True。"

#. type: t{#1}
#: zsh.texi:4156 zsh.texi:8557 zsh.texi:38794
#, no-wrap
msgid "_"
msgstr "_"

#. type: table
#: zsh.texi:4158
msgid "True if at least @var{n} shell constructs were started."
msgstr "如果至少 @var{n} 个 shell 结构体已启动，则为 True。"

#. type: t{#1}
#: zsh.texi:4158 zsh.texi:5456
#, no-wrap
msgid "C"
msgstr "C"

#. type: t{#1}
#: zsh.texi:4159 zsh.texi:7255 zsh.texi:38796
#, no-wrap
msgid "/"
msgstr "/"

#. type: table
#: zsh.texi:4162
msgid "True if the current absolute path has at least @var{n} elements relative to the root directory, hence @t{/} is counted as 0 elements."
msgstr "如果当前绝对路径至少有 @var{n} 个相对于根目录的元素，则为 true，因此 @t{/} 将被视为 0 个元素。"

#. type: t{#1}
#: zsh.texi:4162 zsh.texi:4548 zsh.texi:5450 zsh.texi:7543 zsh.texi:38792
#, no-wrap
msgid "c"
msgstr "c"

#. type: t{#1}
#: zsh.texi:4163 zsh.texi:7264 zsh.texi:12761 zsh.texi:38787
#, no-wrap
msgid "."
msgstr "."

#. type: t{#1}
#: zsh.texi:4164 zsh.texi:5726
#, no-wrap
msgid "~"
msgstr "~"

#. type: table
#: zsh.texi:4168
msgid "True if the current path, with prefix replacement, has at least @var{n} elements relative to the root directory, hence @t{/} is counted as 0 elements."
msgstr "如果当前路径在替换前缀后至少有 @var{n} 个相对于根目录的元素，则为 true，因此 @t{/} 将被视为 0 个元素。"

#. type: t{#1}
#: zsh.texi:4168 zsh.texi:5461 zsh.texi:7511 zsh.texi:31685
#, no-wrap
msgid "D"
msgstr "D"

#. type: table
#: zsh.texi:4170
msgid "True if the month is equal to @var{n} (January = 0)."
msgstr "如果月份等于 @var{n}，则为 true（1 月 = 0）。"

#. type: t{#1}
#: zsh.texi:4170 zsh.texi:7545
#, no-wrap
msgid "d"
msgstr "d"

#. type: table
#: zsh.texi:4172
msgid "True if the day of the month is equal to @var{n}."
msgstr "如果月份的日期等于 @var{n}，则为 True。"

#. type: t{#1}
#: zsh.texi:4172 zsh.texi:4555 zsh.texi:5469 zsh.texi:8245
#, no-wrap
msgid "e"
msgstr "e"

#. type: table
#: zsh.texi:4174
msgid "True if the evaluation depth is at least @var{n}."
msgstr "如果计算（evaluation）深度至少为 @var{n}，则为 True。"

#. type: t{#1}
#: zsh.texi:4174 zsh.texi:36301
#, no-wrap
msgid "g"
msgstr "g"

#. type: table
#: zsh.texi:4176
msgid "True if the effective gid of the current process is @var{n}."
msgstr "如果当前进程的有效 gid 为 @var{n}，则为 True。"

#. type: t{#1}
#: zsh.texi:4176
#, no-wrap
msgid "j"
msgstr "j"

#. type: table
#: zsh.texi:4178
msgid "True if the number of jobs is at least @var{n}."
msgstr "如果作业数量至少为 @var{n}，则为 True。"

#. type: t{#1}
#: zsh.texi:4178 zsh.texi:5503 zsh.texi:7535 zsh.texi:30890
#, no-wrap
msgid "L"
msgstr "L"

#. type: table
#: zsh.texi:4180
msgid "True if the @t{SHLVL} parameter is at least @var{n}."
msgstr "如果 @t{SHLVL} 参数至少为 @var{n}，则为 True。"

#. type: t{#1}
#: zsh.texi:4180 zsh.texi:4579 zsh.texi:6875 zsh.texi:7537
#, no-wrap
msgid "l"
msgstr "l"

#. type: table
#: zsh.texi:4185
msgid ""
"True if at least @var{n} characters have already been printed on the current line.  When @var{n} is negative, true if at least @t{abs}@t{(}@var{n}@t{)} characters remain before the opposite margin (thus "
"the left margin for @t{RPROMPT})."
msgstr "如果当前行至少已打印 @var{n} 个字符，则为 true。 当 @var{n} 为负数时，如果至少 @t{abs}@t{(}@var{n}@t{)} 字符仍在对边距之前（即 @t{RPROMPT} 的左边距），则为 true。"

#. type: t{#1}
#: zsh.texi:4185 zsh.texi:5881 zsh.texi:7318 zsh.texi:31680
#, no-wrap
msgid "S"
msgstr "S"

#. type: table
#: zsh.texi:4187
msgid "True if the @t{SECONDS} parameter is at least @var{n}."
msgstr "如果 @t{SECONDS} 参数至少为 @var{n}，则为 True。"

#. type: t{#1}
#: zsh.texi:4187 zsh.texi:7503
#, no-wrap
msgid "T"
msgstr "T"

#. type: table
#: zsh.texi:4189
msgid "True if the time in hours is equal to @var{n}."
msgstr "如果时间（小时）等于 @var{n}，则为 True。"

#. type: t{#1}
#: zsh.texi:4189 zsh.texi:5587 zsh.texi:7321
#, no-wrap
msgid "t"
msgstr "t"

#. type: table
#: zsh.texi:4191
msgid "True if the time in minutes is equal to @var{n}."
msgstr "如果时间（分钟）等于 @var{n}，则为 True。"

#. type: t{#1}
#: zsh.texi:4191 zsh.texi:5651
#, no-wrap
msgid "v"
msgstr "v"

#. type: table
#: zsh.texi:4193
msgid "True if the array @t{psvar} has at least @var{n} elements."
msgstr "如果数组 @t{psvar} 至少有 @var{n} 个元素，则为 True。"

#. type: t{#1}
#: zsh.texi:4193 zsh.texi:5657
#, no-wrap
msgid "V"
msgstr "V"

#. type: table
#: zsh.texi:4196
msgid "True if element @var{n} of the array @t{psvar} is set and non-empty."
msgstr "如果数组 @t{psvar} 中的元素 @var{n} 已设置且非空，则为 True。"

#. type: t{#1}
#: zsh.texi:4196 zsh.texi:4744 zsh.texi:5660 zsh.texi:7291 zsh.texi:8125
#, no-wrap
msgid "w"
msgstr "w"

#. type: table
#: zsh.texi:4198
msgid "True if the day of the week is equal to @var{n} (Sunday = 0)."
msgstr "如果星期几等于 @var{n}（星期日 = 0），则为 True。"

#. type: item
#: zsh.texi:4200
#, no-wrap
msgid "@t{%<}@var{string}@t{<}"
msgstr "@t{%<}@var{string}@t{<}"

#. type: itemx
#: zsh.texi:4201
#, no-wrap
msgid "@t{%>}@var{string}@t{>}"
msgstr "@t{%>}@var{string}@t{>}"

#. type: itemx
#: zsh.texi:4202
#, no-wrap
msgid "@t{%[}@var{xstring}@t{]}"
msgstr "@t{%[}@var{xstring}@t{]}"

#. type: table
#: zsh.texi:4209
msgid ""
"Specifies truncation behaviour for the remainder of the prompt string.  The third, deprecated, form is equivalent to `@t{%}@var{xstringx}', i.e. @var{x} may be `@t{<}' or `@t{>}'.  The @var{string} will "
"be displayed in place of the truncated portion of any string; note this does not undergo prompt expansion."
msgstr ""
"指定提示符字符串剩余部分的截断行为。 第三种形式已被淘汰，相当于`@t{%}@var{xstringx}'，即 @var{x} 可以是 `@t{<}' 或 `@t{>}'。 @var{string} 将代替任何字符串的截断部分显示出来；请注意，这不会进行提示符扩展。"

#. type: table
#: zsh.texi:4221
msgid ""
"The numeric argument, which in the third form may appear immediately after the `@t{[}', specifies the maximum permitted length of the various strings that can be displayed in the prompt.  In the first two "
"forms, this numeric argument may be negative, in which case the truncation length is determined by subtracting the absolute value of the numeric argument from the number of character positions remaining "
"on the current prompt line.  If this results in a zero or negative length, a length of 1 is used.  In other words, a negative argument arranges that after truncation at least @var{n} characters remain "
"before the right margin (left margin for @t{RPROMPT})."
msgstr ""
"在第三种形式中，数字参数可能紧接在 `@t{[}'之后，用于指定提示符中可显示的各种字符串的最大允许长度。 在前两种形式中，数字参数可以是负数，在这种情况下，截断长度是由当前提示符行剩余字符数减去数字参数的绝对值确"
"定的。 如果结果为零或负数，则使用长度 1。 换句话说，如果参数为负数，则在截断后，右边距（@t{RPROMPT}的左边距）前至少要保留 @var{n} 个字符。"

#. type: table
#: zsh.texi:4233
msgid ""
"The forms with `@t{<}' truncate at the left of the string, and the forms with `@t{>}' truncate at the right of the string.  For example, if the current directory is `@t{/home/pike}', the prompt `@t{%8<.."
"<%/}' will expand to `@t{..e/pike}'.  In this string, the terminating character (`@t{<}', `@t{>}' or `@t{]}'), or in fact any character, may be quoted by a preceding `@t{\\}'; note when using @t{print -"
"P}, however, that this must be doubled as the string is also subject to standard @t{print} processing, in addition to any backslashes removed by a double quoted string: the worst case is therefore "
"`@t{print -P \"%<\\\\\\\\<<...\"}'."
msgstr ""
"带 `@t{<}' 的形式在字符串左边截断，带`@t{>}' 的形式在字符串右边截断。 例如，如果当前目录为 `@t{/home/pike}'，提示符 `@t{%8<..<%/}' 将扩展为 `@t{..e/pike}'。 在该字符串中，结束符（`@t{<}', `@t{>}' 或 "
"`@t{]}'）或实际上的任何字符都可以用前面的`@t{\\}'来引用；但在使用 @t{print -P} 时要注意，除了双引号字符串去掉的反斜线外，该字符串还需经过标准的 @t{print} 处理，因此必须双写：最糟糕的情况是`@t{print -P "
"\"%<\\\\\\\\<<...\"}'。"

#. type: table
#: zsh.texi:4237
msgid "If the @var{string} is longer than the specified truncation length, it will appear in full, completely replacing the truncated string."
msgstr "如果 @var{string} 长度大于指定的截断长度，则会以完整字符串出现，完全替换截断的字符串。"

#. type: table
#: zsh.texi:4251
msgid ""
"The part of the prompt string to be truncated runs to the end of the string, or to the end of the next enclosing group of the `@t{%(}' construct, or to the next truncation encountered at the same grouping "
"level (i.e. truncations inside a `@t{%(}' are separate), which ever comes first.  In particular, a truncation with argument zero (e.g., `@t{%<<}') marks the end of the range of the string to be truncated "
"while turning off truncation from there on. For example, the prompt `@t{%10<...<%~%<<%# }' will print a truncated representation of the current directory, followed by a `@t{%}' or `@t{#}', followed by a "
"space.  Without the `@t{%<<}', those two characters would be included in the string to be truncated.  Note that `@t{%-0<<}' is not equivalent to `@t{%<<}' but specifies that the prompt is truncated at the "
"right margin."
msgstr ""
"要截断的提示符字符串部分会一直延伸到字符串的末尾，或到下一个 `@t{%(}' 结构体的闭合组的末尾，或到下一个在同一分组级别遇到的截断（即 `@t{%(}'内部的截断是独立的），以先到者为准。 特别是，参数为零的截断（例"
"如，`@t{%<<}'）标志着要截断的字符串范围的结束，并从此关闭截断。例如，提示符 `@t{%10<...<%~%<<%# }'  将打印当前目录的截断表示，后面跟一个`@t{%}'  或  `@t{#}' ，后面跟一个空格。 如果没有 `@t{%<<}' ，这两个字"
"符将包含在被截断的字符串中。 请注意， `@t{%-0<<}' 并不等同于 `@t{%<<}'  ，而是指定在右边空白处截断提示符。"

#. type: table
#: zsh.texi:4260
msgid ""
"Truncation applies only within each individual line of the prompt, as delimited by embedded newlines (if any).  If the total length of any line of the prompt after truncation is greater than the terminal "
"width, or if the part to be truncated contains embedded newlines, truncation behavior is undefined and may change in a future version of the shell.  Use `@t{%-}@var{n}@t{(l.}@var{true-text}@t{.}@var{false-"
"text}@t{)}' to remove parts of the prompt when the available space is less than @var{n}."
msgstr ""
"截断仅适用于以内嵌换行符（如有）为分界的每一行提示符。 如果截断后任何一行提示符的总长度大于终端宽度，或者要截断的部分包含内嵌换行符，那么截断行为将是未定义的，并可能在 shell 的未来版本中发生变化。 当可用空"
"间小于 @var{n} 时，使用  `@t{%-}@var{n}@t{(l.}@var{true-text}@t{.}@var{false-text}@t{)}'  删除部分提示符。"

#. type: cindex
#: zsh.texi:4269
#, no-wrap
msgid "expansion"
msgstr "扩展"

#. type: Plain text
#: zsh.texi:4272
msgid "The following types of expansions are performed in the indicated order in five steps:"
msgstr "以下类型的扩展按指定顺序分五个步骤进行："

#. type: node
#: zsh.texi:4275 zsh.texi:4321 zsh.texi:4323 zsh.texi:4349 zsh.texi:4416 zsh.texi:4463 zsh.texi:4503 zsh.texi:4754
#, no-wrap
msgid "History Expansion"
msgstr "历史扩展"

#. type: table
#: zsh.texi:4277
msgid "This is performed only in interactive shells."
msgstr "仅在交互式 shell 中执行。"

#. type: emph{#1}
#: zsh.texi:4278
#, no-wrap
msgid "Alias Expansion"
msgstr "别名扩展"

#. type: table
#: zsh.texi:4282
msgid "Aliases are expanded immediately before the command line is parsed as explained in @ref{Aliasing}."
msgstr "按照 @ref{别名} 中的说明，别名会在解析命令行之前立即展开。"

#. type: node
#: zsh.texi:4283 zsh.texi:4321 zsh.texi:4754 zsh.texi:4756 zsh.texi:4919
#, no-wrap
msgid "Process Substitution"
msgstr "进程替换"

#. type: node
#: zsh.texi:4284 zsh.texi:4754 zsh.texi:4919 zsh.texi:4921 zsh.texi:6249
#, no-wrap
msgid "Parameter Expansion"
msgstr "参数扩展"

#. type: node
#: zsh.texi:4285 zsh.texi:4919 zsh.texi:6249 zsh.texi:6251 zsh.texi:6276
#, no-wrap
msgid "Command Substitution"
msgstr "命令替换"

#. type: node
#: zsh.texi:4286 zsh.texi:6249 zsh.texi:6276 zsh.texi:6278 zsh.texi:6288
#, no-wrap
msgid "Arithmetic Expansion"
msgstr "算术扩展"

#. type: node
#: zsh.texi:4287 zsh.texi:6276 zsh.texi:6288 zsh.texi:6290 zsh.texi:6364
#, no-wrap
msgid "Brace Expansion"
msgstr "括号扩展"

#. type: table
#: zsh.texi:4294
msgid ""
"These five are performed in left-to-right fashion.  On each argument, any of the five steps that are needed are performed one after the other.  Hence, for example, all the parts of parameter expansion are "
"completed before command substitution is started.  After these expansions, all unquoted occurrences of the characters `@t{\\}',`@t{'}' and `@t{\"}' are removed."
msgstr ""
"这五个步骤从左到右依次进行。 在每个参数上，所需的五个步骤中的任何一个都会相继执行。 因此，举例来说，在开始命令替换之前，参数扩展的所有部分都已完成。 在这些扩展之后，所有未引用的 `@t{\\}',`@t{'}' 和 "
"`@t{\"}' 都会被删除。"

#. type: node
#: zsh.texi:4295 zsh.texi:6288 zsh.texi:6364 zsh.texi:6366 zsh.texi:6408 zsh.texi:6516 zsh.texi:6548 zsh.texi:6562 zsh.texi:6583
#, no-wrap
msgid "Filename Expansion"
msgstr "文件名扩展"

#. type: table
#: zsh.texi:4300
msgid ""
"If the @t{SH_FILE_EXPANSION} option is set, the order of expansion is modified for compatibility with @cite{sh} and @cite{ksh}.  In that case @emph{filename expansion} is performed immediately after "
"@emph{alias expansion}, preceding the set of five expansions mentioned above."
msgstr "如果设置了 @t{SH_FILE_EXPANSION} 选项，则会修改扩展顺序，以便与 @cite{sh} 和 @cite{ksh} 兼容。 在这种情况下，@emph{文件名扩展}会紧接着 @emph{ 别名扩展} 之后执行，排在上述五种扩展之前。"

#. type: cindex
#: zsh.texi:4301
#, no-wrap
msgid "globbing"
msgstr "通配"

#. type: table
#: zsh.texi:4304
msgid "This expansion, commonly referred to as @cite{globbing}, is always done last."
msgstr "这种扩展通常称为 @cite{通配}，总是最后进行。"

#. type: Plain text
#: zsh.texi:4309
msgid "The following sections explain the types of expansion in detail."
msgstr "以下各节将详细说明扩展的类型。"

#. type: t{#1}
#: zsh.texi:4325 zsh.texi:13950 zsh.texi:13951 zsh.texi:29750 zsh.texi:29751
#, no-wrap
msgid "history"
msgstr "history"

#. type: cindex
#: zsh.texi:4326
#, no-wrap
msgid "history expansion"
msgstr "历史扩展"

#. type: cindex
#: zsh.texi:4327
#, no-wrap
msgid "expansion, history"
msgstr "扩展, 历史"

#. type: Plain text
#: zsh.texi:4331
msgid ""
"History expansion allows you to use words from previous command lines in the command line you are typing.  This simplifies spelling corrections and the repetition of complicated commands or arguments."
msgstr "历史扩展功能可让你在键入的命令行中使用以前命令行中的单词。 这可以简化拼写更正和复杂命令或参数的重复输入。"

#. type: vindex
#: zsh.texi:4333
#, no-wrap
msgid "HISTSIZE, use of"
msgstr "HISTSIZE, use of"

#. type: Plain text
#: zsh.texi:4341
msgid ""
"Immediately before execution, each command is saved in the history list, the size of which is controlled by the @t{HISTSIZE} parameter.  The one most recent command is always retained in any case.  Each "
"saved command in the history list is called a history @emph{event} and is assigned a number, beginning with 1 (one) when the shell starts up.  The history number that you may see in your prompt (see "
"@ref{Prompt Expansion}) is the number that is to be assigned to the @emph{next} command."
msgstr ""
"每条命令在执行前都会立即保存在历史列表中，其大小由 @t{HISTSIZE} 参数控制。 在任何情况下，最近的一条命令都会被保留下来。 历史列表中保存的每一条命令都称为历史 @emph{事件}，并分配一个编号，从 shell 启动时的 1"
"（1）开始。 您可能在提示符中看到的历史记录编号（参见 @ref{提示符扩展}）就是分配给 @emph{下一个} 命令的编号。"

#. type: menuentry
#: zsh.texi:4348
msgid "Overview::"
msgstr "概述::"

#. type: menuentry
#: zsh.texi:4348
msgid "Event Designators::"
msgstr "事件指示器::"

#. type: menuentry
#: zsh.texi:4348
msgid "Word Designators::"
msgstr "单词指示器::"

#. type: subsection
#: zsh.texi:4348 zsh.texi:4463 zsh.texi:4503 zsh.texi:4505
#, no-wrap
msgid "Modifiers"
msgstr "修饰符"

#. type: subsection
#: zsh.texi:4349 zsh.texi:4351 zsh.texi:4416 zsh.texi:21184
#, no-wrap
msgid "Overview"
msgstr "概述"

#. type: node
#: zsh.texi:4349 zsh.texi:4416 zsh.texi:4418 zsh.texi:4463
#, no-wrap
msgid "Event Designators"
msgstr "事件指示器"

#. type: Plain text
#: zsh.texi:4358
msgid ""
"A history expansion begins with the first character of the @t{histchars} parameter, which is `@t{!}' by default, and may occur anywhere on the command line, including inside double quotes (but not inside "
"single quotes @t{'...'} or C-style quotes @t{$'...'} nor when escaped with a backslash)."
msgstr "历史扩展以 @t{histchars} 参数的第一个字符开始，默认为 `@t{!}' ，可以出现在命令行的任何位置，包括双引号内（但不包括单引号 @t{'...'} 或 C风格引号 @t{$'...'} ，也不包括反斜线转义）。"

#. type: Plain text
#: zsh.texi:4364
msgid ""
"The first character is followed by an optional event designator (@ref{Event Designators}) and then an optional word designator (@ref{Word Designators}); if neither of these designators is present, no "
"history expansion occurs."
msgstr "第一个字符之后是一个可选的事件指示器（@ref{事件指示器}），然后是一个可选的单词指示器（@ref{单词指示器}）；如果这两个指示器都不存在，则不会进行历史扩展。"

#. type: Plain text
#: zsh.texi:4370
msgid ""
"Input lines containing history expansions are echoed after being expanded, but before any other expansions take place and before the command is executed.  It is this expanded form that is recorded as the "
"history event for later references."
msgstr "包含历史扩展的输入行在扩展后，其他扩展发生前和命令执行前，会有回显。 正是这种扩展后的形式被记录为历史事件，供以后引用。"

#. type: Plain text
#: zsh.texi:4373
msgid "History expansions do not nest."
msgstr "历史扩展不会嵌套。"

#. type: Plain text
#: zsh.texi:4379
msgid ""
"By default, a history reference with no event designator refers to the same event as any preceding history reference on that command line; if it is the only history reference in a command, it refers to "
"the previous command."
msgstr "默认情况下，不带事件指示器的历史记录，会引用与该命令行的前一个历史引用指向的相同事件；如果它是一条命令中唯一的历史记录引用，则指向前一条命令。"

#. type: pindex
#: zsh.texi:4379
#, no-wrap
msgid "CSH_JUNKIE_HISTORY, use of"
msgstr "CSH_JUNKIE_HISTORY, use of"

#. type: Plain text
#: zsh.texi:4383
msgid "However, if the option @t{CSH_JUNKIE_HISTORY} is set, then every history reference with no event specification @emph{always} refers to the previous command."
msgstr "但是，如果设置了选项 @t{CSH_JUNKIE_HISTORY}，那么每个没有事件规范（specification）的历史引用 @emph{总是} 指向前一条命令。"

#. type: Plain text
#: zsh.texi:4394
msgid ""
"For example, `@t{!}' is the event designator for the previous command, so `@t{!!:1}' always refers to the first word of the previous command, and `@t{!!$}' always refers to the last word of the previous "
"command.  With @t{CSH_JUNKIE_HISTORY} set, then `@t{!:1}' and `@t{!$}' function in the same manner as `@t{!!:1}' and `@t{!!$}', respectively.  Conversely, if @t{CSH_JUNKIE_HISTORY} is unset, then "
"`@t{!:1}' and `@t{!$}' refer to the first and last words, respectively, of the same event referenced by the nearest other history reference preceding them on the current command line, or to the previous "
"command if there is no preceding reference."
msgstr ""
"例如，`@t{!}'  是前一条命令的事件指示器，因此 `@t{!!:1}' 总是指前一条命令的第一个字，而 `@t{!!$}' 总是指前一条命令的最后一个字。 如果设置了 @t{CSH_JUNKIE_HISTORY}，则  `@t{!:1}'  和  `@t{!$}'  的功能分别"
"与 `@t{!!:1}' 和 `@t{!!$}' 相同。 反之，如果 @t{CSH_JUNKIE_HISTORY} 未设置，则  `@t{!:1}'  和  `@t{!$}'  分别指向当前命令行中最近的历史引用所指向的同一事件的第一个字和最后一个字，如果没有前一个引用，则指向"
"上一条命令。"

#. type: Plain text
#: zsh.texi:4404
msgid ""
"The character sequence `@t{^}@var{foo}@t{^}@var{bar}' (where `@t{^}' is actually the second character of the @t{histchars} parameter)  repeats the last command, replacing the string @var{foo} with "
"@var{bar}.  More precisely, the sequence `@t{^}@var{foo}@t{^}@var{bar}@t{^}' is synonymous with `@t{!!:s}@t{^}@var{foo}@t{^}@var{bar}@t{^}', hence other modifiers (see @ref{Modifiers}) may follow the "
"final `@t{^}'.  In particular, `@t{^}@var{foo}@t{^}@var{bar}@t{^:G}' performs a global substitution."
msgstr ""
"字符序列  `@t{^}@var{foo}@t{^}@var{bar}' （其中 `@t{^}' 实际上是 @t{histchars} 参数的第二个字符）重复上一条命令，用 @var{bar} 替换 @var{foo} 字符串。 更确切地说，序列 `@t{^}@var{foo}@t{^}@var{bar}@t{^}' "
"与 `@t{!!:s}@t{^}@var{foo}@t{^}@var{bar}@t{^}' 是同义词，因此在最后的 `@t{^}' 后面还可以加上其他修饰符（参见 @ref{修饰符}）。 特别是，`@t{^}@var{foo}@t{^}@var{bar}@t{^:G}' 执行全局替换。"

#. type: Plain text
#: zsh.texi:4411
msgid ""
"If the shell encounters the character sequence `@t{!\"}' in the input, the history mechanism is temporarily disabled until the current list (see @ref{Shell Grammar}) is fully parsed.  The `@t{!\"}' is "
"removed from the input, and any subsequent `@t{!}' characters have no special significance."
msgstr "如果 shell 在输入中遇到字符序列 `@t{!\"}'，历史机制会暂时失效，直到当前列表（参见 @ref{Shell 语法}）完全解析完毕。 `@t{!\"}' 将从输入中删除，随后的 `@t{!}' 字符将没有特殊意义。"

#. type: findex
#: zsh.texi:4413
#, no-wrap
msgid "fc, use of"
msgstr "fc, use of"

#. type: Plain text
#: zsh.texi:4416
msgid "A less convenient but more comprehensible form of command history support is provided by the @t{fc} builtin."
msgstr "@t{fc} 内置程序提供了一种不太方便但更易于理解的命令历史记录支持。"

#. type: node
#: zsh.texi:4416 zsh.texi:4463 zsh.texi:4465 zsh.texi:4503
#, no-wrap
msgid "Word Designators"
msgstr "单词指示器"

#. type: cindex
#: zsh.texi:4420
#, no-wrap
msgid "history event designators"
msgstr "历史事件指示器"

#. type: cindex
#: zsh.texi:4421
#, no-wrap
msgid "event designators, history"
msgstr "事件指示器, 历史"

#. type: Plain text
#: zsh.texi:4426
msgid ""
"An event designator is a reference to a command-line entry in the history list.  In the list below, remember that the initial @t{`!'} in each item may be changed to another character by setting the "
"@t{histchars} parameter."
msgstr "事件指示器是对历史记录列表中命令行条目的引用。 在下面的列表中，请记住，通过设置 @t{histchars} 参数，可以将每个条目中的初始 @t{`!'} 更改为其他字符。"

#. type: table
#: zsh.texi:4434
msgid ""
"Start a history expansion, except when followed by a blank, newline, `@t{=}' or `@t{(}'.  If followed immediately by a word designator (@ref{Word Designators}), this forms a history reference with no "
"event designator (@ref{Overview})."
msgstr "开始历史扩展，除非后面是空白、换行符、`@t{=}' 或 `@t{(}' 。 如果后面紧跟一个单词指示器（@ref{单词指示器}），则形成一个没有事件指示器的历史记录引用（@ref{概述}）。"

#. type: t{#1}
#: zsh.texi:4435 zsh.texi:38837
#, no-wrap
msgid "!!"
msgstr "!!"

#. type: table
#: zsh.texi:4439
msgid "Refer to the previous command.  By itself, this expansion repeats the previous command."
msgstr "引用上一条命令。 该扩展本身重复前一条命令。"

#. type: item
#: zsh.texi:4440
#, no-wrap
msgid "@t{!}@var{n}"
msgstr "@t{!}@var{n}"

#. type: table
#: zsh.texi:4442
msgid "Refer to command-line @var{n}."
msgstr "引用命令行 @var{n}。"

#. type: item
#: zsh.texi:4443
#, no-wrap
msgid "@t{!-}@var{n}"
msgstr "@t{!-}@var{n}"

#. type: table
#: zsh.texi:4445
msgid "Refer to the current command-line minus @var{n}."
msgstr "引用当前命令行减 @var{n}。"

#. type: item
#: zsh.texi:4446
#, no-wrap
msgid "@t{!}@var{str}"
msgstr "@t{!}@var{str}"

#. type: table
#: zsh.texi:4448
msgid "Refer to the most recent command starting with @var{str}."
msgstr "引用以 @var{str} 开头的最近命令。"

#. type: item
#: zsh.texi:4449
#, no-wrap
msgid "@t{!?}@var{str}[@t{?}]"
msgstr "@t{!?}@var{str}[@t{?}]"

#. type: table
#: zsh.texi:4453
msgid ""
"Refer to the most recent command containing @var{str}.  The trailing `@t{?}' is necessary if this reference is to be followed by a modifier or followed by any text that is not to be considered part of "
"@var{str}."
msgstr "引用包含 @var{str} 的最近命令。 如果该引用后面有修饰符，或后面有任何不被视为 @var{str} 一部分的文本，则尾部的 `@t{?}' 是必要的。"

#. type: t{#1}
#: zsh.texi:4454
#, no-wrap
msgid "!#"
msgstr "!#"

#. type: table
#: zsh.texi:4458
msgid "Refer to the current command line typed in so far.  The line is treated as if it were complete up to and including the word before the one with the `@t{!#}' reference."
msgstr "引用当前键入的命令行。 该命令行将被视为完整的命令行，直到并包括 `@t{!#}' 引用之前的单词。"

#. type: item
#: zsh.texi:4459
#, no-wrap
msgid "@t{!@{}...@t{@}}"
msgstr "@t{!@{}...@t{@}}"

#. type: table
#: zsh.texi:4461
msgid "Insulate a history reference from adjacent characters (if necessary)."
msgstr "将历史引用字符与相邻字符隔开（如有必要）。"

#. type: cindex
#: zsh.texi:4467
#, no-wrap
msgid "history word designators"
msgstr "历史单词指示器"

#. type: cindex
#: zsh.texi:4468
#, no-wrap
msgid "word designators, history"
msgstr "单词指示器, 历史"

#. type: Plain text
#: zsh.texi:4475
msgid ""
"A word designator indicates which word or words of a given command line are to be included in a history reference.  A `@t{:}' usually separates the event specification from the word designator.  It may be "
"omitted only if the word designator begins with a `@t{^}', `@t{$}', `@t{*}', `@t{-}' or `@t{%}'.  Word designators include:"
msgstr ""
"单词指示器表示指定命令行中的哪个单词或哪些单词将包含在历史记录引用中。 通常， `@t{:}' 将事件说明与单词指示器分隔开来。 只有在单词代号以 `@t{^}', `@t{$}', `@t{*}', `@t{-}'或 `@t{%}' 开头时才可以省略。 单词"
"指示器包括:"

#. type: t{#1}
#: zsh.texi:4478 zsh.texi:5687 zsh.texi:8540 zsh.texi:30662 zsh.texi:38805
#, no-wrap
msgid "0"
msgstr "0"

#. type: table
#: zsh.texi:4480
msgid "The first input word (command)."
msgstr "第一个输入词（命令）。"

#. type: t{#1}
#: zsh.texi:4480 zsh.texi:5506 zsh.texi:7515 zsh.texi:7533
#, no-wrap
msgid "n"
msgstr "n"

#. type: table
#: zsh.texi:4482
msgid "The @var{n}th argument."
msgstr "第 @var{n} 个参数"

#. type: table
#: zsh.texi:4484
msgid "The first argument.  That is, @t{1}."
msgstr "第一个参数。 即 @t{1} 。"

#. type: vindex
#: zsh.texi:4484 zsh.texi:8507
#, no-wrap
msgid "$"
msgstr "$"

#. type: table
#: zsh.texi:4486
msgid "The last argument."
msgstr "最后一个参数。"

#. type: t{#1}
#: zsh.texi:4486 zsh.texi:5378 zsh.texi:7279
#, no-wrap
msgid "%"
msgstr "%"

#. type: table
#: zsh.texi:4488
msgid "The word matched by (the most recent) @t{?}@var{str} search."
msgstr "@t{?}@var{str} 搜索(最近一次）匹配到的单词。"

#. type: item
#: zsh.texi:4488
#, no-wrap
msgid "@var{x}@t{-}@var{y}"
msgstr "@var{x}@t{-}@var{y}"

#. type: table
#: zsh.texi:4490
msgid "A range of words; @var{x} defaults to @t{0}."
msgstr "字词范围；@var{x} 默认为 @t{0}。"

#. type: vindex
#: zsh.texi:4490 zsh.texi:5959 zsh.texi:6621 zsh.texi:7276 zsh.texi:8520
#, no-wrap
msgid "*"
msgstr "*"

#. type: table
#: zsh.texi:4492
msgid "All the arguments, or a null value if there are none."
msgstr "所有参数，如果没有参数则为空值。"

#. type: item
#: zsh.texi:4492
#, no-wrap
msgid "@var{x}@t{*}"
msgstr "@var{x}@t{*}"

#. type: table
#: zsh.texi:4494
msgid "Abbreviates `@var{x}@t{-$}'."
msgstr "缩写为 `@var{x}@t{-$}'。"

#. type: item
#: zsh.texi:4494
#, no-wrap
msgid "@var{x}@t{-}"
msgstr "@var{x}@t{-}"

#. type: table
#: zsh.texi:4496
msgid "Like `@var{x}@t{*}' but omitting word @t{$}."
msgstr "类似于  `@var{x}@t{*}'，但省略了 @t{$} 。"

#. type: Plain text
#: zsh.texi:4503
msgid ""
"Note that a `@t{%}' word designator works only when used in one of `@t{!%}', `@t{!:%}' or `@t{!?}@var{str}@t{?:%}', and only when used after a @t{!?} expansion (possibly in an earlier command).  Anything "
"else results in an error, although the error may not be the most obvious one."
msgstr "请注意， `@t{%}' 单词指示器只有在和 `@t{!%}', `@t{!:%}' 或 `@t{!?}@var{str}@t{?:%}' 一起使用时有用，并且只能在  @t{!?} 扩展（可能在之前的命令中）之后使用。否则会导致错误，尽管错误可能不是最明显的。"

#. type: t{#1}
#: zsh.texi:4507 zsh.texi:21627
#, no-wrap
msgid "modifiers"
msgstr "修饰符"

#. type: cindex
#: zsh.texi:4508
#, no-wrap
msgid "colon modifiers"
msgstr "冒号修饰符"

#. type: cindex
#: zsh.texi:4509
#, no-wrap
msgid "history modifiers"
msgstr "历史修饰符"

#. type: cindex
#: zsh.texi:4510
#, no-wrap
msgid "globbing modifiers"
msgstr "全局修饰符"

#. type: cindex
#: zsh.texi:4511
#, no-wrap
msgid "parameter modifiers"
msgstr "参数修饰符"

#. type: Plain text
#: zsh.texi:4517
msgid ""
"After the optional word designator, you can add a sequence of one or more of the following modifiers, each preceded by a `@t{:}'.  These modifiers also work on the result of @emph{filename generation} and "
"@emph{parameter expansion}, except where noted."
msgstr "在可选的单词指示器后，您可以添加以下一个或多个修改器序列，每个修饰符前都有一个 `@t{:}' 。 这些修改器也适用于 @emph{文件名生成} 和 @emph{参数扩展} 的结果，除非另有说明。"

#. type: t{#1}
#: zsh.texi:4520 zsh.texi:5416 zsh.texi:7539
#, no-wrap
msgid "a"
msgstr "a"

#. type: table
#: zsh.texi:4524
msgid "Turn a file name into an absolute path: prepends the current directory, if necessary; remove `@t{.}' path segments; and remove `@t{..}' path segments and the segments that immediately precede them."
msgstr "将文件名转换为绝对路径：会在必要时对当前目录进行预处理；删除 @t{.}' 路径段；删除 `@t{..}'  路径段和紧接其后的路径段。"

#. type: table
#: zsh.texi:4533
msgid ""
"This transformation is agnostic about what is in the filesystem, i.e. is on the logical, not the physical directory.  It takes place in the same manner as when changing directories when neither of the "
"options @t{CHASE_DOTS} or @t{CHASE_LINKS} is set.  For example, `@t{/before/here/../after}' is always transformed to `@t{/before/after}', regardless of whether `@t{/before/here}' exists or what kind of "
"object (dir, file, symlink, etc.) it is."
msgstr ""
"这种转换与文件系统中的内容无关，也就是说，它只针对逻辑目录，而非物理目录。当 @t{CHASE_DOTS} 或 @t{CHASE_LINKS}  选项均未设置时，转换方式与更改目录的方式相同。例如， `@t{/before/here/../after}' 总是被转换"
"为  `@t{/before/after}' ，而不管 `@t{/before/here}' 是否存在，也不管它是哪种对象（目录、文件、符号链接等）。"

#. type: t{#1}
#: zsh.texi:4534 zsh.texi:5393 zsh.texi:7297
#, no-wrap
msgid "A"
msgstr "A"

#. type: table
#: zsh.texi:4538
msgid "Turn a file name into an absolute path as the `@t{a}' modifier does, and @emph{then} pass the result through the @t{realpath(3)} library function to resolve symbolic links."
msgstr "将文件名转换为绝对路径，就像  `@t{a}'  修饰符所做的那样，然后  @emph{then}  将结果通过 @t{realpath(3)}  库函数来解析符号链接。"

#. type: table
#: zsh.texi:4543
msgid "Note: on systems that do not have a @t{realpath(3)} library function, symbolic links are not resolved, so on those systems `@t{a}' and `@t{A}' are equivalent."
msgstr "注意：在没有 @t{realpath(3)} 库函数的系统上，符号链接不会被解析，因此在这些系统上， `@t{a}' 和 `@t{A}' 是等价的。"

#. type: table
#: zsh.texi:4547
msgid "Note: @t{foo:A} and @t{realpath(foo)} are different on some inputs.  For @t{realpath(foo)} semantics, see the `@t{P}` modifier."
msgstr "注意  @t{foo:A}  和  @t{realpath(foo)}  在某些输入上是不同的。 关于  @t{realpath(foo)} 的语义，请参阅 `@t{P}` 修饰符。"

#. type: table
#: zsh.texi:4554
msgid ""
"Resolve a command name into an absolute path by searching the command path given by the @t{PATH} variable.  This does not work for commands containing directory parts.  Note also that this does not "
"usually work as a glob qualifier unless a file of the same name is found in the current directory."
msgstr "通过搜索 @t{PATH} 变量给出的命令路径，将命令名称解析为绝对路径。 这不适用于包含目录部分的命令。 还需注意的是，除非在当前目录下找到同名文件，否则该命令通常不能用作 glob 限定符。"

#. type: table
#: zsh.texi:4560
msgid ""
"Remove all but the part of the filename extension following the `@t{.}'; see the definition of the filename extension in the description of the @t{r} modifier below.  Note that according to that "
"definition the result will be empty if the string ends with a `@t{.}'."
msgstr "除文件名扩展名中 `@t{.}' 之后的部分外，全部删除；文件名扩展名的定义请参阅下面对 @t{r} 修饰符的描述。 请注意，根据该定义，如果字符串以  `@t{.}' 结尾，结果将为空。"

#. type: item
#: zsh.texi:4561
#, no-wrap
msgid "@t{h} [ @var{digits} ]"
msgstr "@t{h} [ @var{digits} ]"

#. type: table
#: zsh.texi:4578
msgid ""
"Remove a trailing pathname component, shortening the path by one directory level: this is the `head' of the pathname.  This works like `@t{dirname}'.  If the @t{h} is followed immediately (with no spaces "
"or other separator) by any number of decimal digits, and the value of the resulting number is non-zero, that number of leading components is preserved instead of the final component being removed.  In an "
"absolute path the leading `@t{/}' is the first component, so, for example, if @t{var=/my/path/to/something}, then @t{$@{var:h3@}} substitutes @t{/my/path}.  Consecutive `/'s are treated the same as a "
"single `/'.  In parameter substitution, digits may only be used if the expression is in braces, so for example the short form substitution @t{$var:h2} is treated as @t{$@{var:h@}2}, not as @t{$@{var:"
"h2@}}.  No restriction applies to the use of digits in history substitution or globbing qualifiers.  If more components are requested than are present, the entire path is substituted (so this does not "
"trigger a `failed modifier' error in history expansion)."
msgstr ""
"删除路径名的尾部组件，将路径缩短一级目录：这是路径名的 \"头\"。 其作用类似于 `@t{dirname}' 。 如果 @t{h}后面紧跟任意数量的十进制数字（没有空格或其他分隔符），且所得数字的值非零，则保留该数量的前导成分，而"
"不是删除最后一个成分。 在绝对路径中，前导成分  `@t{/}'  是第一个成分，例如，如果 @t{var=/my/path/to/something}，那么 @t{$@{var:h3@}}  将取代  @t{/my/path}。 连续的 `/' 与单个  `/' 的处理方式相同。 在参数替"
"换中，只有当表达式位于大括号中时才能使用数字，例如，简式替换 @t{$var:h2} 将被视为 @t{$@{var:h@}2}，而不是 @t{$@{var:h2@}}。 在历史替换或 globbing 限定符中使用数字不受限制。 如果请求的组件数多于实际存在的组"
"件数，则会替换整个路径（因此不会在历史扩展中触发 `failed modifier' 错误）。"

#. type: table
#: zsh.texi:4581
msgid "Convert the words to all lowercase."
msgstr "将单词转换为全小写。"

#. type: t{#1}
#: zsh.texi:4582 zsh.texi:5702 zsh.texi:7273 zsh.texi:8137 zsh.texi:36306
#, no-wrap
msgid "p"
msgstr "p"

#. type: table
#: zsh.texi:4585
msgid "Print the new command but do not execute it.  Only works with history expansion."
msgstr "打印新命令，但不执行。 仅适用于历史扩展。"

#. type: t{#1}
#: zsh.texi:4586 zsh.texi:5535 zsh.texi:31674
#, no-wrap
msgid "P"
msgstr "P"

#. type: table
#: zsh.texi:4592
msgid ""
"Turn a file name into an absolute path, like @t{realpath(3)}.  The resulting path will be absolute, will refer to the same directory entry as the input filename, and none of its components will be "
"symbolic links or equal to `@t{.}' or `@t{..}'."
msgstr "将文件名转换为绝对路径，如 @t{realpath(3)}。 生成的路径将是绝对路径，将指向与输入文件名相同的目录条目，并且其任何组成部分都不会是符号链接或等于 `@t{.}' 或 `@t{..}'。"

#. type: table
#: zsh.texi:4596
msgid "Unlike @t{realpath(3)}, non-existent trailing components are permitted and preserved."
msgstr "与 @t{realpath(3)}不同的是，允许并保留不存在的尾部成分。"

#. type: t{#1}
#: zsh.texi:4597 zsh.texi:5558 zsh.texi:7031
#, no-wrap
msgid "q"
msgstr "q"

#. type: table
#: zsh.texi:4602
msgid ""
"Quote the substituted words, escaping further substitutions.  Works with history expansion and parameter expansion, though for parameters it is only useful if the resulting text is to be re-evaluated such "
"as by @t{eval}."
msgstr "引用被替换的词语，并转义进一步的替换。 可用于历史扩展和参数扩展，但对于参数而言，只有在生成的文本需要重新计算（如 @t{eval}）时才有用。"

#. type: t{#1}
#: zsh.texi:4603 zsh.texi:5584
#, no-wrap
msgid "Q"
msgstr "Q"

#. type: table
#: zsh.texi:4605
msgid "Remove one level of quotes from the substituted words."
msgstr "去掉替换词的一级引号。"

#. type: t{#1}
#: zsh.texi:4606 zsh.texi:7288 zsh.texi:8146 zsh.texi:14410 zsh.texi:14411
#, no-wrap
msgid "r"
msgstr "r"

#. type: table
#: zsh.texi:4613
msgid ""
"Remove a filename extension leaving the root name.  Strings with no filename extension are not altered.  A filename extension is a `@t{.}' followed by any number of characters (including zero) that are "
"neither `@t{.}' nor `@t{/}' and that continue to the end of the string.  For example, the extension of `@t{foo.orig.c}' is `@t{.c}', and `@t{dir.c/foo}' has no extension."
msgstr ""
"删除文件扩展名，保留根名称。 没有文件扩展名的字符串不会被更改。 文件名扩展名是 `@t{.}' ，后跟任意数量的字符（包括零个），这些字符既不是 `@t{.}'，也不是 `@t{/}' ，并一直延续到字符串的末尾。 例如，`@t{foo."
"orig.c}'的扩展名是`@t{.c}'，而 `@t{dir.c/foo}' 没有扩展名。"

#. type: item
#: zsh.texi:4614
#, no-wrap
msgid "@t{s/}@var{l}@t{/}@var{r}[@t{/}]"
msgstr "@t{s/}@var{l}@t{/}@var{r}[@t{/}]"

#. type: table
#: zsh.texi:4620
msgid ""
"Substitute @var{r} for @var{l} as described below.  The substitution is done only for the first string that matches @var{l}.  For arrays and for filename generation, this applies to each word of the "
"expanded text.  See below for further notes on substitutions."
msgstr "如下所述，用 @var{r} 代替 @var{l}。 替换只针对与 @var{l} 匹配的第一个字符串。 对于数组和文件名生成，这适用于扩展文本的每个单词。 有关替换的进一步说明，请参阅下文。"

#. type: table
#: zsh.texi:4626
msgid ""
"The forms `@t{gs/}@var{l}@t{/}@var{r}' and `@t{s/}@var{l}@t{/}@var{r}@t{/:G}' perform global substitution, i.e. substitute every occurrence of @var{r} for @var{l}.  Note that the @t{g} or @t{:G} must "
"appear in exactly the position shown."
msgstr "形式  `@t{gs/}@var{l}@t{/}@var{r}' 和 `@t{s/}@var{l}@t{/}@var{r}@t{/:G}' 执行全局替换，即用 @var{l} 替换 @var{r} 的每一次出现。 请注意，@t{g} 或 @t{:G} 必须准确出现在所示位置。"

#. type: table
#: zsh.texi:4629
msgid "See further notes on this form of substitution below."
msgstr "请参阅下文关于这种替代形式的进一步说明。"

#. type: table
#: zsh.texi:4635
msgid ""
"Repeat the previous @t{s} substitution.  Like @t{s}, may be preceded immediately by a @t{g}.  In parameter expansion the @t{&} must appear inside braces, and in filename generation it must be quoted with "
"a backslash."
msgstr "重复前面的 @t{s} 替换。 与 @t{s}一样，可以在前面紧接一个 @t{g}。 在参数扩展中，@t{&} 必须出现在大括号内；在文件名生成时，必须用反斜线引用。"

#. type: item
#: zsh.texi:4636
#, no-wrap
msgid "@t{t} [ @var{digits} ]"
msgstr "@t{t} [ @var{digits} ]"

#. type: table
#: zsh.texi:4642
msgid ""
"Remove all leading pathname components, leaving the final component (tail).  This works like `@t{basename}'.  Any trailing slashes are first removed.  Decimal digits are handled as described above for "
"(h), but in this case that number of trailing components is preserved instead of the default 1; 0 is treated the same as 1."
msgstr ""
"删除路径名的所有前导成分，留下最后一个成分（尾部）。 其工作原理类似于 `@t{basename}'。 首先会删除任何尾部的斜线。 小数位的处理方法如上文 (h) 所述，但在这种情况下，尾部成分的个数将被保留，而不是默认的 1；0 "
"与 1 的处理方法相同。"

#. type: t{#1}
#: zsh.texi:4643 zsh.texi:5645 zsh.texi:7043
#, no-wrap
msgid "u"
msgstr "u"

#. type: table
#: zsh.texi:4645
msgid "Convert the words to all uppercase."
msgstr "将单词转换为全大写。"

#. type: t{#1}
#: zsh.texi:4646 zsh.texi:7294 zsh.texi:40267
#, no-wrap
msgid "x"
msgstr "x"

#. type: table
#: zsh.texi:4649
msgid "Like @t{q}, but break into words at whitespace.  Does not work with parameter expansion."
msgstr "与 @t{q}类似，但在空白处分词。 不支持参数扩展。"

#. type: Plain text
#: zsh.texi:4665
msgid ""
"The @t{s/}@var{l}@t{/}@var{r}@t{/} substitution works as follows.  By default the left-hand side of substitutions are not patterns, but character strings.  Any character can be used as the delimiter in "
"place of `@t{/}'.  A backslash quotes the delimiter character.  The character `@t{&}', in the right-hand-side @var{r}, is replaced by the text from the left-hand-side @var{l}.  The `@t{&}' can be quoted "
"with a backslash.  A null @var{l} uses the previous string either from the previous @var{l} or from the contextual scan string @var{s} from `@t{!?}@var{s}'.  You can omit the rightmost delimiter if a "
"newline immediately follows @var{r}; the rightmost `@t{?}' in a context scan can similarly be omitted.  Note the same record of the last @var{l} and @var{r} is maintained across all forms of expansion."
msgstr ""
"@t{s/}@var{l}@t{/}@var{r}@t{/} 替换的工作原理如下。 默认情况下，替换的左侧不是模式，而是字符串。 任何字符都可以代替 `@t{/}' 作为分隔符。 反斜线引用分隔符。 右侧 @var{r} 中的字符 `@t{&}' 将被左侧 @var{l} 中"
"的文本替换。 `@t{&}'  可以用反斜线引用。空的 @var{l} 使用前一个 @var{l} 中的字符串或前一个上下文扫描字符串 `@t{!?}@var{s}'  中的@var{s} 。 如果 @var{r} 后面紧跟换行符，则可以省略最右边的分隔符；同样，也可"
"以省略上下文扫描中最右边的 `@t{?}'。 请注意，在所有扩展形式中，最后一个 @var{l} 和 @var{r} 的记录都是相同的。"

#. type: Plain text
#: zsh.texi:4669
msgid "Note that if a `@t{&}' is used within glob qualifiers an extra backslash is needed as a @t{&} is a special character in this case."
msgstr "请注意，如果在 glob 限定符中使用了 `@t{&}'，则需要额外的反斜杠，因为在这种情况下 @t{&} 是一个特殊字符。"

#. type: Plain text
#: zsh.texi:4683
msgid ""
"Also note that the order of expansions affects the interpretation of @var{l} and @var{r}.  When used in a history expansion, which occurs before any other expansions, @var{l} and @var{r} are treated as "
"literal strings (except as explained for @t{HIST_SUBST_PATTERN} below).  When used in parameter expansion, the replacement of @var{r} into the parameter's value is done first, and then any additional "
"process, parameter, command, arithmetic, or brace references are applied, which may evaluate those substitutions and expansions more than once if @var{l} appears more than once in the starting value.  "
"When used in a glob qualifier, any substitutions or expansions are performed once at the time the qualifier is parsed, even before the `@t{:s}' expression itself is divided into @var{l} and @var{r} sides."
msgstr ""
"还要注意的是，扩展的顺序会影响 @var{l} 和 @var{r} 的解释。 在历史扩展中使用时(在其它扩展发生前)，@var{l} 和 @var{r} 将被视为字面字符串（下文对 @t{HIST_SUBST_PATTERN} 的解释除外）。 在参数扩展中使用时，首先"
"将 @var{r} 替换为参数值，然后应用附加的进程、参数、命令、算术或括号引用，如果 @var{l} 在起始值中出现不止一次，可能会对这些替换和扩展进行多次计算。 在 glob 限定符中使用时，即使在 `@t{:s}'表达式本身被分为 "
"@var{l} 和 @var{r} 两边之前，也会在解析限定符时执行一次替换或扩展。"

#. type: Plain text
#: zsh.texi:4698
msgid ""
"If the option @t{HIST_SUBST_PATTERN} is set, @var{l} is treated as a pattern of the usual form described in @ref{Filename Generation}.  This can be used in all the places where modifiers are available; "
"note, however, that in globbing qualifiers parameter substitution has already taken place, so parameters in the replacement string should be quoted to ensure they are replaced at the correct time.  Note "
"also that complicated patterns used in globbing qualifiers may need the extended glob qualifier notation @t{(#q:s/}@var{...}@t{/}@var{...}@t{/)} in order for the shell to recognize the expression as a "
"glob qualifier.  Further, note that bad patterns in the substitution are not subject to the @t{NO_BAD_PATTERN} option so will cause an error."
msgstr ""
"如果设置了选项 @t{HIST_SUBST_PATTERN}，@var{l} 将被视为 @ref{文件名生成} 中描述的通常形式的模式。 这可以在所有可以使用修饰符的地方使用；但需要注意的是，globbing 限定符中的参数替换已经发生，因此替换字符串中"
"的参数应该加引号，以确保在正确的时间被替换。 还要注意的是，globbing 限定符中使用的复杂模式可能需要使用扩展的 glob 限定符符号 @t{(#q:s/}@var{...}@t{/}@var{...}@t{/)}，这样 shell 才能将表达式识别为 glob 限定"
"符。 此外，请注意替换中的坏模式不受 @t{NO_BAD_PATTERN} 选项的限制，因此会导致错误。"

#. type: Plain text
#: zsh.texi:4706
msgid ""
"When @t{HIST_SUBST_PATTERN} is set, @var{l} may start with a @t{#} to indicate that the pattern must match at the start of the string to be substituted, and a @t{%} may appear at the start or after an "
"@t{#} to indicate that the pattern must match at the end of the string to be substituted.  The @t{%} or @t{#} may be quoted with two backslashes."
msgstr ""
"设置 @t{HIST_SUBST_PATTERN} 时，@var{l} 可以以 @t{#} 开头，表示模式必须在要替换的字符串的开头匹配；@t{%} 可以出现在 @t{#} 的开头或后面，表示模式必须在要替换的字符串的结尾匹配。 @t{%} 或 @t{#} 可以用两个反"
"斜线引用。"

#. type: Plain text
#: zsh.texi:4710
msgid "For example, the following piece of filename generation code with the @t{EXTENDED_GLOB} option:"
msgstr "例如，下面这段使用 @t{EXTENDED_GLOB} 选项的文件名代码："

#. type: example
#: zsh.texi:4714
#, no-wrap
msgid "print -r -- *.c(#q:s/#%(#b)s(*).c/'S$@{match[1]@}.C'/)\n"
msgstr "print -r -- *.c(#q:s/#%(#b)s(*).c/'S$@{match[1]@}.C'/)\n"

#. type: Plain text
#: zsh.texi:4724
msgid ""
"takes the expansion of @t{*.c} and applies the glob qualifiers in the @t{(#q}@var{...}@t{)} expression, which consists of a substitution modifier anchored to the start and end of each word (@t{#%}).  This "
"turns on backreferences (@t{(#b)}), so that the parenthesised subexpression is available in the replacement string as @t{$@{match[1]@}}.  The replacement string is quoted so that the parameter is not "
"substituted before the start of filename generation."
msgstr ""
"使用扩展 @t{*.c}，并应用 @t{(#q}@var{...}@t{)} 表达式中的 glob 限定符，该表达式由锚定在每个单词开头和结尾的替换修饰符 (@t{#%}) 组成。 这样就打开了反向引用 (@t{(#b)})，这样括号中的子表达式就可以在替换字符串"
"中以 @t{$@{match[1]@}} 的形式出现。 替换字符串带有引号，因此不会在文件名生成之前替换参数。"

#. type: Plain text
#: zsh.texi:4729
msgid "The following @t{f}, @t{F}, @t{w} and @t{W} modifiers work only with parameter expansion and filename generation.  They are listed here to provide a single point of reference for all modifiers."
msgstr "以下 @t{f}、@t{F}、@t{w} 和 @t{W} 修饰符仅用于参数扩展和文件名生成。 在此列出它们是为了给所有修饰符提供一个单一的参考点。"

#. type: t{#1}
#: zsh.texi:4732 zsh.texi:5475 zsh.texi:8141
#, no-wrap
msgid "f"
msgstr "f"

#. type: table
#: zsh.texi:4735
msgid "Repeats the immediately (without a colon) following modifier until the resulting word doesn't change any more."
msgstr "重复紧跟修饰符（不带冒号）的词，直到结果词不再变化。"

#. type: item
#: zsh.texi:4736
#, no-wrap
msgid "@t{F:}@var{expr}@t{:}"
msgstr "@t{F:}@var{expr}@t{:}"

#. type: table
#: zsh.texi:4743
msgid ""
"Like @t{f}, but repeats only @var{n} times if the expression @var{expr} evaluates to @var{n}.  Any character can be used instead of the `@t{:}'; if `@t{(}', `@t{[}', or `@t{@{}' is used as the opening "
"delimiter, the closing delimiter should be '@t{)}', `@t{]}', or `@t{@}}', respectively."
msgstr ""
"与 @t{f}类似，但如果表达式 @var{expr} 的值为 @var{n}，则只重复 @var{n} 次。 可以使用任何字符代替 `@t{:}'；如果使用`@t{(}', `@t{[}' 或 `@t{@{}' 作为开头分隔符，则结尾分隔符应分别为 `@t{)}', `@t{]}', 或  "
"`@t{@}}' 。"

#. type: table
#: zsh.texi:4747
msgid "Makes the immediately following modifier work on each word in the string."
msgstr "使紧随其后的修饰符作用于字符串中的每个单词。"

#. type: item
#: zsh.texi:4748
#, no-wrap
msgid "@t{W:}@var{sep}@t{:}"
msgstr "@t{W:}@var{sep}@t{:}"

#. type: table
#: zsh.texi:4752
msgid ""
"Like @t{w} but words are considered to be the parts of the string that are separated by @var{sep}. Any character can be used instead of the `@t{:}'; opening parentheses are handled specially, see above."
msgstr "与 @t{w} 类似，但单词被视为字符串中由 @var{sep} 分隔的部分。任何字符都可以代替 `@t{:}'；开头的括号会特殊处理，见上文。"

#. type: cindex
#: zsh.texi:4758
#, no-wrap
msgid "process substitution"
msgstr "进程替换"

#. type: cindex
#: zsh.texi:4759
#, no-wrap
msgid "substitution, process"
msgstr "替换, 进程"

#. type: Plain text
#: zsh.texi:4771
msgid ""
"Each part of a command argument that takes the form `@t{<(}@var{list}@t{)}', `@t{>(}@var{list}@t{)}' or `@t{=(}@var{list}@t{)}' is subject to process substitution.  The expression may be preceded or "
"followed by other strings except that, to prevent clashes with commonly occurring strings and patterns, the last form must occur at the start of a command argument, and the forms are only expanded when "
"first parsing command or assignment arguments.  Process substitutions may be used following redirection operators; in this case, the substitution must appear with no trailing string."
msgstr ""
"命令参数中格式为 `@t{<(}@var{list}@t{)}'、 `@t{>(}@var{list}@t{)}' 或 `@t{=(}@var{list}@t{)}'  的每一部分都会进行进程替换。 表达式的前面或后面可以有其他字符串，但为了防止与通常的字符串和模式发生冲突，最后"
"一个形式必须出现在命令参数的开头，而且只有在第一次解析命令或赋值参数时才会展开这个形式。 进程替换可以在重定向操作符之后使用；在这种情况下，替换必须不带尾部字符串。"

#. type: Plain text
#: zsh.texi:4778
msgid ""
"Note that `@t{<<(}@var{list}@t{)}' is not a special syntax; it is equivalent to `@t{< <(}@var{list}@t{)}', redirecting standard input from the result of process substitution.  Hence all the following "
"documentation applies.  The second form (with the space)  is recommended for clarity."
msgstr "请注意， `@t{<<(}@var{list}@t{)}' 并非特殊语法；它等同于 `@t{< <(}@var{list}@t{)}'，从进程替换的结果中重定向标准输入。 因此，以下所有文档都适用。 为清晰起见，建议使用第二种形式（带空格）。"

#. type: Plain text
#: zsh.texi:4789
msgid ""
"In the case of the @t{<} or @t{>} forms, the shell runs the commands in @var{list} as a subprocess of the job executing the shell command line.  If the system supports the @t{/dev/fd} mechanism, the "
"command argument is the name of the device file corresponding to a file descriptor; otherwise, if the system supports named pipes (FIFOs), the command argument will be a named pipe.  If the form with "
"@t{>} is selected then writing on this special file will provide input for @var{list}.  If @t{<} is used, then the file passed as an argument will be connected to the output of the @var{list} process.  "
"For example,"
msgstr ""
"对于 @t{<} 或 @t{>} 形式，shell 会将 @var{list} 中的命令作为执行 shell 命令行的作业的子进程运行。 如果系统支持 @t{/dev/fd} 机制，命令参数就是与文件描述符相对应的设备文件名；否则，如果系统支持命名管道"
"（FIFOs），命令参数就是一个命名管道。 如果选择了带 @t{>} 的形式，那么写入该特殊文件将为 @var{list} 提供输入。 如果使用 @t{<}，那么作为参数传递的文件将连接到 @var{list} 进程的输出。 例如"

#. type: example
#: zsh.texi:4794
#, no-wrap
msgid ""
"@t{paste <(cut -f1} @var{file1}@t{) <(cut -f3} @var{file2}@t{) |\n"
"tee >(}@var{process1}@t{) >(}@var{process2}@t{) >/dev/null}\n"
msgstr ""
"@t{paste <(cut -f1} @var{file1}@t{) <(cut -f3} @var{file2}@t{) |\n"
"tee >(}@var{process1}@t{) >(}@var{process2}@t{) >/dev/null}\n"

#. type: Plain text
#: zsh.texi:4800
msgid "cuts fields 1 and 3 from the files @var{file1} and @var{file2} respectively, pastes the results together, and sends it to the processes @var{process1} and @var{process2}."
msgstr "分别从文件 @var{file1} 和 @var{file2} 中剪切字段 1 和 3，将剪切结果粘贴在一起，然后发送给进程 @var{process1} 和 @var{process2} 。"

#. type: Plain text
#: zsh.texi:4809
msgid ""
"If @t{=(}@var{...}@t{)} is used instead of @t{<(}@var{...}@t{)}, then the file passed as an argument will be the name of a temporary file containing the output of the @var{list} process.  This may be used "
"instead of the @t{<} form for a program that expects to lseek (see lseek(2))  on the input file."
msgstr ""
"如果使用 @t{=(}@var{...}@t{)}，而不是  @t{<(}@var{...}@t{)}，那么作为参数传递的文件将是一个包含 @var{list} 进程输出的临时文件的名称。 如果程序希望对输入文件进行 lseek（参见 lseek(2)），则可以用这种形式代"
"替 @t{<} 形式。"

#. type: Plain text
#: zsh.texi:4819
msgid ""
"There is an optimisation for substitutions of the form @t{=(<<<}@var{arg}@t{)}, where @var{arg} is a single-word argument to the here-string redirection @t{<<<}.  This form produces a file name containing "
"the value of @var{arg} after any substitutions have been performed.  This is handled entirely within the current shell.  This is effectively the reverse of the special form @t{$(<}@var{arg}@t{)} which "
"treats @var{arg} as a file name and replaces it with the file's contents."
msgstr ""
"对 @t{=(<<<}@var{arg}@t{)}形式的替换进行了优化，其中 @var{arg} 是 here-string 重定向 @t{<<<} 的单字参数。 在执行任何替换后，这种形式将生成一个包含 @var{arg} 值的文件名。 这完全由当前 shell 处理。 这实际上"
"是特殊形式 @t{$(<}@var{arg}@t{)} 的反向操作，后者将 @var{arg} 作为文件名并替换为文件内容。"

#. type: Plain text
#: zsh.texi:4833
msgid ""
"The @t{=} form is useful as both the @t{/dev/fd} and the named pipe implementation of @t{<(}@var{...}@t{)} have drawbacks.  In the former case, some programmes may automatically close the file descriptor "
"in question before examining the file on the command line, particularly if this is necessary for security reasons such as when the programme is running setuid.  In the second case, if the programme does "
"not actually open the file, the subshell attempting to read from or write to the pipe will (in a typical implementation, different operating systems may have different behaviour) block for ever and have "
"to be killed explicitly.  In both cases, the shell actually supplies the information using a pipe, so that programmes that expect to lseek (see lseek(2)) on the file will not work."
msgstr ""
"@t{=} 形式非常有用，因为 @t{/dev/fd} 和 @t{<(}@var{...}@t{)} 的命名管道实现都有缺点。 在前一种情况下，某些程序可能会在检查命令行上的文件之前自动关闭相关的文件描述符，尤其是出于安全原因必须这样做时，例如当"
"程序正在运行 setuid 时。 在第二种情况下，如果程序没有实际打开文件，试图从管道读取或向管道写入的子shell（在典型的实现中，不同的操作系统可能有不同的行为）将永远阻塞，必须明确地被杀死。 在这两种情况下，shell "
"实际上是通过管道提供信息的，因此那些希望在文件上进行 lseek（见 lseek(2)）的程序将无法运行。"

#. type: Plain text
#: zsh.texi:4837
msgid "Also note that the previous example can be more compactly and efficiently written (provided the @t{MULTIOS} option is set) as:"
msgstr "另外要注意的是，前面的例子可以更简洁、更高效地写成（如果设置了 @t{MULTIOS} 选项）："

#. type: example
#: zsh.texi:4841
#, no-wrap
msgid "@t{paste <(cut -f1} @var{file1}@t{) <(cut -f3} @var{file2}@t{)} @t{> >(}@var{process1}@t{) > >(}@var{process2}@t{)}\n"
msgstr "@t{paste <(cut -f1} @var{file1}@t{) <(cut -f3} @var{file2}@t{)} @t{> >(}@var{process1}@t{) > >(}@var{process2}@t{)}\n"

#. type: Plain text
#: zsh.texi:4846
msgid "The shell uses pipes instead of FIFOs to implement the latter two process substitutions in the above example."
msgstr "shell 使用管道而不是 FIFOs 来实现上例中后两个进程的替换。"

#. type: Plain text
#: zsh.texi:4855
msgid ""
"There is an additional problem with @t{>(}@var{process}@t{)}; when this is attached to an external command, the parent shell does not wait for @var{process} to finish and hence an immediately following "
"command cannot rely on the results being complete.  The problem and solution are the same as described in the section @emph{MULTIOS} in @ref{Redirection}.  Hence in a simplified version of the example "
"above:"
msgstr ""
"@t{>(}@var{process}@t{)}还有一个问题；当它附加到外部命令时，父 shell 不会等待 @var{process} 结束，因此紧随其后的命令无法依赖于完整的结果。 问题和解决方案与 @ref{重定向} 中 @emph{MULTIOS} 部分所述相同。 因"
"此，在上述示例的简化版本中："

#. type: example
#: zsh.texi:4859
#, no-wrap
msgid "@t{paste <(cut -f1} @var{file1}@t{) <(cut -f3} @var{file2}@t{)} @t{> >(}@var{process}@t{)}\n"
msgstr "@t{paste <(cut -f1} @var{file1}@t{) <(cut -f3} @var{file2}@t{)} @t{> >(}@var{process}@t{)}\n"

#. type: Plain text
#: zsh.texi:4864
msgid "(note that no @t{MULTIOS} are involved), @var{process} will be run asynchronously as far as the parent shell is concerned.  The workaround is:"
msgstr "(注意不涉及 @t{MULTIOS}），则 @var{process} 将在父 shell 中异步运行。 解决方法是"

#. type: example
#: zsh.texi:4868
#, no-wrap
msgid "@t{@{ paste <(cut -f1} @var{file1}@t{) <(cut -f3} @var{file2}@t{) @}} @t{> >(}@var{process}@t{)}\n"
msgstr "@t{@{ paste <(cut -f1} @var{file1}@t{) <(cut -f3} @var{file2}@t{) @}} @t{> >(}@var{process}@t{)}\n"

#. type: Plain text
#: zsh.texi:4873
msgid "The extra processes here are spawned from the parent shell which will wait for their completion."
msgstr "这里的额外进程是从父 shell 生成的，父 shell 会等待进程完成。"

#. type: Plain text
#: zsh.texi:4881
msgid ""
"Another problem arises any time a job with a substitution that requires a temporary file is disowned by the shell, including the case where `@t{&!}' or `@t{&|}' appears at the end of a command containing "
"a substitution.  In that case the temporary file will not be cleaned up as the shell no longer has any memory of the job.  A workaround is to use a subshell, for example,"
msgstr ""
"另一个问题出现在 shell 分离（disowned）需要临时文件的带有替换的作业时，包括在包含替换的命令末尾出现 `@t{&!}' 或 `@t{&|}' 的情况。 在这种情况下，临时文件将不会被清理，因为 shell 已不再拥有该任务的任何内"
"存。 解决方法是使用子 shell，例如"

#. type: example
#: zsh.texi:4885
#, no-wrap
msgid "(mycmd =(myoutput)) &!\n"
msgstr "(mycmd =(myoutput)) &!\n"

#. type: Plain text
#: zsh.texi:4890
msgid "as the forked subshell will wait for the command to finish then remove the temporary file."
msgstr "因为分叉(forked)的子shell会等待命令执行完毕，然后删除临时文件。"

#. type: Plain text
#: zsh.texi:4896
msgid ""
"A general workaround to ensure a process substitution endures for an appropriate length of time is to pass it as a parameter to an anonymous shell function (a piece of shell code that is run immediately "
"with function scope).  For example, this code:"
msgstr "要确保进程替换能持续适当的时间，一般的变通方法是将其作为参数传递给匿名 shell 函数（一段 shell 代码，在函数作用域下立即运行）。 例如，这段代码"

#. type: example
#: zsh.texi:4903
#, no-wrap
msgid ""
"() @{\n"
"   print File $1:\n"
"   cat $1\n"
"@} =(print This be the verse)\n"
msgstr ""
"() @{\n"
"   print File $1:\n"
"   cat $1\n"
"@} =(print This be the verse)\n"

#. type: Plain text
#: zsh.texi:4907
msgid "outputs something resembling the following"
msgstr "输出类似下面的内容"

#. type: example
#: zsh.texi:4912
#, no-wrap
msgid ""
"File /tmp/zsh6nU0kS:\n"
"This be the verse\n"
msgstr ""
"File /tmp/zsh6nU0kS:\n"
"This be the verse\n"

#. type: Plain text
#: zsh.texi:4917
msgid "The temporary file created by the process substitution will be deleted when the function exits."
msgstr "进程替换创建的临时文件将在函数退出时删除。"

#. type: cindex
#: zsh.texi:4923
#, no-wrap
msgid "parameter expansion"
msgstr "参数扩展"

#. type: cindex
#: zsh.texi:4924
#, no-wrap
msgid "expansion, parameter"
msgstr "扩展, 参数"

#. type: Plain text
#: zsh.texi:4930
msgid ""
"The character `@t{$}' is used to introduce parameter expansions.  See @ref{Parameters} for a description of parameters, including arrays, associative arrays, and subscript notation to access individual "
"array elements."
msgstr "字符 `@t{$}' 用于引入参数扩展。 有关参数的描述，包括数组、关联数组以及访问单个数组元素的下标符号，请参阅 @ref{参数}。"

#. type: Plain text
#: zsh.texi:4937
msgid ""
"Note in particular the fact that words of unquoted parameters are not automatically split on whitespace unless the option @t{SH_WORD_SPLIT} is set; see references to this option below for more details.  "
"This is an important difference from other shells.  However, as in other shells, null words are elided from unquoted parameters' expansions."
msgstr ""
"需要特别注意的是，除非设置了 @t{SH_WORD_SPLIT} 选项，否则未引用的参数的单词不会在空白处自动分隔；更多详情请参见下文对该选项的说明。 这是与其他 shell 的一个重要区别。 不过，和其他 shell 一样，空null字会从未"
"引用的参数的扩展中省略。"

#. type: Plain text
#: zsh.texi:4940
msgid "With default options, after the assignments:"
msgstr "在分配之后，使用默认选项："

#. type: example
#: zsh.texi:4945
#, no-wrap
msgid ""
"array=(\"first word\" \"\" \"third word\")\n"
"scalar=\"only word\"\n"
msgstr ""
"array=(\"first word\" \"\" \"third word\")\n"
"scalar=\"only word\"\n"

#. type: Plain text
#: zsh.texi:4954
msgid ""
"then @t{$array} substitutes two words, `@t{first word}' and `@t{third word}', and @t{$scalar} substitutes a single word `@t{only word}'.  Note that second element of @t{array} was elided.  Scalar "
"parameters can be elided too if their value is null (empty).  To avoid elision, use quoting as follows: @t{\"$scalar\"} for scalars and @t{\"$@{array[@@]@}\"} or @t{\"$@{(@@)array@}\"} for arrays.  (The "
"last two forms are equivalent.)"
msgstr ""
"则 @t{$array} 替换两个单词 `@t{first word}'  和 `@t{third word}' ，而 @t{$scalar} 替换一个单词 `@t{only word}'。 注意 @t{array} 的第二个元素已被省略。 如果标量参数的值为 null（空），也可以省略。 为避免省"
"略，请使用如下引用：@t{\"$scalar\"} 用于标量，@t{\"$@{array[@@]@}\"}  或  @t{\"$@{(@@)array@}\"}  用于数组。 (后两种形式是等价的）。"

#. type: Plain text
#: zsh.texi:4960
msgid ""
"Parameter expansions can involve @emph{flags}, as in `@t{$@{(@@kv)aliases@}}', and other operators, such as `@t{$@{PREFIX:-\"/usr/local\"@}}'.  Parameter expansions can also be nested.  These topics will "
"be introduced below.  The full rules are complicated and are noted at the end."
msgstr "参数扩展可以涉及 @emph{flags}，像在 `@t{$@{(@@kv)aliases@}}'中，和其他操作符，如 `@t{$@{PREFIX:-\"/usr/local\"@}}'。 参数扩展也可以嵌套。 下文将介绍这些主题。 完整的规则比较复杂，将在最后指出。"

#. type: Plain text
#: zsh.texi:4971
msgid ""
"In the expansions discussed below that require a pattern, the form of the pattern is the same as that used for filename generation; see @ref{Filename Generation}.  Note that these patterns, along with the "
"replacement text of any substitutions, are themselves subject to parameter expansion, command substitution, and arithmetic expansion.  In addition to the following operations, the colon modifiers "
"described in @ref{Modifiers} in @ref{History Expansion} can be applied: for example, @t{$@{i:s/foo/bar/@}} performs string substitution on the expansion of parameter @t{$i}."
msgstr ""
"在下面讨论的需要模式的扩展中，模式的形式与文件名生成时使用的形式相同；参见 @ref{文件名生成}。 需要注意的是，这些模式以及任何替换的替换文本本身都可以进行参数扩展、命令替换和算术扩展。 除以下操作外，还可以使"
"用 @ref{历史扩展} 中 @ref{修饰符} 所描述的冒号修饰符：例如，@t{$@{i:s/foo/bar/@}}  对参数 @t{$i} 的扩展执行字符串替换。"

#. type: Plain text
#: zsh.texi:4975
msgid "In the following descriptions, `@var{word}' refers to a single word substituted on the command line, not necessarily a space delimited word."
msgstr "在以下描述中，`@var{word}'  指的是命令行中替换的单个单词，不一定是空格分隔的单词。"

#. type: item
#: zsh.texi:4978
#, no-wrap
msgid "@t{$@{}@var{name}@t{@}}"
msgstr "@t{$@{}@var{name}@t{@}}"

#. type: table
#: zsh.texi:4988
msgid ""
"The value, if any, of the parameter @var{name} is substituted.  The braces are required if the expansion is to be followed by a letter, digit, or underscore that is not to be interpreted as part of "
"@var{name}.  In addition, more complicated forms of substitution usually require the braces to be present; exceptions, which only apply if the option @t{KSH_ARRAYS} is not set, are a single subscript or "
"any colon modifiers appearing after the name, or any of the characters `@t{^}', `@t{=}', `@t{~}', `@t{#}' or `@t{+}' appearing before the name, all of which work with or without braces."
msgstr ""
"参数 @var{name} 的值将被替换（如果有）。 如果扩展名后的字母、数字或下划线不能被解释为 @var{name} 的一部分，则需要使用大括号。 此外，更复杂的替换形式通常需要使用大括号；只有在未设置选项 @t{KSH_ARRAYS} 的情"
"况下才适用的例外情况是：在名称后面出现单个下标或任何冒号修饰符，或在名称前面出现任何字符@t{^}', `@t{=}', `@t{~}', `@t{#}' 或 `@t{+}'，无论是否使用大括号，这些情况都可以工作。"

#. type: table
#: zsh.texi:4997
msgid ""
"If @var{name} is an array parameter, and the @t{KSH_ARRAYS} option is not set, then the value of each element of @var{name} is substituted, one element per word.  Otherwise, the expansion results in one "
"word only; with @t{KSH_ARRAYS}, this is the first element of an array.  No field splitting is done on the result unless the @t{SH_WORD_SPLIT} option is set.  See also the flags @t{=} and @t{s:}@var{string}"
"@t{:}."
msgstr ""
"如果 @var{name} 是一个数组参数，且未设置 @t{KSH_ARRAYS} 选项，那么 @var{name} 中每个元素的值都会被替换，每个字替换一个元素。 否则，扩展只产生一个字；如果设置 @t{KSH_ARRAYS}，则是数组的第一个元素。 除非设置"
"了 @t{SH_WORD_SPLIT} 选项，否则不会对结果进行字段分割。 另请参阅 @t{=} 和 @t{s:}@var{string}@t{:} 标志。"

#. type: item
#: zsh.texi:4998
#, no-wrap
msgid "@t{$@{+}@var{name}@t{@}}"
msgstr "@t{$@{+}@var{name}@t{@}}"

#. type: table
#: zsh.texi:5001
msgid "If @var{name} is the name of a set parameter `@t{1}' is substituted, otherwise `@t{0}' is substituted."
msgstr "如果 @var{name} 是一个集合参数（a set parameter，一个已设置的参数？）的名称，则替换为 `@t{1}'，否则替换为 `@t{0}' 。"

#. type: item
#: zsh.texi:5002
#, no-wrap
msgid "@t{$@{}@var{name}@t{-}@var{word}@t{@}}"
msgstr "@t{$@{}@var{name}@t{-}@var{word}@t{@}}"

#. type: itemx
#: zsh.texi:5003
#, no-wrap
msgid "@t{$@{}@var{name}@t{:-}@var{word}@t{@}}"
msgstr "@t{$@{}@var{name}@t{:-}@var{word}@t{@}}"

#. type: table
#: zsh.texi:5007
msgid ""
"If @var{name} is set, or in the second form is non-null, then substitute its value; otherwise substitute @var{word}.  In the second form @var{name} may be omitted, in which case @var{word} is always "
"substituted."
msgstr "如果 @var{name} 已设置，或在第二种形式中为非空，则替换其值；否则替换 @var{word}。 在第二种形式中，@var{name} 可以省略，在这种情况下，@var{word} 总是被替换。"

#. type: item
#: zsh.texi:5008
#, no-wrap
msgid "@t{$@{}@var{name}@t{+}@var{word}@t{@}}"
msgstr "@t{$@{}@var{name}@t{+}@var{word}@t{@}}"

#. type: itemx
#: zsh.texi:5009
#, no-wrap
msgid "@t{$@{}@var{name}@t{:+}@var{word}@t{@}}"
msgstr "@t{$@{}@var{name}@t{:+}@var{word}@t{@}}"

#. type: table
#: zsh.texi:5012
msgid "If @var{name} is set, or in the second form is non-null, then substitute @var{word}; otherwise substitute nothing."
msgstr "如果 @var{name} 已设置，或第二种形式为非空，则替换 @var{word}；否则不替换任何内容。"

#. type: item
#: zsh.texi:5013
#, no-wrap
msgid "@t{$@{}@var{name}@t{=}@var{word}@t{@}}"
msgstr "@t{$@{}@var{name}@t{=}@var{word}@t{@}}"

#. type: itemx
#: zsh.texi:5014
#, no-wrap
msgid "@t{$@{}@var{name}@t{:=}@var{word}@t{@}}"
msgstr "@t{$@{}@var{name}@t{:=}@var{word}@t{@}}"

#. type: itemx
#: zsh.texi:5015
#, no-wrap
msgid "@t{$@{}@var{name}@t{::=}@var{word}@t{@}}"
msgstr "@t{$@{}@var{name}@t{::=}@var{word}@t{@}}"

#. type: table
#: zsh.texi:5020
msgid ""
"In the first form, if @var{name} is unset then set it to @var{word}; in the second form, if @var{name} is unset or null then set it to @var{word}; and in the third form, unconditionally set @var{name} to "
"@var{word}.  In all forms, the value of the parameter is then substituted."
msgstr ""
"在第一种形式中，如果 @var{name} 未设置，则将其设置为 @var{word}；在第二种形式中，如果 @var{name} 未设置或为空，则将其设置为 @var{word}；在第三种形式中，无条件地将 @var{name} 设置为 @var{word}。 在所有形式"
"中，参数值都会被替换。"

#. type: item
#: zsh.texi:5021
#, no-wrap
msgid "@t{$@{}@var{name}@t{?}@var{word}@t{@}}"
msgstr "@t{$@{}@var{name}@t{?}@var{word}@t{@}}"

#. type: itemx
#: zsh.texi:5022
#, no-wrap
msgid "@t{$@{}@var{name}@t{:?}@var{word}@t{@}}"
msgstr "@t{$@{}@var{name}@t{:?}@var{word}@t{@}}"

#. type: table
#: zsh.texi:5027
msgid ""
"In the first form, if @var{name} is set, or in the second form if @var{name} is both set and non-null, then substitute its value; otherwise, print @var{word} and exit from the shell.  Interactive shells "
"instead return to the prompt.  If @var{word} is omitted, then a standard message is printed."
msgstr ""
"在第一种形式中，如果 @var{name} 已设置，或在第二种形式中，如果 @var{name} 设置且非空，则替换其值；否则，打印 @var{word} 并退出 shell。 交互式 shell 则返回提示符。 如果省略 @var{word}，则打印标准信息。"

#. type: Plain text
#: zsh.texi:5036
msgid ""
"In any of the above expressions that test a variable and substitute an alternate @var{word}, note that you can use standard shell quoting in the @var{word} value to selectively override the splitting done "
"by the @t{SH_WORD_SPLIT} option and the @t{=} flag, but not splitting by the @t{s:}@var{string}@t{:} flag."
msgstr ""
"在上述任何一个测试变量并替换可选的 @var{word} 的表达式中，请注意可以在 @var{word} 值中使用标准 shell 引用，有选择性地覆盖 @t{SH_WORD_SPLIT} 选项和 @t{=} 标记的分割，但不覆盖 @t{s:}@var{string}@t{:} 标记的"
"分割。"

#. type: Plain text
#: zsh.texi:5042
msgid ""
"In the following expressions, when @var{name} is an array and the substitution is not quoted, or if the `@t{(@@)}' flag or the @var{name}@t{[@@]} syntax is used, matching and replacement is performed on "
"each array element separately."
msgstr "在下面的表达式中，如果 @var{name} 是数组且替换未加引号，或者使用了 `@t{(@@)}' 标志或 @var{name}@t{[@@]} 语法，则会对每个数组元素分别执行匹配和替换。"

#. type: item
#: zsh.texi:5045
#, no-wrap
msgid "@t{$@{}@var{name}@t{#}@var{pattern}@t{@}}"
msgstr "@t{$@{}@var{name}@t{#}@var{pattern}@t{@}}"

#. type: itemx
#: zsh.texi:5046
#, no-wrap
msgid "@t{$@{}@var{name}@t{##}@var{pattern}@t{@}}"
msgstr "@t{$@{}@var{name}@t{##}@var{pattern}@t{@}}"

#. type: table
#: zsh.texi:5054
msgid ""
"If the @var{pattern} matches the beginning of the value of @var{name}, then substitute the value of @var{name} with the matched portion deleted; otherwise, just substitute the value of @var{name}.  In the "
"first form, the smallest matching pattern is preferred; in the second form, the largest matching pattern is preferred."
msgstr ""
"如果 @var{pattern} 与 @var{name} 值的开头部分匹配，则替换 @var{name} 值并删除匹配部分；否则，只替换 @var{name} 值。 在第一种形式中，优先使用匹配度最小的模式；在第二种形式中，优先使用匹配度最大的模式。"

#. type: item
#: zsh.texi:5055
#, no-wrap
msgid "@t{$@{}@var{name}@t{%}@var{pattern}@t{@}}"
msgstr "@t{$@{}@var{name}@t{%}@var{pattern}@t{@}}"

#. type: itemx
#: zsh.texi:5056
#, no-wrap
msgid "@t{$@{}@var{name}@t{%%}@var{pattern}@t{@}}"
msgstr "@t{$@{}@var{name}@t{%%}@var{pattern}@t{@}}"

#. type: table
#: zsh.texi:5064
msgid ""
"If the @var{pattern} matches the end of the value of @var{name}, then substitute the value of @var{name} with the matched portion deleted; otherwise, just substitute the value of @var{name}.  In the first "
"form, the smallest matching pattern is preferred; in the second form, the largest matching pattern is preferred."
msgstr "如果 @var{pattern} 与 @var{name} 值的末尾匹配，则替换 @var{name} 值并删除匹配部分；否则，只替换 @var{name} 值。 在第一种形式中，优先使用匹配度最小的模式；在第二种形式中，优先使用匹配度最大的模式。"

#. type: item
#: zsh.texi:5065
#, no-wrap
msgid "@t{$@{}@var{name}@t{:#}@var{pattern}@t{@}}"
msgstr "@t{$@{}@var{name}@t{:#}@var{pattern}@t{@}}"

#. type: table
#: zsh.texi:5071
msgid ""
"If the @var{pattern} matches the value of @var{name}, then substitute the empty string; otherwise, just substitute the value of @var{name}.  If @var{name} is an array the matching array elements are "
"removed (use the `@t{(M)}' flag to remove the non-matched elements)."
msgstr "如果 @var{pattern} 与 @var{name} 的值匹配，则替换空字符串；否则，只替换 @var{name} 的值。 如果 @var{name} 是一个数组，则会删除匹配的数组元素（使用  `@t{(M)}' 标志删除不匹配的元素）。"

#. type: item
#: zsh.texi:5072
#, no-wrap
msgid "@t{$@{}@var{name}@t{:|}@var{arrayname}@t{@}}"
msgstr "@t{$@{}@var{name}@t{:|}@var{arrayname}@t{@}}"

#. type: table
#: zsh.texi:5079
msgid ""
"If @var{arrayname} is the name (N.B., not contents) of an array variable, then any elements contained in @var{arrayname} are removed from the substitution of @var{name}.  If the substitution is scalar, "
"either because @var{name} is a scalar variable or the expression is quoted, the elements of @var{arrayname} are instead tested against the entire expression."
msgstr ""
"如果 @var{arrayname} 是数组变量的名称（注意，不是内容），那么 @var{arrayname} 中包含的任何元素都会从 @var{name} 的替换中删除。 如果是标量替换（因为 @var{name} 是标量变量或表达式是带引号的），则 "
"@var{arrayname} 中的元素将针对整个表达式进行测试。"

#. type: item
#: zsh.texi:5080
#, no-wrap
msgid "@t{$@{}@var{name}@t{:*}@var{arrayname}@t{@}}"
msgstr "@t{$@{}@var{name}@t{:*}@var{arrayname}@t{@}}"

#. type: table
#: zsh.texi:5084
msgid "Similar to the preceding substitution, but in the opposite sense, so that entries present in both the original substitution and as elements of @var{arrayname} are retained and others removed."
msgstr "与前面的替换类似，但意义相反，原始替换中的条目和作为 @var{arrayname} 元素的条目将保留下来，删除其他条目。"

#. type: item
#: zsh.texi:5085
#, no-wrap
msgid "@t{$@{}@var{name}@t{:^}@var{arrayname}@t{@}}"
msgstr "@t{$@{}@var{name}@t{:^}@var{arrayname}@t{@}}"

#. type: itemx
#: zsh.texi:5086
#, no-wrap
msgid "@t{$@{}@var{name}@t{:^^}@var{arrayname}@t{@}}"
msgstr "@t{$@{}@var{name}@t{:^^}@var{arrayname}@t{@}}"

#. type: table
#: zsh.texi:5092
msgid ""
"Zips two arrays, such that the output array is twice as long as the shortest (longest for `@t{:^^}') of @t{name} and @t{arrayname}, with the elements alternatingly being picked from them. For `@t{:^}', if "
"one of the input arrays is longer, the output will stop when the end of the shorter array is reached.  Thus,"
msgstr ""
"对两个数组进行压缩，使输出数组的长度是 @t{name} 和 @t{arrayname} 中最短（对于 `@t{:^^}'，最长）数组的两倍，并交替从中提取元素。对于 `@t{:^}'，如果其中一个输入数组较长，输出将在到达较短数组的末尾时停止。 因"
"此"

#. type: example
#: zsh.texi:5096
#, no-wrap
msgid "a=(1 2 3 4); b=(a b); print $@{a:^b@}\n"
msgstr "a=(1 2 3 4); b=(a b); print $@{a:^b@}\n"

#. type: table
#: zsh.texi:5102
msgid "will output `@t{1 a 2 b}'.  For `@t{:^^}', then the input is repeated until all of the longer array has been used up and the above will output `@t{1 a 2 b 3 a 4 b}'."
msgstr "将输出 `@t{1 a 2 b}'。 如果是  `@t{:^^}'，则重复输入，直到用完所有较长的数组，然后输出 `@t{1 a 2 b 3 a 4 b}'。"

#. type: table
#: zsh.texi:5107
msgid ""
"Either or both inputs may be a scalar, they will be treated as an array of length 1 with the scalar as the only element. If either array is empty, the other array is output with no extra elements inserted."
msgstr "任一输入或两个输入都可以是标量，它们将被视为长度为 1 的数组，标量是唯一的元素。如果任一数组为空，则输出另一个数组，不插入任何额外元素。"

#. type: table
#: zsh.texi:5112
msgid ""
"Currently the following code will output `@t{a b}' and `@t{1}' as two separate elements, which can be unexpected. The second print provides a workaround which should continue to work if this is changed."
msgstr "目前，以下代码会将 `@t{a b}' 和 `@t{1}' 作为两个独立的元素输出，这可能会出乎意料。第二段打印提供了一个变通方法，如果修改了这一方法，它也能继续工作。"

#. type: example
#: zsh.texi:5116
#, no-wrap
msgid "a=(a b); b=(1 2); print -l \"$@{a:^b@}\"; print -l \"$@{$@{a:^b@}@}\"\n"
msgstr "a=(a b); b=(1 2); print -l \"$@{a:^b@}\"; print -l \"$@{$@{a:^b@}@}\"\n"

#. type: item
#: zsh.texi:5118
#, no-wrap
msgid "@t{$@{}@var{name}@t{:}@var{offset}@t{@}}"
msgstr "@t{$@{}@var{name}@t{:}@var{offset}@t{@}}"

#. type: itemx
#: zsh.texi:5119
#, no-wrap
msgid "@t{$@{}@var{name}@t{:}@var{offset}@t{:}@var{length}@t{@}}"
msgstr "@t{$@{}@var{name}@t{:}@var{offset}@t{:}@var{length}@t{@}}"

#. type: table
#: zsh.texi:5124
msgid ""
"This syntax gives effects similar to parameter subscripting in the form @t{$}@var{name}@t{[}@var{start}@t{,}@var{end}@t{]}, but is compatible with other shells; note that both @var{offset} and "
"@var{length} are interpreted differently from the components of a subscript."
msgstr "该语法的效果类似于 @t{$}@var{name}@t{[}@var{start}@t{,}@var{end}@t{]} 形式的参数下标，但与其他 shell 兼容；需要注意的是，@var{offset} 和 @var{length} 的解释与下标部分不同。"

#. type: table
#: zsh.texi:5132
msgid ""
"If @var{offset} is non-negative, then if the variable @var{name} is a scalar substitute the contents starting @var{offset} characters from the first character of the string, and if @var{name} is an array "
"substitute elements starting @var{offset} elements from the first element.  If @var{length} is given, substitute that many characters or elements, otherwise the entire rest of the scalar or array."
msgstr ""
"如果 @var{offset} 为非负数，那么如果变量 @var{name} 是标量，则从字符串的第一个字符开始，替换 @var{offset} 个字符的内容；如果 @var{name} 是数组，则替换从第一个元素开始， @var{offset}个元素。 如果给定了 "
"@var{length}，则替换该数量的字符或元素，否则替换整个标量或数组的其余部分。（offset是指第几个字符开始的内容？）"

#. type: table
#: zsh.texi:5139
msgid ""
"A positive @var{offset} is always treated as the offset of a character or element in @var{name} from the first character or element of the array (this is different from native zsh subscript notation).  "
"Hence 0 refers to the first character or element regardless of the setting of the option @t{KSH_ARRAYS}."
msgstr "正数 @var{offset} 始终被视为 @var{name} 中的字符或元素从第一个字符或数组的元素开始的偏移量（这与原生的 zsh 下标符号不同）。 因此，无论选项 @t{KSH_ARRAYS} 的设置如何，0 都是指第一个字符或元素。"

#. type: table
#: zsh.texi:5143
msgid "A negative offset counts backwards from the end of the scalar or array, so that -1 corresponds to the last character or element, and so on."
msgstr "负偏移量从标量或数组的末尾开始向后计数，因此-1 相当于最后一个字符或元素，以此类推。"

#. type: table
#: zsh.texi:5149
msgid ""
"When positive, @var{length} counts from the @var{offset} position toward the end of the scalar or array.  When negative, @var{length} counts back from the end.  If this results in a position smaller than "
"@var{offset}, a diagnostic is printed and nothing is substituted."
msgstr ""
"当为正数时，@var{length} 从 @var{offset} 位置开始向标量或数组的末尾计数。 负数时，@var{length} 从末尾开始向后（back）计数。 如果结果显示的位置小于 @var{offset}，则会打印诊断信息，并且不会替换任何内容。"

#. type: table
#: zsh.texi:5153
msgid "The option @t{MULTIBYTE} is obeyed, i.e. the offset and length count multibyte characters where appropriate."
msgstr "遵从 @t{MULTIBYTE} 选项，即偏移量和长度会酌情计算多字节字符。"

#. type: table
#: zsh.texi:5158
msgid "@var{offset} and @var{length} undergo the same set of shell substitutions as for scalar assignment; in addition, they are then subject to arithmetic evaluation.  Hence, for example"
msgstr "@var{offset} 和 @var{length} 会进行与标量赋值相同的 shell 替换；此外，它们还需要进行算术运算。 因此，例如"

#. type: example
#: zsh.texi:5165
#, no-wrap
msgid ""
"print $@{foo:3@}\n"
"print $@{foo: 1 + 2@}\n"
"print $@{foo:$(( 1 + 2))@}\n"
"print $@{foo:$(echo 1 + 2)@}\n"
msgstr ""
"print $@{foo:3@}\n"
"print $@{foo: 1 + 2@}\n"
"print $@{foo:$(( 1 + 2))@}\n"
"print $@{foo:$(echo 1 + 2)@}\n"

#. type: table
#: zsh.texi:5175
msgid ""
"all have the same effect, extracting the string starting at the fourth character of @t{$foo} if the substitution would otherwise return a scalar, or the array starting at the fourth element if @t{$foo} "
"would return an array.  Note that with the option @t{KSH_ARRAYS} @t{$foo} always returns a scalar (regardless of the use of the offset syntax) and a form such as @t{$@{foo[*]:3@}} is required to extract "
"elements of an array named @t{foo}."
msgstr ""
"都有相同的效果，如果替换返回的是标量，则从 @t{$foo} 的第四个字符开始提取字符串；如果 @t{$foo} 返回的是数组，则从第四个元素开始提取数组。 请注意，使用 @t{KSH_ARRAYS} 选项时 @t{$foo} 返回的总是标量（无论是否"
"使用偏移量语法），因此需要使用  @t{$@{foo[*]:3@}}  这样的形式来提取名为 @t{foo} 的数组的元素。"

#. type: table
#: zsh.texi:5188
msgid ""
"If @var{offset} is negative, the @t{-} may not appear immediately after the @t{:} as this indicates the @t{$@{}@var{name}@t{:-}@var{word}@t{@}} form of substitution.  Instead, a space may be inserted "
"before the @t{-}.  Furthermore, neither @var{offset} nor @var{length} may begin with an alphabetic character or @t{&} as these are used to indicate history-style modifiers.  To substitute a value from a "
"variable, the recommended approach is to precede it with a @t{$} as this signifies the intention (parameter substitution can easily be rendered unreadable); however, as arithmetic substitution is "
"performed, the expression @t{$@{var: offs@}} does work, retrieving the offset from @t{$offs}."
msgstr ""
"如果 @var{offset} 为负数，则 @t{-} 不能紧接在 @t{:} 之后，因为这表示  @t{$@{}@var{name}@t{:-}@var{word}@t{@}}的替换形式。 相反，可以在 @t{-} 之前插入一个空格。 此外，@var{offset} 和 @var{length} 都不能以字"
"母或 @t{&} 开头，因为这些字符用于表示历史类型的修饰符。 要从变量中替换一个值，建议在前面加上 @t{$}，因为这表示了意图（参数替换很容易导致无法读取）；不过，由于执行的是算术替换，表达式 @t{$@{var: offs@}} 确"
"实有效，可以从 @t{$offs} 中获取偏移量。"

#. type: table
#: zsh.texi:5198
msgid ""
"For further compatibility with other shells there is a special case for array offset 0.  This usually accesses the first element of the array.  However, if the substitution refers to the positional "
"parameter array, e.g. @t{$@@} or @t{$*}, then offset 0 instead refers to @t{$0}, offset 1 refers to @t{$1}, and so on.  In other words, the positional parameter array is effectively extended by prepending "
"@t{$0}.  Hence @t{$@{*:0:1@}} substitutes @t{$0} and @t{$@{*:1:1@}} substitutes @t{$1}."
msgstr ""
"为了进一步与其他 shell 兼容，数组偏移量 0 有一个特殊情况。 这通常会访问数组的第一个元素。 但是，如果替换指向位置参数数组，例如 @t{$@@} 或 @t{$*}，则偏移量 0 指向 @t{$0}，偏移量 1 指向 @t{$1}，依此类推。 换"
"句话说，位置参数数组实际上是通过预置 @t{$0} 来扩展的。  因此，@t{$@{*:0:1@}} 替代 @t{$0}，@t{$@{*:1:1@}} 替代 @t{$1}。"

#. type: item
#: zsh.texi:5199
#, no-wrap
msgid "@t{$@{}@var{name}@t{/}@var{pattern}@t{/}@var{repl}@t{@}}"
msgstr "@t{$@{}@var{name}@t{/}@var{pattern}@t{/}@var{repl}@t{@}}"

#. type: itemx
#: zsh.texi:5200
#, no-wrap
msgid "@t{$@{}@var{name}@t{//}@var{pattern}@t{/}@var{repl}@t{@}}"
msgstr "@t{$@{}@var{name}@t{//}@var{pattern}@t{/}@var{repl}@t{@}}"

#. type: itemx
#: zsh.texi:5201
#, no-wrap
msgid "@t{$@{}@var{name}@t{:/}@var{pattern}@t{/}@var{repl}@t{@}}"
msgstr "@t{$@{}@var{name}@t{:/}@var{pattern}@t{/}@var{repl}@t{@}}"

#. type: table
#: zsh.texi:5211
msgid ""
"Replace the longest possible match of @var{pattern} in the expansion of parameter @var{name} by string @var{repl}.  The first form replaces just the first occurrence, the second form all occurrences, and "
"the third form replaces only if @var{pattern} matches the entire string.  Both @var{pattern} and @var{repl} are subject to double-quoted substitution, so that expressions like @t{$@{name/$opat/$npat@}} "
"will work, but obey the usual rule that pattern characters in @t{$opat} are not treated specially unless either the option @t{GLOB_SUBST} is set, or @t{$opat} is instead substituted as @t{$@{~opat@}}."
msgstr ""
"用字符串 @var{repl} 替换参数 @var{name} 扩展中可能与 @var{pattern} 匹配的最长字符串。 第一种形式只替换第一次出现的字符串，第二种形式替换所有出现的字符串，第三种形式仅在 @var{pattern} 与整个字符串匹配时才替"
"换。 @var{pattern} 和 @var{repl} 都会进行双引号替换，因此 @t{$@{name/$opat/$npat@}} 这样的表达式可以正常工作，但要遵守通常的规则，即 @t{$opat} 中的模式字符不会被特殊处理，除非设置了 @t{GLOB_SUBST} 选项，或"
"者 @t{$opat} 被替换为 @t{$@{~opat@}}。"

#. type: table
#: zsh.texi:5223
msgid ""
"The @var{pattern} may begin with a `@t{#}', in which case the @var{pattern} must match at the start of the string, or `@t{%}', in which case it must match at the end of the string, or `@t{#%}' in which "
"case the @var{pattern} must match the entire string.  The @var{repl} may be an empty string, in which case the final `@t{/}' may also be omitted.  To quote the final `@t{/}' in other cases it should be "
"preceded by a single backslash; this is not necessary if the `@t{/}' occurs inside a substituted parameter.  Note also that the `@t{#}', `@t{%}' and `@t{#%} are not active if they occur inside a "
"substituted parameter, even at the start."
msgstr ""
"@var{pattern} 可以以 `@t{#}' 开头，在这种情况下，@var{pattern} 必须匹配字符串的开头；或者以 `@t{#}' 开头，在这种情况下，@var{pattern} 必须匹配字符串的结尾；或者以 `@t{#%}' 开头，在这种情况下，"
"@var{pattern} 必须匹配整个字符串。 @var{repl} 可以是空字符串，在这种情况下，也可以省略最后的 `@t{/}'。 在其他情况下，要引用最后的 `@t{/}'，应在其前面加一个反斜线；如果 `@t{/}' 出现在一个被替换的参数中，则"
"不必这样做。 还需注意的是， `@t{#}', `@t{%}' 和 `@t{#%} 如果出现在被替换参数内，即使是在起始位置，也不会被激活。"

#. type: table
#: zsh.texi:5229
msgid ""
"If, after quoting rules apply, @t{$@{}@var{name}@t{@}} expands to an array, the replacements act on each element individually.  Note also the effect of the @t{I} and @t{S} parameter expansion flags below; "
"however, the flags @t{M}, @t{R}, @t{B}, @t{E} and @t{N} are not useful."
msgstr "如果在引用规则应用后，@t{$@{}@var{name}@t{@}} 扩展为一个数组，那么替换将单独作用于每个元素。 请注意下面 @t{I} 和 @t{S} 参数扩展标志的作用；但 @t{M}、@t{R}、@t{B}、@t{E} 和 @t{N} 标志并无用处。"

#. type: example
#: zsh.texi:5238
#, no-wrap
msgid ""
"foo=\"twinkle twinkle little star\" sub=\"t*e\" rep=\"spy\"\n"
"print $@{foo//$@{~sub@}/$rep@}\n"
"print $@{(S)foo//$@{~sub@}/$rep@}\n"
msgstr ""
"foo=\"twinkle twinkle little star\" sub=\"t*e\" rep=\"spy\"\n"
"print $@{foo//$@{~sub@}/$rep@}\n"
"print $@{(S)foo//$@{~sub@}/$rep@}\n"

#. type: table
#: zsh.texi:5246
msgid ""
"Here, the `@t{~}' ensures that the text of @t{$sub} is treated as a pattern rather than a plain string.  In the first case, the longest match for @t{t*e} is substituted and the result is `@t{spy star}', "
"while in the second case, the shortest matches are taken and the result is `@t{spy spy lispy star}'."
msgstr "这里， `@t{~}' 确保 @t{$sub} 的文本被视为模式而非普通字符串。 在第一种情况下，@t{t*e} 的最长匹配项被替换，结果为 `@t{spy star}'，而在第二种情况下，最短匹配项被替换，结果为 `@t{spy spy lispy star}'。"

#. type: item
#: zsh.texi:5247
#, no-wrap
msgid "@t{$@{#}@var{spec}@t{@}}"
msgstr "@t{$@{#}@var{spec}@t{@}}"

#. type: table
#: zsh.texi:5256
msgid ""
"If @var{spec} is one of the above substitutions, substitute the length in characters of the result instead of the result itself.  If @var{spec} is an array expression, substitute the number of elements of "
"the result.  This has the side-effect that joining is skipped even in quoted forms, which may affect other sub-expressions in @var{spec}.  Note that `@t{^}', `@t{=}', and `@t{~}', below, must appear to "
"the left of `@t{#}' when these forms are combined."
msgstr ""
"如果 @var{spec} 是上述替换之一，则替换结果的字符长度，而不是结果本身。 如果 @var{spec} 是数组表达式，则用结果的元素个数代替。 这样做的副作用是，即使是带引号的形式，也会跳过连接，这可能会影响 @var{spec} 中"
"的其他子表达式。 请注意，下面的 `@t{^}'， `@t{=}' 和 `@t{~}' 在组合这些形式时必须出现在 `@t{#}'  的左边。"

#. type: table
#: zsh.texi:5264
msgid ""
"If the option @t{POSIX_IDENTIFIERS} is not set, and @var{spec} is a simple name, then the braces are optional; this is true even for special parameters so e.g. @t{$#-} and @t{$#*} take the length of the "
"string @t{$-} and the array @t{$*} respectively.  If @t{POSIX_IDENTIFIERS} is set, then braces are required for the @t{#} to be treated in this fashion."
msgstr ""
"如果未设置选项 @t{POSIX_IDENTIFIERS}，并且 @var{spec} 是一个简单的名称，那么大括号是可选的；即使对于特殊参数也是如此，例如 @t{$#-} 和 @t{$#*} 分别取字符串 @t{$-} 和数组 @t{$*} 的长度。 如果设置了 "
"@t{POSIX_IDENTIFIERS}，则需要使用大括号来处理 @t{#}。"

#. type: item
#: zsh.texi:5265
#, no-wrap
msgid "@t{$@{^}@var{spec}@t{@}}"
msgstr "@t{$@{^}@var{spec}@t{@}}"

#. type: itemx
#: zsh.texi:5266
#, no-wrap
msgid "@t{$@{^^}@var{spec}@t{@}}"
msgstr "@t{$@{^^}@var{spec}@t{@}}"

#. type: pindex
#: zsh.texi:5267
#, no-wrap
msgid "RC_EXPAND_PARAM, toggle"
msgstr "RC_EXPAND_PARAM, 切换"

#. type: cindex
#: zsh.texi:5268
#, no-wrap
msgid "array expansion style, rc"
msgstr "数组扩展风格, rc"

#. type: cindex
#: zsh.texi:5269
#, no-wrap
msgid "rc, array expansion style"
msgstr "rc, 数组扩展风格"

#. type: table
#: zsh.texi:5279
msgid ""
"Turn on the @t{RC_EXPAND_PARAM} option for the evaluation of @var{spec}; if the `@t{^}' is doubled, turn it off.  When this option is set, array expansions of the form @var{foo}@t{$@{}@var{xx}@t{@}}"
"@var{bar}, where the parameter @var{xx} is set to @t{(}@var{a b c}@t{)}, are substituted with `@var{fooabar foobbar foocbar}' instead of the default `@var{fooa b cbar}'.  Note that an empty array will "
"therefore cause all arguments to be removed."
msgstr ""
"打开 @t{RC_EXPAND_PARAM} 选项，用于 @var{spec} 的求值；如果 `@t{^}' 双写，则关闭该选项。  设置该选项后， @var{foo}@t{$@{}@var{xx}@t{@}}@var{bar}形式的数组扩展会被替换为 `@var{fooabar foobbar foocbar}' ，而"
"不是默认的 `@var{fooa b cbar}'。其中参数 @var{xx} 被设置为 @t{(}@var{a b c}@t{)}。 请注意，如果数组为空，所有参数都会被移除。"

#. type: table
#: zsh.texi:5289
msgid ""
"Internally, each such expansion is converted into the equivalent list for brace expansion.  E.g., @t{$@{^var@}} becomes @t{@{$var[1],$var[2],}...@t{@}}, and is processed as described in @ref{Brace "
"Expansion} below: note, however, the expansion happens immediately, with any explicit brace expansion happening later.  If word splitting is also in effect the @t{$var[}@var{N}@t{]} may themselves be "
"split into different list elements."
msgstr ""
"在内部，每个此类扩展都会转换为括号扩展的等效列表。 例如，@t{$@{^var@}} 变为 @t{@{$var[1],$var[2],}...@t{@}}，并按照下面 @ref{括号扩展} 中的描述进行处理：但请注意，扩展是立即进行的，任何显式的括号扩展都会在"
"后面进行。 如果同时进行分词，@t{$var[}@var{N}@t{]} 本身可能会被分割成不同的列表元素。"

#. type: item
#: zsh.texi:5290
#, no-wrap
msgid "@t{$@{=}@var{spec}@t{@}}"
msgstr "@t{$@{=}@var{spec}@t{@}}"

#. type: itemx
#: zsh.texi:5291
#, no-wrap
msgid "@t{$@{==}@var{spec}@t{@}}"
msgstr "@t{$@{==}@var{spec}@t{@}}"

#. type: pindex
#: zsh.texi:5292
#, no-wrap
msgid "SH_WORD_SPLIT, toggle"
msgstr "SH_WORD_SPLIT, 切换"

#. type: cindex
#: zsh.texi:5293
#, no-wrap
msgid "field splitting, sh style, parameter"
msgstr "字段分割, sh 样式, 参数"

#. type: cindex
#: zsh.texi:5294
#, no-wrap
msgid "sh, field splitting style, parameter"
msgstr "sh, 字段分割样式, 参数"

#. type: table
#: zsh.texi:5298
msgid ""
"Perform word splitting using the rules for @t{SH_WORD_SPLIT} during the evaluation of @var{spec}, but regardless of whether the parameter appears in double quotes; if the `@t{=}' is doubled, turn it off."
msgstr "在计算 @var{spec} 时，使用 @t{SH_WORD_SPLIT} 的规则进行分词，但无论参数是否出现在双引号中；如果 `@t{=}' 是双引号，则关闭分词。"

#. type: vindex
#: zsh.texi:5298 zsh.texi:6261 zsh.texi:14415
#, no-wrap
msgid "IFS, use of"
msgstr "IFS, use of"

#. type: table
#: zsh.texi:5302
msgid "This forces parameter expansions to be split into separate words before substitution, using @t{IFS} as a delimiter.  This is done by default in most other shells."
msgstr "这将强制在替换前将参数扩展拆分成单独的词，使用 @t{IFS} 作为分隔符。 大多数其他 shell 默认都是这样做的。"

#. type: table
#: zsh.texi:5307
msgid ""
"Note that splitting is applied to @var{word} in the assignment forms of @var{spec} @emph{before} the assignment to @var{name} is performed.  This affects the result of array assignments with the @t{A} "
"flag."
msgstr "请注意，在 @var{spec}  的赋值形式中,在对 @var{name} 进行赋值@emph{之前}，@var{word} 将被拆分。 这会影响使用 @t{A} 标志的数组赋值结果。"

#. type: item
#: zsh.texi:5308
#, no-wrap
msgid "@t{$@{~}@var{spec}@t{@}}"
msgstr "@t{$@{~}@var{spec}@t{@}}"

#. type: itemx
#: zsh.texi:5309
#, no-wrap
msgid "@t{$@{~~}@var{spec}@t{@}}"
msgstr "@t{$@{~~}@var{spec}@t{@}}"

#. type: pindex
#: zsh.texi:5310
#, no-wrap
msgid "GLOB_SUBST, toggle"
msgstr "GLOB_SUBST, 切换"

#. type: table
#: zsh.texi:5317
msgid ""
"Turn on the @t{GLOB_SUBST} option for the evaluation of @var{spec}; if the `@t{~}' is doubled, turn it off.  When this option is set, the string resulting from the expansion will be interpreted as a "
"pattern anywhere that is possible, such as in filename expansion and filename generation and pattern-matching contexts like the right hand side of the `@t{=}' and `@t{!=}' operators in conditions."
msgstr ""
"打开 @t{GLOB_SUBST} 选项，用于计算 @var{spec}；如果 `@t{~}' 双写，则关闭该选项。 设置该选项后，扩展后的字符串将在任何可能的情况下被解释为模式，例如在文件名扩展和文件名生成以及模式匹配上下文中，如条件中的 "
"`@t{=}' 和 `@t{!=}' 操作符的右侧。"

#. type: table
#: zsh.texi:5326
msgid ""
"In nested substitutions, note that the effect of the @t{~} applies to the result of the current level of substitution.  A surrounding pattern operation on the result may cancel it.  Hence, for example, if "
"the parameter @t{foo} is set to @t{*}, @t{$@{~foo//\\*/*.c@}} is substituted by the pattern @t{*.c}, which may be expanded by filename generation, but @t{$@{$@{~foo@}//\\*/*.c@}} substitutes to the string "
"@t{*.c}, which will not be further expanded."
msgstr ""
"在嵌套替换中，请注意 @t{~} 的效果适用于当前层次的替换结果。 外围的模式操作可能会抵消该结果。 因此，举例来说，如果参数 @t{foo} 设置为 @t{*}，@t{$@{~foo//\\*/*.c@}} 将被模式 @t{*.c} 取代，该模式可能会通过文"
"件名生成进行扩展，但 @t{$@{$@{~foo@}//\\*/*.c@}}  将取代为字符串 @t{*.c}，该字符串不会被进一步扩展。"

#. type: Plain text
#: zsh.texi:5341
msgid ""
"If a @t{$@{}...@t{@}} type parameter expression or a @t{$(}...@t{)} type command substitution is used in place of @var{name} above, it is expanded first and the result is used as if it were the value of "
"@var{name}.  Thus it is possible to perform nested operations: @t{$@{$@{foo#head@}%tail@}} substitutes the value of @t{$foo} with both `@t{head}' and `@t{tail}' deleted.  The form with @t{$(}...@t{)} is "
"often useful in combination with the flags described next; see the examples below.  Each @var{name} or nested @t{$@{}...@t{@}} in a parameter expansion may also be followed by a subscript expression as "
"described in @ref{Array Parameters}."
msgstr ""
"如果使用  @t{$@{}...@t{@}} 类型的参数表达式或 @t{$(}...@t{)}  类型的命令替换来代替上述 @var{name}，则首先展开该表达式，然后将其结果作为 @var{name} 的值使用。 因此，可以执行嵌套操作： "
"@t{$@{$@{foo#head@}%tail@}} 将替换 @t{$foo} 的值，同时删除 `@t{head}' 和 `@t{tail}' 。 带有  @t{$(}...@t{)} 的形式通常与接下来描述的标志结合使用；请参阅下面的示例。 参数扩展中的每个 @var{name} 或嵌套 "
"@t{$@{}...@t{@}} 后面还可以跟一个下标表达式，如 @ref{数组参数} 中所述。"

#. type: Plain text
#: zsh.texi:5351
msgid ""
"Note that double quotes may appear around nested expressions, in which case only the part inside is treated as quoted; for example, @t{$@{(f)\"$(foo)\"@}} quotes the result of @t{$(foo)}, but the flag "
"`@t{(f)}' (see below) is applied using the rules for unquoted expansions.  Note further that quotes are themselves nested in this context; for example, in @t{\"$@{(@@f)\"$(foo)\"@}\"}, there are two sets "
"of quotes, one surrounding the whole expression, the other (redundant) surrounding the @t{$(foo)} as before."
msgstr ""
"请注意，双引号可能会出现在嵌套表达式的周围，在这种情况下，只有内部的部分才会被视为引号；例如，@t{$@{(f)\"$(foo)\"@}} 引用了 @t{$(foo)} 的结果，但标记 `@t{(f)}' （见下文）是使用无引号扩展的规则。 请进一步注"
"意，在这种情况下，引号本身是嵌套的；例如，在  @t{\"$@{(@@f)\"$(foo)\"@}\"} 中，有两组引号，一组围绕整个表达式，另一组（多余的）围绕 @t{$(foo)} 如前。"

#. type: subsection
#: zsh.texi:5354
#, no-wrap
msgid "Parameter Expansion Flags"
msgstr "参数扩展标志"

#. type: cindex
#: zsh.texi:5356
#, no-wrap
msgid "parameter expansion flags"
msgstr "参数扩展标志"

#. type: cindex
#: zsh.texi:5357
#, no-wrap
msgid "flags, parameter expansion"
msgstr "标志, 参数扩展"

#. type: cindex
#: zsh.texi:5358
#, no-wrap
msgid "substitution, parameter, flags"
msgstr "替换, 参数, 标志"

#. type: Plain text
#: zsh.texi:5365
msgid ""
"If the opening brace is directly followed by an opening parenthesis, the string up to the matching closing parenthesis will be taken as a list of flags.  In cases where repeating a flag is meaningful, the "
"repetitions need not be consecutive; for example, `(@t{q%q%q})' means the same thing as the more readable `(@t{%%qqq})'.  The following flags are supported:"
msgstr ""
"如果开头括号后直接跟了一个开头括号，那么直到匹配的结尾括号为止的字符串将被视为标志列表。  在重复标记有意义的情况下，重复标记不必是连续的； 例如，`(@t{q%q%q})' 与更易读的  `(@t{%%qqq})' 意思相同。 支持以下"
"标志："

#. type: table
#: zsh.texi:5373
msgid ""
"Evaluate the resulting words as numeric expressions and interpret these as character codes.  Output the corresponding characters.  Note that this form is entirely distinct from use of the @t{#} without "
"parentheses."
msgstr "将得到的单词作为数值表达式进行计算，并将其解释为字符代码。 输出相应的字符。 请注意，这种形式与使用不带括号的 @t{#} 完全不同。"

#. type: table
#: zsh.texi:5377
msgid "If the @t{MULTIBYTE} option is set and the number is greater than 127 (i.e. not an ASCII character) it is treated as a Unicode character."
msgstr "如果设置了 @t{MULTIBYTE} 选项，且数字大于 127（即不是 ASCII 字符），则会被视为 Unicode 字符。"

#. type: table
#: zsh.texi:5385
msgid ""
"Expand all @t{%} escapes in the resulting words in the same way as in prompts (see @ref{Prompt Expansion}). If this flag is given twice, full prompt expansion is done on the resulting words, depending on "
"the setting of the @t{PROMPT_PERCENT}, @t{PROMPT_SUBST} and @t{PROMPT_BANG} options."
msgstr ""
"以与提示符相同的方式扩展结果词中的所有 @t{%} 转义符（参见 @ref{提示符扩展}）。如果两次给出该标记，则会根据 @t{PROMPT_PERCENT}、@t{PROMPT_SUBST} 和 @t{PROMPT_BANG} 选项的设置，对生成的单词进行完全的提示符扩"
"展。"

#. type: vindex
#: zsh.texi:5386 zsh.texi:7267 zsh.texi:8532
#, no-wrap
msgid "@@"
msgstr "@@"

#. type: table
#: zsh.texi:5392
msgid ""
"In double quotes, array elements are put into separate words.  E.g., `@t{\"$@{(@@)foo@}\"}' is equivalent to `@t{\"$@{foo[@@]@}\"}' and `@t{\"$@{(@@)foo[1,2]@}\"}' is the same as `@t{\"$foo[1]\" "
"\"$foo[2]\"}'.  This is distinct from @emph{field splitting} by the @t{f}, @t{s} or @t{z} flags, which still applies within each array element."
msgstr ""
"在双引号中，数组元素被放在单独的词中。 例如， `@t{\"$@{(@@)foo@}\"}' 等同于 `@t{\"$@{foo[@@]@}\"}' ，而 `@t{\"$@{(@@)foo[1,2]@}\"}' 等同于 `@t{\"$foo[1]\" \"$foo[2]\"}' 相同。 这与使用 @t{f}、@t{s} 或 "
"@t{z} 标记的 @emph{字段分割} 不同，仍适用于每个数组元素。"

#. type: table
#: zsh.texi:5399
msgid ""
"Convert the substitution into an array expression, even if it otherwise would be scalar.  This has lower precedence than subscripting, so one level of nested expansion is required in order that subscripts "
"apply to array elements.  Thus @t{$@{$@{(A}@t{)}@var{name}@t{@}[1]@}} yields the full value of @var{name} when @var{name} is scalar."
msgstr ""
"将替换转换为数组表达式，即使它本来是标量表达式。 这比下标优先级低，因此需要一级嵌套扩展才能使下标适用于数组元素。 因此，当 @var{name} 是标量时，@t{$@{$@{(A}@t{)}@var{name}@t{@}[1]@}}  将产生 @var{name} 的"
"完整值。"

#. type: table
#: zsh.texi:5410
msgid ""
"This assigns an array parameter with `@t{$@{}...@t{=}...@t{@}}', `@t{$@{}...@t{:=}...@t{@}}' or `@t{$@{}...@t{::=}...@t{@}}'.  If this flag is repeated (as in `@t{AA}'), assigns an associative array "
"parameter.  Assignment is made before sorting or padding; if field splitting is active, the @var{word} part is split before assignment.  The @var{name} part may be a subscripted range for ordinary arrays; "
"when assigning an associative array, the @var{word} part @emph{must} be converted to an array, for example by using `@t{$@{(AA)=}@var{name}@t{=}...@t{@}}' to activate field splitting."
msgstr ""
"这会用  `@t{$@{}...@t{=}...@t{@}}', `@t{$@{}...@t{:=}...@t{@}}' 或 `@t{$@{}...@t{::=}...@t{@}}' 指定一个数组参数。 如果该标志重复出现（如 `@t{AA}' ），则会分配一个关联数组参数。 赋值在排序或填充之前进行；"
"如果激活了字段分割，@var{word} 部分会在赋值前被分割。 对于普通数组，@var{name} 部分可以是下标范围；当赋值一个关联数组时，@var{word} 部分 @emph{必须} 转换为数组，例如使用  `@t{$@{(AA)=}@var{name}@t{=}..."
"@t{@}}' 激活字段分割。"

#. type: table
#: zsh.texi:5415
msgid "Surrounding context such as additional nesting or use of the value in a scalar assignment may cause the array to be joined back into a single string again."
msgstr "周围环境（如额外嵌套或在标量赋值中使用值）可能会导致数组再次连接回单个字符串。"

#. type: table
#: zsh.texi:5421
msgid ""
"Sort in array index order; when combined with `@t{O}' sort in reverse array index order.  Note that `@t{a}' is therefore equivalent to the default but `@t{Oa}' is useful for obtaining an array's elements "
"in reverse order."
msgstr "按数组索引顺序排序；与 `@t{O}' 结合使用时，按数组索引倒序排序。 请注意， `@t{a}'  因此等同于默认值，但 `@t{Oa}' 在按相反顺序获取数组元素时非常有用。"

#. type: t{#1}
#: zsh.texi:5422 zsh.texi:6887
#, no-wrap
msgid "b"
msgstr "b"

#. type: table
#: zsh.texi:5426
msgid ""
"Quote with backslashes only characters that are special to pattern matching. This is useful when the contents of the variable are to be tested using @t{GLOB_SUBST}, including the @t{$@{~}@var{...}@t{@}} "
"switch."
msgstr "仅对模式匹配中的特殊字符使用反斜线引用。这在使用 @t{GLOB_SUBST} （包括 @t{$@{~}@var{...}@t{@}} 开关测试变量内容时非常有用。"

#. type: table
#: zsh.texi:5431
msgid "Quoting using one of the @t{q} family of flags does not work for this purpose since quotes are not stripped from non-pattern characters by @t{GLOB_SUBST}.  In other words,"
msgstr "由于 @t{GLOB_SUBST} 不会从非模式字符中去除引号，因此使用 @t{q} 系列标志之一的引号无法实现这一目的。 换句话说"

#. type: example
#: zsh.texi:5436
#, no-wrap
msgid ""
"pattern=$@{(q)str@}\n"
"[[ $str = $@{~pattern@} ]]\n"
msgstr ""
"pattern=$@{(q)str@}\n"
"[[ $str = $@{~pattern@} ]]\n"

#. type: table
#: zsh.texi:5440
msgid "works if @t{$str} is `@t{a*b}' but not if it is `@t{a b}', whereas"
msgstr "如果 @t{$str} 是 `@t{a*b}' 则有效，如果是 `@t{a b}'则无效，而"

#. type: example
#: zsh.texi:5445
#, no-wrap
msgid ""
"pattern=$@{(b)str@}\n"
"[[ $str = $@{~pattern@} ]]\n"
msgstr ""
"pattern=$@{(b)str@}\n"
"[[ $str = $@{~pattern@} ]]\n"

#. type: table
#: zsh.texi:5449
msgid "is always true for any possible value of @t{$str}."
msgstr "对于 @t{$str} 的任何可能值都是 true。"

#. type: table
#: zsh.texi:5455
msgid ""
"With @t{$@{#}@var{name}@t{@}}, count the total number of characters in an array, as if the elements were concatenated with spaces between them.  This is not a true join of the array, so other expressions "
"used with this flag may have an effect on the elements of the array before it is counted."
msgstr "用 @t{$@{#}@var{name}@t{@}}， 计算数组中的字符总数，就像元素之间用空格连接一样。 这并不是数组的真正连接，因此在计算之前，使用此标志的其他表达式可能会对数组元素产生影响。"

#. type: table
#: zsh.texi:5460
msgid "Capitalize the resulting words.  `Words' in this case refers to sequences of alphanumeric characters separated by non-alphanumerics, @emph{not} to words that result from field splitting."
msgstr "将生成的单词大写。 这里的 `Words'  指的是由非字母数字分隔的字母数字字符序列，@emph{不是}指字段分割产生的单词。"

#. type: table
#: zsh.texi:5468
msgid ""
"Assume the string or array elements contain directories and attempt to substitute the leading part of these by names.  The remainder of the path (the whole of it if the leading part was not substituted)  "
"is then quoted so that the whole string can be used as a shell argument.  This is the reverse of `@t{~}' substitution: see @ref{Filename Expansion}."
msgstr ""
"假定字符串或数组元素包含目录，并尝试用名称替换其前导部分。 路径的其余部分（如果前导部分未被替换，则为整个路径）会被加引号，这样整个字符串就可以用作 shell 参数。 这是`@t{~}'替换的反向操作：参见 @ref{文件名"
"扩展}。"

#. type: table
#: zsh.texi:5474
msgid ""
"Perform single word shell expansions, namely @emph{parameter expansion}, @emph{command substitution} and @emph{arithmetic expansion}, on the result. Such expansions can be nested but too deep recursion "
"may have unpredictable effects."
msgstr "对结果执行单字 shell 扩展，即在结果上执行 @emph{参数扩展}、@emph{命令替换} 和 @emph{算术扩展}。此类扩展可以嵌套，但过深的递归可能会产生不可预知的效果。"

#. type: table
#: zsh.texi:5478
msgid "Split the result of the expansion at newlines. This is a shorthand for `@t{ps:\\n:}'."
msgstr "在换行符处分割扩展结果。这是 `@t{ps:\\n:}' 的简写。"

#. type: t{#1}
#: zsh.texi:5479 zsh.texi:7258
#, no-wrap
msgid "F"
msgstr "F"

#. type: table
#: zsh.texi:5482
msgid "Join the words of arrays together using newline as a separator.  This is a shorthand for `@t{pj:\\n:}'."
msgstr "使用换行符作为分隔符，将数组的单词连接在一起。 这是 `@t{pj:\\n:}' 的简写。"

#. type: item
#: zsh.texi:5483
#, no-wrap
msgid "@t{g:}@var{opts}@t{:}"
msgstr "@t{g:}@var{opts}@t{:}"

#. type: table
#: zsh.texi:5490
msgid ""
"Process escape sequences like the echo builtin when no options are given (@t{g::}).  With the @t{o} option, octal escapes don't take a leading zero.  With the @t{c} option, sequences like `@t{^X}' are "
"also processed.  With the @t{e} option, processes `@t{\\M-t}' and similar sequences like the print builtin.  With both of the @t{o} and @t{e} options, behaves like the print builtin except that in none of "
"these modes is `@t{\\c}' interpreted."
msgstr ""
"在未给出任何选项的情况下（@t{g::}），像 echo 内置程序一样处理转义序列。 使用 @t{o} 选项时，八进制转义字符不带前导零。 使用 @t{c} 选项时，类似 `@t{^X}' 的序列也会被处理。 如果使用 @t{e} 选项，则会处理 "
"`@t{\\M-t}' 和类似 print 内置命令的序列。 同时使用 @t{o} 和 @t{e} 选项时，除了不解释 `@t{\\c}' 以外，其行为与 print 内置程序类似。"

#. type: t{#1}
#: zsh.texi:5491 zsh.texi:6871 zsh.texi:8194
#, no-wrap
msgid "i"
msgstr "i"

#. type: table
#: zsh.texi:5493
msgid "Sort case-insensitively.  May be combined with `@t{n}' or `@t{O}'."
msgstr "不区分大小写排序。 可与 `@t{n}' 或 `@t{O}' 结合使用。"

#. type: t{#1}
#: zsh.texi:5494 zsh.texi:8220
#, no-wrap
msgid "k"
msgstr "k"

#. type: table
#: zsh.texi:5502
msgid ""
"If @var{name} refers to an associative array, substitute the @emph{keys} (element names) rather than the values of the elements.  Used with subscripts (including ordinary arrays), force indices or keys to "
"be substituted even if the subscript form refers to values.  However, this flag may not be combined with subscript ranges.  With the @t{KSH_ARRAYS} option a subscript `@t{[*]}' or `@t{[@@]}' is needed to "
"operate on the whole array, as usual."
msgstr ""
"如果 @var{name} 指向关联数组，则替换 @emph{keys}（元素名）而不是元素的值。 与下标（包括普通数组）一起使用时，即使下标形式指的是值，也会强制替换索引或键。 但是，该标志不能与下标范围结合使用。 使用 "
"@t{KSH_ARRAYS} 选项时，需要使用下标 `@t{[*]}' 或 `@t{[@@]}' 对整个数组进行操作。"

#. type: table
#: zsh.texi:5505
msgid "Convert all letters in the result to lower case."
msgstr "将结果中的所有字母转换为小写。"

#. type: table
#: zsh.texi:5514
msgid ""
"Sort decimal integers numerically; if the first differing characters of two test strings are not digits, sorting is lexical.  `@t{+}' and `@t{-}' are not treated specially; they are treated as any other "
"non-digit.  Integers with more initial zeroes are sorted before those with fewer or none.  Hence the array `@t{foo+24 foo1 foo02 foo2 foo3 foo20 foo23}' is sorted into the order shown.  May be combined "
"with `@t{i}' or `@t{O}'."
msgstr ""
"对十进制整数按数值排序；如果两个测试字符串的第一个不同字符不是数字，则按词法排序。 `@t{+}' 和 `@t{-}' 不会被特殊处理；它们与其他非数字一样被处理。 前导零位较多的整数排序在前导零位较少或没有前导零位的整数之"
"前。 因此，数组  `@t{foo+24 foo1 foo02 foo2 foo3 foo20 foo23}' 的排列为所示顺序。 可与 `@t{i}' 或 `@t{O}' 结合使用。"

#. type: table
#: zsh.texi:5521
msgid ""
"As @t{n}, but a leading minus sign indicates a negative decimal integer.  A leading minus sign not followed by an integer does not trigger numeric sorting.  Note that `@t{+}' signs are not handled "
"specially (this may change in the future)."
msgstr "与 @t{n}相同，但前导负号表示十进制负整数。 前面的负号后面没有整数，不会触发数字排序。 请注意，`@t{+}' 符号不会被特殊处理（这点将来可能会改变）。"

#. type: t{#1}
#: zsh.texi:5522
#, no-wrap
msgid "o"
msgstr "o"

#. type: table
#: zsh.texi:5528
msgid ""
"Sort the resulting words in ascending order; if this appears on its own the sorting is lexical and case-sensitive (unless the locale renders it case-insensitive).  Sorting in ascending order is the "
"default for other forms of sorting, so this is ignored if combined with `@t{a}', `@t{i}', `@t{n}' or `@t{-}'."
msgstr ""
"按升序排序结果；如果该选项单独出现，则按字面和大小写排序（除非本地语言不区分大小写）。 升序排序是其他排序形式的默认排序方式，因此，如果与 `@t{a}', `@t{i}', `@t{n}'  或  `@t{-}' 一起使用，则会被忽略。"

#. type: t{#1}
#: zsh.texi:5529 zsh.texi:30896
#, no-wrap
msgid "O"
msgstr "O"

#. type: table
#: zsh.texi:5534
msgid ""
"Sort the resulting words in descending order; `@t{O}' without `@t{a}', `@t{i}', `@t{n}' or `@t{-}' sorts in reverse lexical order.  May be combined with `@t{a}', `@t{i}', `@t{n}' or `@t{-}' to reverse the "
"order of sorting."
msgstr "按降序排序； `@t{O}' 不含 `@t{a}', `@t{i}', `@t{n}' 或 `@t{-}' 时，按相反的词序排序。 可与 `@t{a}', `@t{i}', `@t{n}' 或  `@t{-}' 结合使用，以颠倒排序顺序。"

#. type: table
#: zsh.texi:5541
msgid ""
"This forces the value of the parameter @var{name} to be interpreted as a further parameter name, whose value will be used where appropriate.  Note that flags set with one of the @t{typeset} family of "
"commands (in particular case transformations) are not applied to the value of @var{name} used in this fashion."
msgstr "这会强制将参数 @var{name} 的值解释为另一个参数名，并在适当的地方使用其值。 需要注意的是，使用 @t{typeset} 系列命令之一设置的标志（特别是转换）并不适用于以这种方式使用的 @var{name} 值。"

#. type: table
#: zsh.texi:5548
msgid ""
"If used with a nested parameter or command substitution, the result of that will be taken as a parameter name in the same way.  For example, if you have `@t{foo=bar}' and `@t{bar=baz}', the strings "
"@t{$@{(P)foo@}}, @t{$@{(P)$@{foo@}@}}, and @t{$@{(P)$(echo bar)@}} will be expanded to `@t{baz}'."
msgstr ""
"如果与嵌套参数或命令替换一起使用，其结果将以同样的方式作为参数名。 例如，如果有 `@t{foo=bar}' 和 `@t{bar=baz}'，则字符串 @t{$@{(P)foo@}}、@t{$@{(P)$@{foo@}@}} 和 @t{$@{(P)$(echo bar)@}} 将扩展为 "
"`@t{baz}'。"

#. type: table
#: zsh.texi:5557
msgid ""
"Likewise, if the reference is itself nested, the expression with the flag is treated as if it were directly replaced by the parameter name.  It is an error if this nested substitution produces an array "
"with more than one word.  For example, if `@t{name=assoc}' where the parameter @t{assoc} is an associative array, then `@t{$@{$@{(P)name@}[elt]@}}' refers to the element of the associative subscripted "
"`@t{elt}'."
msgstr ""
"同样，如果引用本身是嵌套的，则带有标志的表达式将被视为直接替换为参数名。 如果这种嵌套替换产生了一个包含多个单词的数组，则属于错误。 例如，如果 `@t{name=assoc}' 中的参数 @t{assoc} 是一个关联数组，那么  "
"`@t{$@{$@{(P)name@}[elt]@}}' 指的就是关联下标 `@t{elt}' 中的元素。"

#. type: table
#: zsh.texi:5562
msgid ""
"Quote characters that are special to the shell in the resulting words with backslashes; unprintable or invalid characters are quoted using the @t{$'\\}@var{NNN}@t{'} form, with separate quotes for each "
"octet."
msgstr "使用反斜线引用结果字中对 shell 有特殊意义的字符；使用 @t{$'\\}@var{NNN}@t{'} 格式引用无法打印或无效的字符，每个八位位组使用单独的引号。"

#. type: table
#: zsh.texi:5571
msgid ""
"If this flag is given twice, the resulting words are quoted in single quotes and if it is given three times, the words are quoted in double quotes; in these forms no special handling of unprintable or "
"invalid characters is attempted.  If the flag is given four times, the words are quoted in single quotes preceded by a @t{$}.  Note that in all three of these forms quoting is done unconditionally, even "
"if this does not change the way the resulting string would be interpreted by the shell."
msgstr ""
"如果两次使用该标记，生成的单词将用单引号引用；如果三次使用该标记，生成的单词将用双引号引用；在这些形式中，不会对无法打印或无效的字符进行特殊处理。 如果标记出现四次，则以单引号引用，前面加上 @t{$}。 需要注"
"意的是，在所有这三种形式中，引用都是无条件执行的，即使这并不改变 shell 解释字符串的方式。"

#. type: table
#: zsh.texi:5577
msgid ""
"If a @t{q-} is given (only a single @t{q} may appear), a minimal form of single quoting is used that only quotes the string if needed to protect special characters.  Typically this form gives the most "
"readable output."
msgstr "如果给出 @t{q-}（只能出现单个 @t{q}），则会使用最小形式的单引号，仅在需要保护特殊字符时对字符串加引号。 通常，这种形式的输出最易读。"

#. type: table
#: zsh.texi:5583
msgid ""
"If a @t{q+} is given, an extended form of minimal quoting is used that causes unprintable characters to be rendered using @t{$'}@var{...}@t{'}.  This quoting is similar to that used by the output of "
"values by the @t{typeset} family of commands."
msgstr "如果给出 @t{q+}，将使用扩展的最小引号形式，使用  @t{$'}@var{...}@t{'} 呈现无法打印的字符。 这种引号与 @t{typeset} 系列命令输出值时使用的引号类似。"

#. type: table
#: zsh.texi:5586
msgid "Remove one level of quotes from the resulting words."
msgstr "从得到的单词中删除一级引号。"

#. type: table
#: zsh.texi:5594
msgid ""
"Use a string describing the type of the parameter where the value of the parameter would usually appear. This string consists of keywords separated by hyphens (`@t{-}'). The first keyword in the string "
"describes the main type, it can be one of `@t{scalar}', `@t{array}', `@t{integer}', `@t{float}' or `@t{association}'. The other keywords describe the type in more detail:"
msgstr ""
"使用描述参数类型的字符串，参数值通常会出现在该字符串中。该字符串由以连字符（ `@t{-}' ）分隔的关键字组成。字符串中的第一个关键字描述主要类型，可以是 `@t{scalar}', `@t{array}', `@t{integer}', `@t{float}' 或 "
"`@t{association}'。其他关键字会更详细地描述类型："

#. type: t{#1}
#: zsh.texi:5597 zsh.texi:14151 zsh.texi:22848
#, no-wrap
msgid "local"
msgstr "local"

#. type: table
#: zsh.texi:5599
msgid "for local parameters"
msgstr "为局部参数"

#. type: t{#1}
#: zsh.texi:5600
#, no-wrap
msgid "left"
msgstr "left"

#. type: table
#: zsh.texi:5602
msgid "for left justified parameters"
msgstr "用于左对齐参数"

#. type: t{#1}
#: zsh.texi:5603
#, no-wrap
msgid "right_blanks"
msgstr "right_blanks"

#. type: table
#: zsh.texi:5605
msgid "for right justified parameters with leading blanks"
msgstr "用于右对齐参数，带前导空格"

#. type: t{#1}
#: zsh.texi:5606
#, no-wrap
msgid "right_zeros"
msgstr "right_zeros"

#. type: table
#: zsh.texi:5608
msgid "for right justified parameters with leading zeros"
msgstr "用于右对齐参数，带前导零"

#. type: t{#1}
#: zsh.texi:5609
#, no-wrap
msgid "lower"
msgstr "lower"

#. type: table
#: zsh.texi:5612
msgid "for parameters whose value is converted to all lower case when it is expanded"
msgstr "用于参数值在展开时被转换为全小写的参数"

#. type: t{#1}
#: zsh.texi:5613
#, no-wrap
msgid "upper"
msgstr "upper"

#. type: table
#: zsh.texi:5616
msgid "for parameters whose value is converted to all upper case when it is expanded"
msgstr "用于参数值在展开时被转换为全大写的参数"

#. type: t{#1}
#: zsh.texi:5617 zsh.texi:14546
#, no-wrap
msgid "readonly"
msgstr "readonly"

#. type: table
#: zsh.texi:5619
msgid "for readonly parameters"
msgstr "用于只读参数"

#. type: t{#1}
#: zsh.texi:5620
#, no-wrap
msgid "tag"
msgstr "tag"

#. type: table
#: zsh.texi:5622
msgid "for tagged parameters"
msgstr "用于已标记参数"

#. type: t{#1}
#: zsh.texi:5623
#, no-wrap
msgid "tied"
msgstr "tied"

#. type: table
#: zsh.texi:5627
msgid "for parameters tied to another parameter in the manner of @t{PATH} (colon-separated list) and @t{path} (array), whether these are special parameters or user-defined with `@t{typeset -T}'"
msgstr "用于以@t{PATH} (冒号分隔列表) 和 @t{path} (数组)方式绑定到另一个参数的参数，无论这些参数是特殊参数还是用户用  `@t{typeset -T}' 定义的参数。"

#. type: findex
#: zsh.texi:5628 zsh.texi:7733 zsh.texi:13525
#, no-wrap
msgid "export"
msgstr "export"

#. type: table
#: zsh.texi:5630
msgid "for exported parameters"
msgstr "用于导出参数"

#. type: t{#1}
#: zsh.texi:5631
#, no-wrap
msgid "unique"
msgstr "unique"

#. type: table
#: zsh.texi:5633
msgid "for arrays which keep only the first occurrence of duplicated values"
msgstr "用于只保留重复值首次出现的数组"

#. type: t{#1}
#: zsh.texi:5634
#, no-wrap
msgid "hide"
msgstr "hide"

#. type: table
#: zsh.texi:5636
msgid "for parameters with the `hide' flag"
msgstr "为参数加上 `hide' 标志"

#. type: t{#1}
#: zsh.texi:5637
#, no-wrap
msgid "hideval"
msgstr "hideval"

#. type: table
#: zsh.texi:5639
msgid "for parameters with the `hideval' flag"
msgstr "用于带有 `hideval' 标志的参数"

#. type: t{#1}
#: zsh.texi:5640 zsh.texi:19019
#, no-wrap
msgid "special"
msgstr "special"

#. type: table
#: zsh.texi:5642
msgid "for special parameters defined by the shell"
msgstr "用于 shell 定义的特殊参数"

#. type: table
#: zsh.texi:5647
msgid "Expand only the first occurrence of each unique word."
msgstr "只扩展每个唯一单词的第一次出现。"

#. type: t{#1}
#: zsh.texi:5648 zsh.texi:7052 zsh.texi:7427
#, no-wrap
msgid "U"
msgstr "U"

#. type: table
#: zsh.texi:5650
msgid "Convert all letters in the result to upper case."
msgstr "将结果中的所有字母转换为大写字母。"

#. type: table
#: zsh.texi:5656
msgid ""
"Used with @t{k}, substitute (as two consecutive words) both the key and the value of each associative array element.  Used with subscripts, force values to be substituted even if the subscript form refers "
"to indices or keys."
msgstr "与 @t{k} 一起使用时，（以两个连续词的形式）替换每个关联数组元素的键和值。 与下标一起使用时，即使下标形式指的是索引或键，也会强制替换值。"

#. type: table
#: zsh.texi:5659
msgid "Make any special characters in the resulting words visible."
msgstr "使结果字中的任何特殊字符可见。"

#. type: table
#: zsh.texi:5663
msgid "With @t{$@{#}@var{name}@t{@}}, count words in arrays or strings; the @t{s} flag may be used to set a word delimiter."
msgstr "使用 @t{$@{#}@var{name}@t{@}}，可以计算数组或字符串中的单词数；可以使用 @t{s} 标志设置单词分隔符。"

#. type: t{#1}
#: zsh.texi:5664 zsh.texi:7309
#, no-wrap
msgid "W"
msgstr "W"

#. type: table
#: zsh.texi:5667
msgid "Similar to @t{w} with the difference that empty words between repeated delimiters are also counted."
msgstr "与 @t{w} 类似，不同之处在于重复分隔符之间的空字也会被计算在内。"

#. type: t{#1}
#: zsh.texi:5668 zsh.texi:7312
#, no-wrap
msgid "X"
msgstr "X"

#. type: table
#: zsh.texi:5673
msgid ""
"With this flag, parsing errors occurring with the @t{Q}, @t{e} and @t{#} flags or the pattern matching forms such as `@t{$@{}@var{name}@t{#}@var{pattern}@t{@}}' are reported.  Without the flag, errors are "
"silently ignored."
msgstr "使用该标志时，将报告使用 @t{Q}, @t{e} and @t{#} 标志或模式匹配形式（如 `@t{$@{}@var{name}@t{#}@var{pattern}@t{@}}' ）出现的解析错误。 如果没有标志，错误将被忽略。"

#. type: t{#1}
#: zsh.texi:5674
#, no-wrap
msgid "z"
msgstr "z"

#. type: table
#: zsh.texi:5680
msgid ""
"Split the result of the expansion into words using shell parsing to find the words, i.e. taking into account any quoting in the value.  Comments are not treated specially but as ordinary strings, similar "
"to interactive shells with the @t{INTERACTIVE_COMMENTS} option unset (however, see the @t{Z} flag below for related options)"
msgstr ""
"使用 shell 解析将扩展结果拆分为单词，即考虑值中的任何引号。 注释不会被特殊处理，而是作为普通字符串处理，类似于未设置 @t{INTERACTIVE_COMMENTS} 选项的交互式 shell（不过，相关选项请参见下面的 @t{Z} 标志）"

#. type: table
#: zsh.texi:5686
msgid ""
"Note that this is done very late, even later than the `@t{(s)}' flag. So to access single words in the result use nested expansions as in `@t{$@{$@{(z)foo@}[2]@}}'. Likewise, to remove the quotes in the "
"resulting words use `@t{$@{(Q)$@{(z)foo@}@}}'."
msgstr "需要注意的是，这个过程进行得很晚，甚至比 `@t{(s)}' 标志更晚。因此，要访问结果中的单字，请使用嵌套扩展，如 `@t{$@{$@{(z)foo@}[2]@}}'。同样，要删除结果单词中的引号，请使用 `@t{$@{(Q)$@{(z)foo@}@}}'。"

#. type: table
#: zsh.texi:5690
msgid "Split the result of the expansion on null bytes.  This is a shorthand for `@t{ps:\\0:}'."
msgstr "在空字节处分割扩展结果。 这是 `@t{ps:\\0:}' 的简写。"

#. type: Plain text
#: zsh.texi:5699
msgid ""
"The following flags (except @t{p}) are followed by one or more arguments as shown.  Any character, or the matching pairs `@t{(}...@t{)}', `@t{@{}...@t{@}}', `@t{[}...@t{]}', or `@t{<}...@t{>}', may be "
"used in place of a colon as delimiters, but note that when a flag takes more than one argument, a matched pair of delimiters must surround each argument."
msgstr ""
"下列标志（@t{p} 除外）后跟一个或多个参数，如所示。 任何字符或匹配对 `@t{(}...@t{)}', `@t{@{}...@t{@}}', `@t{[}...@t{]}' 或 `@t{<}...@t{>}' 都可以代替冒号作为分隔符，但要注意的是，当一个标志有多个参数时，每"
"个参数周围必须有一对匹配的分隔符。"

#. type: table
#: zsh.texi:5706
msgid "Recognize the same escape sequences as the @t{print} builtin in string arguments to any of the flags described below that follow this argument."
msgstr "在该参数后面，下面所述的标志，识别为 @t{print} 内置函数相同的转义序列。（不怎么通顺）"

#. type: table
#: zsh.texi:5712
msgid ""
"Alternatively, with this option string arguments may be in the form @t{$}@var{var} in which case the value of the variable is substituted.  Note this form is strict; the string argument does not undergo "
"general parameter expansion."
msgstr "另外，使用该选项时，字符串参数的形式可以是 @t{$}@var{var}，在这种情况下，变量的值会被替换。 请注意，这种形式是严格的；字符串参数不会进行一般的参数扩展。"

#. type: example
#: zsh.texi:5721
#, no-wrap
msgid ""
"sep=:\n"
"val=a:b:c\n"
"print $@{(ps.$sep.)val@}\n"
msgstr ""
"sep=:\n"
"val=a:b:c\n"
"print $@{(ps.$sep.)val@}\n"

#. type: table
#: zsh.texi:5725
msgid "splits the variable on a @t{:}."
msgstr "在 @t{:} 上分割变量。"

#. type: table
#: zsh.texi:5732
msgid ""
"Strings inserted into the expansion by any of the flags below are to be treated as patterns.  This applies to the string arguments of flags that follow @t{~} within the same set of parentheses.  Compare "
"with @t{~} outside parentheses, which forces the entire substituted string to be treated as a pattern.  Hence, for example,"
msgstr "由以下任何标志插入扩展的字符串都将被视为模式。 这也适用于 @t{~} 之后在同一组括号内的标志的字符串参数。 与括号外的 @t{~} 相比，括号外的 @t{~} 会强制将整个替换的字符串作为模式处理。 因此，例如"

#. type: example
#: zsh.texi:5736
#, no-wrap
msgid "[[ \"?\" = $@{(~j.|.)array@} ]]\n"
msgstr "[[ \"?\" = $@{(~j.|.)array@} ]]\n"

#. type: table
#: zsh.texi:5743
msgid ""
"treats `@t{|}' as a pattern and succeeds if and only if @t{$array} contains the string `@t{?}' as an element.  The @t{~} may be repeated to toggle the behaviour; its effect only lasts to the end of the "
"parenthesised group."
msgstr "将 `@t{|}' 视为模式，并且只有当 @t{$array} 包含字符串 `@t{?}' 作为一个元素时才会成功。 可以重复使用 @t{~} 来切换行为；其效果只持续到括号中的组的末尾。"

#. type: item
#: zsh.texi:5744
#, no-wrap
msgid "@t{j:}@var{string}@t{:}"
msgstr "@t{j:}@var{string}@t{:}"

#. type: table
#: zsh.texi:5746
msgid "Join the words of arrays together using @var{string} as a separator."
msgstr "使用 @var{string} 作为分隔符，将数组的单词连接在一起。"

#. type: pindex
#: zsh.texi:5746
#, no-wrap
msgid "SH_WORD_SPLIT, use of"
msgstr "SH_WORD_SPLIT, use of"

#. type: table
#: zsh.texi:5749
msgid "Note that this occurs before field splitting by the @t{s:}@var{string}@t{:} flag or the @t{SH_WORD_SPLIT} option."
msgstr "请注意，这发生在使用 @t{s:}@var{string}@t{:} 标志或 @t{SH_WORD_SPLIT} 选项进行字段分割之前。"

#. type: item
#: zsh.texi:5750
#, no-wrap
msgid "@t{l:}@var{expr}@t{::}@var{string1}@t{::}@var{string2}@t{:}"
msgstr "@t{l:}@var{expr}@t{::}@var{string1}@t{::}@var{string2}@t{:}"

#. type: table
#: zsh.texi:5753
msgid "Pad the resulting words on the left.  Each word will be truncated if required and placed in a field @var{expr} characters wide."
msgstr "将得到的单词填充到左边。 如果需要，每个单词都将被截断，并放入一个 @var{expr} 字宽的字段中。"

#. type: table
#: zsh.texi:5763
msgid ""
"The arguments @t{:}@var{string1}@t{:} and @t{:}@var{string2}@t{:} are optional; neither, the first, or both may be given.  Note that the same pairs of delimiters must be used for each of the three "
"arguments.  The space to the left will be filled with @var{string1} (concatenated as often as needed) or spaces if @var{string1} is not given.  If both @var{string1} and @var{string2} are given, "
"@var{string2} is inserted once directly to the left of each word, truncated if necessary, before @var{string1} is used to produce any remaining padding."
msgstr ""
"参数 @t{:}@var{string1}@t{:} 和 @t{:}@var{string2}@t{:} 是可选参数；可以两个参数都不给，也可以给第一个参数，或者两个参数都给。 请注意，三个参数必须使用相同的分隔符。 左边的空格将由 @var{string1}（根据需要"
"进行连接）填充，如果没有给出 @var{string1}，则由空格填充。 如果同时给出了@var{string1}和@var{string2}，则在使用@var{string1}生成任何剩余的填充之前，在每个单词的左侧直接插入一次@var{string2}（如有必要，则截"
"断）。"

#. type: table
#: zsh.texi:5768
msgid "If either of @var{string1} or @var{string2} is present but empty, i.e. there are two delimiters together at that point, the first character of @t{$IFS} is used instead."
msgstr "如果 @var{string1} 或 @var{string2} 中的任何一个存在但为空，即在该点有两个分隔符，则使用 @t{$IFS} 的第一个字符来代替。"

#. type: table
#: zsh.texi:5774
msgid ""
"If the @t{MULTIBYTE} option is in effect, the flag @t{m} may also be given, in which case widths will be used for the calculation of padding; otherwise individual multibyte characters are treated as "
"occupying one unit of width."
msgstr "如果 @t{MULTIBYTE} 选项有效，也可以给出标志 @t{m}，在这种情况下，宽度将被用于计算填充；否则，单个多字节字符将被视为占用一个宽度单位。"

#. type: table
#: zsh.texi:5778
msgid "If the @t{MULTIBYTE} option is not in effect, each byte in the string is treated as occupying one unit of width."
msgstr "如果 @t{MULTIBYTE} 选项未生效，字符串中的每个字节将被视为占用一个宽度单位。"

#. type: table
#: zsh.texi:5782
msgid "Control characters are always assumed to be one unit wide; this allows the mechanism to be used for generating repetitions of control characters."
msgstr "控制字符始终被假定为一个单位宽；这使得该机制可用于生成重复的控制字符。"

#. type: t{#1}
#: zsh.texi:5783 zsh.texi:6968 zsh.texi:7541
#, no-wrap
msgid "m"
msgstr "m"

#. type: table
#: zsh.texi:5793
msgid ""
"Only useful together with one of the flags @t{l} or @t{r} or with the @t{#} length operator when the @t{MULTIBYTE} option is in effect.  Use the character width reported by the system in calculating how "
"much of the string it occupies or the overall length of the string.  Most printable characters have a width of one unit, however certain Asian character sets and certain special effects use wider "
"characters; combining characters have zero width.  Non-printable characters are arbitrarily counted as zero width; how they would actually be displayed will vary."
msgstr ""
"当 @t{MULTIBYTE} 选项有效时，仅与 @t{l} 或 @t{r} 标志之一或 @t{#} 长度运算符一起使用。 使用系统报告的字符宽度来计算它在字符串中的占用量或字符串的总长度。 大多数可打印字符的宽度为一个单位，但某些亚洲字符集"
"和某些特效字使用更宽的字符；组合字符的宽度为零； 不可打印字符的宽度为零；但实际显示方式会有所不同。"

#. type: table
#: zsh.texi:5800
msgid ""
"If the @t{m} is repeated, the character either counts zero (if it has zero width), else one.  For printable character strings this has the effect of counting the number of glyphs (visibly separate "
"characters), except for the case where combining characters themselves have non-zero width (true in certain alphabets)."
msgstr "如果 @t{m} 重复出现，该字符的宽度要么为零（如果宽度为零），要么为一。 对于可打印字符串，这具有计算字形（明显分开的字符）数量的效果，除非组合字符本身的宽度不为零（在某些字母表中确实如此）。"

#. type: item
#: zsh.texi:5801
#, no-wrap
msgid "@t{r:}@var{expr}@t{::}@var{string1}@t{::}@var{string2}@t{:}"
msgstr "@t{r:}@var{expr}@t{::}@var{string1}@t{::}@var{string2}@t{:}"

#. type: table
#: zsh.texi:5804
msgid "As @t{l}, but pad the words on the right and insert @var{string2} immediately to the right of the string to be padded."
msgstr "与 @t{l}相同，但将单词填充到右侧，并在要填充的字符串右侧插入 @var{string2}。"

#. type: table
#: zsh.texi:5810
msgid ""
"Left and right padding may be used together.  In this case the strategy is to apply left padding to the first half width of each of the resulting words, and right padding to the second half.  If the "
"string to be padded has odd width the extra padding is applied on the left."
msgstr "左填充和右填充可以同时使用。 在这种情况下，策略是对每个结果字的前半部分宽度使用左填充，后半部分使用右填充。 如果要填充的字符串宽度为奇数，则额外的填充会应用在左边。"

#. type: item
#: zsh.texi:5811 zsh.texi:8133
#, no-wrap
msgid "@t{s:}@var{string}@t{:}"
msgstr "@t{s:}@var{string}@t{:}"

#. type: table
#: zsh.texi:5819
msgid ""
"Force field splitting at the separator @var{string}.  Note that a @var{string} of two or more characters means that all of them must match in sequence; this differs from the treatment of two or more "
"characters in the @t{IFS} parameter.  See also the @t{=} flag and the @t{SH_WORD_SPLIT} option.  An empty string may also be given in which case every character will be a separate element."
msgstr ""
"在分隔符 @var{string} 处进行字段分割。 请注意，包含两个或多个字符的 @var{string} 意味着所有字符必须依次匹配；这与 @t{IFS} 参数中两个或多个字符的处理方式不同。 另请参阅 @t{=} 标志和 @t{SH_WORD_SPLIT} 选"
"项。  也可以给出一个空字符串，在这种情况下，每个字符都是一个单独的元素。"

#. type: table
#: zsh.texi:5824
msgid "For historical reasons, the usual behaviour that empty array elements are retained inside double quotes is disabled for arrays generated by splitting; hence the following:"
msgstr "由于历史原因，对于通过拆分生成的数组，通常会将空数组元素保留在双引号内，但这一行为被禁用了，因此出现了以下情况："

#. type: example
#: zsh.texi:5829
#, no-wrap
msgid ""
"line=\"one::three\"\n"
"print -l \"$@{(s.:.)line@}\"\n"
msgstr ""
"line=\"one::three\"\n"
"print -l \"$@{(s.:.)line@}\"\n"

#. type: table
#: zsh.texi:5835
msgid "produces two lines of output for @t{one} and @t{three} and elides the empty field.  To override this behaviour, supply the `@t{(@@)}' flag as well, i.e.  @t{\"$@{(@@s.:.)line@}\"}."
msgstr "会为 @t{one} 和 @t{three} 生成两行输出，并忽略空字段。 要覆盖这一行为，请同时提供 `@t{(@@)}' 标志，即 @t{\"$@{(@@s.:.)line@}\"}。"

#. type: item
#: zsh.texi:5836
#, no-wrap
msgid "@t{Z:}@var{opts}@t{:}"
msgstr "@t{Z:}@var{opts}@t{:}"

#. type: table
#: zsh.texi:5840
msgid "As @t{z} but takes a combination of option letters between a following pair of delimiter characters.  With no options the effect is identical to @t{z}.  The following options are available:"
msgstr "与 @t{z}相同，但在后面一对分隔符之间使用选项字母组合。 如果没有选项，效果与 @t{z}相同。 有以下选项"

#. type: t{#1}
#: zsh.texi:5843
#, no-wrap
msgid "(Z+c+)"
msgstr "(Z+c+)"

#. type: table
#: zsh.texi:5847
msgid "causes comments to be parsed as a string and retained; any field in the resulting array beginning with an unquoted comment character is a comment."
msgstr "会将注释解析为字符串并保留；结果数组中以未加引号的注释字符开头的任何字段都是注释。"

#. type: t{#1}
#: zsh.texi:5848
#, no-wrap
msgid "(Z+C+)"
msgstr "(Z+C+)"

#. type: table
#: zsh.texi:5853
msgid ""
"causes comments to be parsed and removed.  The rule for comments is standard: anything between a word starting with the third character of @t{$HISTCHARS}, default @t{#}, up to the next newline is a "
"comment."
msgstr "会解析并删除注释。 注释的规则是标准的：从 @t{$HISTCHARS}（默认为 @t{#}）的第三个字符开始的单词到下一个换行符之间的任何内容都是注释。"

#. type: t{#1}
#: zsh.texi:5854
#, no-wrap
msgid "(Z+n+)"
msgstr "(Z+n+)"

#. type: table
#: zsh.texi:5859
msgid "causes unquoted newlines to be treated as ordinary whitespace, else they are treated as if they are shell code delimiters and converted to semicolons."
msgstr "将未加引号的换行符视为普通空白，否则会将其视为 shell 代码分隔符并转换为分号。"

#. type: table
#: zsh.texi:5865
msgid "Options are combined within the same set of delimiters, e.g. @t{(Z+Cn+)}."
msgstr "选项在同一组分隔符内组合，例如 @t{(Z+Cn+)}。"

#. type: item
#: zsh.texi:5866
#, no-wrap
msgid "@t{_:}@var{flags}@t{:}"
msgstr "@t{_:}@var{flags}@t{:}"

#. type: table
#: zsh.texi:5871
msgid ""
"The underscore (@t{_}) flag is reserved for future use.  As of this revision of zsh, there are no valid @var{flags}; anything following an underscore, other than an empty pair of delimiters, is treated as "
"an error, and the flag itself has no effect."
msgstr "下划线 (@t{_}) 标志保留给将来使用。 在本次修订的 zsh 中，没有有效的 @var{flags}；除了空的分隔符之外，下划线后面的任何内容都会被视为错误，而标志本身则没有任何作用。"

#. type: Plain text
#: zsh.texi:5878
msgid "The following flags are meaningful with the @t{$@{}...@t{#}...@t{@}} or @t{$@{}...@t{%}...@t{@}} forms.  The @t{S}, @t{I}, and @t{*} flags may also be used with the @t{$@{}...@t{/}...@t{@}} forms."
msgstr "以下标志对 @t{$@{}...@t{#}...@t{@}} or @t{$@{}...@t{%}...@t{@}} 形式有意义。  @t{S}, @t{I} 和 @t{*} 标志也可与 @t{$@{}...@t{/}...@t{@}} 形式一起使用。"

#. type: table
#: zsh.texi:5885
msgid ""
"With @t{#} or @t{##}, search for the match that starts closest to the start of the string (a `substring match'). Of all matches at a particular position, @t{#} selects the shortest and @t{##} the longest:"
msgstr "使用 @t{#} 或 @t{##}，搜索最靠近字符串起始位置的匹配项（`子串匹配'）。在特定位置的所有匹配中，@t{#} 选择最短的，而 @t{##} 则选择最长的："

#. type: example
#: zsh.texi:5894
#, no-wrap
msgid ""
"% str=\"aXbXc\"\n"
"% echo $@{(S)str#X*@}\n"
"abXc\n"
"% echo $@{(S)str##X*@}\n"
"a\n"
"% \n"
msgstr ""
"% str=\"aXbXc\"\n"
"% echo $@{(S)str#X*@}\n"
"abXc\n"
"% echo $@{(S)str##X*@}\n"
"a\n"
"% \n"

#. type: table
#: zsh.texi:5899
msgid "With @t{%} or @t{%%}, search for the match that starts closest to the end of the string:"
msgstr "使用 @t{%} 或 @t{%%}，搜索最靠近字符串末尾的匹配项："

#. type: example
#: zsh.texi:5908
#, no-wrap
msgid ""
"% str=\"aXbXc\"\n"
"% echo $@{(S)str%X*@}\n"
"aXbc\n"
"% echo $@{(S)str%%X*@}\n"
"aXb\n"
"% \n"
msgstr ""
"% str=\"aXbXc\"\n"
"% echo $@{(S)str%X*@}\n"
"aXbc\n"
"% echo $@{(S)str%%X*@}\n"
"aXb\n"
"% \n"

#. type: table
#: zsh.texi:5913
msgid "(Note that @t{%} and @t{%%} don't search for the match that ends closest to the end of the string, as one might expect.)"
msgstr "(请注意，@t{%} 和 @t{%%} 并不像人们想象的那样，搜索最靠近字符串末尾的匹配项）。"

#. type: table
#: zsh.texi:5918
msgid "With substitution via @t{$@{}...@t{/}...@t{@}} or @t{$@{}...@t{//}...@t{@}}, specifies non-greedy matching, i.e. that the shortest instead of the longest match should be replaced:"
msgstr "通过  @t{$@{}...@t{/}...@t{@}} or @t{$@{}...@t{//}...@t{@}} 进行替换时，指定非贪婪匹配，即替换最短匹配而不是最长匹配："

#. type: example
#: zsh.texi:5927
#, no-wrap
msgid ""
"% str=\"abab\"\n"
"% echo $@{str/*b/_@}\n"
"_\n"
"% echo $@{(S)str/*b/_@}\n"
"_ab\n"
"% \n"
msgstr ""
"% str=\"abab\"\n"
"% echo $@{str/*b/_@}\n"
"_\n"
"% echo $@{(S)str/*b/_@}\n"
"_ab\n"
"% \n"

#. type: item
#: zsh.texi:5929
#, no-wrap
msgid "@t{I:}@var{expr}@t{:}"
msgstr "@t{I:}@var{expr}@t{:}"

#. type: table
#: zsh.texi:5935
msgid ""
"Search the @var{expr}th match (where @var{expr} evaluates to a number).  This only applies when searching for substrings, either with the @t{S} flag, or with @t{$@{}...@t{/}...@t{@}} (only the @var{expr}"
"th match is substituted) or @t{$@{}...@t{//}...@t{@}} (all matches from the @var{expr}th on are substituted).  The default is to take the first match."
msgstr ""
"搜索的第  @var{expr} 个匹配项（其中 @var{expr} 的值为数字）。 这仅适用于搜索子字符串时，使用 @t{S} 标志，或 @t{$@{}...@t{/}...@t{@}} （仅替换第 @var{expr}  个匹配项）。(只替换第 @var{expr} 个匹配）或  "
"@t{$@{}...@t{//}...@t{@}} (从 @var{expr} 开始的所有匹配都会被替换）。 默认情况下，取第一个匹配项。"

#. type: table
#: zsh.texi:5943
msgid ""
"The @var{expr}th match is counted such that there is either one or zero matches from each starting position in the string, although for global substitution matches overlapping previous replacements are "
"ignored.  With the @t{$@{}...@t{%}...@t{@}} and @t{$@{}...@t{%%}...@t{@}} forms, the starting position for the match moves backwards from the end as the index increases, while with the other forms it "
"moves forward from the start."
msgstr ""
"第 @var{expr} 个匹配的计算方法是，从字符串的每个起始位置开始，要么有一个匹配，要么为零，尽管在全局替换时匹配可能会与之前的替换重叠，但重叠部分的替换会被忽略。 对于 @t{$@{}...@t{%}...@t{@}} 和 @t{$@{}..."
"@t{%%}...@t{@}} 形式，随着索引的增加，匹配的起始位置会从尾部向后（backward）移动，而对于其他形式，则会从起始位置向前移动。"

#. type: table
#: zsh.texi:5946
msgid "Hence with the string"
msgstr "因此，用字符串"

#. type: example
#: zsh.texi:5948
#, no-wrap
msgid "which switch is the right switch for Ipswich?\n"
msgstr "which switch is the right switch for Ipswich?\n"

#. type: table
#: zsh.texi:5958
msgid ""
"substitutions of the form @t{$@{}(@t{SI:}@var{N}@t{:})@t{string#w*ch@}} as @var{N} increases from 1 will match and remove `@t{which}', `@t{witch}', `@t{witch}' and `@t{wich}'; the form using `@t{##}' will "
"match and remove `@t{which switch is the right switch for Ipswich}', `@t{witch is the right switch for Ipswich}', `@t{witch for Ipswich}' and `@t{wich}'. The form using `@t{%}' will remove the same "
"matches as for `@t{#}', but in reverse order, and the form using `@t{%%}' will remove the same matches as for `@t{##}' in reverse order."
msgstr ""
"当 @var{N} 从 1 开始增加时，形式为 @t{$@{}(@t{SI:}@var{N}@t{:})@t{string#w*ch@}} 的替换，将匹配并移除 `@t{which}', `@t{witch}', `@t{witch}' 和 `@t{wich}'； 使用 `@t{##}' 的形式将匹配并移除 `@t{which "
"switch is the right switch for Ipswich}', `@t{witch is the right switch for Ipswich}', `@t{witch for Ipswich}' 和 `@t{wich}'。使用 `@t{%}' 的形式将删除与 `@t{#}' 相同的匹配，但顺序相反；使用 `@t{%%}' 的形"
"式将删除与 `@t{##}' 相同的匹配，但顺序相反。"

#. type: pindex
#: zsh.texi:5960
#, no-wrap
msgid "EXTENDED_GLOB, enable"
msgstr "EXTENDED_GLOB, 启用"

#. type: table
#: zsh.texi:5963
msgid "Enable @t{EXTENDED_GLOB} for substitution via @t{$@{}...@t{/}...@t{@}} or @t{$@{}...@t{//}...@t{@}}.  Note that `@t{**}' does not disable extendedglob."
msgstr "启用 @t{EXTENDED_GLOB} 以通过 @t{$@{}...@t{/}...@t{@}} or @t{$@{}...@t{//}...@t{@}} 进行替换。 请注意， `@t{**}' 不会禁用扩展glob。"

#. type: t{#1}
#: zsh.texi:5964 zsh.texi:6948
#, no-wrap
msgid "B"
msgstr "B"

#. type: table
#: zsh.texi:5966
msgid "Include the index of the beginning of the match in the result."
msgstr "在结果中包含匹配起始的索引。"

#. type: t{#1}
#: zsh.texi:5967 zsh.texi:7303
#, no-wrap
msgid "E"
msgstr "E"

#. type: table
#: zsh.texi:5970
msgid "Include the index one character past the end of the match in the result (note this is inconsistent with other uses of parameter index)."
msgstr "在结果中包含匹配结束后一个字符的索引（注意这与参数索引的其他用法不一致）。"

#. type: t{#1}
#: zsh.texi:5971 zsh.texi:6995 zsh.texi:7499
#, no-wrap
msgid "M"
msgstr "M"

#. type: table
#: zsh.texi:5973
msgid "Include the matched portion in the result."
msgstr "在结果中包含匹配的部分。"

#. type: t{#1}
#: zsh.texi:5974 zsh.texi:7507 zsh.texi:7550
#, no-wrap
msgid "N"
msgstr "N"

#. type: table
#: zsh.texi:5976
msgid "Include the length of the match in the result."
msgstr "在结果中包含匹配长度。"

#. type: t{#1}
#: zsh.texi:5977 zsh.texi:7306 zsh.texi:8172
#, no-wrap
msgid "R"
msgstr "R"

#. type: table
#: zsh.texi:5979
msgid "Include the unmatched portion in the result (the @emph{R}est)."
msgstr "在结果中包含未匹配的部分（@emph{R}est）。"

#. type: subsection
#: zsh.texi:5984
#, no-wrap
msgid "Rules"
msgstr "Rules"

#. type: cindex
#: zsh.texi:5986
#, no-wrap
msgid "parameter expansion rules"
msgstr "参数扩展规则"

#. type: cindex
#: zsh.texi:5987
#, no-wrap
msgid "rules, parameter expansion"
msgstr "规则, 参数扩展"

#. type: cindex
#: zsh.texi:5988
#, no-wrap
msgid "substitution, parameter, rules"
msgstr "替换, 参数, 规则"

#. type: Plain text
#: zsh.texi:5994
msgid ""
"Here is a summary of the rules for substitution; this assumes that braces are present around the substitution, i.e. @t{$@{}@var{...}@t{@}}.  Some particular examples are given below.  Note that the Zsh "
"Development Group accepts @emph{no responsibility} for any brain damage which may occur during the reading of the following rules."
msgstr "以下是替换规则的摘要；假设替换周围有大括号，即 @t{$@{}@var{...}@t{@}}。 下面给出了一些特殊的示例。 请注意，Zsh 开发小组对阅读以下规则时可能造成的任何脑损伤概不负责。"

#. type: item
#: zsh.texi:5997
#, no-wrap
msgid "@t{1.} @emph{Nested substitution}"
msgstr "@t{1.} @emph{嵌套替换}"

#. type: table
#: zsh.texi:6007
msgid ""
"If multiple nested @t{$@{}@var{...}@t{@}} forms are present, substitution is performed from the inside outwards.  At each level, the substitution takes account of whether the current value is a scalar or "
"an array, whether the whole substitution is in double quotes, and what flags are supplied to the current level of substitution, just as if the nested substitution were the outermost.  The flags are not "
"propagated up to enclosing substitutions; the nested substitution will return either a scalar or an array as determined by the flags, possibly adjusted for quoting.  All the following steps take place "
"where applicable at all levels of substitution."
msgstr ""
"如果存在多个嵌套的 @t{$@{}@var{...}@t{@}} 形式，则从内向外进行替换。 在每一层中，替换都会考虑当前值是标量还是数组，整个替换是否使用双引号，以及为当前替换层提供了哪些标志，就像嵌套替换是最外层一样。 这些标"
"志不会向上传播到外层替换；嵌套替换将根据标志返回标量或数组，并可能根据引号进行调整。 下面的所有步骤都将在各级替换中进行。"

#. type: table
#: zsh.texi:6015
msgid ""
"Note that, unless the `@t{(P)}' flag is present, the flags and any subscripts apply directly to the value of the nested substitution; for example, the expansion @t{$@{$@{foo@}@}} behaves exactly the same "
"as @t{$@{foo@}}.  When the `@t{(P)}' flag is present in a nested substitution, the other substitution rules are applied to the value @emph{before} it is interpreted as a name, so @t{$@{$@{(P)foo@}@}} may "
"differ from @t{$@{(P)foo@}}."
msgstr ""
"请注意，除非存在 `@t{(P)}' 标记，否则标记和任何下标都直接应用于嵌套替换的值；例如，扩展 @t{$@{$@{foo@}@}} 的行为与 @t{$@{foo@}} 完全相同。 当嵌套替换中出现 `@t{(P)}' 标记时，其他替换规则将在值被解释为名称"
"@emph{之前}应用到值，因此 @t{$@{$@{(P)foo@}@}} 可能与 @t{$@{(P)foo@}} 不同。"

#. type: table
#: zsh.texi:6026
msgid ""
"At each nested level of substitution, the substituted words undergo all forms of single-word substitution (i.e. not filename generation), including command substitution, arithmetic expansion and filename "
"expansion (i.e. leading @t{~} and @t{=}).  Thus, for example, @t{$@{$@{:-=cat@}:h@}} expands to the directory where the @t{cat} program resides.  (Explanation: the internal substitution has no parameter "
"but a default value @t{=cat}, which is expanded by filename expansion to a full path; the outer substitution then applies the modifier @t{:h} and takes the directory part of the path.)"
msgstr ""
"在每一级嵌套替换中，被替换的单词都会进行所有形式的单字替换（即不生成文件名），包括命令替换、算术扩展和文件名扩展（即前导 @t{~} 和 @t{=}）。 例如， @t{$@{$@{:-=cat@}:h@}} 扩展到 @t{cat} 程序所在的目录。 (解"
"释：内部替换没有参数，只有一个缺省值 @t{=cat}，该值通过文件名扩展扩展为完整路径；外部替换应用修饰符 @t{:h}，并获取路径中的目录部分）。"

#. type: item
#: zsh.texi:6027
#, no-wrap
msgid "@t{2.} @emph{Internal parameter flags}"
msgstr "@t{2.} @emph{内部参数标志}"

#. type: table
#: zsh.texi:6033
msgid ""
"Any parameter flags set by one of the @t{typeset} family of commands, in particular the @t{-L}, @t{-R}, @t{-Z}, @t{-u} and @t{-l} options for padding and capitalization, are applied directly to the "
"parameter value.  Note these flags are options to the command, e.g. `@t{typeset -Z}'; they are not the same as the flags used within parameter substitutions."
msgstr ""
"任何由 @t{typeset} 系列命令之一设置的参数标志，特别是用于填充和大写的 @t{-L}, @t{-R}, @t{-Z}, @t{-u} 和 @t{-l} 选项，都会直接应用于参数值。 请注意，这些标志是命令的选项，例如 `@t{typeset -Z}'；它们与参数替"
"换中使用的标志不同。"

#. type: table
#: zsh.texi:6041
msgid ""
"At the outermost level of substitution, the `@t{(P)}' flag (rule @t{4.})  ignores these transformations and uses the unmodified value of the parameter as the name to be replaced.  This is usually the "
"desired behavior because padding may make the value syntactically illegal as a parameter name, but if capitalization changes are desired, use the @t{$@{$@{(P)foo@}@}} form (rule @t{25.})."
msgstr ""
"在替换的最外层， `@t{(P)}' 标志（规则 @t{4.}）会忽略这些转换，并使用未修改的参数值作为要替换的名称。 这通常是我们所希望的行为，因为填充可能会使值作为参数名在语法上不合法，但如果需要更改大写字母，则应使用 "
"@t{$@{$@{(P)foo@}@}} 形式（规则 @t{25.}）。"

#. type: item
#: zsh.texi:6042
#, no-wrap
msgid "@t{3.} @emph{Parameter subscripting}"
msgstr "@t{3.} @emph{参数下标}"

#. type: table
#: zsh.texi:6052
msgid ""
"If the value is a raw parameter reference with a subscript, such as @t{$@{}@var{var}@t{[3]@}}, the effect of subscripting is applied directly to the parameter.  Subscripts are evaluated left to right; "
"subsequent subscripts apply to the scalar or array value yielded by the previous subscript.  Thus if @t{var} is an array, @t{$@{var[1][2]@}} is the second character of the first word, but @t{$@{var[2,4]"
"[2]@}} is the entire third word (the second word of the range of words two through four of the original array).  Any number of subscripts may appear.  Flags such as `@t{(k)}' and `@t{(v)}' which alter the "
"result of subscripting are applied."
msgstr ""
"如果数值是带有下标的原始参数引用，例如 @t{$@{}@var{var}@t{[3]@}}，下标的作用将直接应用于参数。 下标从左到右依次求值；后续下标适用于前一个下标产生的标量或数组值。 因此，如果 @t{var} 是一个数组，@t{$@{var[1]"
"[2]@}}  就是第一个单词的第二个字符，而  @t{$@{var[2,4][2]@}}  就是整个第三个单词（原始数组中第二到第四个单词范围内的第二个单词）。 可以出现任意数量的下标。 `@t{(k)}'  和 `@t{(v)}' 等标志可用来改变下标结"
"果。"

#. type: item
#: zsh.texi:6053
#, no-wrap
msgid "@t{4.} @emph{Parameter name replacement}"
msgstr "@t{4.} @emph{参数名替换}"

#. type: table
#: zsh.texi:6059
msgid ""
"At the outermost level of nesting only, the `@t{(P)}' flag is applied.  This treats the value so far as a parameter name (which may include a subscript expression) and replaces that with the corresponding "
"value.  This replacement occurs later if the `@t{(P)}' flag appears in a nested substitution."
msgstr "仅在嵌套的最外层，才使用 `@t{(P)}' 标记。 这会将迄今为止的值视为参数名（可能包括下标表达式），并用相应的值替换。 如果 `@t{(P)}' 标志出现在嵌套替换中，替换将在后面进行。"

#. type: table
#: zsh.texi:6063
msgid "If the value so far names a parameter that has internal flags (rule @t{2.}), those internal flags are applied to the new value after replacement."
msgstr "如果当前值命名的参数有内部标志（规则 @t{2.}），则替换后的新值将应用这些内部标志。"

#. type: item
#: zsh.texi:6064
#, no-wrap
msgid "@t{5.} @emph{Double-quoted joining}"
msgstr "@t{5.} @emph{双引号连接}"

#. type: table
#: zsh.texi:6072
msgid ""
"If the value after this process is an array, and the substitution appears in double quotes, and neither an `@t{(@@)}' flag nor a `@t{#}' length operator is present at the current level, then words of the "
"value are joined with the first character of the parameter @t{$IFS}, by default a space, between each word (single word arrays are not modified).  If the `@t{(j)}' flag is present, that is used for "
"joining instead of @t{$IFS}."
msgstr ""
"如果处理后的值是一个数组，且替换出现在双引号中，且当前层级既没有 `@t{(@@)}' 标志，也没有 `@t{#}' l长度操作符，那么值的字将被连接，每个字之间使用参数 @t{$IFS} 的第一个字符（默认为空格）（单字数组不会被修"
"改）。 如果存在 `@t{(j)}' 标志，则将使用该标志代替 @t{$IFS} 进行连接。"

#. type: item
#: zsh.texi:6073
#, no-wrap
msgid "@t{6.} @emph{Nested subscripting}"
msgstr "@t{6.} @emph{嵌套下标}"

#. type: table
#: zsh.texi:6081
msgid ""
"Any remaining subscripts (i.e. of a nested substitution) are evaluated at this point, based on whether the value is an array or a scalar.  As with @t{3.}, multiple subscripts can appear.  Note that "
"@t{$@{foo[2,4][2]@}} is thus equivalent to @t{$@{$@{foo[2,4]@}[2]@}} and also to @t{\"$@{$@{(@@)foo[2,4]@}[2]@}\"} (the nested substitution returns an array in both cases), but not to @t{\"$@{$@{foo[2,4]@}"
"[2]@}\"} (the nested substitution returns a scalar because of the quotes)."
msgstr ""
"此时，将根据值是数组还是标量，对任何剩余的下标（即嵌套替换的下标）进行计算。 与 @t{3.} 一样，可以出现多个下标。 请注意， @t{$@{foo[2,4][2]@}} 等价于 @t{$@{$@{foo[2,4]@}[2]@}}，也等价于 "
"@t{\"$@{$@{(@@)foo[2,4]@}[2]@}\"} （嵌套替换在这两种情况下都返回一个数组），但不等价于 @t{\"$@{$@{foo[2,4]@}[2]@}\"} （由于引号的存在，嵌套替换返回一个标量）。"

#. type: item
#: zsh.texi:6082
#, no-wrap
msgid "@t{7.} @emph{Modifiers}"
msgstr "@t{7.} @emph{修饰符}"

#. type: table
#: zsh.texi:6087
msgid ""
"Any modifiers, as specified by a trailing `@t{#}', `@t{%}', `@t{/}' (possibly doubled) or by a set of modifiers of the form `@t{:...}' (see @ref{Modifiers} in @ref{History Expansion}), are applied to the "
"words of the value at this level."
msgstr "任何修饰符，如尾部的`@t{#}', `@t{%}', `@t{/}'（可能双写）或一组形式为 `@t{:...}' 的修饰符（见 @ref{历史扩展} 中的 @ref{修饰符}）所指定的，都会应用到这一层的值的字词上。"

#. type: item
#: zsh.texi:6088
#, no-wrap
msgid "@t{8.} @emph{Character evaluation}"
msgstr "@t{8.} @emph{字符求值}"

#. type: table
#: zsh.texi:6091
msgid "Any `@t{(#)}' flag is applied, evaluating the result so far numerically as a character."
msgstr "任何 `@t{(#)}' 标记都会被应用，并将目前的结果作为一个字符进行数字求值。"

#. type: item
#: zsh.texi:6092
#, no-wrap
msgid "@t{9.} @emph{Length}"
msgstr "@t{9.} @emph{长度}"

#. type: table
#: zsh.texi:6095
msgid "Any initial `@t{#}' modifier, i.e. in the form @t{$@{#}@var{var}@t{@}}, is used to evaluate the length of the expression so far."
msgstr "任何初始 `@t{#}' 修饰符，即  @t{$@{#}@var{var}@t{@}} 形式的修饰符，都会被用来计算表达式的长度。"

#. type: item
#: zsh.texi:6096
#, no-wrap
msgid "@t{10.} @emph{Forced joining}"
msgstr "@t{10.} @emph{强制连接}"

#. type: table
#: zsh.texi:6103
msgid ""
"If the `@t{(j)}' flag is present, or no `@t{(j)}' flag is present but the string is to be split as given by rule @t{11.}, and joining did not take place at rule @t{5.}, any words in the value are joined "
"together using the given string or the first character of @t{$IFS} if none.  Note that the `@t{(F)}' flag implicitly supplies a string for joining in this manner."
msgstr ""
"如果存在 `@t{(j)}' 标志，或没有 `@t{(j)}' 标志，但字符串要按规则 @t{11.} 进行拆分，且未按规则 @t{5.} 进行连接，则使用给定的字符串或（如果没有给定字符串） @t{$IFS} 的第一个字符连接值中的任何单词。 请注意， "
"`@t{(F)}' 标志隐含地提供了一个字符串，以便以这种方式连接。"

#. type: item
#: zsh.texi:6104
#, no-wrap
msgid "@t{11.} @emph{Simple word splitting}"
msgstr "@t{11.} @emph{简单的单词拆分}"

#. type: table
#: zsh.texi:6109
msgid ""
"If one of the `@t{(s)}' or `@t{(f)}' flags are present, or the `@t{=}' specifier was present (e.g. @t{$@{=}@var{var}@t{@}}), the word is split on occurrences of the specified string, or (for @t{=} with "
"neither of the two flags present) any of the characters in @t{$IFS}."
msgstr "如果存在 `@t{(s)}' 或 `@t{(f)}' 标志之一，或存在 `@t{=}' 指示符（例如 @t{$@{=}@var{var}@t{@}} ），则在出现指定字符串或（对于两个标志均不存在的 @t{=}）@t{$IFS}中的任何字符时分割单词。"

#. type: table
#: zsh.texi:6115
msgid ""
"If no `@t{(s)}', `@t{(f)}' or `@t{=}' was given, but the word is not quoted and the option @t{SH_WORD_SPLIT} is set, the word is split on occurrences of any of the characters in @t{$IFS}.  Note this step, "
"too, takes place at all levels of a nested substitution."
msgstr "如果没有给出 `@t{(s)}', `@t{(f)}' 或 `@t{=}' ，但单词没有加引号，且设置了选项 @t{SH_WORD_SPLIT}，则会在出现 @t{$IFS} 中的任何字符时分割单词。 请注意，这一步骤也会在嵌套替换的各级进行。"

#. type: item
#: zsh.texi:6116
#, no-wrap
msgid "@t{12.} @emph{Case modification}"
msgstr "@t{12.} @emph{大小写修改}"

#. type: table
#: zsh.texi:6119
msgid "Any case modification from one of the flags `@t{(L)}', `@t{(U)}' or `@t{(C)}' is applied."
msgstr "任何由 `@t{(L)}', `@t{(U)}' 或 `@t{(C)}' 标志之一产生的大小写修改都会被应用。"

#. type: item
#: zsh.texi:6120
#, no-wrap
msgid "@t{13.} @emph{Escape sequence replacement}"
msgstr "@t{13.} @emph{转义序列替换}"

#. type: table
#: zsh.texi:6123
msgid "First any replacements from the `@t{(g)}' flag are performed, then any prompt-style formatting from the `@t{(%)}' family of flags is applied."
msgstr "首先执行 `@t{(g)}' 标志中的任何替换，然后应用 `@t{(%)}' 标志系列中的任何提示符样式格式。"

#. type: item
#: zsh.texi:6124
#, no-wrap
msgid "@t{14.} @emph{Quote application}"
msgstr "@t{14.} @emph{引号应用}"

#. type: table
#: zsh.texi:6127
msgid "Any quoting or unquoting using `@t{(q)}' and `@t{(Q)}' and related flags is applied."
msgstr "任何使用 `@t{(q)}' 和 `@t{(Q)}' 及相关标志的引号或反引号（unquoting）都会被应用。"

#. type: item
#: zsh.texi:6128
#, no-wrap
msgid "@t{15.} @emph{Directory naming}"
msgstr "@t{15.} @emph{目录命名}"

#. type: table
#: zsh.texi:6130
msgid "Any directory name substitution using `@t{(D)}' flag is applied."
msgstr "任何使用 `@t{(D)}' 标志的目录名替换都会被应用。"

#. type: item
#: zsh.texi:6131
#, no-wrap
msgid "@t{16.} @emph{Visibility enhancement}"
msgstr "@t{16.} @emph{可视化增强}"

#. type: table
#: zsh.texi:6134
msgid "Any modifications to make characters visible using the `@t{(V)}' flag are applied."
msgstr "任何使用 `@t{(V)}' 标志使字符可见（ visible ）的修改都会被应用。"

#. type: item
#: zsh.texi:6135
#, no-wrap
msgid "@t{17.} @emph{Lexical word splitting}"
msgstr "@t{17.} @emph{词性拆分}"

#. type: table
#: zsh.texi:6142
msgid ""
"If the '@t{(z)}' flag or one of the forms of the '@t{(Z)}' flag is present, the word is split as if it were a shell command line, so that quotation marks and other metacharacters are used to decide what "
"constitutes a word.  Note this form of splitting is entirely distinct from that described by rule @t{11.}: it does not use @t{$IFS}, and does not cause forced joining."
msgstr ""
"如果存在 '@t{(z)}' 标志或 '@t{(Z)}' 标记的其中一种形式，单词将像 shell 命令行一样被拆分，因此引号和其他元字符被用来决定什么是单词。 请注意，这种形式的分词与规则 @t{11.} 所描述的分词完全不同：它不使用 "
"@t{$IFS}，也不会导致强制连接。"

#. type: item
#: zsh.texi:6143
#, no-wrap
msgid "@t{18.} @emph{Uniqueness}"
msgstr "@t{18.} @emph{唯一性}"

#. type: table
#: zsh.texi:6146
msgid "If the result is an array and the `@t{(u)}' flag was present, duplicate elements are removed from the array."
msgstr "如果结果是一个数组，且存在 `@t{(u)}' 标记，则会从数组中删除重复元素。"

#. type: item
#: zsh.texi:6147
#, no-wrap
msgid "@t{19.} @emph{Ordering}"
msgstr "@t{19.} @emph{排序}"

#. type: table
#: zsh.texi:6150
msgid "If the result is still an array and one of the `@t{(o)}' or `@t{(O)}' flags was present, the array is reordered."
msgstr "如果结果仍然是一个数组，并且存在 `@t{(o)}' 或 `@t{(O)}' 标志，数组将被重新排序。"

#. type: item
#: zsh.texi:6151
#, no-wrap
msgid "@t{20.} @t{RC_EXPAND_PARAM}"
msgstr "@t{20.} @t{RC_EXPAND_PARAM}"

#. type: table
#: zsh.texi:6155
msgid ""
"At this point the decision is made whether any resulting array elements are to be combined element by element with surrounding text, as given by either the @t{RC_EXPAND_PARAM} option or the `@t{^}' flag."
msgstr "此时，将决定是否按照 @t{RC_EXPAND_PARAM} 选项或 `@t{^}' 标志的指示，将数组元素与周围的文本逐一组合。"

#. type: item
#: zsh.texi:6156
#, no-wrap
msgid "@t{21.} @emph{Re-evaluation}"
msgstr "@t{21.} @emph{重新求值}"

#. type: table
#: zsh.texi:6160
msgid "Any `@t{(e)}' flag is applied to the value, forcing it to be re-examined for new parameter substitutions, but also for command and arithmetic substitutions."
msgstr "任何 `@t{(e)}' 标记都会应用于该值，从而迫使它在进行新参数替换以及命令和算术替换时被重新检查。"

#. type: item
#: zsh.texi:6161
#, no-wrap
msgid "@t{22.} @emph{Padding}"
msgstr "@t{22.} @emph{填充}"

#. type: table
#: zsh.texi:6164
msgid "Any padding of the value by the `@t{(l.}@var{fill}@t{.)}' or `@t{(r.}@var{fill}@t{.)}' flags is applied."
msgstr "使用 `@t{(l.}@var{fill}@t{.)}' 或 `@t{(r.}@var{fill}@t{.)}' 标志对值进行填充。"

#. type: item
#: zsh.texi:6165
#, no-wrap
msgid "@t{23.} @emph{Semantic joining}"
msgstr "@t{23.} @emph{语义连接}"

#. type: table
#: zsh.texi:6171
msgid ""
"In contexts where expansion semantics requires a single word to result, all words are rejoined with the first character of @t{IFS} between.  So in `@t{$@{(P}@t{)$@{(f}@t{)lines@}@}}' the value of "
"@t{$@{lines@}} is split at newlines, but then must be joined again before the `@t{(P)}' flag can be applied."
msgstr ""
"在扩展语义要求只产生一个单词的情况下，所有单词之间都会用 @t{IFS} 的第一个字符重新连接。 因此，在 `@t{$@{(P}@t{)$@{(f}@t{)lines@}@}}' 中， @t{$@{lines@}} 的值在换行符处被分割，但在应用 `@t{(P)}' 标记之前必"
"须再次连接。"

#. type: table
#: zsh.texi:6174
msgid "If a single word is not required, this rule is skipped."
msgstr "如果不需要单个单词，则跳过该规则。"

#. type: item
#: zsh.texi:6175
#, no-wrap
msgid "@t{24.} @emph{Empty argument removal}"
msgstr "@t{24.} @emph{空参数移除}"

#. type: table
#: zsh.texi:6179
msgid ""
"If the substitution does not appear in double quotes, any resulting zero-length argument, whether from a scalar or an element of an array, is elided from the list of arguments inserted into the command "
"line."
msgstr "如果替换不在双引号中出现，任何由此产生的零长度参数，无论是来自标量还是数组元素，都会从插入命令行的参数列表中删除。"

#. type: table
#: zsh.texi:6184
msgid "Strictly speaking, the removal happens later as the same happens with other forms of substitution; the point to note here is simply that it occurs after any of the above parameter operations."
msgstr "严格来说，移除发生在后面，因为其他形式的替换也是如此；这里需要注意的是，移除发生在上述任何参数操作之后。"

#. type: item
#: zsh.texi:6185
#, no-wrap
msgid "@t{25.} @emph{Nested parameter name replacement}"
msgstr "@t{25.} @emph{嵌套参数名替换}"

#. type: table
#: zsh.texi:6190
msgid ""
"If the `@t{(P)}' flag is present and rule @t{4.} has not applied, the value so far is treated as a parameter name (which may include a subscript expression) and replaced with the corresponding value, with "
"internal flags (rule @t{2.}) applied to the new value."
msgstr "如果存在 `@t{(P)}' 标记，且规则 @t{4.} 尚未应用，则迄今为止的值将被视为参数名（可能包括下标表达式），并替换为相应的值，内部标记（规则 @t{2.}）将应用于新值。"

#. type: subsection
#: zsh.texi:6195 zsh.texi:37717
#, no-wrap
msgid "Examples"
msgstr "示例"

#. type: cindex
#: zsh.texi:6197
#, no-wrap
msgid "parameter expansion, examples"
msgstr "参数扩展, 示例"

#. type: Plain text
#: zsh.texi:6205
msgid ""
"The flag @t{f} is useful to split a double-quoted substitution line by line.  For example, @t{$@{(f)\"$(<}@var{file}@t{)\"@}} substitutes the contents of @var{file} divided so that each line is an element "
"of the resulting array.  Compare this with the effect of @t{$}@t{(<}@var{file}@t{)} alone, which divides the file up by words, or the same inside double quotes, which makes the entire content of the file "
"a single string."
msgstr ""
"标记 @t{f} 用于逐行分割双引号替换。 例如，@t{$@{(f)\"$(<}@var{file}@t{)\"@}}  会替换 @var{file} 中被分割的内容，这样每一行都是结果数组中的一个元素。 与  @t{$}@t{(<}@var{file}@t{)}  单独使用的效果相比， "
"@t{$}@t{(<}@var{file}@t{)}  将文件按单词分割，而在双引号内使用同样的效果，这将文件的全部内容变成一个字符串。"

#. type: Plain text
#: zsh.texi:6209
msgid "The following illustrates the rules for nested parameter expansions.  Suppose that @t{$foo} contains the array @t{(bar baz}@t{)}:"
msgstr "下面说明了嵌套参数展开的规则。 假设 @t{$foo} 包含数组  @t{(bar baz}@t{)} ："

#. type: t{#1}
#: zsh.texi:6212
#, no-wrap
msgid "\"$@{(@@)$@{foo@}[1]@}\""
msgstr "\"$@{(@@)$@{foo@}[1]@}\""

#. type: table
#: zsh.texi:6218
msgid ""
"This produces the result @t{b}.  First, the inner substitution @t{\"$@{foo@}\"}, which has no array (@t{@@}) flag, produces a single word result @t{\"bar baz\"}.  The outer substitution @t{\"$@{(@@)..."
"[1]@}\"} detects that this is a scalar, so that (despite the `@t{(@@)}' flag) the subscript picks the first character."
msgstr ""
"结果是 @t{b}。 首先，内部替换  @t{\"$@{foo@}\"}（没有数组 (@t{@@}) 标志）产生了单字结果  @t{\"bar baz\"}。 外层替换  @t{\"$@{(@@)...[1]@}\"} 检测到这是一个标量，因此（尽管有 `@t{(@@)}' 标志）下标选择了第一"
"个字符。"

#. type: t{#1}
#: zsh.texi:6219
#, no-wrap
msgid "\"$@{$@{(@@)foo@}[1]@}\""
msgstr "\"$@{$@{(@@)foo@}[1]@}\""

#. type: table
#: zsh.texi:6224
msgid ""
"This produces the result `@t{bar}'.  In this case, the inner substitution @t{\"$@{(@@)foo@}\"} produces the array `@t{(bar baz}@t{)}'.  The outer substitution @t{\"$@{...[1]@}\"} detects that this is an "
"array and picks the first word.  This is similar to the simple case @t{\"$@{foo[1]@}\"}."
msgstr ""
"这将产生结果 `@t{bar}'。 在这种情况下，内部替换 @t{\"$@{(@@)foo@}\"} 产生数组 `@t{(bar baz}@t{)}'。 外层替换 @t{\"$@{...[1]@}\"}  会检测到这是一个数组，并选择第一个单词。 这与简单情况 @t{\"$@{foo[1]@}\"} "
"类似。"

#. type: Plain text
#: zsh.texi:6230
msgid "As an example of the rules for word splitting and joining, suppose @t{$foo} contains the array `@t{(ax1 bx1}@t{)}'.  Then"
msgstr "以分词和连词的规则为例，假设 @t{$foo} 包含数组 `@t{(ax1 bx1}@t{)}'。 那么"

#. type: t{#1}
#: zsh.texi:6233
#, no-wrap
msgid "$@{(s/x/)foo@}"
msgstr "$@{(s/x/)foo@}"

#. type: table
#: zsh.texi:6235
msgid "produces the words `@t{a}', `@t{1 b}' and `@t{1}'."
msgstr "会产生 `@t{a}', `@t{1 b}' 和 `@t{1}'。"

#. type: t{#1}
#: zsh.texi:6236
#, no-wrap
msgid "$@{(j/x/s/x/)foo@}"
msgstr "$@{(j/x/s/x/)foo@}"

#. type: table
#: zsh.texi:6238
msgid "produces `@t{a}', `@t{1}', `@t{b}' and `@t{1}'."
msgstr "会产生 `@t{a}', `@t{1}', `@t{b}' 和 `@t{1}'。"

#. type: t{#1}
#: zsh.texi:6239
#, no-wrap
msgid "$@{(s/x/)foo%%1*@}"
msgstr "$@{(s/x/)foo%%1*@}"

#. type: table
#: zsh.texi:6245
msgid ""
"produces `@t{a}' and `@t{ b}' (note the extra space).  As substitution occurs before either joining or splitting, the operation first generates the modified array @t{(ax bx}@t{)}, which is joined to give "
"@t{\"ax bx\"}, and then split to give `@t{a}', `@t{ b}' and `'.  The final empty string will then be elided, as it is not in double quotes."
msgstr ""
"产生 `@t{a}' 和 `@t{ b}'（注意多出的空格）。 由于替换发生在连接或拆分之前，因此操作首先生成修改后的数组 @t{(ax bx}@t{)} ，连接后得到  @t{\"ax bx\"} ，然后拆分得到  `@t{a}', `@t{ b}'  和  `'。 最后的空字符"
"串将被省略，因为它不在双引号中。"

#. type: cindex
#: zsh.texi:6253
#, no-wrap
msgid "command substitution"
msgstr "命令替换"

#. type: cindex
#: zsh.texi:6254
#, no-wrap
msgid "substitution, command"
msgstr "替换, 命令"

#. type: Plain text
#: zsh.texi:6261
msgid ""
"A command enclosed in parentheses preceded by a dollar sign, like `@t{$(}...@t{)}', or quoted with grave accents, like `@t{`}...@t{`}', is replaced with its standard output, with any trailing newlines "
"deleted.  If the substitution is not enclosed in double quotes, the output is broken into words using the @t{IFS} parameter."
msgstr ""
"在以美元符号开头的括号中括起来的命令，如 `@t{$(}...@t{)}'，或带重音符号的引号，如 `@t{`}...@t{`}' ，将被替换为它的标准输出，并删除尾部换行符。 如果替换内容没有用双引号括起来，则使用 @t{IFS} 参数将输出内容"
"分解成单词。"

#. type: Plain text
#: zsh.texi:6269
msgid ""
"The substitution `@t{$(cat} @var{foo}@t{)}' may be replaced by the faster `@t{$(<}@var{foo}@t{)}'.  In this case @var{foo} undergoes single word shell expansions (@emph{parameter expansion}, @emph{command "
"substitution} and @emph{arithmetic expansion}), but not filename generation."
msgstr ""
" `@t{$(cat} @var{foo}@t{)}' 可以被速度更快的 `@t{$(<}@var{foo}@t{)}' 替换。 在这种情况下，@var{foo} 会进行单字 shell 扩展（@emph{参数扩展}、@emph{命令替换}和 @emph{算术扩展}），但不会执行文件名生成。"

#. type: Plain text
#: zsh.texi:6274
msgid "If the option @t{GLOB_SUBST} is set, the result of any unquoted command substitution, including the special form just mentioned, is eligible for filename generation."
msgstr "如果设置了选项 @t{GLOB_SUBST}，则任何未加引号的命令替换结果，包括刚才提到的特殊形式，都可以用于文件名生成。"

#. type: cindex
#: zsh.texi:6280
#, no-wrap
msgid "arithmetic expansion"
msgstr "算术扩展"

#. type: cindex
#: zsh.texi:6281
#, no-wrap
msgid "expansion, arithmetic"
msgstr "扩展, 算术"

#. type: Plain text
#: zsh.texi:6288
msgid ""
"A string of the form `@t{$[}@var{exp}@t{]}' or `@t{$((}@var{exp}@t{))}' is substituted with the value of the arithmetic expression @var{exp}.  @var{exp} is subjected to @emph{parameter expansion}, "
"@emph{command substitution} and @emph{arithmetic expansion} before it is evaluated.  See @ref{Arithmetic Evaluation}."
msgstr ""
"形式为 `@t{$[}@var{exp}@t{]}' 或 `@t{$((}@var{exp}@t{))}' 的字符串会被算术表达式 @var{exp} 的值所替代。 在求值之前，@var{exp} 会进行 @emph{参数扩展}、@emph{命令替换} 和 @emph{算术扩展}。 请参阅 @ref{算术求"
"值}。"

#. type: cindex
#: zsh.texi:6292
#, no-wrap
msgid "brace expansion"
msgstr "括号扩展"

#. type: cindex
#: zsh.texi:6293
#, no-wrap
msgid "expansion, brace"
msgstr "扩展, 括号"

#. type: Plain text
#: zsh.texi:6301
msgid ""
"A string of the form `@var{foo}@t{@{}@var{xx}@t{,}@var{yy}@t{,}@var{zz}@t{@}}@var{bar}' is expanded to the individual words `@var{fooxxbar}', `@var{fooyybar}' and `@var{foozzbar}'.  Left-to-right order is "
"preserved.  This construct may be nested.  Commas may be quoted in order to include them literally in a word."
msgstr ""
"形式为 `@var{foo}@t{@{}@var{xx}@t{,}@var{yy}@t{,}@var{zz}@t{@}}@var{bar}' 的字符串会扩展为单独的字 `@var{fooxxbar}', `@var{fooyybar}' 和 `@var{foozzbar}'。 保留从左到右的顺序。 该结构可以嵌套。 逗号可以加"
"引号，以便按字面意思将其包含在单词中。"

#. type: Plain text
#: zsh.texi:6311
msgid ""
"An expression of the form `@t{@{}@var{n1}@t{..}@var{n2}@t{@}}', where @var{n1} and @var{n2} are integers, is expanded to every number between @var{n1} and @var{n2} inclusive.  If either number begins with "
"a zero, all the resulting numbers will be padded with leading zeroes to that minimum width, but for negative numbers the @t{-} character is also included in the width.  If the numbers are in decreasing "
"order the resulting sequence will also be in decreasing order."
msgstr ""
"形式为 `@t{@{}@var{n1}@t{..}@var{n2}@t{@}}' 的表达式，其中 @var{n1} 和 @var{n2} 均为整数，会扩展为 @var{n1} 和 @var{n2} 之间的所有数字。 如果任一数字以 0 开头，所有生成的数字都会以 0 为前导填充，达到最小宽"
"度，但对于负数，@t{-} 字符也会包含在宽度中。 如果数字按递减顺序排列，则产生的序列也将按递减顺序排列。"

#. type: Plain text
#: zsh.texi:6322
msgid ""
"An expression of the form `@t{@{}@var{n1}@t{..}@var{n2}@t{..}@var{n3}@t{@}}', where @var{n1}, @var{n2}, and @var{n3} are integers, is expanded as above, but only every @var{n3}th number starting from "
"@var{n1} is output.  If @var{n3} is negative the numbers are output in reverse order, this is slightly different from simply swapping @var{n1} and @var{n2} in the case that the step @var{n3} doesn't "
"evenly divide the range.  Zero padding can be specified in any of the three numbers, specifying it in the third can be useful to pad for example `@t{@{-99..100..01@}}' which is not possible to specify by "
"putting a 0 on either of the first two numbers (i.e. pad to two characters)."
msgstr ""
"一个形式为 `@t{@{}@var{n1}@t{..}@var{n2}@t{..}@var{n3}@t{@}}' 的表达式，其中 @var{n1}、@var{n2} 和 @var{n3} 均为整数，将按上述方式展开，但只输出从 @var{n1} 开始的第 @var{n3} 个数字。 如果 @var{n3} 为负数，"
"数字将以相反的顺序输出，这与简单地交换 @var{n1} 和 @var{n2} 稍有不同，因为 @var{n3} 的步长不能平均分割范围。 可以在三个数字中的任何一个指定零填充，在第三个数字中指定零填充可能会很有用，例如 "
"`@t{@{-99..100..01@}}' ，如果不能在前两个数字中的任何一个上打 0，就无法指定零填充（即填充为两个字符）。"

#. type: Plain text
#: zsh.texi:6333
msgid ""
"An expression of the form `@t{@{}@var{c1}@t{..}@var{c2}@t{@}}', where @var{c1} and @var{c2} are single characters (which may be multibyte characters), is expanded to every character in the range from "
"@var{c1} to @var{c2} in whatever character sequence is used internally.  For characters with code points below 128 this is US ASCII (this is the only case most users will need).  If any intervening "
"character is not printable, appropriate quotation is used to render it printable.  If the character sequence is reversed, the output is in reverse order, e.g. `@t{@{d..a@}}' is substituted as `@t{d c b "
"a}'."
msgstr ""
"形式为 `@t{@{}@var{c1}@t{..}@var{c2}@t{@}}' 的表达式，其中 @var{c1} 和 @var{c2} 为单个字符（可以是多字节字符），将扩展为内部使用的字符序列中 @var{c1} 至 @var{c2} 范围内的每个字符。 对于码位低于 128 的字"
"符，则使用 US ASCII（这是大多数用户唯一需要的情况）。 如果中间的任何字符不可打印，将使用适当的引用使其可打印。 如果字符序列颠倒，则按相反顺序输出，例如，`@t{@{d..a@}}' 被替换为 `@t{d c b a}'。"

#. type: Plain text
#: zsh.texi:6338
msgid "If a brace expression matches none of the above forms, it is left unchanged, unless the option @t{BRACE_CCL} (an abbreviation for `brace character class') is set."
msgstr "如果括号表达式与上述任何形式都不匹配，则保持不变，除非设置了选项 @t{BRACE_CCL}（ `brace character class' = `括号字符类' 的缩写）。"

#. type: pindex
#: zsh.texi:6338
#, no-wrap
msgid "BRACE_CCL, use of"
msgstr "BRACE_CCL, use of"

#. type: Plain text
#: zsh.texi:6347
msgid ""
"In that case, it is expanded to a list of the individual characters between the braces sorted into the order of the characters in the ASCII character set (multibyte characters are not currently handled).  "
"The syntax is similar to a @t{[}...@t{]} expression in filename generation: `@t{-}' is treated specially to denote a range of characters, but `@t{^}' or `@t{!}' as the first character is treated "
"normally.  For example, `@t{@{abcdef0-9@}}' expands to 16 words @t{0 1 2 3 4 5 6 7 8 9 a b c d e f}."
msgstr ""
"在这种情况下，它将扩展为大括号之间的单个字符列表，并按照 ASCII 字符集中的字符顺序进行排序（目前不处理多字节字符）。 该语法类似于文件名生成中的  @t{[}...@t{]} 表达式：`@t{-}' 被特殊处理以表示一系列字符，但"
"作为第一个字符的 `@t{^}' 或 `@t{!}' 则被正常处理。 例如， `@t{@{abcdef0-9@}}' 扩展为 16 个词 @t{0 1 2 3 4 5 6 7 8 9 a b c d e f}。"

#. type: Plain text
#: zsh.texi:6356
msgid ""
"Note that brace expansion is not part of filename generation (globbing); an expression such as @t{*/@{foo,bar@}} is split into two separate words @t{*/foo} and @t{*/bar} before filename generation takes "
"place.  In particular, note that this is liable to produce a `no match' error if @emph{either} of the two expressions does not match; this is to be contrasted with @t{*/(foo|bar)}, which is treated as a "
"single pattern but otherwise has similar effects."
msgstr ""
"请注意，括号扩展并不是文件名生成（globbing）的一部分；在文件名生成之前，像  @t{*/@{foo,bar@}} 这样的表达式会被拆分成两个独立的词 @t{*/foo} 和 @t{*/bar}。 特别要注意的是，如果 @emph{either} 与两个表达式不匹"
"配，就会产生  `no match'  错误；这一点与 @t{*/(foo|bar)} 相反，后者被视为一个单独的模式，但在其他方面具有类似的效果。"

#. type: Plain text
#: zsh.texi:6362
msgid "To combine brace expansion with array expansion, see the @t{$@{^}@var{spec}@t{@}} form described in @ref{Parameter Expansion} above."
msgstr "要将括号扩展与数组扩展结合起来，请参阅上文 @ref{参数扩展}中描述的 @t{$@{^}@var{spec}@t{@}} 形式。"

#. type: cindex
#: zsh.texi:6368
#, no-wrap
msgid "filename expansion"
msgstr "文件名扩展"

#. type: cindex
#: zsh.texi:6369
#, no-wrap
msgid "expansion, filename"
msgstr "扩展, 文件名"

#. type: Plain text
#: zsh.texi:6376
msgid ""
"Each word is checked to see if it begins with an unquoted `@t{~}'.  If it does, then the word up to a `@t{/}', or the end of the word if there is no `@t{/}', is checked to see if it can be substituted in "
"one of the ways described here.  If so, then the `@t{~}' and the checked portion are replaced with the appropriate substitute value."
msgstr ""
"每个单词都会被检查是否以未加引号的 `@t{~}' 开头。 如果是，则检查词头至 `@t{/}' 的部分，如果没有 `@t{/}'，则检查词尾部分，看是否可以用这里描述的方法之一进行替换。 如果可以，则 `@t{~}' 和被检查的部分将被替换"
"为相应的替代值。"

#. type: Plain text
#: zsh.texi:6381
msgid "A `@t{~}' by itself is replaced by the value of @t{$HOME}.  A `@t{~}' followed by a `@t{+}' or a `@t{-}' is replaced by current or previous working directory, respectively."
msgstr " `@t{~}' 本身会被 @t{$HOME} 的值替换。 后跟 `@t{+}' 或 `@t{-}' 的 `@t{~}' 会分别被当前或上一个工作目录替换。"

#. type: Plain text
#: zsh.texi:6394
msgid ""
"A `@t{~}' followed by a number is replaced by the directory at that position in the directory stack.  `@t{~0}' is equivalent to `@t{~+}', and `@t{~1}' is the top of the stack.  `@t{~+}' followed by a "
"number is replaced by the directory at that position in the directory stack.  `@t{~+0}' is equivalent to `@t{~+}', and `@t{~+1}' is the top of the stack.  `@t{~-}' followed by a number is replaced by the "
"directory that many positions from the bottom of the stack.  `@t{~-0}' is the bottom of the stack."
msgstr ""
"后跟数字的 `@t{~}' 会被目录堆栈中该位置的目录替换。   `@t{~0}' 等同于 `@t{~+}'，而 `@t{~1}' 是目录栈的顶层。 后跟数字的 `@t{~+}' 会被目录堆栈中该位置的目录替换。   `@t{~+0}' 等同于 `@t{~+}'， `@t{~+1}' 是"
"目录栈的顶层。 后跟数字的  `@t{~-}' 会被从堆栈底部起多少个位置的目录替换。  `@t{~-0}' 为堆栈底部。"

#. type: pindex
#: zsh.texi:6394 zsh.texi:14171 zsh.texi:14358
#, no-wrap
msgid "PUSHD_MINUS, use of"
msgstr "PUSHD_MINUS, use of"

#. type: Plain text
#: zsh.texi:6398
msgid "The @t{PUSHD_MINUS} option exchanges the effects of `@t{~+}' and `@t{~-}' where they are followed by a number."
msgstr "后面跟一个数字，@t{PUSHD_MINUS} 选项可以交换 `@t{~+}' 和 `@t{~-}' 的效果。"

#. type: menuentry
#: zsh.texi:6405
msgid "Dynamic named directories::"
msgstr "动态命名目录"

#. type: menuentry
#: zsh.texi:6405
msgid "Static named directories::"
msgstr "静态命名目录"

#. type: menuentry
#: zsh.texi:6405
msgid "`=' expansion::"
msgstr "`=' 扩展::"

#. type: subsection
#: zsh.texi:6405 zsh.texi:6548 zsh.texi:6562 zsh.texi:6564
#, no-wrap
msgid "Notes"
msgstr "注意"

#. type: node
#: zsh.texi:6408 zsh.texi:6410 zsh.texi:6516
#, no-wrap
msgid "Dynamic named directories"
msgstr "动态命名目录"

#. type: node
#: zsh.texi:6408 zsh.texi:6516 zsh.texi:6518 zsh.texi:6548
#, no-wrap
msgid "Static named directories"
msgstr "静态命名目录"

#. type: cindex
#: zsh.texi:6412
#, no-wrap
msgid "directories, named, dynamic"
msgstr "目录, 命名, 动态"

#. type: cindex
#: zsh.texi:6413
#, no-wrap
msgid "named directories, dynamic"
msgstr "命名目录, 动态"

#. type: cindex
#: zsh.texi:6414
#, no-wrap
msgid "dynamic named directories"
msgstr "动态命名目录"

#. type: Plain text
#: zsh.texi:6421
msgid ""
"If the function @t{zsh_directory_name} exists, or the shell variable @t{zsh_directory_name_functions} exists and contains an array of function names, then the functions are used to implement dynamic "
"directory naming.  The functions are tried in order until one returns status zero, so it is important that functions test whether they can handle the case in question and return an appropriate status."
msgstr ""
"如果函数 @t{zsh_directory_name} 已存在，或者 shell 变量 @t{zsh_directory_name_functions} 已存在并包含函数名数组，那么这些函数将用于实现动态目录命名。 这些函数会依次尝试，直到其中一个返回状态为零，因此函数"
"必须测试它们是否能处理相关情况，并返回适当的状态。"

#. type: Plain text
#: zsh.texi:6434
msgid ""
"A `@t{~}' followed by a string @var{namstr} in unquoted square brackets is treated specially as a dynamic directory name.  Note that the first unquoted closing square bracket always terminates "
"@var{namstr}.  The shell function is passed two arguments: the string @t{n} (for name) and @var{namstr}.  It should either set the array @t{reply} to a single element which is the directory corresponding "
"to the name and return status zero (executing an assignment as the last statement is usually sufficient), or it should return status non-zero.  In the former case the element of reply is used as the "
"directory; in the latter case the substitution is deemed to have failed.  If all functions fail and the option @t{NOMATCH} is set, an error results."
msgstr ""
"后跟未加引号的方括号里的字符串 @var{namstr} 的 `@t{~}' 会被视为动态目录名。 请注意，第一个未加引号的结尾方括号总是 @var{namstr} 的结束符。 shell 函数有两个参数：字符串 @t{n}（表示名称）和 @var{namstr}。 它"
"要么将数组 @t{reply} 设置为单个元素，即与名称对应的目录，并返回状态为零（作为最后一条语句执行赋值通常就足够了），要么返回状态非零。 在前一种情况下，reply 的元素被用作目录；在后一种情况下，替换被视为失败。 "
"如果所有函数都失败，且选项 @t{NOMATCH} 被设置，则会出现错误。"

#. type: Plain text
#: zsh.texi:6448
msgid ""
"The functions defined as above are also used to see if a directory can be turned into a name, for example when printing the directory stack or when expanding @t{%~} in prompts.  In this case each function "
"is passed two arguments: the string @t{d} (for directory) and the candidate for dynamic naming.  The function should either return non-zero status, if the directory cannot be named by the function, or it "
"should set the array reply to consist of two elements: the first is the dynamic name for the directory (as would appear within `@t{~[}@var{...}@t{]}'), and the second is the prefix length of the directory "
"to be replaced.  For example, if the trial directory is @t{/home/myname/src/zsh} and the dynamic name for @t{/home/myname/src} (which has 16 characters) is @t{s}, then the function sets"
msgstr ""
"上述定义的函数还可用于查看目录是否可以转化为名称，例如在打印目录堆栈或在提示符中扩展 @t{%~} 时。 在这种情况下，每个函数都会传递两个参数：字符串 @t{d}（表示目录）和动态命名的候选名称。 如果函数无法命名目"
"录，则函数应返回非零状态，或者将数组 reply 设置为由两个元素组成：第一个元素是目录的动态名称（如在  `@t{~[}@var{...}@t{]}' 中显示的名称），第二个元素是要替换的目录的前缀长度。 例如，如果试用目录是 @t{/home/"
"myname/src/zsh}，而 @t{/home/myname/src}（有 16 个字符）的动态名称是 @t{s}，那么函数会设置"

#. type: example
#: zsh.texi:6452
#, no-wrap
msgid "reply=(s 16)\n"
msgstr "reply=(s 16)\n"

#. type: Plain text
#: zsh.texi:6459
msgid ""
"The directory name so returned is compared with possible static names for parts of the directory path, as described below; it is used if the prefix length matched (16 in the example) is longer than that "
"matched by any static name."
msgstr "这样返回的目录名称将与目录路径部分可能的静态名称进行比较，如下所述；如果匹配的前缀长度（示例中为 16）长于任何静态名称所匹配的长度，则使用该名称。"

#. type: Plain text
#: zsh.texi:6466
msgid ""
"It is not a requirement that a function implements both @t{n} and @t{d} calls; for example, it might be appropriate for certain dynamic forms of expansion not to be contracted to names.  In that case any "
"call with the first argument @t{d} should cause a non-zero status to be returned."
msgstr "并不要求函数同时实现 @t{n} 和 @t{d} 调用；例如，某些动态扩展形式可能不适合收缩为名称。 在这种情况下，任何带有第一个参数 @t{d} 的调用都应返回一个非零状态。"

#. type: Plain text
#: zsh.texi:6474
msgid ""
"The completion system calls `@t{zsh_directory_name c}' followed by equivalent calls to elements of the array @t{zsh_directory_name_functions}, if it exists, in order to complete dynamic names for "
"directories.  The code for this should be as for any other completion function as described in @ref{Completion System}."
msgstr "补全系统会调用 `@t{zsh_directory_name c}'，后面是数组 @t{zsh_directory_name_functions} 中的元素（如果存在）的等价调用，以补全目录的动态名称。 其代码应与 @ref{补全系统}中描述的其他补全函数相同。"

#. type: Plain text
#: zsh.texi:6480
msgid ""
"As a working example, here is a function that expands any dynamic names beginning with the string @t{p:} to directories below @t{/home/pws/perforce}.  In this simple case a static name for the directory "
"would be just as effective."
msgstr "作为一个工作示例，下面的函数可将以 @t{p:} 字符串开头的任何动态名称扩展到 @t{/home/pws/perforce} 以下的目录。 在这个简单的例子中，目录的静态名称也同样有效。"

#. type: example
#: zsh.texi:6513
#, no-wrap
msgid ""
"zsh_directory_name() @{\n"
"  emulate -L zsh\n"
"  setopt extendedglob\n"
"  local -a match mbegin mend\n"
"  if [[ $1 = d ]]; then\n"
"    # turn the directory into a name\n"
"    if [[ $2 = (#b)(/home/pws/perforce/)([^/]##)* ]]; then\n"
"      typeset -ga reply\n"
"      reply=(p:$match[2] $(( $@{#match[1]@} + $@{#match[2]@} )) )\n"
"    else\n"
"      return 1\n"
"    fi\n"
"  elif [[ $1 = n ]]; then\n"
"    # turn the name into a directory\n"
"    [[ $2 != (#b)p:(?*) ]] && return 1\n"
"    typeset -ga reply\n"
"    reply=(/home/pws/perforce/$match[1])\n"
"  elif [[ $1 = c ]]; then\n"
"    # complete names\n"
"    local expl\n"
"    local -a dirs\n"
"    dirs=(/home/pws/perforce/*(/:t))\n"
"    dirs=(p:$@{^dirs@})\n"
"    _wanted dynamic-dirs expl 'dynamic directory' compadd -S\\] -a dirs\n"
"    return\n"
"  else\n"
"    return 1\n"
"  fi\n"
"  return 0\n"
"@}\n"
msgstr ""
"zsh_directory_name() @{\n"
"  emulate -L zsh\n"
"  setopt extendedglob\n"
"  local -a match mbegin mend\n"
"  if [[ $1 = d ]]; then\n"
"    # turn the directory into a name\n"
"    if [[ $2 = (#b)(/home/pws/perforce/)([^/]##)* ]]; then\n"
"      typeset -ga reply\n"
"      reply=(p:$match[2] $(( $@{#match[1]@} + $@{#match[2]@} )) )\n"
"    else\n"
"      return 1\n"
"    fi\n"
"  elif [[ $1 = n ]]; then\n"
"    # turn the name into a directory\n"
"    [[ $2 != (#b)p:(?*) ]] && return 1\n"
"    typeset -ga reply\n"
"    reply=(/home/pws/perforce/$match[1])\n"
"  elif [[ $1 = c ]]; then\n"
"    # complete names\n"
"    local expl\n"
"    local -a dirs\n"
"    dirs=(/home/pws/perforce/*(/:t))\n"
"    dirs=(p:$@{^dirs@})\n"
"    _wanted dynamic-dirs expl 'dynamic directory' compadd -S\\] -a dirs\n"
"    return\n"
"  else\n"
"    return 1\n"
"  fi\n"
"  return 0\n"
"@}\n"

#. type: node
#: zsh.texi:6516 zsh.texi:6548 zsh.texi:6550 zsh.texi:6562
#, no-wrap
msgid "`=' expansion"
msgstr "`=' 扩展"

#. type: cindex
#: zsh.texi:6520
#, no-wrap
msgid "directories, named, static"
msgstr "目录, 命名, 静态"

#. type: cindex
#: zsh.texi:6521
#, no-wrap
msgid "named directories, static"
msgstr "命名目录, 静态"

#. type: cindex
#: zsh.texi:6522
#, no-wrap
msgid "static named directories"
msgstr "静态命名目录"

#. type: Plain text
#: zsh.texi:6532
msgid ""
"A `@t{~}' followed by anything not already covered consisting of any number of alphanumeric characters or underscore (`@t{_}'), hyphen (`@t{-}'), or dot (`@t{.}') is looked up as a named directory, and "
"replaced by the value of that named directory if found.  Named directories are typically home directories for users on the system.  They may also be defined if the text after the `@t{~}' is the name of a "
"string shell parameter whose value begins with a `@t{/}'.  Note that trailing slashes will be removed from the path to the directory (though the original parameter is not modified)."
msgstr ""
" `@t{~}' 后跟任何字母数字字符或下划线 (`@t{_}')、连字符 (`@t{-}')或点 (`@t{.}')组成的任何未包含（covered）的内容，都会作为命名目录被查找，如果找到，则用该命名目录的值替换。 命名目录通常是系统中用户的主目"
"录。 如果 `@t{~}' 后面的文本是以 `@t{/}'开头的字符串 shell 参数的名称，也可以定义命名目录。 请注意，目录路径中的尾部斜线将被删除（但原始参数不会被修改）。"

#. type: Plain text
#: zsh.texi:6536
msgid "It is also possible to define directory names using the @t{-d} option to the @t{hash} builtin."
msgstr "也可以使用 @t{hash} 内置命令的 @t{-d} 选项来定义目录名。"

#. type: Plain text
#: zsh.texi:6546
msgid ""
"When the shell prints a path (e.g. when expanding @t{%~} in prompts or when printing the directory stack), the path is checked to see if it has a named directory as its prefix.  If so, then the prefix "
"portion is replaced with a `@t{~}' followed by the name of the directory.  The shorter of the two ways of referring to the directory is used, i.e. either the directory name or the full path; the name is "
"used if they are the same length.  The parameters @t{$PWD} and @t{$OLDPWD} are never abbreviated in this fashion."
msgstr ""
"当 shell 打印路径时（例如，在提示符中扩展 @t{%~} 或打印目录栈时），会检查路径的前缀是否为已命名的目录。 如果有，那么前缀部分就会被替换为 `@t{~}' ，然后是目录名。 在引用目录的两种方式中，使用较短的一种，即"
"目录名或完整路径；如果两者长度相同，则使用目录名。 参数 @t{$PWD} 和 @t{$OLDPWD} 绝不会以这种方式缩写。"

#. type: Plain text
#: zsh.texi:6560
msgid ""
"If a word begins with an unquoted `@t{=}' and the @t{EQUALS} option is set, the remainder of the word is taken as the name of a command.  If a command exists by that name, the word is replaced by the full "
"pathname of the command."
msgstr "如果一个单词以未加引号的 `@t{=}' 开头，且设置了 @t{EQUALS} 选项，则该单词的其余部分将作为命令名称。 如果存在以该名称开头的命令，则会用命令的完整路径名替换该单词。"

#. type: cindex
#: zsh.texi:6566
#, no-wrap
msgid "filename expansion, notes"
msgstr "文件名扩展, 注意"

#. type: Plain text
#: zsh.texi:6575
msgid ""
"Filename expansion is performed on the right hand side of a parameter assignment, including those appearing after commands of the @t{typeset} family.  In this case, the right hand side will be treated as "
"a colon-separated list in the manner of the @t{PATH} parameter, so that a `@t{~}' or an `@t{=}' following a `@t{:}' is eligible for expansion.  All such behaviour can be disabled by quoting the `@t{~}', "
"the `@t{=}', or the whole expression (but not simply the colon); the @t{EQUALS} option is also respected."
msgstr ""
"文件名扩展在参数赋值的右侧执行，包括出现在 @t{typeset} 系列命令之后的参数。 在这种情况下，右侧将按照 @t{PATH} 参数的方式，被视为一个以冒号分隔的列表，因此， `@t{~}' 或 `@t{=}' 后跟 `@t{:}' 均可进行扩展。 "
"所有这些行为都可以通过引用 `@t{~}'、 `@t{=}' 或整个表达式（而不仅仅是冒号）来禁用；@t{EQUALS}选项也同样受到尊守。"

#. type: Plain text
#: zsh.texi:6581
msgid ""
"If the option @t{MAGIC_EQUAL_SUBST} is set, any unquoted shell argument in the form `@var{identifier}@t{=}@var{expression}' becomes eligible for file expansion as described in the previous paragraph.  "
"Quoting the first `@t{=}' also inhibits this."
msgstr "如果设置了选项 @t{MAGIC_EQUAL_SUBST}，任何未被引用的 shell 参数，其形式为 `@var{identifier}@t{=}@var{expression}'，都有资格按照上段所述进行文件扩展。 引用第一个 `@t{=}' 也会抑制这种情况。"

#. type: cindex
#: zsh.texi:6587
#, no-wrap
msgid "filename generation"
msgstr "文件名生成"

#. type: Plain text
#: zsh.texi:6591
msgid ""
"If a word contains an unquoted instance of one of the characters `@t{*}', `@t{(}', `@t{|}', `@t{<}', `@t{[}', or `@t{?}', it is regarded as a pattern for filename generation, unless the @t{GLOB} option is "
"unset."
msgstr "如果一个单词包含 `@t{*}', `@t{(}', `@t{|}', `@t{<}', `@t{[}', or `@t{?}'字符 中的一个未加引号实例，除非 @t{GLOB} 选项未设置，否则该单词将被视为文件名生成的模式。"

#. type: pindex
#: zsh.texi:6591
#, no-wrap
msgid "GLOB, use of"
msgstr "GLOB, use of"

#. type: Plain text
#: zsh.texi:6593
msgid "If the @t{EXTENDED_GLOB} option is set,"
msgstr "如果设置了 @t{EXTENDED_GLOB} 选项，"

#. type: pindex
#: zsh.texi:6593
#, no-wrap
msgid "EXTENDED_GLOB, use of"
msgstr "EXTENDED_GLOB, use of"

#. type: Plain text
#: zsh.texi:6596
msgid "the `@t{^}' and `@t{#}' characters also denote a pattern; otherwise they are not treated specially by the shell."
msgstr " `@t{^}' 和 `@t{#}' 字符也表示模式，否则 shell 不会对它们进行特殊处理。"

#. type: Plain text
#: zsh.texi:6601
msgid "The word is replaced with a list of sorted filenames that match the pattern.  If no matching pattern is found, the shell gives an error message, unless the @t{NULL_GLOB} option is set,"
msgstr "单词会被匹配模式的经排序后的文件名列表替换。 如果没有找到匹配的模式，shell 会给出错误信息，除非设置了 @t{NULL_GLOB} 选项，"

#. type: pindex
#: zsh.texi:6601
#, no-wrap
msgid "NULL_GLOB, use of"
msgstr "NULL_GLOB, use of"

#. type: Plain text
#: zsh.texi:6604
msgid "in which case the word is deleted; or unless the @t{NOMATCH} option is unset, in which case the word is left unchanged."
msgstr "在这种情况下，单词将被删除；或者，除非 @t{NOMATCH} 选项未被设置，在这种情况下，单词将保持不变。"

#. type: pindex
#: zsh.texi:6604
#, no-wrap
msgid "NOMATCH, use of"
msgstr "NOMATCH, use of"

#. type: Plain text
#: zsh.texi:6612
msgid ""
"In filename generation, the character `@t{/}' must be matched explicitly; also, a `@t{.}' must be matched explicitly at the beginning of a pattern or after a `@t{/}', unless the @t{GLOB_DOTS} option is "
"set."
msgstr "在文件名生成时，必须明确匹配字符 `@t{/}' ；此外，除非设置了 @t{GLOB_DOTS} 选项，否则必须明确匹配位于模式开头或 `@t{/}' 之后的 `@t{.}' 。"

#. type: pindex
#: zsh.texi:6612
#, no-wrap
msgid "GLOB_DOTS, use of"
msgstr "GLOB_DOTS, use of"

#. type: Plain text
#: zsh.texi:6616
msgid "No filename generation pattern matches the files `@t{.}' or `@t{..}'.  In other instances of pattern matching, the `@t{/}' and `@t{.}' are not treated specially."
msgstr "没有文件名生成模式与 `@t{.}' 或 `@t{..}' 文件匹配。 在其他模式匹配情况下， `@t{/}' 和 `@t{.}' 不会被特殊处理。"

#. type: subsection
#: zsh.texi:6617
#, no-wrap
msgid "Glob Operators"
msgstr "Glob 操作符"

#. type: cindex
#: zsh.texi:6619
#, no-wrap
msgid "glob operators"
msgstr "Glob 操作符"

#. type: table
#: zsh.texi:6623
msgid "Matches any string, including the null string."
msgstr "匹配任何字符串，包括空字符串。"

#. type: table
#: zsh.texi:6626
msgid "Matches any character."
msgstr "匹配任何字符。"

#. type: item
#: zsh.texi:6627
#, no-wrap
msgid "@t{[}...@t{]}"
msgstr "@t{[}...@t{]}"

#. type: table
#: zsh.texi:6632
msgid ""
"Matches any of the enclosed characters.  Ranges of characters can be specified by separating two characters by a `@t{-}'.  A `@t{-}' or `@t{]}' may be matched by including it as the first character in the "
"list."
msgstr "匹配所包含（enclosed）的任何字符。 可以通过用 `@t{-}' 分隔两个字符来指定字符范围。`@t{-}' 或 `@t{]}' 可作为列表中的第一个字符进行匹配。"

#. type: cindex
#: zsh.texi:6632
#, no-wrap
msgid "character classes"
msgstr "字符类"

#. type: table
#: zsh.texi:6639
msgid ""
"There are also several named classes of characters, in the form `@t{[:}@var{name}@t{:]}' with the following meanings.  The first set use the macros provided by the operating system to test for the given "
"character combinations, including any modifications due to local language settings, see ctype(3):"
msgstr "还有几类命名的字符，其形式为 `@t{[:}@var{name}@t{:]}' ，含义如下。 第一组使用操作系统提供的宏来测试给定的字符组合，包括因本地语言设置而进行的任何修改，参见 ctype(3)："

#. type: t{#1}
#: zsh.texi:6642
#, no-wrap
msgid "[:alnum:]"
msgstr "[:alnum:]"

#. type: table
#: zsh.texi:6644
msgid "The character is alphanumeric"
msgstr "字符为字母数字"

#. type: t{#1}
#: zsh.texi:6645
#, no-wrap
msgid "[:alpha:]"
msgstr "[:alpha:]"

#. type: table
#: zsh.texi:6647
msgid "The character is alphabetic"
msgstr "字符为字母"

#. type: t{#1}
#: zsh.texi:6648
#, no-wrap
msgid "[:ascii:]"
msgstr "[:ascii:]"

#. type: table
#: zsh.texi:6651
msgid "The character is 7-bit, i.e. is a single-byte character without the top bit set."
msgstr "字符为 7 位，即未设置最高位的单字节字符。"

#. type: t{#1}
#: zsh.texi:6652
#, no-wrap
msgid "[:blank:]"
msgstr "[:blank:]"

#. type: table
#: zsh.texi:6654
msgid "The character is a blank character"
msgstr "该字符为空白字符"

#. type: t{#1}
#: zsh.texi:6655
#, no-wrap
msgid "[:cntrl:]"
msgstr "[:cntrl:]"

#. type: table
#: zsh.texi:6657
msgid "The character is a control character"
msgstr "该字符为控制字符"

#. type: t{#1}
#: zsh.texi:6658
#, no-wrap
msgid "[:digit:]"
msgstr "[:digit:]"

#. type: table
#: zsh.texi:6660
msgid "The character is a decimal digit"
msgstr "字符为十进制数字"

#. type: t{#1}
#: zsh.texi:6661
#, no-wrap
msgid "[:graph:]"
msgstr "[:graph:]"

#. type: table
#: zsh.texi:6663
msgid "The character is a printable character other than whitespace"
msgstr "该字符是除空格外的可打印字符"

#. type: t{#1}
#: zsh.texi:6664
#, no-wrap
msgid "[:lower:]"
msgstr "[:lower:]"

#. type: table
#: zsh.texi:6666
msgid "The character is a lowercase letter"
msgstr "字符为小写字母"

#. type: t{#1}
#: zsh.texi:6667
#, no-wrap
msgid "[:print:]"
msgstr "[:print:]"

#. type: table
#: zsh.texi:6669
msgid "The character is printable"
msgstr "字符是可打印字符"

#. type: t{#1}
#: zsh.texi:6670
#, no-wrap
msgid "[:punct:]"
msgstr "[:punct:]"

#. type: table
#: zsh.texi:6672
msgid "The character is printable but neither alphanumeric nor whitespace"
msgstr "该字符可打印，但既不是字母数字，也不是空格"

#. type: t{#1}
#: zsh.texi:6673
#, no-wrap
msgid "[:space:]"
msgstr "[:space:]"

#. type: table
#: zsh.texi:6675
msgid "The character is whitespace"
msgstr "该字符为空白字符"

#. type: t{#1}
#: zsh.texi:6676
#, no-wrap
msgid "[:upper:]"
msgstr "[:upper:]"

#. type: table
#: zsh.texi:6678
msgid "The character is an uppercase letter"
msgstr "字符为大写字母"

#. type: t{#1}
#: zsh.texi:6679
#, no-wrap
msgid "[:xdigit:]"
msgstr "[:xdigit:]"

#. type: table
#: zsh.texi:6681
msgid "The character is a hexadecimal digit"
msgstr "字符是十六进制数字"

#. type: table
#: zsh.texi:6687
msgid "Another set of named classes is handled internally by the shell and is not sensitive to the locale:"
msgstr "另一组命名类，由 shell 内部处理，对本地语言不敏感："

#. type: t{#1}
#: zsh.texi:6690
#, no-wrap
msgid "[:IDENT:]"
msgstr "[:IDENT:]"

#. type: table
#: zsh.texi:6694
msgid "The character is allowed to form part of a shell identifier, such as a parameter name; this test respects the @t{POSIX_IDENTIFIERS} option"
msgstr "允许该字符构成 shell 标识的一部分，例如参数名；该测试尊重 @t{POSIX_IDENTIFIERS} 选项"

#. type: t{#1}
#: zsh.texi:6695
#, no-wrap
msgid "[:IFS:]"
msgstr "[:IFS:]"

#. type: table
#: zsh.texi:6698
msgid "The character is used as an input field separator, i.e. is contained in the @t{IFS} parameter"
msgstr "该字符用作输入字段分隔符，即包含在 @t{IFS} 参数中"

#. type: t{#1}
#: zsh.texi:6699
#, no-wrap
msgid "[:IFSSPACE:]"
msgstr "[:IFSSPACE:]"

#. type: table
#: zsh.texi:6703
msgid "The character is an IFS white space character; see the documentation for @t{IFS} in @ref{Parameters Used By The Shell}."
msgstr "该字符为 IFS 空白字符；参见 @ref{Shell 使用的参数}中 @t{IFS} 的文档。"

#. type: t{#1}
#: zsh.texi:6704
#, no-wrap
msgid "[:INCOMPLETE:]"
msgstr "[:INCOMPLETE:]"

#. type: table
#: zsh.texi:6711
msgid ""
"Matches a byte that starts an incomplete multibyte character.  Note that there may be a sequence of more than one bytes that taken together form the prefix of a multibyte character.  To test for a "
"potentially incomplete byte sequence, use the pattern `@t{[[:INCOMPLETE:]]*}'.  This will never match a sequence starting with a valid multibyte character."
msgstr ""
"匹配不完整多字节字符开头的字节。 请注意，可能会有一个以上的字节序列共同构成一个多字节字符的前缀。 要测试可能不完整的字节序列，请使用模式 `@t{[[:INCOMPLETE:]]*}'。 该模式永远不会匹配以有效多字节字符开头的序"
"列。"

#. type: t{#1}
#: zsh.texi:6712
#, no-wrap
msgid "[:INVALID:]"
msgstr "[:INVALID:]"

#. type: table
#: zsh.texi:6717
msgid ""
"Matches a byte that does not start a valid multibyte character.  Note this may be a continuation byte of an incomplete multibyte character as any part of a multibyte string consisting of invalid and "
"incomplete multibyte characters is treated as single bytes."
msgstr "匹配不以有效多字节字符开头的字节。 请注意，这可能是不完整多字节字符的延续字节，因为由无效和不完整多字节字符组成的多字节字符串的任何部分都被视为单字节。"

#. type: t{#1}
#: zsh.texi:6718
#, no-wrap
msgid "[:WORD:]"
msgstr "[:WORD:]"

#. type: table
#: zsh.texi:6721
msgid "The character is treated as part of a word; this test is sensitive to the value of the @t{WORDCHARS} parameter"
msgstr "该字符被视为单词的一部分；该测试对 @t{WORDCHARS} 参数的值很敏感"

#. type: table
#: zsh.texi:6730
msgid ""
"Note that the square brackets are additional to those enclosing the whole set of characters, so to test for a single alphanumeric character you need `@t{[[:alnum:]]}'.  Named character sets can be used "
"alongside other types, e.g. `@t{[[:alpha:]0-9]}'."
msgstr "请注意，方括号是在包围整个字符集的方括号之外的，因此要测试单个字母数字字符，需要使用 `@t{[[:alnum:]]}'。 已命名字符集可与其他类型一起使用，例如 `@t{[[:alpha:]0-9]}' 。"

#. type: item
#: zsh.texi:6731
#, no-wrap
msgid "@t{[^}...@t{]}"
msgstr "@t{[^}...@t{]}"

#. type: itemx
#: zsh.texi:6732
#, no-wrap
msgid "@t{[!}...@t{]}"
msgstr "@t{[!}...@t{]}"

#. type: table
#: zsh.texi:6735
msgid "Like @t{[}...@t{]}, except that it matches any character which is not in the given set."
msgstr "与  @t{[}...@t{]} 相似，但它匹配的字符不在给定的字符集中。"

#. type: item
#: zsh.texi:6736
#, no-wrap
msgid "@t{<}[@var{x}]@t{-}[@var{y}]@t{>}"
msgstr "@t{<}[@var{x}]@t{-}[@var{y}]@t{>}"

#. type: table
#: zsh.texi:6741
msgid ""
"Matches any number in the range @var{x} to @var{y}, inclusive.  Either of the numbers may be omitted to make the range open-ended; hence `@t{<->}' matches any number.  To match individual digits, the "
"@t{[}...@t{]} form is more efficient."
msgstr "匹配 @var{x} 至 @var{y}（含）范围内的任意数字。 可以省略任何一个数字，使范围不受限制；因此， `@t{<->}' 可以匹配任何数字。 要匹配单个数字， @t{[}...@t{]} 形式更有效。"

#. type: table
#: zsh.texi:6750
msgid ""
"Be careful when using other wildcards adjacent to patterns of this form; for example, @t{<0-9>*} will actually match any number whatsoever at the start of the string, since the `@t{<0-9>}' will match the "
"first digit, and the `@t{*}' will match any others.  This is a trap for the unwary, but is in fact an inevitable consequence of the rule that the longest possible match always succeeds.  Expressions such "
"as `@t{<0-9>[^[:digit:]]*}' can be used instead."
msgstr ""
"在使用与这种形式的模式相近的其他通配符时要小心；例如，@t{<0-9>*} 实际上将匹配字符串开头的任何数字， 因为 `@t{<0-9>}' 将匹配第一个数字，而 `@t{*}' 将匹配任何其他数字。这对不小心的人来说是个陷阱，但实际上是 "
"\"尽可能长的匹配总是成功的 \"这一规则的必然结果。 可以使用 `@t{<0-9>[^[:digit:]]*}' 等表达式来代替。"

#. type: item
#: zsh.texi:6751
#, no-wrap
msgid "@t{(}...@t{)}"
msgstr "@t{(}...@t{)}"

#. type: table
#: zsh.texi:6758
msgid ""
"Matches the enclosed pattern.  This is used for grouping.  If the @t{KSH_GLOB} option is set, then a `@t{@@}', `@t{*}', `@t{+}', `@t{?}' or `@t{!}' immediately preceding the `@t{(}' is treated specially, "
"as detailed below. The option @t{SH_GLOB} prevents bare parentheses from being used in this way, though the @t{KSH_GLOB} option is still available."
msgstr ""
"与括起来的模式匹配。 用于分组。 如果设置了 @t{KSH_GLOB}选项，那么紧接在 `@t{(}' 之前的 `@t{@@}', `@t{*}', `@t{+}', `@t{?}' 或\" `@t{!}' 将被特殊处理，详情如下。选项 @t{SH_GLOB} 可以防止以这种方式使用空括号"
"（bare parentheses），但 @t{KSH_GLOB} 选项仍然可用。"

#. type: table
#: zsh.texi:6766
msgid ""
"Note that grouping cannot extend over multiple directories: it is an error to have a `@t{/}' within a group (this only applies for patterns used in filename generation).  There is one exception: a group "
"of the form @t{(}@var{pat}@t{/)#} appearing as a complete path segment can match a sequence of directories.  For example, @t{foo/(a*/)#bar} matches @t{foo/bar}, @t{foo/any/bar}, @t{foo/any/anyother/bar}, "
"and so on."
msgstr ""
"请注意，分组不能扩展到多个目录：在分组中出现 `@t{/}' 是错误的（这只适用于文件名生成中使用的模式）。 但有一个例外：以 @t{(}@var{pat}@t{/)#} 形式出现的组作为一个完整的路径段，可以匹配一系列目录。 例如， "
"@t{foo/(a*/)#bar}  匹配 @t{foo/bar}、@t{foo/any/bar}、@t{foo/any/anyother/bar}，以此类推。"

#. type: item
#: zsh.texi:6767
#, no-wrap
msgid "@var{x}@t{|}@var{y}"
msgstr "@var{x}@t{|}@var{y}"

#. type: table
#: zsh.texi:6773
msgid ""
"Matches either @var{x} or @var{y}.  This operator has lower precedence than any other.  The `@t{|}' character must be within parentheses, to avoid interpretation as a pipeline.  The alternatives are tried "
"in order from left to right."
msgstr "匹配 @var{x} 或 @var{y}。 该操作符的优先级低于其他操作符。  `@t{|}'  字符必须在括号内，以免被解释为管道。 从左到右依次选择。"

#. type: item
#: zsh.texi:6774
#, no-wrap
msgid "@t{^}@var{x}"
msgstr "@t{^}@var{x}"

#. type: table
#: zsh.texi:6780
msgid ""
"(Requires @t{EXTENDED_GLOB} to be set.)  Matches anything except the pattern @var{x}.  This has a higher precedence than `@t{/}', so `@t{^foo/bar}' will search directories in `@t{.}' except `@t{./foo}' "
"for a file named `@t{bar}'."
msgstr "(需要设置 @t{EXTENDED_GLOB}）匹配模式 @var{x} 以外的任何内容。 其优先级高于 `@t{/}'，因此 `@t{^foo/bar}' 将搜索 `@t{.}' 中除 `@t{./foo}' 之外的目录，以查找名为 `@t{bar}' 的文件。"

#. type: item
#: zsh.texi:6781
#, no-wrap
msgid "@var{x}@t{~}@var{y}"
msgstr "@var{x}@t{~}@var{y}"

#. type: table
#: zsh.texi:6791
msgid ""
"(Requires @t{EXTENDED_GLOB} to be set.)  Match anything that matches the pattern @var{x} but does not match @var{y}.  This has lower precedence than any operator except `@t{|}', so `@t{*/*~foo/bar}' will "
"search for all files in all directories in `@t{.}' and then exclude `@t{foo/bar}' if there was such a match.  Multiple patterns can be excluded by `@var{foo}@t{~}@var{bar}@t{~}@var{baz}'.  In the "
"exclusion pattern (@var{y}), `@t{/}' and `@t{.}' are not treated specially the way they usually are in globbing."
msgstr ""
"(需要设置 @t{EXTENDED_GLOB}）匹配任何匹配 @var{x} 但不匹配 @var{y} 的模式。 它的优先级比除 `@t{|}' 之外的任何操作符都低，因此 `@t{*/*~foo/bar}' 将搜索 `@t{.}' 中所有目录下的所有文件，如果有匹配，则排除 "
"`@t{foo/bar}'。`@var{foo}@t{~}@var{bar}@t{~}@var{baz}' 可以排除多个模式。 在排除模式（@var{y}）中，`@t{/}' 和 `@t{.}' 不会像通常的全局模式(globbing)那样被特殊处理。"

#. type: item
#: zsh.texi:6792
#, no-wrap
msgid "@var{x}@t{#}"
msgstr "@var{x}@t{#}"

#. type: table
#: zsh.texi:6802
msgid ""
"(Requires @t{EXTENDED_GLOB} to be set.)  Matches zero or more occurrences of the pattern @var{x}.  This operator has high precedence; `@t{12#}' is equivalent to `@t{1(2#)}', rather than `@t{(12)#}'.  It "
"is an error for an unquoted `@t{#}' to follow something which cannot be repeated; this includes an empty string, a pattern already followed by `@t{##}', or parentheses when part of a @t{KSH_GLOB} pattern "
"(for example, `@t{!(}@var{foo}@t{)#}' is invalid and must be replaced by `@t{*(!(}@var{foo}@t{))}')."
msgstr ""
"(需要设置 @t{EXTENDED_GLOB}）匹配模式 @var{x} 的零次或多次出现。 该操作符具有高优先级；`@t{12#}' 等同于 `@t{1(2#)}'，而不是 `@t{(12)#}'。 如果未加引号的 `@t{#}' 跟在不能重复的内容后面，则属于错误；这包括空"
"字符串、已跟在 `@t{##}' 后面的模式，或 @t{KSH_GLOB} 模式中的括号（例如， `@t{!(}@var{foo}@t{)#}' 无效，必须替换为  `@t{*(!(}@var{foo}@t{))}')。"

#. type: item
#: zsh.texi:6803
#, no-wrap
msgid "@var{x}@t{##}"
msgstr "@var{x}@t{##}"

#. type: table
#: zsh.texi:6810
msgid ""
"(Requires @t{EXTENDED_GLOB} to be set.)  Matches one or more occurrences of the pattern @var{x}.  This operator has high precedence; `@t{12##}' is equivalent to `@t{1(2##)}', rather than `@t{(12)##}'.  No "
"more than two active `@t{#}' characters may appear together.  (Note the potential clash with glob qualifiers in the form `@t{1(2##)}' which should therefore be avoided.)"
msgstr ""
"(需要设置 @t{EXTENDED_GLOB}）匹配模式 @var{x} 的一次或多次出现。 该操作符具有高优先级； `@t{12##}' 等同于 `@t{1(2##)}'，而不是 `@t{(12)##}'。 同时出现的 `@t{#}' 字符不得超过两个。 (注意可能会与格式为 "
"`@t{1(2##)}' 的 glob 限定符发生冲突，因此应避免使用）。"

#. type: subsection
#: zsh.texi:6813
#, no-wrap
msgid "ksh-like Glob Operators"
msgstr "类ksh Glob 操作符"

#. type: pindex
#: zsh.texi:6815
#, no-wrap
msgid "KSH_GLOB, use of"
msgstr "KSH_GLOB, use of"

#. type: Plain text
#: zsh.texi:6820
msgid ""
"If the @t{KSH_GLOB} option is set, the effects of parentheses can be modified by a preceding `@t{@@}', `@t{*}', `@t{+}', `@t{?}' or `@t{!}'.  This character need not be unquoted to have special effects, "
"but the `@t{(}' must be."
msgstr "如果设置了 @t{KSH_GLOB}选项，括号的效果可以通过前面的 `@t{@@}', `@t{*}', `@t{+}', `@t{?}' 或 `@t{!}' 来修改。 该字符不需要不加引号就能产生特殊效果，但 `@t{(}' 必须不加引号。"

#. type: item
#: zsh.texi:6823
#, no-wrap
msgid "@t{@@(}...@t{)}"
msgstr "@t{@@(}...@t{)}"

#. type: table
#: zsh.texi:6825
msgid "Match the pattern in the parentheses.  (Like `@t{(}...@t{)}'.)"
msgstr "匹配括号中的模式。 (如 `@t{(}...@t{)}'）。"

#. type: item
#: zsh.texi:6826
#, no-wrap
msgid "@t{*(}...@t{)}"
msgstr "@t{*(}...@t{)}"

#. type: table
#: zsh.texi:6829
msgid "Match any number of occurrences.  (Like `@t{(}...@t{)#}', except that recursive directory searching is not supported.)"
msgstr "匹配任意数量的出现。 (类似于 `@t{(}...@t{)#}'，但不支持递归目录搜索）。"

#. type: item
#: zsh.texi:6830
#, no-wrap
msgid "@t{+(}...@t{)}"
msgstr "@t{+(}...@t{)}"

#. type: table
#: zsh.texi:6833
msgid "Match at least one occurrence.  (Like `@t{(}...@t{)##}', except that recursive directory searching is not supported.)"
msgstr "至少匹配一次出现。 (类似于 `@t{(}...@t{)##}'，但不支持递归目录搜索）。"

#. type: item
#: zsh.texi:6834
#, no-wrap
msgid "@t{?(}...@t{)}"
msgstr "@t{?(}...@t{)}"

#. type: table
#: zsh.texi:6836
msgid "Match zero or one occurrence.  (Like `@t{(|}...@t{)}'.)"
msgstr "匹配零次或一次出现。 (类似于 `@t{(|}...@t{)}'）。"

#. type: item
#: zsh.texi:6837
#, no-wrap
msgid "@t{!(}...@t{)}"
msgstr "@t{!(}...@t{)}"

#. type: table
#: zsh.texi:6840
msgid "Match anything but the expression in parentheses.  (Like `@t{(^(}...@t{))}'.)"
msgstr "匹配括号内表达式以外的任何内容。 (类似于  `@t{(^(}...@t{))}'）。"

#. type: subsection
#: zsh.texi:6843
#, no-wrap
msgid "Precedence"
msgstr "优先级"

#. type: cindex
#: zsh.texi:6845
#, no-wrap
msgid "precedence of glob operators"
msgstr "glob 操作符的优先级"

#. type: Plain text
#: zsh.texi:6858
msgid ""
"The precedence of the operators given above is (highest) `@t{^}', `@t{/}', `@t{~}', `@t{|}' (lowest); the remaining operators are simply treated from left to right as part of a string, with `@t{#}' and "
"`@t{##}' applying to the shortest possible preceding unit (i.e. a character, `@t{?}', `@t{[}...@t{]}', `@t{<}...@t{>}', or a parenthesised expression).  As mentioned above, a `@t{/}' used as a directory "
"separator may not appear inside parentheses, while a `@t{|}' must do so; in patterns used in other contexts than filename generation (for example, in @t{case} statements and tests within `@t{[[}..."
"@t{]]}'), a `@t{/}' is not special; and `@t{/}' is also not special after a `@t{~}' appearing outside parentheses in a filename pattern."
msgstr ""
"上述运算符的优先级为（最高） `@t{^}', `@t{/}', `@t{~}', `@t{|}' （最低）；其余运算符从左到右被简单地视为字符串的一部分，其中 `@t{#}' 和 `@t{##}' 适用于前面尽可能短的单位（即字符、 `@t{?}', `@t{[}..."
"@t{]}', `@t{<}...@t{>}'，或一个带括号的表达式）。\n"
" 如上所述，作为目录分隔符的 `@t{/}'  可能不会出现在括号内，而 `@t{|}' 则必须出现在括号内；在文件名生成以外的其他情况下使用的模式中（例如，在 @t{case} 语句和  `@t{[[}...@t{]]}' 中的测试），`@t{/}' 并不特"
"殊；在文件名模式中括号外出现的 `@t{~}' 之后，`@t{/}' 也不特殊。"

#. type: subsection
#: zsh.texi:6859
#, no-wrap
msgid "Globbing Flags"
msgstr "Globbing 标志"

#. type: cindex
#: zsh.texi:6861
#, no-wrap
msgid "globbing flags"
msgstr "globbing 标志"

#. type: cindex
#: zsh.texi:6862
#, no-wrap
msgid "glob flags"
msgstr "glob 标志"

#. type: Plain text
#: zsh.texi:6868
msgid ""
"There are various flags which affect any text to their right up to the end of the enclosing group or to the end of the pattern; they require the @t{EXTENDED_GLOB} option. All take the form @t{(#}@var{X}"
"@t{)} where @var{X} may have one of the following forms:"
msgstr "有多种标志会影响其右侧直至包围组的末尾或模式的末尾的任何文本；这些标志需要使用 @t{EXTENDED_GLOB} 选项。所有标志的形式都是 @t{(#}@var{X}@t{)}，其中 @var{X} 可以是以下形式之一："

#. type: table
#: zsh.texi:6874
msgid "Case insensitive: upper or lower case characters in the pattern match upper or lower case characters."
msgstr "大小写不敏感：模式中的大写或小写字符与大写或小写字符匹配。"

#. type: table
#: zsh.texi:6879
msgid "Lower case characters in the pattern match upper or lower case characters; upper case characters in the pattern still only match upper case characters."
msgstr "模式中的小写字符匹配大写或小写字符；模式中的大写字符仍然只匹配大写字符。"

#. type: t{#1}
#: zsh.texi:6880 zsh.texi:7300 zsh.texi:8209 zsh.texi:30893
#, no-wrap
msgid "I"
msgstr "I"

#. type: table
#: zsh.texi:6883
msgid "Case sensitive: locally negates the effect of @t{i} or @t{l} from that point on."
msgstr "区分大小写：局部反转 @t{i} 或 @t{l} 的效果。"

#. type: t{#1}
#: zsh.texi:6884 zsh.texi:9233 zsh.texi:19812 zsh.texi:39694
#, no-wrap
msgid "match"
msgstr "match"

#. type: t{#1}
#: zsh.texi:6885 zsh.texi:9234
#, no-wrap
msgid "mbegin"
msgstr "mbegin"

#. type: t{#1}
#: zsh.texi:6886 zsh.texi:9235
#, no-wrap
msgid "mend"
msgstr "mend"

#. type: table
#: zsh.texi:6900
msgid ""
"Activate backreferences for parenthesised groups in the pattern; this does not work in filename generation.  When a pattern with a set of active parentheses is matched, the strings matched by the groups "
"are stored in the array @t{$match}, the indices of the beginning of the matched parentheses in the array @t{$mbegin}, and the indices of the end in the array @t{$mend}, with the first element of each "
"array corresponding to the first parenthesised group, and so on.  These arrays are not otherwise special to the shell.  The indices use the same convention as does parameter substitution, so that elements "
"of @t{$mend} and @t{$mbegin} may be used in subscripts; the @t{KSH_ARRAYS} option is respected.  Sets of globbing flags are not considered parenthesised groups; only the first nine active parentheses can "
"be referenced."
msgstr ""
"为模式中的括号组激活反向引用；这在文件名生成中不起作用。 当一个带有激活括号组的模式被匹配时，与括号组匹配的字符串将存储在数组 @t{$match}中，与括号组匹配的字符串的起始索引存储在数组 @t{$mbegin}中，结束索引"
"存储在数组 @t{$mend}中，每个数组的第一个元素对应于第一个括号组，以此类推。 这些数组与 shell 并无其他特殊关系。 索引使用与参数替换相同的约定，因此 @t{$mend} 和 @t{$mbegin} 中的元素可以用于下标；"
"@t{KSH_ARRAYS} 选项受到尊守。 全局标志集不视为括号组；只能引用前九个有效括号。"

#. type: example
#: zsh.texi:6910
#, no-wrap
msgid ""
"foo=\"a_string_with_a_message\"\n"
"if [[ $foo = (a|an)_(#b)(*) ]]; then\n"
"  print $@{foo[$mbegin[1],$mend[1]]@}\n"
"fi\n"
msgstr ""
"foo=\"a_string_with_a_message\"\n"
"if [[ $foo = (a|an)_(#b)(*) ]]; then\n"
"  print $@{foo[$mbegin[1],$mend[1]]@}\n"
"fi\n"

#. type: table
#: zsh.texi:6916
msgid "prints `@t{string_with_a_message}'.  Note that the first set of parentheses is before the @t{(#b)} and does not create a backreference."
msgstr "打印 `@t{string_with_a_message}'。 请注意，第一组括号位于 @t{(#b)} 之前，不会产生反向引用。"

#. type: table
#: zsh.texi:6924
msgid ""
"Backreferences work with all forms of pattern matching other than filename generation, but note that when performing matches on an entire array, such as @t{$@{}@var{array}@t{#}@var{pattern}@t{@}}, or a "
"global substitution, such as @t{$@{}@var{param}@t{//}@var{pat}@t{/}@var{repl}@t{@}}, only the data for the last match remains available.  In the case of global replacements this may still be useful.  See "
"the example for the @t{m} flag below."
msgstr ""
"除文件名生成外，反向引用适用于所有形式的模式匹配，但请注意，在对整个数组（如 @t{$@{}@var{array}@t{#}@var{pattern}@t{@}} ）或全局替换（如 @t{$@{}@var{param}@t{//}@var{pat}@t{/}@var{repl}@t{@}} ）执行匹配"
"时，只有最后一次匹配的数据可用。 在全局替换的情况下，这可能仍然有用。 请参阅下面的 @t{m} 标志示例。"

#. type: table
#: zsh.texi:6936
msgid ""
"The numbering of backreferences strictly follows the order of the opening parentheses from left to right in the pattern string, although sets of parentheses may be nested.  There are special rules for "
"parentheses followed by `@t{#}' or `@t{##}'.  Only the last match of the parenthesis is remembered: for example, in `@t{[[ abab = (#b)([ab])# ]]}', only the final `@t{b}' is stored in @t{match[1]}.  Thus "
"extra parentheses may be necessary to match the complete segment: for example, use `@t{X((ab|cd)#)Y}' to match a whole string of either `@t{ab}' or `@t{cd}' between `@t{X}' and `@t{Y}', using the value of "
"@t{$match[1]} rather than @t{$match[2]}."
msgstr ""
"反向引用的编号严格遵循模式字符串中从左到右的开头括号顺序，但括号组可以嵌套。 对于括号后的 `@t{#}' 或 `@t{##}'有特殊规定。 只有括号的最后一个匹配才会被记住：例如，在 `@t{[[ abab = (#b)([ab])# ]]}' 中，只有"
"最后的 `@t{b}' 才会被存储在 @t{match[1]} 中。 因此，可能需要额外的括号来匹配完整的段：例如，使用`@t{X((ab|cd)#)Y}'  来匹配 `@t{X}' 和 `@t{Y}' 之间的整个 `@t{ab}' 或 `@t{cd}' 字符串，使用 @t{$match[1]} 的"
"值，而不是 @t{$match[2]}。"

#. type: table
#: zsh.texi:6944
msgid ""
"If the match fails none of the parameters is altered, so in some cases it may be necessary to initialise them beforehand.  If some of the backreferences fail to match --- which happens if they are in an "
"alternate branch which fails to match, or if they are followed by @t{#} and matched zero times --- then the matched string is set to the empty string, and the start and end indices are set to -1."
msgstr ""
"如果匹配失败，所有参数都不会改变，因此在某些情况下可能需要事先初始化这些参数。 如果某些反向引用匹配失败--如果这些反向引用位于匹配失败的备用分支中，或者如果这些反向引用紧跟 @t{#} 且匹配次数为零--那么匹配的"
"字符串将被设置为空字符串，开始和结束索引将被设置为-1。"

#. type: table
#: zsh.texi:6947
msgid "Pattern matching with backreferences is slightly slower than without."
msgstr "有反向引用的模式匹配比没有反向引用的模式匹配稍慢。"

#. type: table
#: zsh.texi:6951
msgid "Deactivate backreferences, negating the effect of the @t{b} flag from that point on."
msgstr "停用反向引用，并从此反转 @t{b} 标记的作用。"

#. type: item
#: zsh.texi:6952
#, no-wrap
msgid "@t{c}@var{N}@t{,}@var{M}"
msgstr "@t{c}@var{N}@t{,}@var{M}"

#. type: table
#: zsh.texi:6964
msgid ""
"The flag @t{(#c}@var{N}@t{,}@var{M}@t{)} can be used anywhere that the @t{#} or @t{##} operators can be used except in the expressions `@t{(*/)#}' and `@t{(*/)##}' in filename generation, where `@t{/}' "
"has special meaning; it cannot be combined with other globbing flags and a bad pattern error occurs if it is misplaced.  It is equivalent to the form @t{@{}@var{N}@t{,}@var{M}@t{@}} in regular "
"expressions.  The previous character or group is required to match between @var{N} and @var{M} times, inclusive.  The form @t{(#c}@var{N}@t{)} requires exactly @t{N} matches; @t{(#c,}@var{M}@t{)} is "
"equivalent to specifying @var{N} as 0; @t{(#c}@var{N}@t{,)} specifies that there is no maximum limit on the number of matches."
msgstr ""
"标志  @t{(#c}@var{N}@t{,}@var{M}@t{)}  可以在任何可以使用 @t{#} 或 @t{##} 操作符的地方使用，但在文件名生成中的表达式 `@t{(*/)#}' 和 `@t{(*/)##}' 中除外，其中 `@t{/}' 有特殊含义； 它不能与其他 globbing 标志"
"结合使用，如果放错位置，就会出现坏模式错误。 它等同于正则表达式中的 @t{@{}@var{N}@t{,}@var{M}@t{@}} 。 要求前一个字符或组匹配 @var{N} 到 @var{M} 次，包括 @var{N} 和 @var{M} 次。 格式 @t{(#c}@var{N}@t{)} 要"
"求匹配 @t{N} 次； @t{(#c,}@var{M}@t{)}  等同于指定 @var{N} 为 0； @t{(#c}@var{N}@t{,)} 则表示对匹配次数没有最大限制。"

#. type: t{#1}
#: zsh.texi:6965 zsh.texi:9240
#, no-wrap
msgid "MATCH"
msgstr "MATCH"

#. type: t{#1}
#: zsh.texi:6966 zsh.texi:9241
#, no-wrap
msgid "MBEGIN"
msgstr "MBEGIN"

#. type: t{#1}
#: zsh.texi:6967 zsh.texi:9242
#, no-wrap
msgid "MEND"
msgstr "MEND"

#. type: table
#: zsh.texi:6976
msgid ""
"Set references to the match data for the entire string matched; this is similar to backreferencing and does not work in filename generation.  The flag must be in effect at the end of the pattern, i.e. not "
"local to a group. The parameters @t{$MATCH}, @t{$MBEGIN} and @t{$MEND} will be set to the string matched and to the indices of the beginning and end of the string, respectively.  This is most useful in "
"parameter substitutions, as otherwise the string matched is obvious."
msgstr ""
"设置对整个匹配字符串的匹配数据的引用；这类似于反向引用，在文件名生成中不起作用。 该标记必须在模式末尾有效，即不属于某个组。参数 @t{$MATCH}、@t{$MBEGIN} 和 @t{$MEND} 将分别设置为匹配的字符串以及字符串开始和"
"结束的索引。 这在参数替换中最有用，否则匹配的字符串就显而易见了。"

#. type: example
#: zsh.texi:6984
#, no-wrap
msgid ""
"arr=(veldt jynx grimps waqf zho buck)\n"
"print $@{arr//(#m)[aeiou]/$@{(U)MATCH@}@}\n"
msgstr ""
"arr=(veldt jynx grimps waqf zho buck)\n"
"print $@{arr//(#m)[aeiou]/$@{(U)MATCH@}@}\n"

#. type: table
#: zsh.texi:6989
msgid "forces all the matches (i.e. all vowels) into uppercase, printing `@t{vEldt jynx grImps wAqf zhO bUck}'."
msgstr "将所有匹配项（即所有元音）强制改为大写，打印 `@t{vEldt jynx grImps wAqf zhO bUck}'。"

#. type: table
#: zsh.texi:6994
msgid "Unlike backreferences, there is no speed penalty for using match references, other than the extra substitutions required for the replacement strings in cases such as the example shown."
msgstr "与反向引用不同，使用匹配引用不会影响速度，只是在所示示例中需要对替换字符串进行额外的替换。"

#. type: table
#: zsh.texi:6998
msgid "Deactivate the @t{m} flag, hence no references to match data will be created."
msgstr "停用 @t{m} 标志，因此不会创建匹配数据的引用。"

#. type: item
#: zsh.texi:6999
#, no-wrap
msgid "@t{a}@var{num}"
msgstr "@t{a}@var{num}"

#. type: table
#: zsh.texi:7002
msgid "Approximate matching: @var{num} errors are allowed in the string matched by the pattern.  The rules for this are described in the next subsection."
msgstr "近似匹配： 在模式匹配的字符串中允许出现 @var{num} 个错误。 相关规则将在下一小节中介绍。"

#. type: item
#: zsh.texi:7003
#, no-wrap
msgid "@t{s}, @t{e}"
msgstr "@t{s}, @t{e}"

#. type: table
#: zsh.texi:7014
msgid ""
"Unlike the other flags, these have only a local effect, and each must appear on its own: `@t{(#s)}' and `@t{(#e)}' are the only valid forms.  The `@t{(#s)}' flag succeeds only at the start of the test "
"string, and the `@t{(#e)}' flag succeeds only at the end of the test string; they correspond to `@t{^}' and `@t{$}' in standard regular expressions.  They are useful for matching path segments in patterns "
"other than those in filename generation (where path segments are in any case treated separately).  For example, `@t{*((#s)|/)test((#e)|/)*}' matches a path segment `@t{test}' in any of the following "
"strings: @t{test}, @t{test/at/start}, @t{at/end/test}, @t{in/test/middle}."
msgstr ""
"与其他标志不同，这些标志只有局部效果，而且每个标志都必须单独出现： `@t{(#s)}' 和 `@t{(#e)}' 是唯一有效的形式。 `@t{(#s)}' 标志只在测试字符串的起始处生效，而  `@t{(#e)}'  标志只在测试字符串的末尾处生效；它"
"们对应于标准正则表达式中的 `@t{^}' 和 `@t{$}' 。 它们适用于匹配文件名生成模式以外的模式中的路径段（在任何情况下，路径段都是单独处理的）。 例如，`@t{*((#s)|/)test((#e)|/)*}' 匹配以下任何字符串中的路径段 "
"`@t{test}' ： @t{test}, @t{test/at/start}, @t{at/end/test}, @t{in/test/middle}。"

#. type: table
#: zsh.texi:7023
msgid ""
"Another use is in parameter substitution; for example `@t{$@{array/(#s)A*Z(#e)@}}' will remove only elements of an array which match the complete pattern `@t{A*Z}'.  There are other ways of performing "
"many operations of this type, however the combination of the substitution operations `@t{/}' and `@t{//}' with the `@t{(#s)}' and `@t{(#e)}' flags provides a single simple and memorable method."
msgstr ""
"另一个用途是参数替换；例如， `@t{$@{array/(#s)A*Z(#e)@}}'  将只删除与完整模式 `@t{A*Z}' 匹配的数组中的元素。 执行此类操作的方法还有很多，但将替换操作 `@t{/}' 和 `@t{//}'与 `@t{(#s)}' 和 `@t{(#e)}'标志相结"
"合，就提供了一种简单易记的方法。"

#. type: table
#: zsh.texi:7030
msgid ""
"Note that assertions of the form `@t{(^(#s))}' also work, i.e. match anywhere except at the start of the string, although this actually means `anything except a zero-length portion at the start of the "
"string'; you need to use `@t{(\"\"~(#s))}' to match a zero-length portion of the string not at the start."
msgstr "请注意， `@t{(^(#s))}' 形式的断言也可以工作，即匹配字符串开头以外的任何地方，但这实际上意味着 `字符串开头零长度部分以外的任何地方'；您需要使用 `@t{(\"\"~(#s))}' 来匹配字符串开头以外的零长度部分。"

#. type: table
#: zsh.texi:7042
msgid ""
"A `@t{q}' and everything up to the closing parenthesis of the globbing flags are ignored by the pattern matching code.  This is intended to support the use of glob qualifiers, see below.  The result is "
"that the pattern `@t{(#b)(*).c(#q.)}' can be used both for globbing and for matching against a string.  In the former case, the `@t{(#q.)}' will be treated as a glob qualifier and the `@t{(#b)}' will not "
"be useful, while in the latter case the `@t{(#b)}' is useful for backreferences and the `@t{(#q.)}' will be ignored.  Note that colon modifiers in the glob qualifiers are also not applied in ordinary "
"pattern matching."
msgstr ""
"模式匹配代码将忽略`@t{q}' 和直到 globbing 标志结尾括号内的所有内容。 这样做的目的是支持 glob 限定符的使用，见下文。 因此， `@t{(#b)(*).c(#q.)}' 模式既可用于globbing，也可用于字符串匹配。 在前一种情况下， "
"`@t{(#q.)}' 将被视为全局限定符，而 `@t{(#b)}' 将不起作用；在后一种情况下， `@t{(#b)}' 可用于反向引用，而 `@t{(#q.)}' 将被忽略。 请注意，glob 限定符中的冒号限定符也不适用于普通模式匹配。"

#. type: table
#: zsh.texi:7051
msgid ""
"Respect the current locale in determining the presence of multibyte characters in a pattern, provided the shell was compiled with @t{MULTIBYTE_SUPPORT}.  This overrides the @t{MULTIBYTE} option; the "
"default behaviour is taken from the option.  Compare @t{U}.  (Mnemonic: typically multibyte characters are from Unicode in the UTF-8 encoding, although any extension of ASCII supported by the system "
"library may be used.)"
msgstr ""
"如果 shell 在编译时使用了 @t{MULTIBYTE_SUPPORT}，则在判断模式中是否存在多字节字符时尊重当前的语言环境。 这将覆盖 @t{MULTIBYTE} 选项；默认行为取自该选项。 比较 @t{U}。 (提示：多字节字符通常来自 UTF-8 编码"
"的 Unicode，但也可以使用系统库支持的任何 ASCII 扩展）。"

#. type: table
#: zsh.texi:7055
msgid "All characters are considered to be a single byte long.  The opposite of @t{u}.  This overrides the @t{MULTIBYTE} option."
msgstr "所有字符都被视为单字节长。 与 @t{u} 相反。 此选项覆盖 @t{MULTIBYTE} 选项。"

#. type: Plain text
#: zsh.texi:7065
msgid ""
"For example, the test string @t{fooxx} can be matched by the pattern @t{(#i}@t{)FOOXX}, but not by @t{(#l}@t{)FOOXX}, @t{(#i}@t{)FOO}@t{(#I}@t{)XX} or @t{((#i}@t{)FOOX}@t{)X}.  The string @t{(#ia2}"
"@t{)readme} specifies case-insensitive matching of @t{readme} with up to two errors."
msgstr ""
"例如，测试字符串 @t{fooxx} 可与模式 @t{(#i}@t{)FOOXX} 匹配，但不能与 @t{(#l}@t{)FOOXX}、@t{(#i}@t{)FOO}@t{(#I}@t{)XX} 或 @t{((#i}@t{)FOOX}@t{)X} 匹配。 字符串  @t{(#ia2}@t{)readme} 指定不区分大小写的 "
"@t{readme} 匹配，最多有两个错误。"

#. type: Plain text
#: zsh.texi:7075
msgid ""
"When using the ksh syntax for grouping both @t{KSH_GLOB} and @t{EXTENDED_GLOB} must be set and the left parenthesis should be preceded by @t{@@}.  Note also that the flags do not affect letters inside "
"@t{[}...@t{]} groups, in other words @t{(#i}@t{)[a-z]} still matches only lowercase letters.  Finally, note that when examining whole paths case-insensitively every directory must be searched for all "
"files which match, so that a pattern of the form @t{(#i}@t{)/foo/bar/...} is potentially slow."
msgstr ""
"使用 ksh 语法进行分组时，必须同时设置 @t{KSH_GLOB} 和 @t{EXTENDED_GLOB}，左括号前应加上 @t{@@}。 还要注意的是，标志不会影响 @t{[}...@t{]} 组内的字母，换句话说，@t{(#i}@t{)[a-z]} 仍然只匹配小写字母。 最后要"
"注意的是，在检查整个路径时，由于对大小写不敏感，所以必须搜索每个目录中所有匹配的文件，因此格式为  @t{(#i}@t{)/foo/bar/...} 的模式可能会比较慢。"

#. type: subsection
#: zsh.texi:7078
#, no-wrap
msgid "Approximate Matching"
msgstr "近似匹配"

#. type: cindex
#: zsh.texi:7080
#, no-wrap
msgid "approximate matching"
msgstr "近似匹配"

#. type: cindex
#: zsh.texi:7081
#, no-wrap
msgid "matching, approximate"
msgstr "匹配, 近似"

#. type: Plain text
#: zsh.texi:7085
msgid "When matching approximately, the shell keeps a count of the errors found, which cannot exceed the number specified in the @t{(#a}@var{num}@t{)} flags.  Four types of error are recognised:"
msgstr "在近似匹配时，shell 会对发现的错误进行计数，计数不能超过 @t{(#a}@var{num}@t{)} 标志中指定的数量。 可识别四种类型的错误："

#. type: item
#: zsh.texi:7088 zsh.texi:13426 zsh.texi:31710
#, no-wrap
msgid "1."
msgstr "1."

#. type: table
#: zsh.texi:7090
msgid "Different characters, as in @t{fooxbar} and @t{fooybar}."
msgstr "不同的字符，如 @t{fooxbar} 和 @t{fooybar}。"

#. type: item
#: zsh.texi:7091 zsh.texi:13433 zsh.texi:31713
#, no-wrap
msgid "2."
msgstr "2."

#. type: table
#: zsh.texi:7093
msgid "Transposition of characters, as in @t{banana} and @t{abnana}."
msgstr "字符的转置，如 @t{banana} 和 @t{abnana}。"

#. type: item
#: zsh.texi:7094 zsh.texi:13438 zsh.texi:31716
#, no-wrap
msgid "3."
msgstr "3."

#. type: table
#: zsh.texi:7097
msgid "A character missing in the target string, as with the pattern @t{road} and target string @t{rod}."
msgstr "目标字符串中缺少一个字符，如模式 @t{road} 和目标字符串 @t{rod}。"

#. type: item
#: zsh.texi:7098 zsh.texi:13442 zsh.texi:31719
#, no-wrap
msgid "4."
msgstr "4."

#. type: table
#: zsh.texi:7101
msgid "An extra character appearing in the target string, as with @t{stove} and @t{strove}."
msgstr "目标字符串中出现的额外字符，如 @t{stove} 和 @t{strove}。"

#. type: Plain text
#: zsh.texi:7108
msgid "Thus, the pattern @t{(#a3}@t{)abcd} matches @t{dcba}, with the errors occurring by using the first rule twice and the second once, grouping the string as @t{[d][cb][a]} and @t{[a][bc][d]}."
msgstr "因此，模式 @t{(#a3}@t{)abcd} 与 @t{dcba}相匹配，错误发生在使用第一条规则两次，第二条规则一次，将字符串分组为 @t{[d][cb][a]}  和 @t{[a][bc][d]}。"

#. type: Plain text
#: zsh.texi:7120
msgid ""
"Non-literal parts of the pattern must match exactly, including characters in character ranges: hence @t{(#a1}@t{)???} matches strings of length four, by applying rule 4 to an empty part of the pattern, "
"but not strings of length two, since all the @t{?} must match.  Other characters which must match exactly are initial dots in filenames (unless the @t{GLOB_DOTS} option is set), and all slashes in "
"filenames, so that @t{a/bc} is two errors from @t{ab/c} (the slash cannot be transposed with another character).  Similarly, errors are counted separately for non-contiguous strings in the pattern, so "
"that @t{(ab|cd}@t{)ef} is two errors from @t{aebf}."
msgstr ""
"模式中的非字面部分必须完全匹配，包括字符范围中的字符：因此， @t{(#a1}@t{)???} 通过对模式的空部分应用规则 4，可以匹配长度为 4 的字符串，但不能匹配长度为 2 的字符串，因为所有 @t{?} 都必须匹配。 其他必须完全"
"匹配的字符包括文件名中的首字母点（除非设置了 @t{GLOB_DOTS} 选项），以及文件名中的所有斜线，因此 @t{a/bc} 与 @t{ab/c} 之间有两个错误（斜线不能与其他字符换位）。 同样，对于模式中的非连续字符串，错误也会单独"
"计算，因此 @t{(ab|cd}@t{)ef} 以 @t{aebf} 来说是两个错误。"

#. type: Plain text
#: zsh.texi:7130
msgid ""
"When using exclusion via the @t{~} operator, approximate matching is treated entirely separately for the excluded part and must be activated separately.  Thus, @t{(#a1}@t{)README~READ_ME} matches @t{READ."
"ME} but not @t{READ_ME}, as the trailing @t{READ_ME} is matched without approximation.  However, @t{(#a1}@t{)README~(#a1}@t{)READ_ME} does not match any pattern of the form @t{READ}@var{?}@t{ME} as all "
"such forms are now excluded."
msgstr ""
"当通过 @t{~} 操作符使用排除时，近似匹配将完全单独处理被排除的部分，并且必须单独激活。 因此，@t{(#a1}@t{)README~READ_ME} 会匹配 @t{READ.ME}，但不会匹配 @t{READ_ME}，因为尾部的 @t{READ_ME} 不会进行近似匹"
"配。 不过，@t{(#a1}@t{)README~(#a1}@t{)READ_ME} 不会匹配任何形式为  @t{READ}@var{?}@t{ME}  的模式，因为所有此类形式现在都被排除在外。"

#. type: Plain text
#: zsh.texi:7143
msgid ""
"Apart from exclusions, there is only one overall error count; however, the maximum errors allowed may be altered locally, and this can be delimited by grouping.  For example, @t{(#a1}@t{)cat}@t{((#a0}"
"@t{)dog}@t{)fox} allows one error in total, which may not occur in the @t{dog} section, and the pattern @t{(#a1}@t{)cat}@t{(#a0}@t{)dog}@t{(#a1}@t{)fox} is equivalent.  Note that the point at which an "
"error is first found is the crucial one for establishing whether to use approximation; for example, @t{(#a1)abc(#a0)xyz} will not match @t{abcdxyz}, because the error occurs at the `@t{x}', where "
"approximation is turned off."
msgstr ""
"除排除项外，只有一个总体错误计数；不过，允许的最大错误数可以局部更改，而且可以通过分组来限定。 例如， @t{(#a1}@t{)cat}@t{((#a0}@t{)dog}@t{)fox} 总共允许出现一个错误，而这个错误可能不会出现在 @t{dog} 部分，"
"因此 @t{(#a1}@t{)cat}@t{(#a0}@t{)dog}@t{(#a1}@t{)fox} 模式是等价的。请注意，首次发现错误的点是确定是否使用近似的关键点；  例如，@t{(#a1)abc(#a0)xyz}  不会匹配 @t{abcdxyz}，因为错误发生在 `@t{x}' 处，而此处"
"的近似是关闭的。"

#. type: Plain text
#: zsh.texi:7151
msgid ""
"Entire path segments may be matched approximately, so that `@t{(#a1)/foo/d/is/available/at/the/bar}' allows one error in any path segment.  This is much less efficient than without the @t{(#a1)}, however, "
"since every directory in the path must be scanned for a possible approximate match.  It is best to place the @t{(#a1)} after any path segments which are known to be correct."
msgstr ""
"整个路径段可以近似匹配，因此 `@t{(#a1)/foo/d/is/available/at/the/bar}' 允许在任何路径段中出现一个错误。 不过，这比不使用 @t{(#a1)}时的效率要低得多，因为必须扫描路径中的每个目录，以寻找可能的近似匹配。 最好"
"将 @t{(#a1)} 放在已知正确的路径段之后。"

#. type: subsection
#: zsh.texi:7154
#, no-wrap
msgid "Recursive Globbing"
msgstr "递归 Globbing"

#. type: cindex
#: zsh.texi:7156
#, no-wrap
msgid "recursive globbing"
msgstr "递归 globbing"

#. type: cindex
#: zsh.texi:7157
#, no-wrap
msgid "globbing, recursive"
msgstr "globbing, 递归递归"

#. type: Plain text
#: zsh.texi:7161
msgid "A pathname component of the form `@t{(}@var{foo}@t{/)#}' matches a path consisting of zero or more directories matching the pattern @var{foo}."
msgstr "形式为 `@t{(}@var{foo}@t{/)#}' 的路径名部分匹配由零个或多个符合 @var{foo} 模式的目录组成的路径。"

#. type: Plain text
#: zsh.texi:7167
msgid "As a shorthand, `@t{**/}' is equivalent to `@t{(*/)#}'; note that this therefore matches files in the current directory as well as subdirectories.  Thus:"
msgstr "作为简写， `@t{**/}' 等同于 `@t{(*/)#}'；请注意，这将匹配当前目录和子目录中的文件。 因此"

#. type: example
#: zsh.texi:7171
#, no-wrap
msgid "ls -ld -- (*/)#bar\n"
msgstr "ls -ld -- (*/)#bar\n"

#. type: Plain text
#: zsh.texi:7175
msgid "or"
msgstr "或"

#. type: example
#: zsh.texi:7179
#, no-wrap
msgid "ls -ld -- **/bar\n"
msgstr "ls -ld -- **/bar\n"

#. type: Plain text
#: zsh.texi:7188
msgid ""
"does a recursive directory search for files named `@t{bar}' (potentially including the file `@t{bar}' in the current directory).  This form does not follow symbolic links; the alternative form `@t{***/}' "
"does, but is otherwise identical.  Neither of these can be combined with other forms of globbing within the same path segment; in that case, the `@t{*}' operators revert to their usual effect."
msgstr ""
"进行递归目录搜索,查找 `@t{bar}' (可能包括当前目录中的文件 `@t{bar}' ） 。 这种形式不遵循符号链接；另一种形式 `@t{***/}' 遵循符号链接，但在其他方面完全相同。 在同一路径段中，这两种形式都不能与其他形式的 "
"globbing 结合使用；在这种情况下， `@t{*}'  操作符将恢复其通常的效果。"

#. type: Plain text
#: zsh.texi:7194
msgid ""
"Even shorter forms are available when the option @t{GLOB_STAR_SHORT} is set.  In that case if no @t{/} immediately follows a @t{**} or @t{***} they are treated as if both a @t{/} plus a further @t{*} are "
"present.  Hence:"
msgstr "如果设置了 @t{GLOB_STAR_SHORT} 选项，还可以使用更短的形式。 在这种情况下，如果 @t{**} 或 @t{***} 后面没有紧跟 @t{/}，它们就会被当作同时存在 @t{/} 和 @t{*} 处理。 因此"

#. type: example
#: zsh.texi:7199
#, no-wrap
msgid ""
"setopt GLOBSTARSHORT\n"
"ls -ld -- **.c\n"
msgstr ""
"setopt GLOBSTARSHORT\n"
"ls -ld -- **.c\n"

#. type: example
#: zsh.texi:7207
#, no-wrap
msgid "ls -ld -- **/*.c\n"
msgstr "ls -ld -- **/*.c\n"

#. type: subsection
#: zsh.texi:7209
#, no-wrap
msgid "Glob Qualifiers"
msgstr "Glob 限定符"

#. type: cindex
#: zsh.texi:7211
#, no-wrap
msgid "globbing, qualifiers"
msgstr "globbing, 限定符"

#. type: cindex
#: zsh.texi:7212
#, no-wrap
msgid "qualifiers, globbing"
msgstr "限定符, globbing"

#. type: Plain text
#: zsh.texi:7217
msgid ""
"Patterns used for filename generation may end in a list of qualifiers enclosed in parentheses.  The qualifiers specify which filenames that otherwise match the given pattern will be inserted in the "
"argument list."
msgstr "用于生成文件名的模式可以以括号中的限定符列表结尾。 限定符指定哪些与给定模式匹配的文件名将插入参数列表。"

#. type: pindex
#: zsh.texi:7219
#, no-wrap
msgid "BARE_GLOB_QUAL, use of"
msgstr "BARE_GLOB_QUAL, use of"

#. type: Plain text
#: zsh.texi:7227
msgid ""
"If the option @t{BARE_GLOB_QUAL} is set, then a trailing set of parentheses containing no `@t{|}' or `@t{(}' characters (or `@t{~}' if it is special)  is taken as a set of glob qualifiers.  A glob "
"subexpression that would normally be taken as glob qualifiers, for example `@t{(^x)}', can be forced to be treated as part of the glob pattern by doubling the parentheses, in this case producing "
"`@t{((^x))}'."
msgstr ""
"如果设置了选项 @t{BARE_GLOB_QUAL}，那么尾部不包含 `@t{|}' 或 `@t{(}' 字符（或 `@t{~}' ，如果是特殊符号）的括号将被视为一组 glob 限定符。 通常会被当作 glob 限定符的 glob 子表达式，例如  `@t{(^x)}'，可以通过"
"将括号双写来强制当作 glob 模式的一部分，在这种情况下会产生 `@t{((^x))}'。"

#. type: Plain text
#: zsh.texi:7249
msgid ""
"If the option @t{EXTENDED_GLOB} is set, a different syntax for glob qualifiers is available, namely `@t{(#q}@var{x}@t{)}' where @var{x} is any of the same glob qualifiers used in the other format.  The "
"qualifiers must still appear at the end of the pattern.  However, with this syntax multiple glob qualifiers may be chained together.  They are treated as a logical AND of the individual sets of flags.  "
"Also, as the syntax is unambiguous, the expression will be treated as glob qualifiers just as long any parentheses contained within it are balanced; appearance of `@t{|}', `@t{(}' or `@t{~}' does not "
"negate the effect.  Note that qualifiers will be recognised in this form even if a bare glob qualifier exists at the end of the pattern, for example `@t{*(#q*)(.)}' will recognise executable regular files "
"if both options are set; however, mixed syntax should probably be avoided for the sake of clarity.  Note that within conditions using the `@t{[[}' form the presence of a parenthesised expression @t{(#q}"
"@var{...}@t{)} at the end of a string indicates that globbing should be performed; the expression may include glob qualifiers, but it is also valid if it is simply @t{(#q)}.  This does not apply to the "
"right hand side of pattern match operators as the syntax already has special significance."
msgstr ""
"如果设置了选项 @t{EXTENDED_GLOB}，glob 限定符就有了不同的语法，即 `@t{(#q}@var{x}@t{)}'，其中 @var{x} 是与其他格式相同的任何 glob 限定符。 限定符仍必须出现在格式末尾。 不过，这种语法可以将多个 glob 限定符"
"串联起来。 它们被视为各组标志的逻辑与。 此外，由于语法不含糊，只要表达式中包含的任何括号是平衡的，表达式就会被视为 glob 限定符；出现 `@t{|}'、`@t{(}' 或 `@t{~}'并不能否定其效果。 请注意，即使在模式末尾存在"
"裸 glob 限定符，限定符也会以这种形式被识别，例如，如果同时设置了两个选项，`@t{*(#q*)(.)}' 将识别可执行的常规文件；不过，为了清晰起见，最好避免使用混合语法。 请注意，在使用 `@t{[[}' 形式的条件中，如果字符串"
"末尾出现带括号的表达式 @t{(#q}@var{...}@t{)} ，则表示应执行globbing；该表达式可能包含 glob 限定符，但如果只是 @t{(#q)}，也是有效的。 这不适用于模式匹配运算符的右侧，因为该语法已经具有特殊意义。"

#. type: Plain text
#: zsh.texi:7252
msgid "A qualifier may be any one of the following:"
msgstr "限定符可以是以下任何一种："

#. type: t{#1}
#: zsh.texi:7257 zsh.texi:21507
#, no-wrap
msgid "directories"
msgstr "directories"

#. type: table
#: zsh.texi:7263
msgid "`full' (i.e. non-empty) directories.  Note that the opposite sense @t{(^F}@t{)} expands to empty directories and all non-directories.  Use @t{(/^F}@t{)} for empty directories."
msgstr "`full'（即非空）目录。 请注意，与之相反的 @t{(^F}@t{)} 会扩展到空目录和所有非目录。 对于空目录，请使用 @t{(/^F}@t{)} 。"

#. type: table
#: zsh.texi:7266
msgid "plain files"
msgstr "文本文件"

#. type: cindex
#: zsh.texi:7269 zsh.texi:9838
#, no-wrap
msgid "symbolic links"
msgstr "符号链接"

#. type: t{#1}
#: zsh.texi:7270
#, no-wrap
msgid "="
msgstr "="

#. type: cindex
#: zsh.texi:7272 zsh.texi:30256
#, no-wrap
msgid "sockets"
msgstr "套接字"

#. type: table
#: zsh.texi:7275
msgid "named pipes (FIFOs)"
msgstr "命名管道 (FIFOs)"

#. type: table
#: zsh.texi:7278
msgid "executable plain files (0100 or 0010 or 0001)"
msgstr "可执行普通文件 (0100 or 0010 or 0001)"

#. type: table
#: zsh.texi:7281
msgid "device files (character or block special)"
msgstr "设备文件（字符或块特殊文件）"

#. type: t{#1}
#: zsh.texi:7282 zsh.texi:37062 zsh.texi:37125
#, no-wrap
msgid "%b"
msgstr "%b"

#. type: table
#: zsh.texi:7284
msgid "block special files"
msgstr "块特殊文件"

#. type: table
#: zsh.texi:7287
msgid "character special files"
msgstr "字符特殊文件"

#. type: table
#: zsh.texi:7290
msgid "owner-readable files (0400)"
msgstr "所有者可读文件 (0400)"

#. type: table
#: zsh.texi:7293
msgid "owner-writable files (0200)"
msgstr "所有者可写文件 (0200)"

#. type: table
#: zsh.texi:7296
msgid "owner-executable files (0100)"
msgstr "所有者可执行文件 (100) "

#. type: table
#: zsh.texi:7299
msgid "group-readable files (0040)"
msgstr "组可读文件 (0040)"

#. type: table
#: zsh.texi:7302
msgid "group-writable files (0020)"
msgstr "组可写文件 (0020)"

#. type: table
#: zsh.texi:7305
msgid "group-executable files (0010)"
msgstr "组可执行文件 (0010)"

#. type: table
#: zsh.texi:7308
msgid "world-readable files (0004)"
msgstr "世界可读文件 (0004)"

#. type: table
#: zsh.texi:7311
msgid "world-writable files (0002)"
msgstr "世界可写文件 (0002)"

#. type: table
#: zsh.texi:7314
msgid "world-executable files (0001)"
msgstr "世界可执行文件 (0001)"

#. type: t{#1}
#: zsh.texi:7315 zsh.texi:36309
#, no-wrap
msgid "s"
msgstr "s"

#. type: table
#: zsh.texi:7317
msgid "setuid files (04000)"
msgstr "setuid 文件 (04000)"

#. type: table
#: zsh.texi:7320
msgid "setgid files (02000)"
msgstr "setgid 文件 (02000)"

#. type: table
#: zsh.texi:7323
msgid "files with the sticky bit (01000)"
msgstr "带 sticky bit  位的文件 (01000)"

#. type: item
#: zsh.texi:7324
#, no-wrap
msgid "@t{f}@var{spec}"
msgstr "@t{f}@var{spec}"

#. type: table
#: zsh.texi:7336
msgid ""
"files with access rights matching @var{spec}. This @var{spec} may be a octal number optionally preceded by a `@t{=}', a `@t{+}', or a `@t{-}'. If none of these characters is given, the behavior is the "
"same as for `@t{=}'. The octal number describes the mode bits to be expected, if combined with a `@t{=}', the value given must match the file-modes exactly, with a `@t{+}', at least the bits in the given "
"number must be set in the file-modes, and with a `@t{-}', the bits in the number must not be set. Giving a `@t{?}' instead of a octal digit anywhere in the number ensures that the corresponding bits in "
"the file-modes are not checked, this is only useful in combination with `@t{=}'."
msgstr ""
"访问权限与 @var{spec} 匹配的文件。@var{spec} 可以是一个八进制数，前面可选择加上`@t{=}',  `@t{+}', 或 `@t{-}'。如果没有给出这些字符，则行为与 `@t{=}' 相同。八进制数描述了预期的模式位，如果与 `@t{=}' 组合，"
"给出的值必须与文件模式完全匹配；如果与 `@t{+}' 组合，至少要在文件模式中设置所给数字中的位；如果与 `@t{-}' 组合，数字中的位数必须不被设置。如果不在数字的任何位置给出八进制数字，而是给出 `@t{?}' ，则不会检查"
"文件模式中的相应位，这只有在与 `@t{=}' 结合使用时才有用。"

#. type: table
#: zsh.texi:7358
msgid ""
"If the qualifier `@t{f}' is followed by any other character anything up to the next matching character (`@t{[}', `@t{@{}', and `@t{<}' match `@t{]}', `@t{@}}', and `@t{>}' respectively, any other "
"character matches itself) is taken as a list of comma-separated @var{sub-spec}s. Each @var{sub-spec} may be either an octal number as described above or a list of any of the characters `@t{u}', `@t{g}', "
"`@t{o}', and `@t{a}', followed by a `@t{=}', a `@t{+}', or a `@t{-}', followed by a list of any of the characters `@t{r}', `@t{w}', `@t{x}', `@t{s}', and `@t{t}', or an octal digit. The first list of "
"characters specify which access rights are to be checked. If a `@t{u}' is given, those for the owner of the file are used, if a `@t{g}' is given, those of the group are checked, a `@t{o}' means to test "
"those of other users, and the `@t{a}' says to test all three groups. The `@t{=}', `@t{+}', and `@t{-}' again says how the modes are to be checked and have the same meaning as described for the first form "
"above. The second list of characters finally says which access rights are to be expected: `@t{r}' for read access, `@t{w}' for write access, `@t{x}' for the right to execute the file (or to search a "
"directory), `@t{s}' for the setuid and setgid bits, and `@t{t}' for the sticky bit."
msgstr ""
"如果限定符 `@t{f}' 后跟有任何其他字符，则下一个匹配字符之前的任何字符（ `@t{[}', `@t{@{}' 和 `@t{<}' 分别与 `@t{]}', `@t{@}}' 和 `@t{>}' 匹配，任何其他字符则与自身匹配）都将作为逗号分隔的 @var{sub-spec}s "
"列表。每个 @var{sub-spec} 既可以是上述八进制数，也可以是 `@t{u}', `@t{g}', `@t{o}' 和 `@t{a}' 中的任意字符, 后接 `@t{=}' 、 `@t{+}' 或 `@t{-}' ，后接 `@t{r}', `@t{w}', `@t{x}', `@t{s}' 和 `@t{t}' 中的任意"
"字符或一个八进制数字。第一个列表字符指定要检查的访问权限。如果给出 `@t{u}' ，则使用文件所有者的访问权限；如果给出 `@t{g}' ，则检查组的访问权限； `@t{o}' 表示检查其他用户的访问权限； `@t{a}' 表示检查所有三"
"个组的访问权限。 `@t{=}', `@t{+}' 和 `@t{-}' 再次说明如何检查模式，其含义与上述第一种形式相同。第二个字符列表说明了预期的访问权限： `@t{r}'  表示读取权限， `@t{w}' 表示写入权限， `@t{x}' 表示执行文件（或搜"
"索目录）的权限，`@t{s}' 表示 setuid 和 setgid 位， `@t{t}' 表示 sticky 位。"

#. type: table
#: zsh.texi:7368
msgid ""
"Thus, `@t{*(f70?)}' gives the files for which the owner has read, write, and execute permission, and for which other group members have no rights, independent of the permissions for other users. The "
"pattern `@t{*(f-100)}' gives all files for which the owner does not have execute permission, and `@t{*(f:gu+w,o-rx:)}' gives the files for which the owner and the other members of the group have at least "
"write permission, and for which other users don't have read or execute permission."
msgstr ""
"因此， `@t{*(f70?)}' 给出了所有者有读取、写入和执行权限，而其他组员没有权限的文件，与其他用户的权限无关。模式 `@t{*(f-100)}' 给出所有所有者没有执行权限的文件，而 `@t{*(f:gu+w,o-rx:)}' 给出所有者和组内其他"
"成员至少有写入权限，而其他用户没有读取或执行权限的文件。"

#. type: item
#: zsh.texi:7369 zsh.texi:7552
#, no-wrap
msgid "@t{e}@var{string}"
msgstr "@t{e}@var{string}"

#. type: itemx
#: zsh.texi:7370 zsh.texi:7553
#, no-wrap
msgid "@t{+}@var{cmd}"
msgstr "@t{+}@var{cmd}"

#. type: table
#: zsh.texi:7374
msgid "The @var{string} will be executed as shell code.  The filename will be included in the list if and only if the code returns a zero status (usually the status of the last command)."
msgstr "@var{string} 将作为 shell 代码执行。 当且仅当代码返回零状态（通常是最后一条命令的状态）时，文件名才会包含在列表中。"

#. type: table
#: zsh.texi:7385
msgid ""
"In the first form, the first character after the `@t{e}' will be used as a separator and anything up to the next matching separator will be taken as the @var{string}; `@t{[}', `@t{@{}', and `@t{<}' match "
"`@t{]}', `@t{@}}', and `@t{>}', respectively, while any other character matches itself. Note that expansions must be quoted in the @var{string} to prevent them from being expanded before globbing is "
"done.  @var{string} is then executed as shell code.  The string @t{globqual} is appended to the array @t{zsh_eval_context} the duration of execution."
msgstr ""
"在第一种形式中， `@t{e}' 之后的第一个字符将被用作分隔符，下一个匹配的分隔符之前的任何字符将被用作 @var{string}；`@t{[}', `@t{@{}' 和 `@t{<}' 分别匹配 `@t{]}', `@t{@}}' 和 `@t{>}'，而任何其他字符则匹配自"
"身。需要注意的是，扩展必须在 @var{string} 中加上引号，以防止在执行 globbing 之前被扩展。 然后，@var{string} 将作为 shell 代码执行。 在执行过程中，字符串 @t{globqual} 会被附加到数组 @t{zsh_eval_context} "
"中。"

#. type: vindex
#: zsh.texi:7388 zsh.texi:14420 zsh.texi:27150 zsh.texi:27301 zsh.texi:32241
#, no-wrap
msgid "reply, use of"
msgstr "reply, use of"

#. type: table
#: zsh.texi:7395
msgid ""
"During the execution of @var{string} the filename currently being tested is available in the parameter @t{REPLY}; the parameter may be altered to a string to be inserted into the list instead of the "
"original filename.  In addition, the parameter @t{reply} may be set to an array or a string, which overrides the value of @t{REPLY}.  If set to an array, the latter is inserted into the command line word "
"by word."
msgstr ""
"在 @var{string} 的执行过程中，正在测试的文件名在参数 @t{REPLY} 中可用；该参数可更改为一个字符串，以代替原始文件名插入到列表中。 此外，参数 @t{reply} 可以设置为数组或字符串，这将覆盖 @t{REPLY} 的值。 如果设"
"置为数组，则后者会逐字插入命令行。"

#. type: table
#: zsh.texi:7401
msgid ""
"For example, suppose a directory contains a single file `@t{lonely}'.  Then the expression `@t{*(e:'reply=($@{REPLY@}@{1,2@})':)}' will cause the words `@t{lonely1}' and `@t{lonely2}' to be inserted into "
"the command line.  Note the quoting of @var{string}."
msgstr "例如，假设一个目录包含一个文件 `@t{lonely}'。 那么表达式 `@t{*(e:'reply=($@{REPLY@}@{1,2@})':)}' 将导致在命令行中插入 `@t{lonely1}' 和 `@t{lonely2}' 。 注意 @var{string} 的引号。"

#. type: table
#: zsh.texi:7408
msgid ""
"The form @t{+}@var{cmd} has the same effect, but no delimiters appear around @var{cmd}.  Instead, @var{cmd} is taken as the longest sequence of characters following the @t{+} that are alphanumeric or "
"underscore.  Typically @var{cmd} will be the name of a shell function that contains the appropriate test.  For example,"
msgstr "形式  @t{+}@var{cmd} 也有同样的效果，但 @var{cmd} 周围没有分隔符。 取而代之的是，@var{cmd} 是 @t{+} 后面最长的字母数字或下划线字符序列。 通常情况下，@var{cmd} 是包含相应测试的 shell 函数名称。 例如"

#. type: example
#: zsh.texi:7414
#, no-wrap
msgid ""
"nt() @{ [[ $REPLY -nt $NTREF ]] @}\n"
"NTREF=reffile\n"
"ls -ld -- *(+nt)\n"
msgstr ""
"nt() @{ [[ $REPLY -nt $NTREF ]] @}\n"
"NTREF=reffile\n"
"ls -ld -- *(+nt)\n"

#. type: table
#: zsh.texi:7419
msgid "lists all files in the directory that have been modified more recently than @t{reffile}."
msgstr "会列出目录中所有最近修改次数多于 @t{reffile} 的文件。"

#. type: item
#: zsh.texi:7420
#, no-wrap
msgid "@t{d}@var{dev}"
msgstr "@t{d}@var{dev}"

#. type: table
#: zsh.texi:7422
msgid "files on the device @var{dev}"
msgstr "设备 @var{dev} 上的文件"

#. type: item
#: zsh.texi:7423
#, no-wrap
msgid "@t{l}[@t{-}|@t{+}]@var{ct}"
msgstr "@t{l}[@t{-}|@t{+}]@var{ct}"

#. type: table
#: zsh.texi:7426
msgid "files having a link count less than @var{ct} (@t{-}), greater than @var{ct} (@t{+}), or equal to @var{ct}"
msgstr "链接数小于 @var{ct} (@t{-})、大于 @var{ct} (@t{+}) 或等于 @var{ct} 的文件"

#. type: table
#: zsh.texi:7429
msgid "files owned by the effective user ID"
msgstr "有效用户 ID 拥有的文件"

#. type: t{#1}
#: zsh.texi:7430
#, no-wrap
msgid "G"
msgstr "G"

#. type: table
#: zsh.texi:7432
msgid "files owned by the effective group ID"
msgstr "有效组 ID 拥有的文件"

#. type: item
#: zsh.texi:7433
#, no-wrap
msgid "@t{u}@var{id}"
msgstr "@t{u}@var{id}"

#. type: table
#: zsh.texi:7443
msgid ""
"files owned by user ID @var{id} if that is a number.  Otherwise, @var{id} specifies a user name: the character after the `@t{u}' will be taken as a separator and the string between it and the next "
"matching separator will be taken as a user name.  The starting separators `@t{[}', `@t{@{}', and `@t{<}' match the final separators `@t{]}', `@t{@}}', and `@t{>}', respectively; any other character "
"matches itself.  The selected files are those owned by this user.  For example, `@t{u:foo:}' or `@t{u[foo]}' selects files owned by user `@t{foo}'."
msgstr ""
"用户 ID 为 @var{id} 的所拥有的文件。 否则，@var{id} 将指定用户名：`@t{u}' 后面的字符将作为分隔符，它与下一个匹配分隔符之间的字符串将作为用户名。 起始分隔符 `@t{[}', `@t{@{}' 和 `@t{<}' 分别与最终分隔符 "
"`@t{]}', `@t{@}}' 和 `@t{>}'匹配；任何其他字符都与自身匹配。 所选文件为该用户拥有的文件。 例如，`@t{u:foo:}' 或 `@t{u[foo]}' 选择用户 `@t{foo}' 所拥有的文件。"

#. type: item
#: zsh.texi:7444
#, no-wrap
msgid "@t{g}@var{id}"
msgstr "@t{g}@var{id}"

#. type: table
#: zsh.texi:7446
msgid "like @t{u}@var{id} but with group IDs or names"
msgstr "类似 @t{u}@var{id} ，但使用组 ID 或名称"

#. type: item
#: zsh.texi:7447
#, no-wrap
msgid "@t{a}[@t{Mwhms}][@t{-}|@t{+}]@var{n}"
msgstr "@t{a}[@t{Mwhms}][@t{-}|@t{+}]@var{n}"

#. type: table
#: zsh.texi:7456
msgid ""
"files accessed exactly @var{n} days ago.  Files accessed within the last @var{n} days are selected using a negative value for @var{n} (@t{-}@var{n}).  Files accessed more than @var{n} days ago are "
"selected by a positive @var{n} value (@t{+}@var{n}).  Optional unit specifiers `@t{M}', `@t{w}', `@t{h}', `@t{m}' or `@t{s}' (e.g. `@t{ah5}') cause the check to be performed with months (of 30 days), "
"weeks, hours, minutes or seconds instead of days, respectively.  An explicit `@t{d}' for days is also allowed."
msgstr ""
"（精确的）@var{n} 天前访问过的文件。使用 @var{n} 的负值（@t{-}@var{n}）选择最近 @var{n} 天内访问的文件。超过 @var{n} 天前访问的文件则使用 @var{n} 的正值（@t{+}@var{n}）来选择。可选的单位指定符 `@t{M}', "
"`@t{w}', `@t{h}', `@t{m}' 或 `@t{s}' （例如 `@t{ah5}' ）会分别导致以月（30 天）、周、小时、分钟或秒来代替天进行检查。也可以使用显式的 `@t{d}' 来表示天数。"

#. type: table
#: zsh.texi:7464
msgid ""
"Any fractional part of the difference between the access time and the current part in the appropriate units is ignored in the comparison.  For instance, `@t{echo *(ah-5)}' would echo files accessed within "
"the last five hours, while `@t{echo *(ah+5)}' would echo files accessed at least six hours ago, as times strictly between five and six hours are treated as five hours."
msgstr ""
"在比较过程中，访问时间与当前时间之间的任何小数部分将被忽略。 例如， `@t{echo *(ah-5)}' 将回显最近 5 小时内访问的文件，而 `@t{echo *(ah+5)}' 将回显至少 6 小时前访问的文件，因为严格介于 5 至 6 小时之间的时间"
"被视为 5 小时。"

#. type: item
#: zsh.texi:7465
#, no-wrap
msgid "@t{m}[@t{Mwhms}][@t{-}|@t{+}]@var{n}"
msgstr "@t{m}[@t{Mwhms}][@t{-}|@t{+}]@var{n}"

#. type: table
#: zsh.texi:7468
msgid "like the file access qualifier, except that it uses the file modification time."
msgstr "和文件访问限定符一样，只不过它使用的是文件修改时间。"

#. type: item
#: zsh.texi:7469
#, no-wrap
msgid "@t{c}[@t{Mwhms}][@t{-}|@t{+}]@var{n}"
msgstr "@t{c}[@t{Mwhms}][@t{-}|@t{+}]@var{n}"

#. type: table
#: zsh.texi:7472
msgid "like the file access qualifier, except that it uses the file inode change time."
msgstr "和文件访问限定符一样，只不过它使用的是文件的 inode 更改时间。"

#. type: item
#: zsh.texi:7473
#, no-wrap
msgid "@t{L}[@t{+}|@t{-}]@var{n}"
msgstr "@t{L}[@t{+}|@t{-}]@var{n}"

#. type: table
#: zsh.texi:7476
msgid "files less than @var{n} bytes (@t{-}), more than @var{n} bytes (@t{+}), or exactly @var{n} bytes in length."
msgstr "长度小于 @var{n} 字节（@t{-}）、大于 @var{n} 字节（@t{+}）或正好 @var{n} 字节的文件。"

#. type: table
#: zsh.texi:7489
msgid ""
"If this flag is directly followed by a @emph{size specifier} `@t{k}' (`@t{K}'), `@t{m}' (`@t{M}'), or `@t{p}' (`@t{P}') (e.g. `@t{Lk-50}') the check is performed with kilobytes, megabytes, or blocks (of "
"512 bytes) instead.  (On some systems additional specifiers are available for gigabytes, `@t{g}' or `@t{G}', and terabytes, `@t{t}' or `@t{T}'.) If a size specifier is used a file is regarded as "
"\"exactly\" the size if the file size rounded up to the next unit is equal to the test size.  Hence `@t{*(Lm1)}' matches files from 1 byte up to 1 Megabyte inclusive.  Note also that the set of files "
"\"less than\" the test size only includes files that would not match the equality test; hence `@t{*(Lm-1)}' only matches files of zero size."
msgstr ""
"如果该标志后直接跟了 @emph{size 指定符} `@t{k}' (`@t{K}'), `@t{m}' (`@t{M}') 或 `@t{p}' (`@t{P}')（例如`@t{Lk-50}'），则检查将以千字节、兆字节或块（512 字节）为单位进行。 (在某些系统中，还可以使用额外的千"
"兆字节（ `@t{g}' 或 `@t{G}' ）和百万兆字节（ `@t{t}' 或 `@t{T}' ）说明符）。如果使用了文件大小指定符，那么四舍五入到下一单位的文件大小等于测试大小时，文件就被视为大小 \"准确 \"。 因此，`@t{*(Lm1)}' 可以匹"
"配从 1 字节到 1 兆字节（含 1 兆字节）的文件。 还要注意的是，\"小于 \"测试大小的文件集只包括不符合相等测试的文件；因此， `@t{*(Lm-1)}' 只匹配大小为零的文件。"

#. type: table
#: zsh.texi:7492
msgid "negates all qualifiers following it"
msgstr "否定后面的所有限定符"

#. type: table
#: zsh.texi:7498
msgid ""
"toggles between making the qualifiers work on symbolic links (the default) and the files they point to, if any; any symbolic link for whose target the `@t{stat}' system call fails (whatever the cause of "
"the failure) is treated as a file in its own right"
msgstr "在使限定符作用于符号链接（默认）和符号链接指向的文件之间切换，如果有的话；如果 `@t{stat}'  系统调用的目标符号链接失败（无论失败原因如何），该符号链接本身将被视为文件"

#. type: table
#: zsh.texi:7501
msgid "sets the @t{MARK_DIRS} option for the current pattern"
msgstr "为当前模式设置 @t{MARK_DIRS} 选项"

#. type: pindex
#: zsh.texi:7501
#, no-wrap
msgid "MARK_DIRS, setting in pattern"
msgstr "MARK_DIRS, 在模式中设置"

#. type: table
#: zsh.texi:7506
msgid "appends a trailing qualifier mark to the filenames, analogous to the @t{LIST_TYPES} option, for the current pattern (overrides @t{M})"
msgstr "为文件名添加尾部限定符标记，类似于当前模式的 @t{LIST_TYPES} 选项（覆盖 @t{M}"

#. type: table
#: zsh.texi:7509
msgid "sets the @t{NULL_GLOB} option for the current pattern"
msgstr "为当前模式设置 @t{NULL_GLOB} 选项"

#. type: pindex
#: zsh.texi:7509
#, no-wrap
msgid "NULL_GLOB, setting in pattern"
msgstr "NULL_GLOB, 在模式中设置"

#. type: table
#: zsh.texi:7513
msgid "sets the @t{GLOB_DOTS} option for the current pattern"
msgstr "设置当前模式的 @t{GLOB_DOTS} 选项"

#. type: pindex
#: zsh.texi:7513
#, no-wrap
msgid "GLOB_DOTS, setting in pattern"
msgstr "GLOB_DOTS, 在模式中设置"

#. type: table
#: zsh.texi:7517
msgid "sets the @t{NUMERIC_GLOB_SORT} option for the current pattern"
msgstr "为当前模式设置 @t{NUMERIC_GLOB_SORT} 选项"

#. type: pindex
#: zsh.texi:7517
#, no-wrap
msgid "NUMERIC_GLOB_SORT, setting in pattern"
msgstr "NUMERIC_GLOB_SORT, 在模式中设置"

#. type: item
#: zsh.texi:7519
#, no-wrap
msgid "@t{Y}@var{n}"
msgstr "@t{Y}@var{n}"

#. type: table
#: zsh.texi:7523
msgid "enables short-circuit mode: the pattern will expand to at most @var{n} filenames.  If more than @var{n} matches exist, only the first @var{n} matches in directory traversal order will be considered."
msgstr "启用短路模式：模式最多会扩展到 @var{n} 个文件名。 如果存在多于 @var{n} 个匹配项，则只考虑目录遍历顺序中的前 @var{n} 个匹配项。"

#. type: table
#: zsh.texi:7526
msgid "Implies @t{oN} when no @t{o}@var{c} qualifier is used."
msgstr "在未使用 @t{o}@var{c} 限定符时，意味着 @t{oN}。"

#. type: item
#: zsh.texi:7527
#, no-wrap
msgid "@t{o}@var{c}"
msgstr "@t{o}@var{c}"

#. type: table
#: zsh.texi:7530
msgid "specifies how the names of the files should be sorted. The following values of @var{c} sort in the following ways:"
msgstr "指定文件名的排序方式。@var{c} 的下列值按以下方式排序："

#. type: table
#: zsh.texi:7535
msgid "By name."
msgstr "按名称。"

#. type: table
#: zsh.texi:7537
msgid "By the size (length) of the files."
msgstr "按文件的大小（长度）。"

#. type: table
#: zsh.texi:7539
msgid "By number of links."
msgstr "按链接数量。"

#. type: table
#: zsh.texi:7541
msgid "By time of last access, youngest first."
msgstr "按最后一次访问时间排列，最年轻者优先。"

#. type: table
#: zsh.texi:7543
msgid "By time of last modification, youngest first."
msgstr "按最后一次修改时间排序，最年轻的先修改。"

#. type: table
#: zsh.texi:7545
msgid "By time of last inode change, youngest first."
msgstr "按最后一次改变 inode 的时间排列，最年轻的在前。"

#. type: table
#: zsh.texi:7550
msgid ""
"By directories: files in subdirectories appear before those in the current directory at each level of the search --- this is best combined with other criteria, for example `@t{odon}' to sort on names for "
"files within the same directory."
msgstr "按目录：在每一级搜索中，子目录下的文件都会出现在当前目录下的文件之前--这最好与其他条件结合起来，例如，`@t{odon}' 可以对同一目录下的文件名进行排序。"

#. type: table
#: zsh.texi:7552
msgid "No sorting is performed."
msgstr "不执行排序。"

#. type: table
#: zsh.texi:7555
msgid "Sort by shell code (see below)."
msgstr "按 shell 代码排序（见下文）。"

#. type: table
#: zsh.texi:7562
msgid ""
"Note that the modifiers @t{^} and @t{-} are used, so `@t{*(^-oL)}' gives a list of all files sorted by file size in descending order, following any symbolic links.  Unless @t{oN} is used, multiple order "
"specifiers may occur to resolve ties."
msgstr "请注意，由于使用了修饰符 @t{^} 和 @t{-}，因此 `@t{*(^-oL)}' 给出的是一个按文件大小降序排序的所有文件的列表，任何符号链接都在其后。 除非使用 @t{oN}，否则可以用多个顺序指定符来解决并列问题。"

#. type: table
#: zsh.texi:7566
msgid "The default sorting is @t{n} (by name) unless the @t{Y} glob qualifier is used, in which case it is @t{N} (unsorted)."
msgstr "默认排序为 @t{n}（按名称），除非使用了 @t{Y} glob 限定符，在这种情况下，排序为 @t{N}（未排序）。"

#. type: table
#: zsh.texi:7578
msgid ""
"@t{oe} and @t{o+} are special cases; they are each followed by shell code, delimited as for the @t{e} glob qualifier and the @t{+} glob qualifier respectively (see above).  The code is executed for each "
"matched file with the parameter @t{REPLY} set to the name of the file on entry and @t{globsort} appended to @t{zsh_eval_context}.  The code should modify the parameter @t{REPLY} in some fashion.  On "
"return, the value of the parameter is used instead of the file name as the string on which to sort.  Unlike other sort operators, @t{oe} and @t{o+} may be repeated, but note that the maximum number of "
"sort operators of any kind that may appear in any glob expression is 12."
msgstr ""
"@t{oe} 和 @t{o+} 是特殊情况；它们后面都有 shell 代码，分别以 @t{e} glob 限定符和 @t{+} glob 限定符分隔（见上文）。 每执行一个匹配文件的代码，都会将参数 @t{REPLY} 设置为输入文件的名称，并将 @t{globsort} 追"
"加到 @t{zsh_eval_context} 中。 代码应以某种方式修改参数 @t{REPLY}。 返回时，将使用参数值而不是文件名作为排序字符串。 与其他排序运算符不同，@t{oe} 和 @t{o+} 可以重复使用，但请注意，在任何 glob 表达式中出现"
"的任何类型的排序运算符的最大数量都是 12。"

#. type: item
#: zsh.texi:7579
#, no-wrap
msgid "@t{O}@var{c}"
msgstr "@t{O}@var{c}"

#. type: table
#: zsh.texi:7584
msgid ""
"like `@t{o}', but sorts in descending order; i.e. `@t{*(^o}@var{c}@t{)}' is the same as `@t{*(O}@var{c}@t{)}' and `@t{*(^O}@var{c}@t{)}' is the same as `@t{*(o}@var{c}@t{)}'; `@t{Od}' puts files in the "
"current directory before those in subdirectories at each level of the search."
msgstr ""
"和 `@t{o}' 一样，但按降序排序；即 `@t{*(^o}@var{c}@t{)}' 与 `@t{*(O}@var{c}@t{)}' 相同，而 `@t{*(^O}@var{c}@t{)}' 与 `@t{*(o}@var{c}@t{)}' 相同；`@t{Od}' 将当前目录下的文件排在每一级搜索的子目录下的文件之"
"前。"

#. type: item
#: zsh.texi:7585
#, no-wrap
msgid "@t{[}@var{beg}[@t{,}@var{end}]@t{]}"
msgstr "@t{[}@var{beg}[@t{,}@var{end}]@t{]}"

#. type: table
#: zsh.texi:7592
msgid ""
"specifies which of the matched filenames should be included in the returned list. The syntax is the same as for array subscripts. @var{beg} and the optional @var{end} may be mathematical expressions. As "
"in parameter subscripting they may be negative to make them count from the last match backward. E.g.: `@t{*(-OL[1,3])}' gives a list of the names of the three largest files."
msgstr ""
"指定哪些匹配的文件名应包含在返回的列表中。语法与数组下标相同。@var{beg} 和可选的 @var{end} 可以是数学表达式。与参数下标一样，它们可以是负数，以便从最后一次匹配开始反向计数。例如 `@t{*(-OL[1,3])}' 给出了三"
"个最大文件的名称列表。"

#. type: item
#: zsh.texi:7593
#, no-wrap
msgid "@t{P}@var{string}"
msgstr "@t{P}@var{string}"

#. type: table
#: zsh.texi:7600
msgid ""
"The @var{string} will be prepended to each glob match as a separate word.  @var{string} is delimited in the same way as arguments to the @t{e} glob qualifier described above.  The qualifier can be "
"repeated; the words are prepended separately so that the resulting command line contains the words in the same order they were given in the list of glob qualifiers."
msgstr ""
"@var{string} 将作为一个单独的单词被添加到每个 glob 匹配结果中。 @var{string} 的分隔方式与上述 glob 限定符 @t{e} 的参数相同。 限定符可以重复使用；单词会被分别放在前面，因此命令行中的单词顺序与 glob 限定符列"
"表中的顺序相同。"

#. type: table
#: zsh.texi:7605
msgid ""
"A typical use for this is to prepend an option before all occurrences of a file name; for example, the pattern `@t{*(P:-f:)}' produces the command line arguments `@t{-f} @var{file1} @t{-f} @var{file2} ...'"
msgstr "典型的用法是在所有出现的文件名前加上一个选项；例如，模式 `@t{*(P:-f:)}' 会产生命令行参数 `@t{-f} @var{file1} @t{-f} @var{file2} ...'"

#. type: table
#: zsh.texi:7612
msgid ""
"If the modifier @t{^} is active, then @var{string} will be appended instead of prepended.  Prepending and appending is done independently so both can be used on the same glob expression; for example by "
"writing `@t{*(P:foo:^P:bar:^P:baz:)}' which produces the command line arguments `@t{foo} @t{baz} @var{file1} @t{bar} ...'"
msgstr ""
"如果修改器 @t{^} 已激活，那么 @var{string} 将被追加而非前置。 前置和追加是独立进行的，因此可以在同一个 glob 表达式中同时使用这两种方式；例如，编写 `@t{*(P:foo:^P:bar:^P:baz:)}' 会产生命令行参数 `@t{foo} "
"@t{baz} @var{file1} @t{bar} ...'"

#. type: Plain text
#: zsh.texi:7623
msgid ""
"More than one of these lists can be combined, separated by commas. The whole list matches if at least one of the sublists matches (they are `or'ed, the qualifiers in the sublists are `and'ed).  Some "
"qualifiers, however, affect all matches generated, independent of the sublist in which they are given.  These are the qualifiers `@t{M}', `@t{T}', `@t{N}', `@t{D}', `@t{n}', `@t{o}', `@t{O}' and the "
"subscripts given in brackets (`@t{[}@var{...}@t{]}')."
msgstr ""
"可以合并多个列表，并用逗号分隔。如果至少有一个子列表匹配，则整个列表匹配（它们是 \"或 \"关系，子列表中的限定符是 \"和 \"关系的）。 不过，有些限定符会影响生成的所有匹配结果，与在哪个子列表中给出限定符无"
"关。 这些限定符包括 `@t{M}', `@t{T}', `@t{N}', `@t{D}', `@t{n}', `@t{o}', `@t{O}' 和括号（brackets）中的下标（`@t{[}@var{...}@t{]}'）。"

#. type: Plain text
#: zsh.texi:7635
msgid ""
"If a `@t{:}' appears in a qualifier list, the remainder of the expression in parenthesis is interpreted as a modifier (see @ref{Modifiers} in @ref{History Expansion}).  Each modifier must be introduced by "
"a separate `@t{:}'.  Note also that the result after modification does not have to be an existing file.  The name of any existing file can be followed by a modifier of the form `@t{(:}@var{...}@t{)}' even "
"if no actual filename generation is performed, although note that the presence of the parentheses causes the entire expression to be subjected to any global pattern matching options such as @t{NULL_GLOB}. "
"Thus:"
msgstr ""
"如果限定符列表中出现 `@t{:}' ，括号中表达式的其余部分将被解释为修饰符（参见 @ref{历史扩展} 中的 @ref{修饰符}）。 每个修饰符必须用单独的 `@t{:}' 引入。 还要注意的是，修改后的结果不一定是现有文件。 即使没有"
"实际执行文件名生成，也可以在任何现有文件名后面加上形式为  `@t{(:}@var{...}@t{)}' 的修饰符，但要注意的是，括号的存在会导致整个表达式受全局模式匹配选项（如 @t{NULL_GLOB}）的影响。因此"

#. type: example
#: zsh.texi:7639
#, no-wrap
msgid "ls -ld -- *(-/)\n"
msgstr "ls -ld -- *(-/)\n"

#. type: Plain text
#: zsh.texi:7644
msgid "lists all directories and symbolic links that point to directories, and"
msgstr "会列出所有目录和指向目录的符号链接，而"

#. type: example
#: zsh.texi:7648
#, no-wrap
msgid "ls -ld -- *(-@@)\n"
msgstr "ls -ld -- *(-@@)\n"

#. type: Plain text
#: zsh.texi:7652
msgid "lists all broken symbolic links, and"
msgstr "会列出所有断开的符号链接，而"

#. type: example
#: zsh.texi:7656
#, no-wrap
msgid "ls -ld -- *(%W)\n"
msgstr "ls -ld -- *(%W)\n"

#. type: Plain text
#: zsh.texi:7660
msgid "lists all world-writable device files in the current directory, and"
msgstr "会列出当前目录下所有世界可写设备文件，而"

#. type: example
#: zsh.texi:7664
#, no-wrap
msgid "ls -ld -- *(W,X)\n"
msgstr "ls -ld -- *(W,X)\n"

#. type: Plain text
#: zsh.texi:7669
msgid "lists all files in the current directory that are world-writable or world-executable, and"
msgstr "会列出当前目录下所有世界可写或世界可执行的文件，而"

#. type: example
#: zsh.texi:7673
#, no-wrap
msgid "print -rC1 /tmp/foo*(u0^@@:t)\n"
msgstr "print -rC1 /tmp/foo*(u0^@@:t)\n"

#. type: Plain text
#: zsh.texi:7678
msgid "outputs the basename of all root-owned files beginning with the string `@t{foo}' in @t{/tmp}, ignoring symlinks, and"
msgstr "输出 @t{/tmp} 中以字符串 `@t{foo}' 开头的 root 所有的文件的基名，忽略符号链接，以及"

#. type: example
#: zsh.texi:7682
#, no-wrap
msgid "ls -ld -- *.*~(lex|parse).[ch](^D^l1)\n"
msgstr "ls -ld -- *.*~(lex|parse).[ch](^D^l1)\n"

#. type: Plain text
#: zsh.texi:7688
msgid ""
"lists all files having a link count of one whose names contain a dot (but not those starting with a dot, since @t{GLOB_DOTS} is explicitly switched off) except for @t{lex.c}, @t{lex.h}, @t{parse.c} and "
"@t{parse.h}."
msgstr "会列出所有链接数为 1 且名称包含点的文件（但不包括以点开头的文件，因为 @t{GLOB_DOTS} 已明确关闭），但 @t{lex.c}、@t{lex.h}、@t{parse.c} 和 @t{parse.h} 除外。"

#. type: example
#: zsh.texi:7692
#, no-wrap
msgid "print -rC1 b*.pro(#q:s/pro/shmo/)(#q.:s/builtin/shmiltin/)\n"
msgstr "print -rC1 b*.pro(#q:s/pro/shmo/)(#q.:s/builtin/shmiltin/)\n"

#. type: Plain text
#: zsh.texi:7702
msgid ""
"demonstrates how colon modifiers and other qualifiers may be chained together.  The ordinary qualifier `@t{.}' is applied first, then the colon modifiers in order from left to right.  So if "
"@t{EXTENDED_GLOB} is set and the base pattern matches the regular file @t{builtin.pro}, the shell will print `@t{shmiltin.shmo}'."
msgstr ""
"演示了如何将冒号修饰符和其他限定符串联起来。 首先应用普通限定符  `@t{.}'，然后按从左到右的顺序应用冒号修饰符。 因此，如果设置了 @t{EXTENDED_GLOB}，且基本模式与常规文件 @t{builtin.pro} 匹配，shell 将打印 "
"`@t{shmiltin.shmo}'。"

#. type: t{#1}
#: zsh.texi:7706 zsh.texi:21672 zsh.texi:29724 zsh.texi:29725
#, no-wrap
msgid "parameters"
msgstr "参数"

#. type: t{#1}
#: zsh.texi:7707 zsh.texi:35806
#, no-wrap
msgid "variables"
msgstr "变量"

#. type: section
#: zsh.texi:7709 zsh.texi:16087 zsh.texi:19229 zsh.texi:20554 zsh.texi:26837 zsh.texi:27609 zsh.texi:32616 zsh.texi:33728 zsh.texi:34697 zsh.texi:35460
#, no-wrap
msgid "Description"
msgstr "说明"

#. type: Plain text
#: zsh.texi:7717
msgid ""
"A parameter has a name, a value, and a number of attributes.  A name may be any sequence of alphanumeric characters and underscores, or the single characters `@t{*}', `@t{@@}', `@t{#}', `@t{?}', `@t{-}', "
"`@t{$}', or `@t{!}'.  A parameter whose name begins with an alphanumeric or underscore is also referred to as a @emph{variable}."
msgstr ""
"参数有一个名称、一个值和若干属性。 名称可以是字母数字字符和下划线的任意序列，也可以是单字符`@t{*}', `@t{@@}', `@t{#}', `@t{?}', `@t{-}', `@t{$}' 或 `@t{!}'。 名称以字母数字或下划线开头的参数也称为 @emph{变"
"量}。"

#. type: cindex
#: zsh.texi:7719
#, no-wrap
msgid "scalar"
msgstr "标量"

#. type: cindex
#: zsh.texi:7720
#, no-wrap
msgid "parameters, scalar"
msgstr "参数, 标量"

#. type: cindex
#: zsh.texi:7721
#, no-wrap
msgid "parameters, array"
msgstr "参数, 数组"

#. type: cindex
#: zsh.texi:7722
#, no-wrap
msgid "parameters, associative array"
msgstr "参数, 关联数组"

#. type: findex
#: zsh.texi:7723 zsh.texi:13891
#, no-wrap
msgid "hash"
msgstr "散列(hash)"

#. type: Plain text
#: zsh.texi:7731
msgid ""
"The attributes of a parameter determine the @emph{type} of its value, often referred to as the parameter type or variable type, and also control other processing that may be applied to the value when it "
"is referenced.  The value type may be a @emph{scalar} (a string, an integer, or a floating point number), an array (indexed numerically), or an @emph{associative} array (an unordered set of name-value "
"pairs, indexed by name, also referred to as a @emph{hash})."
msgstr ""
"参数的属性决定了其值的 @emph{类型}（通常称为参数类型或变量类型），并控制着在引用该值时可能对其进行的其他处理。 值类型可以是 @emph{标量}（字符串、整数或浮点数）、数组（按数字索引）或 @emph{关联}数组（按名称"
"索引的键值对的无序集合，也称为 @emph{哈希}）。"

#. type: cindex
#: zsh.texi:7734
#, no-wrap
msgid "environment"
msgstr "环境"

#. type: cindex
#: zsh.texi:7735
#, no-wrap
msgid "environment variables"
msgstr "环境变量"

#. type: cindex
#: zsh.texi:7736
#, no-wrap
msgid "variables, environment"
msgstr "变量, 环境"

#. type: Plain text
#: zsh.texi:7745
msgid ""
"Named scalar parameters may have the @emph{exported}, @t{-x}, attribute, to copy them into the process environment, which is then passed from the shell to any new processes that it starts.  Exported "
"parameters are called @emph{environment variables}. The shell also @emph{imports} environment variables at startup time and automatically marks the corresponding parameters as exported.  Some environment "
"variables are not imported for reasons of security or because they would interfere with the correct operation of other shell features."
msgstr ""
"已命名的标量参数可以使用 @emph{exported}、@t{-x} 属性，将其复制到进程环境中，然后由 shell 传递给启动的任何新进程。 导出参数被称为 @emph{环境变量}。shell 还会在启动时 @emph{导入} 环境变量，并自动将相应参数"
"标记为导出参数。 出于安全考虑，或由于某些环境变量会干扰其他 shell 功能的正确运行，这样的变量不会导入。"

#. type: cindex
#: zsh.texi:7747
#, no-wrap
msgid "special parameters"
msgstr "特殊参数"

#. type: cindex
#: zsh.texi:7748 zsh.texi:29607 zsh.texi:31860
#, no-wrap
msgid "parameters, special"
msgstr "参数, 特殊"

#. type: Plain text
#: zsh.texi:7753
msgid ""
"Parameters may also be @emph{special}, that is, they have a predetermined meaning to the shell.  Special parameters cannot have their type changed or their readonly attribute turned off, and if a special "
"parameter is unset, then later recreated, the special properties will be retained."
msgstr "参数也可以是 @emph{特殊的}，即它们对 shell 有预定义意义。 特殊参数的类型不能更改，其只读属性也不能关闭，如果一个特殊参数被取消设置，随后又重新创建，其特殊属性将被保留。"

#. type: Plain text
#: zsh.texi:7757
msgid "To declare the type of a parameter, or to assign a string or numeric value to a scalar parameter, use the @t{typeset} builtin."
msgstr "要声明参数的类型，或为标量参数赋于字符串或数值，请使用 @t{typeset} 内置命令。"

#. type: findex
#: zsh.texi:7757 zsh.texi:7902
#, no-wrap
msgid "typeset, use of"
msgstr "typeset, use of"

#. type: Plain text
#: zsh.texi:7761
msgid "The value of a scalar parameter may also be assigned by writing:"
msgstr "标量参数的值也可以通过下面写法来分配："

#. type: quotation
#: zsh.texi:7765
msgid "@var{name}@t{=}@var{value}"
msgstr "@var{name}@t{=}@var{value}"

#. type: Plain text
#: zsh.texi:7771
msgid "In scalar assignment, @var{value} is expanded as a single string, in which the elements of arrays are joined together; filename expansion is not performed unless the option @t{GLOB_ASSIGN} is set."
msgstr "在标量赋值中，@var{value} 会展开为单个字符串，其中数组元素被连接在一起；除非设置了选项 @t{GLOB_ASSIGN}，否则不会执行文件名展开。"

#. type: Plain text
#: zsh.texi:7779
msgid ""
"When the integer attribute, @t{-i}, or a floating point attribute, @t{-E} or @t{-F}, is set for @var{name}, the @var{value} is subject to arithmetic evaluation.  Furthermore, by replacing `@t{=}' with "
"`@t{+=}', a parameter can be incremented or appended to.  See @ref{Array Parameters} and @ref{Arithmetic Evaluation} for additional forms of assignment."
msgstr ""
"为 @var{name} 设置整数属性 @t{-i} 或浮点属性 @t{-E} 或 @t{-F} 时，@var{value} 将进行算术求值。 此外，将 `@t{=}' 替换为 `@t{+=}'，还可以递增或追加参数。 有关赋值的其他形式，请参阅 @ref{数组参数} 和 @ref{算"
"术求值}。"

#. type: Plain text
#: zsh.texi:7785
msgid ""
"Note that assignment may implicitly change the attributes of a parameter.  For example, assigning a number to a variable in arithmetic evaluation may change its type to integer or float, and with "
"@t{GLOB_ASSIGN} assigning a pattern to a variable may change its type to an array."
msgstr "请注意，赋值可能会隐含地改变参数的属性。 例如，在算术运算中为变量赋一个数值可能会将其类型改为整型或浮型，而用 @t{GLOB_ASSIGN}选项， 为变量赋值一个模式，可能会将其类型改为数组。"

#. type: Plain text
#: zsh.texi:7793
msgid ""
"To reference the value of a parameter, write `@t{$}@var{name}' or `@t{$@{}@var{name}@t{@}}'.  See @ref{Parameter Expansion} for complete details.  That section also explains the effect of the difference "
"between scalar and array assignment on parameter expansion."
msgstr "要引用一个参数的值，请写成 `@t{$}@var{name}' 或 `@t{$@{}@var{name}@t{@}}'。 详情请参见 @ref{参数扩展}。 该章节还解释了标量赋值和数组赋值之间的差异对参数扩展的影响。"

#. type: node
#: zsh.texi:7800 zsh.texi:7802 zsh.texi:8391
#, no-wrap
msgid "Array Parameters"
msgstr "数组参数"

#. type: node
#: zsh.texi:7800 zsh.texi:8391 zsh.texi:8393 zsh.texi:8423
#, no-wrap
msgid "Positional Parameters"
msgstr "位置参数"

#. type: Plain text
#: zsh.texi:7805
msgid "To assign an array value, write one of:"
msgstr "要为数组赋值，请写入以下其中一个："

#. type: findex
#: zsh.texi:7805
#, no-wrap
msgid "set, use of"
msgstr "set, use of"

#. type: cindex
#: zsh.texi:7806
#, no-wrap
msgid "array assignment"
msgstr "数组赋值"

#. type: quotation
#: zsh.texi:7810
msgid "@t{set -A} @var{name} @var{value} ..."
msgstr "@t{set -A} @var{name} @var{value} ..."

#. type: quotation
#: zsh.texi:7813
msgid "@var{name}@t{=(}@var{value} ...@t{)}"
msgstr "@var{name}@t{=(}@var{value} ...@t{)}"

#. type: quotation
#: zsh.texi:7816 zsh.texi:7927
msgid "@var{name}@t{=(}@t{[}@var{key}@t{]=}@var{value} ...@t{)}"
msgstr "@var{name}@t{=(}@t{[}@var{key}@t{]=}@var{value} ...@t{)}"

#. type: Plain text
#: zsh.texi:7822
msgid "If no parameter @var{name} exists, an ordinary array parameter is created.  If the parameter @var{name} exists and is a scalar, it is replaced by a new array."
msgstr "如果不存在参数 @var{name}，则会创建一个普通数组参数。 如果参数 @var{name} 存在且是标量，则会被一个新数组取代。"

#. type: Plain text
#: zsh.texi:7835
msgid ""
"In the third form, @var{key} is an expression that will be evaluated in arithmetic context (in its simplest form, an integer) that gives the index of the element to be assigned with @var{value}.  In this "
"form any elements not explicitly mentioned that come before the largest index to which a value is assigned are assigned an empty string.  The indices may be in any order.  Note that this syntax is strict: "
"@t{[} and @t{]=} must not be quoted, and @var{key} may not consist of the unquoted string @t{]=}, but is otherwise treated as a simple string.  The enhanced forms of subscript expression that may be used "
"when directly subscripting a variable name, described in the section `Array Subscripts' below, are not available."
msgstr ""
"在第三种形式中，@var{key} 是一个将在算术上下文中求值的表达式（最简单的形式是一个整数），它给出了赋值为 @var{value} 的元素的索引。 在这种形式中，在赋值的最大索引之前的任何未明确提及的元素都将被赋值为空字符"
"串。 索引可以是任意顺序。 请注意，这种语法是严格的： @t{[} 和 @t{]=} 不得加引号，并且 @var{key} 不得包含未加引号的字符串 @t{]=}，否则视为简单字符串。 下面 `数组下标 ' 一节中描述的下标表达式增强形式在直接下"
"标变量名时不可用。"

#. type: Plain text
#: zsh.texi:7841
msgid ""
"The syntaxes with and without the explicit key may be mixed.  An implicit @var{key} is deduced by incrementing the index from the previously assigned element.  Note that it is not treated as an error if "
"latter assignments in this form overwrite earlier assignments."
msgstr "有显式键和无显式键的语法可以混合使用。 隐式 @var{key} 是通过递增先前赋值元素的索引来推导的。 请注意，如果后面的赋值覆盖了前面的赋值，不会被视为错误。"

#. type: Plain text
#: zsh.texi:7844
msgid "For example, assuming the option @t{KSH_ARRAYS} is not set, the following:"
msgstr "例如，假设未设置选项 @t{KSH_ARRAYS}，则会出现以下情况："

#. type: example
#: zsh.texi:7848
#, no-wrap
msgid "array=(one [3]=three four)\n"
msgstr "array=(one [3]=three four)\n"

#. type: Plain text
#: zsh.texi:7853
msgid "causes the array variable @t{array} to contain four elements @t{one}, an empty string, @t{three} and @t{four}, in that order."
msgstr "会使数组变量 @t{array} 依次包含四个元素 @t{one}、空字符串、@t{three} 和 @t{four}。"

#. type: Plain text
#: zsh.texi:7857
msgid "In the forms where only @var{value} is specified, full command line expansion is performed."
msgstr "在只指定 @var{value} 的形式中，将执行完整的命令行扩展。"

#. type: Plain text
#: zsh.texi:7872
msgid ""
"In the @t{[}@var{key}@t{]=}@var{value} form, both @var{key} and @var{value} undergo all forms of expansion allowed for single word shell expansions (this does not include filename generation); these are "
"as performed by the parameter expansion flag @t{(e)} as described in @ref{Parameter Expansion}.  Nested parentheses may surround @var{value} and are included as part of the value, which is joined into a "
"plain string; this differs from ksh which allows the values themselves to be arrays.  A future version of zsh may support that.  To cause the brackets to be interpreted as a character class for filename "
"generation, and therefore to treat the resulting list of files as a set of values, quote the equal sign using any form of quoting.  Example:"
msgstr ""
"在 @t{[}@var{key}@t{]=}@var{value} 形式中，@var{key}和@var{value}都会经历单字 shell 扩展所允许的所有扩展形式（不包括文件名生成）；这些扩展由参数扩展标志 @t{(e)} 执行，如 @ref{参数扩展} 中所述。 @var{value}"
"周围可能会有嵌套的小括号，这些小括号将作为值的一部分包含在内，并被连接成一个纯字符串；这与允许值本身为数组的 ksh 不同。 未来版本的 zsh 可能会支持这一点。 要将括号解释为文件名生成的字符类，并因此将生成的文"
"件列表视为一组值，请使用任何形式的引号为等号加引号。 例如"

#. type: quotation
#: zsh.texi:7875
msgid "@var{name}@t{=(}@t{[a-z]'='*)}"
msgstr "@var{name}@t{=(}@t{[a-z]'='*)}"

#. type: Plain text
#: zsh.texi:7880
msgid "To append to an array without changing the existing values, use one of the following:"
msgstr "要在不改变现有值的情况下追加到数组，请使用以下方法之一："

#. type: quotation
#: zsh.texi:7883
msgid "@var{name}@t{+=(}@var{value} ...@t{)}"
msgstr "@var{name}@t{+=(}@var{value} ...@t{)}"

#. type: quotation
#: zsh.texi:7886 zsh.texi:7944
msgid "@var{name}@t{+=(}@t{[}@var{key}@t{]=}@var{value} ...@t{)}"
msgstr "@var{name}@t{+=(}@t{[}@var{key}@t{]=}@var{value} ...@t{)}"

#. type: Plain text
#: zsh.texi:7893
msgid ""
"In the second form @var{key} may specify an existing index as well as an index off the end of the old array; any existing value is overwritten by @var{value}.  Also, it is possible to use @t{[}@var{key}"
"@t{]+=}@var{value} to append to the existing value at that index."
msgstr ""
"在第二种形式中，@var{key} 可以指定一个现有的索引，也可以指定旧数组末尾（之后 off the end of）的索引；任何现有值都会被 @var{value} 覆盖。 此外，还可以使用 @t{[}@var{key}@t{]+=}@var{value} 追加到该索引处的现"
"有值。"

#. type: Plain text
#: zsh.texi:7899
msgid ""
"Within the parentheses on the right hand side of either form of the assignment, newlines and semicolons are treated the same as white space, separating individual @var{value}s.  Any consecutive sequence "
"of such characters has the same effect."
msgstr "在任何一种赋值形式右侧的括号内，换行符和分号都与空白一样，用于分隔各个 @var{value}s。 任何连续的此类字符序列都具有相同的效果。"

#. type: Plain text
#: zsh.texi:7902
msgid "Ordinary array parameters may also be explicitly declared with:"
msgstr "普通数组参数也可以明确声明用："

#. type: quotation
#: zsh.texi:7906
msgid "@t{typeset -a} @var{name}"
msgstr "@t{typeset -a} @var{name}"

#. type: Plain text
#: zsh.texi:7910
msgid "Associative arrays @emph{must} be declared before assignment, by using:"
msgstr "@emph{必须}在赋值前声明关联数组 ，方法是使用："

#. type: quotation
#: zsh.texi:7913
msgid "@t{typeset -A} @var{name}"
msgstr "@t{typeset -A} @var{name}"

#. type: Plain text
#: zsh.texi:7918
msgid "When @var{name} refers to an associative array, the list in an assignment is interpreted as alternating keys and values:"
msgstr "当 @var{name} 指向关联数组时，赋值中的列表被解释为交替的键和值："

#. type: quotation
#: zsh.texi:7921
msgid "@t{set -A} @var{name} @var{key} @var{value} ..."
msgstr "@t{set -A} @var{name} @var{key} @var{value} ..."

#. type: quotation
#: zsh.texi:7924
msgid "@var{name}@t{=(}@var{key} @var{value} ...@t{)}"
msgstr "@var{name}@t{=(}@var{key} @var{value} ...@t{)}"

#. type: Plain text
#: zsh.texi:7933
msgid "Note that only one of the two syntaxes above may be used in any given assignment; the forms may not be mixed.  This is unlike the case of numerically indexed arrays."
msgstr "请注意，在任何给定的赋值中，只能使用上述两种语法中的一种；这两种形式不能混合使用。 这与数字索引数组的情况不同。"

#. type: Plain text
#: zsh.texi:7938
msgid ""
"Every @var{key} must have a @var{value} in this case.  Note that this assigns to the entire array, deleting any elements that do not appear in the list.  The append syntax may also be used with an "
"associative array:"
msgstr "在这种情况下，每个 @var{key} 都必须有一个 @var{value}。 需要注意的是，这样做会对整个数组赋值，删除列表中没有出现的元素。追加语法也可用于关联数组："

#. type: quotation
#: zsh.texi:7941
msgid "@var{name}@t{+=(}@var{key} @var{value} ...@t{)}"
msgstr "@var{name}@t{+=(}@var{key} @var{value} ...@t{)}"

#. type: Plain text
#: zsh.texi:7953
msgid ""
"This adds a new key/value pair if the key is not already present, and replaces the value for the existing key if it is.  In the second form it is also possible to use @t{[}@var{key}@t{]+=}@var{value} to "
"append to the existing value at that key.  Expansion is performed identically to the corresponding forms for normal arrays, as described above."
msgstr "如果键还不存在，则添加新的键/值对，如果存在，则替换现有键的值。 在第二种形式中，也可以使用  @t{[}@var{key}@t{]+=}@var{value} 来追加到该键的现有值。 如上所述，扩展的执行方式与普通数组的相应形式相同。"

#. type: Plain text
#: zsh.texi:7956
msgid "To create an empty array (including associative arrays), use one of:"
msgstr "要创建一个空数组（包括关联数组），请使用以下命令之一："

#. type: quotation
#: zsh.texi:7959
msgid "@t{set -A} @var{name}"
msgstr "@t{set -A} @var{name}"

#. type: quotation
#: zsh.texi:7962
msgid "@var{name}@t{=()}"
msgstr "@var{name}@t{=()}"

#. type: subsection
#: zsh.texi:7966
#, no-wrap
msgid "Array Subscripts"
msgstr "数组下标"

#. type: cindex
#: zsh.texi:7968
#, no-wrap
msgid "subscripts"
msgstr "下标"

#. type: Plain text
#: zsh.texi:7976
msgid ""
"Individual elements of an array may be selected using a subscript.  A subscript of the form `@t{[}@var{exp}@t{]}' selects the single element @var{exp}, where @var{exp} is an arithmetic expression which "
"will be subject to arithmetic expansion as if it were surrounded by `@t{$((}...@t{))}'.  The elements are numbered beginning with 1, unless the @t{KSH_ARRAYS} option is set in which case they are numbered "
"from zero."
msgstr ""
"使用下标可以选择数组中的单个元素。 形式为 `@t{[}@var{exp}@t{]}' 的下标将选择单个元素 @var{exp}，其中 @var{exp} 是一个算术表达式，它将被算术展开，就像它被 `@t{$((}...@t{))}' 包围一样。 元素的编号从 1 开始，"
"除非设置了 @t{KSH_ARRAYS} 选项，在这种情况下，元素的编号从 0 开始。"

#. type: pindex
#: zsh.texi:7976 zsh.texi:14592
#, no-wrap
msgid "KSH_ARRAYS, use of"
msgstr "KSH_ARRAYS, use of"

#. type: Plain text
#: zsh.texi:7983
msgid ""
"Subscripts may be used inside braces used to delimit a parameter name, thus `@t{$@{foo[2]@}}' is equivalent to `@t{$foo[2]}'.  If the @t{KSH_ARRAYS} option is set, the braced form is the only one that "
"works, as bracketed expressions otherwise are not treated as subscripts."
msgstr "下标可以用在大括号内，用于限定参数名，因此 `@t{$@{foo[2]@}}' 等同于 `@t{$foo[2]}'。 如果设置了 @t{KSH_ARRAYS} 选项，则括号形式是唯一有效的形式，否则括号内的表达式不会被视为下标。"

#. type: Plain text
#: zsh.texi:7991
msgid ""
"If the @t{KSH_ARRAYS} option is not set, then by default accesses to an array element with a subscript that evaluates to zero return an empty string, while an attempt to write such an element is treated "
"as an error.  For backward compatibility the @t{KSH_ZERO_SUBSCRIPT} option can be set to cause subscript values 0 and 1 to be equivalent; see the description of the option in @ref{Description of Options}."
msgstr ""
"如果没有设置 @t{KSH_ARRAYS} 选项，那么默认情况下，访问下标值为 0 的数组元素时，会返回空字符串，而尝试写入这样的元素则会被视为错误。 为了向后兼容，可以设置 @t{KSH_ZERO_SUBSCRIPT} 选项，使下标值 0 和 1 等"
"价；参见 @ref{选项说明} 中的选项描述。"

#. type: Plain text
#: zsh.texi:7998
msgid ""
"The same subscripting syntax is used for associative arrays, except that no arithmetic expansion is applied to @var{exp}.  However, the parsing rules for arithmetic expressions still apply, which affects "
"the way that certain special characters must be protected from interpretation.  See @emph{Subscript Parsing} below for details."
msgstr "除了 @var{exp} 不进行算术扩展外，关联数组使用了相同的下标语法。然而，算术表达式的解析规则仍然适用，这影响了某些特殊字符必须受到保护以免被解释的方式。 详见下面的 @emph{下标解析}。"

#. type: Plain text
#: zsh.texi:8015
msgid ""
"A subscript of the form `@t{[*]}' or `@t{[@@]}' evaluates to all elements of an array; there is no difference between the two except when they appear within double quotes.  `@t{\"$foo[*]\"}' evaluates to "
"`@t{\"$foo[1] $foo[2] }...@t{\"}', whereas `@t{\"$foo[@@]\"}' evaluates to `@t{\"$foo[1]\" \"$foo[2]\" }...'.  For associative arrays, `@t{[*]}' or `@t{[@@]}' evaluate to all the values, in no particular "
"order.  Note that this does not substitute the keys; see the documentation for the `@t{k}' flag under @ref{Parameter Expansion} for complete details.  When an array parameter is referenced as `@t{$}"
"@var{name}' (with no subscript) it evaluates to `@t{$}@var{name}@t{[*]}', unless the @t{KSH_ARRAYS} option is set in which case it evaluates to `@t{$@{}@var{name}@t{[0]@}}' (for an associative array, this "
"means the value of the key `@t{0}', which may not exist even if there are values for other keys)."
msgstr ""
"形式为 `@t{[*]}' 或 `@t{[@@]}' 的下标计算为数组的所有元素；除了出现在双引号内时，两者没有区别。  `@t{\"$foo[*]\"}' 的运算结果为 `@t{\"$foo[1] $foo[2] }...@t{\"}' ，而 `@t{\"$foo[@@]\"}' 的运算结果为 "
"`@t{\"$foo[1]\" \"$foo[2]\" }...'。  对于关联数组， `@t{[*]}' 或 `@t{[@@]}' 计算为所有值，没有特定顺序。 请注意，这并不能替代键值；详情请参见 @ref{参数} 下的 `@t{k}' 标志文档。 当一个数组参数被引用为`@t{$}"
"@var{name}'（不带下标）时，其值将被计算为 `@t{$}@var{name}@t{[*]}'、 除非设置了 @t{KSH_ARRAYS}选项，在这种情况下，它的值为 `@t{$@{}@var{name}@t{[0]@}}' （对于关联数组，这意味着键`@t{0}' 的值，这可能不存"
"在，，即使其他键的值存在）。"

#. type: Plain text
#: zsh.texi:8025
msgid ""
"A subscript of the form `@t{[}@var{exp1}@t{,}@var{exp2}@t{]}' selects all elements in the range @var{exp1} to @var{exp2}, inclusive. (Associative arrays are unordered, and so do not support ranges.) If "
"one of the subscripts evaluates to a negative number, say @t{-}@var{n}, then the @var{n}th element from the end of the array is used.  Thus `@t{$foo[-3]}' is the third element from the end of the array "
"@t{foo}, and `@t{$foo[1,-1]}' is the same as `@t{$foo[*]}'."
msgstr ""
"形式为 `@t{[}@var{exp1}@t{,}@var{exp2}@t{]}' 的下标会选择 @var{exp1} 至 @var{exp2} 范围内的所有元素，包括 @var{exp1} 和 @var{exp2} 。(关联数组是无序的，因此不支持范围。）如果其中一个下标求值为负数，例如 "
"@t{-}@var{n}，则使用数组末尾的第 @var{n} 个元素。 因此， `@t{$foo[-3]}' 是数组 @t{foo} 末尾的第三个元素，而 `@t{$foo[1,-1]}' 与 `@t{$foo[*]}' 相同。"

#. type: Plain text
#: zsh.texi:8035
msgid ""
"Subscripting may also be performed on non-array values, in which case the subscripts specify a substring to be extracted.  For example, if @t{FOO} is set to `@t{foobar}', then `@t{echo $FOO[2,5]}' prints "
"`@t{ooba}'.  Note that some forms of subscripting described below perform pattern matching, and in that case the substring extends from the start of the match of the first subscript to the end of the "
"match of the second subscript.  For example,"
msgstr ""
"下标运算也可以用于非数组值，此时下标指定了要提取的子字符串。例如，如果@t{FOO}被设置为 `@t{foobar}' ，那么 `@t{echo $FOO[2,5]}' 将输出 `@t{ooba}'。请注意，下面描述的某些形式的下标运算执行模式匹配，在这种情"
"况下，子字符串从第一个下标的匹配开始，一直延伸到第二个下标的匹配结束。例如，"

#. type: example
#: zsh.texi:8040
#, no-wrap
msgid ""
"string=\"abcdefghijklm\"\n"
"print $@{string[(r)d?,(r)h?]@}\n"
msgstr ""
"string=\"abcdefghijklm\"\n"
"print $@{string[(r)d?,(r)h?]@}\n"

#. type: Plain text
#: zsh.texi:8047
msgid ""
"prints `@t{defghi}'.  This is an obvious generalisation of the rule for single-character matches.  For a single subscript, only a single character is referenced (not the range of characters covered by the "
"match)."
msgstr "会打印 `@t{defghi}'。 这显然是对单字符匹配规则的概括。 对于单个下标，只引用单个字符（而不是匹配所覆盖的字符范围）。"

#. type: Plain text
#: zsh.texi:8056
msgid ""
"Note that in substring operations the second subscript is handled differently by the @t{r} and @t{R} subscript flags: the former takes the shortest match as the length and the latter the longest match.  "
"Hence in the former case a @t{*} at the end is redundant while in the latter case it matches the whole remainder of the string.  This does not affect the result of the single subscript case as here the "
"length of the match is irrelevant."
msgstr ""
"请注意，在子串操作中，@t{r} 和 @t{R} 下标标志对第二个下标有不同的处理方式：前者以最短的匹配值作为长度，后者以最长的匹配值作为长度。 因此，在前一种情况下，末尾的 @t{*} 是多余的，而在后一种情况下，它匹配字符"
"串的整个剩余部分。 这不会影响单个下标情况下的结果，因为这里匹配的长度无关紧要。"

#. type: subsection
#: zsh.texi:8059
#, no-wrap
msgid "Array Element Assignment"
msgstr "数组元素赋值"

#. type: Plain text
#: zsh.texi:8064
msgid "A subscript may be used on the left side of an assignment like so:"
msgstr "在赋值的左侧可以使用下标，如下所示："

#. type: quotation
#: zsh.texi:8067
msgid "@var{name}@t{[}@var{exp}@t{]=}@var{value}"
msgstr "@var{name}@t{[}@var{exp}@t{]=}@var{value}"

#. type: Plain text
#: zsh.texi:8077
msgid ""
"In this form of assignment the element or range specified by @var{exp} is replaced by the expression on the right side.  An array (but not an associative array) may be created by assignment to a range or "
"element.  Arrays do not nest, so assigning a parenthesized list of values to an element or range changes the number of elements in the array, shifting the other elements to accommodate the new values.  "
"(This is not supported for associative arrays.)"
msgstr ""
"在这种赋值形式中，@var{exp} 指定的元素或范围会被右侧的表达式替换。 数组（但不是关联数组）可以通过对元素或范围赋值来创建。 数组不会嵌套，因此给元素或范围赋值一列括号中的值会改变数组中元素的数量，并移动其他"
"元素以容纳新值。 (关联数组不支持这种方式）。"

#. type: Plain text
#: zsh.texi:8080
msgid "This syntax also works as an argument to the @t{typeset} command:"
msgstr "该语法也可作为 @t{typeset} 命令的参数："

#. type: quotation
#: zsh.texi:8083
msgid "@t{typeset} @t{\"}@var{name}@t{[}@var{exp}@t{]\"=}@var{value}"
msgstr "@t{typeset} @t{\"}@var{name}@t{[}@var{exp}@t{]\"=}@var{value}"

#. type: Plain text
#: zsh.texi:8091
msgid ""
"The @var{value} may @emph{not} be a parenthesized list in this case; only single-element assignments may be made with @t{typeset}.  Note that quotes are necessary in this case to prevent the brackets from "
"being interpreted as filename generation operators.  The @t{noglob} precommand modifier could be used instead."
msgstr ""
"在这种情况下，@var{value} 可以 @emph{不}是一个带括号的列表；只能使用 @t{typeset} 进行单元素赋值。 请注意，在这种情况下必须使用引号，以防止括号被解释为文件名生成操作符。 可以使用 @t{noglob} 前置命令修饰符代"
"替。"

#. type: Plain text
#: zsh.texi:8096
msgid "To delete an element of an ordinary array, assign `@t{()}' to that element.  To delete an element of an associative array, use the @t{unset} command:"
msgstr "要删除普通数组中的一个元素，请为该元素赋值 `@t{()}' 。 要删除关联数组的元素，请使用 @t{unset} 命令："

#. type: quotation
#: zsh.texi:8099
msgid "@t{unset} @t{\"}@var{name}@t{[}@var{exp}@t{]\"}"
msgstr "@t{unset} @t{\"}@var{name}@t{[}@var{exp}@t{]\"}"

#. type: subsection
#: zsh.texi:8103
#, no-wrap
msgid "Subscript Flags"
msgstr "下标标志"

#. type: cindex
#: zsh.texi:8105
#, no-wrap
msgid "subscript flags"
msgstr "下标标志"

#. type: Plain text
#: zsh.texi:8110
msgid ""
"If the opening bracket, or the comma in a range, in any subscript expression is directly followed by an opening parenthesis, the string up to the matching closing one is considered to be a list of flags, "
"as in `@var{name}@t{[(}@var{flags}@t{)}@var{exp}@t{]}'."
msgstr ""
"如果在任何下标表达式中，开头括号（bracket)或范围中的逗号，后直接跟了一个开头小括号(parenthesis)，则直到匹配的结尾括号的字符串将被视为一个标志列表，如在 `@var{name}@t{[(}@var{flags}@t{)}@var{exp}@t{]}' 中。"

#. type: Plain text
#: zsh.texi:8119
msgid ""
"The flags @t{s}, @t{n} and @t{b} take an argument; the delimiter is shown below as `@t{:}', but any character, or the matching pairs `@t{(}...@t{)}', `@t{@{}...@t{@}}', `@t{[}...@t{]}', or `@t{<}..."
"@t{>}', may be used, but note that `@t{<}...@t{>}' can only be used if the subscript is inside a double quoted expression or a parameter substitution enclosed in braces as otherwise the expression is "
"interpreted as a redirection."
msgstr ""
"标志 @t{s}、@t{n} 和 @t{b} 都有一个参数；分隔符如下所示： `@t{:}'，但可以使用任何字符或匹配对 `@t{(}...@t{)}', `@t{@{}...@t{@}}', `@t{[}...@t{]}' 或 `@t{<}...@t{>}'。 但要注意的是， `@t{<}...@t{>}' 只能在"
"下标位于双引号表达式或括号内的参数替换中时使用，否则表达式将被解释为重定向。"

#. type: Plain text
#: zsh.texi:8122
msgid "The flags currently understood are:"
msgstr "目前可理解的标志有:"

#. type: table
#: zsh.texi:8132
msgid ""
"If the parameter subscripted is a scalar then this flag makes subscripting work on words instead of characters.  The default word separator is whitespace.  When combined with the @t{i} or @t{I} flag, the "
"effect is to produce the index of the first character of the first/last word which matches the given pattern; note that a failed match in this case always yields 0."
msgstr ""
"如果下标的参数是标量，则该标志会使下标作用于单词而不是字符。 默认的单词分隔符是空白。 当与 @t{i} 或 @t{I} 标志结合使用时，效果是生成与给定模式匹配的第一个/最后一个单词的第一个字符的索引；请注意，在这种情况"
"下，匹配失败的结果总是 0。"

#. type: table
#: zsh.texi:8136
msgid "This gives the @var{string} that separates words (for use with the @t{w} flag).  The delimiter character @t{:} is arbitrary; see above."
msgstr "这给出了分隔单词的 @var{string}（与 @t{w} 标志一起使用）。 分隔符 @t{:} 是任意的，见上文。"

#. type: table
#: zsh.texi:8140
msgid "Recognize the same escape sequences as the @t{print} builtin in the string argument of a subsequent `@t{s}' flag."
msgstr "在随后的 `@t{s}' 标志的字符串参数中，识别与 @t{print} 内置命令相同的转义序列。"

#. type: table
#: zsh.texi:8145
msgid "If the parameter subscripted is a scalar then this flag makes subscripting work on lines instead of characters, i.e. with elements separated by newlines.  This is a shorthand for `@t{pws:\\n:}'."
msgstr "如果下标的参数是一个标量，那么该标志会使下标作用在行上，而不是字符上，也就是用换行符分隔元素。这是 `@t{pws:\\n:}' 的简写。"

#. type: table
#: zsh.texi:8156
msgid ""
"Reverse subscripting: if this flag is given, the @var{exp} is taken as a pattern and the result is the first matching array element, substring or word (if the parameter is an array, if it is a scalar, or "
"if it is a scalar and the `@t{w}' flag is given, respectively).  The subscript used is the number of the matching element, so that pairs of subscripts such as `@t{$foo[(r)??,3]}' and `@t{$foo[(r)??,"
"(r)f*]}' are possible if the parameter is not an associative array.  If the parameter is an associative array, only the value part of each pair is compared to the pattern, and the result is that value."
msgstr ""
"反向（reverse)下标：如果给出此标记，@var{exp} 将作为模式，结果是第一个匹配的数组元素、子串或单词（如果参数是数组，如果参数是标量，或者如果参数是标量且给出了 `@t{w}' 标志）。使用的下标是匹配元素的编号，因"
"此，如果参数不是关联数组，则可以使用成对的下标，如 `@t{$foo[(r)??,3]}'  和 `@t{$foo[(r)??,(r)f*]}' 。 如果参数是关联数组，则只将每一对的值部分与模式进行比较，结果就是该值。"

#. type: table
#: zsh.texi:8163
msgid ""
"If a search through an ordinary array failed, the search sets the subscript to one past the end of the array, and hence @t{$@{array[(r)}@var{pattern}@t{]@}} will substitute the empty string.  Thus the "
"success of a search can be tested by using the @t{(i)} flag, for example (assuming the option @t{KSH_ARRAYS} is not in effect):"
msgstr ""
"如果对普通数组的搜索失败，搜索会将下标设置为数组末尾之后的一个，因此 @t{$@{array[(r)}@var{pattern}@t{]@}} 将替换为空字符串。因此，可以使用 @t{(i)} 标志来测试搜索是否成功，例如（假设选项 @t{KSH_ARRAYS} 未生"
"效）："

#. type: example
#: zsh.texi:8167
#, no-wrap
msgid "[[ $@{array[(i)pattern]@} -le $@{#array@} ]]\n"
msgstr "[[ $@{array[(i)pattern]@} -le $@{#array@} ]]\n"

#. type: table
#: zsh.texi:8171
msgid "If @t{KSH_ARRAYS} is in effect, the @t{-le} should be replaced by @t{-lt}."
msgstr "如果 @t{KSH_ARRAYS} 有效，则 @t{-le} 应替换为 @t{-lt}。"

#. type: table
#: zsh.texi:8179
msgid ""
"Like `@t{r}', but gives the last match.  For associative arrays, gives all possible matches. May be used for assigning to ordinary array elements, but not for assigning to associative arrays.  On failure, "
"for normal arrays this has the effect of returning the element corresponding to subscript 0; this is empty unless one of the options @t{KSH_ARRAYS} or @t{KSH_ZERO_SUBSCRIPT} is in effect."
msgstr ""
"类似于 `@t{r}'，但给出最后一个匹配项。对于关联数组，会给出所有可能的匹配结果。可用于普通数组元素的赋值，但不能用于关联数组的赋值。 对于普通数组，赋值失败后会返回下标 0 对应的元素；除非使用b  "
"@t{KSH_ARRAYS} 或 @t{KSH_ZERO_SUBSCRIPT} 选项之一，否则返回的元素为空。"

#. type: table
#: zsh.texi:8187
msgid ""
"Note that in subscripts with both `@t{r}' and `@t{R}' pattern characters are active even if they were substituted for a parameter (regardless of the setting of @t{GLOB_SUBST} which controls this feature "
"in normal pattern matching).  The flag `@t{e}' can be added to inhibit pattern matching.  As this flag does not inhibit other forms of substitution, care is still required; using a parameter to hold the "
"key has the desired effect:"
msgstr ""
"需要注意的是，在同时包含 `@t{r}'  和 `@t{R}' 的下标中，模式字符即使被替换为参数，也是有效的（与在正常模式匹配中控制该功能的 @t{GLOB_SUBST} 的设置无关）。可以添加标志 `@t{e}' 来抑制模式匹配。 由于该标志并不"
"抑制其他形式的替换，因此仍需小心谨慎；使用参数来保持关键字（key）可以达到预期效果："

#. type: example
#: zsh.texi:8192
#, no-wrap
msgid ""
"key2='original key'\n"
"print $@{array[(Re)$key2]@}\n"
msgstr ""
"key2='original key'\n"
"print $@{array[(Re)$key2]@}\n"

#. type: table
#: zsh.texi:8202
msgid ""
"Like `@t{r}', but gives the index of the match instead; this may not be combined with a second argument.  On the left side of an assignment, behaves like `@t{r}'.  For associative arrays, the key part of "
"each pair is compared to the pattern, and the first matching key found is the result.  On failure substitutes the length of the array plus one, as discussed under the description of `@t{r}', or the empty "
"string for an associative array."
msgstr ""
"类似于 `@t{r}'，但给出的是匹配的索引；不能与第二个参数一起使用。 在赋值的左侧，行为类似于 `@t{r}'。 对于关联数组，每个键值对的键部分都会与模式进行比较，找到的第一个匹配键就是结果。 如果失败，则用数组的长度"
"加一代替，这在`@t{r}'的描述中已经讨论过，如果是关联数组，则是空字符串。"

#. type: table
#: zsh.texi:8208
msgid ""
"Note: Although `@t{i}' may be applied to a scalar substitution to find the offset of a substring, the results are likely to be misleading when searching within substitutions that yield an empty string, or "
"when searching for the empty substring."
msgstr "注意：虽然 `@t{i}' 可以应用于标量替换，以查找子串的偏移量，但当在产生空字符串的替换中查找，或查找空子串时，结果很可能会产生误导。"

#. type: table
#: zsh.texi:8214
msgid ""
"Like `@t{i}', but gives the index of the last match, or all possible matching keys in an associative array.  On failure substitutes 0, or the empty string for an associative array.  This flag is best when "
"testing for values or keys that do not exist."
msgstr "与 `@t{i}' 类似，但会给出最后一个匹配项的索引，或关联数组中所有可能匹配的键。 如果失败，则替换为 0 或对于关联数组是空字符串。 在测试不存在的值或键时，最好使用该标志。"

#. type: table
#: zsh.texi:8219
msgid "Note: If the option @t{KSH_ARRAYS} is in effect and no match is found, the result is indistinguishable from the case when the first element of the array matches."
msgstr "注意：如果选项 @t{KSH_ARRAYS} 有效，但未找到匹配，则结果与数组中第一个元素匹配的情况无异。"

#. type: table
#: zsh.texi:8227
msgid ""
"If used in a subscript on an associative array, this flag causes the keys to be interpreted as patterns, and returns the value for the first key found where @var{exp} is matched by the key.  Note this "
"could be any such key as no ordering of associative arrays is defined.  This flag does not work on the left side of an assignment to an associative array element.  If used on another type of parameter, "
"this behaves like `@t{r}'."
msgstr ""
"如果在关联数组的下标中使用该标志，则键会被解释为模式，并返回键与 @var{exp} 匹配的第一个键的值。 请注意，这可能是任何键，因为关联数组没有定义排序。 该标志不适用于关联数组元素赋值的左侧。 如果使用在其他类型"
"的参数上，则行为类似于 `@t{r}'。"

#. type: t{#1}
#: zsh.texi:8228
#, no-wrap
msgid "K"
msgstr "K"

#. type: table
#: zsh.texi:8232
msgid "On an associative array this is like `@t{k}' but returns all values where @var{exp} is matched by the keys.  On other types of parameters this has the same effect as `@t{R}'."
msgstr "在关联数组中，这与 `@t{k}' 类似，但会返回 @var{exp} 与键匹配的所有值。 对于其他类型的参数，作用与 `@t{R}' 相同。"

#. type: item
#: zsh.texi:8233
#, no-wrap
msgid "@t{n:}@var{expr}@t{:}"
msgstr "@t{n:}@var{expr}@t{:}"

#. type: table
#: zsh.texi:8238
msgid ""
"If combined with `@t{r}', `@t{R}', `@t{i}' or `@t{I}', makes them give the @var{n}th or @var{n}th last match (if @var{expr} evaluates to @var{n}).  This flag is ignored when the array is associative.  The "
"delimiter character @t{:} is arbitrary; see above."
msgstr ""
"如果与 `@t{r}', `@t{R}', `@t{i}' 或 `@t{I}' 结合使用，则会给出第 @var{n} 个或后数第 @var{n} 个匹配（如果 @var{expr} 值为 @var{n}）。 当数组是关联数组时，该标志将被忽略。 分隔符 @t{:} 是任意的；见上文。"

#. type: item
#: zsh.texi:8239
#, no-wrap
msgid "@t{b:}@var{expr}@t{:}"
msgstr "@t{b:}@var{expr}@t{:}"

#. type: table
#: zsh.texi:8244
msgid ""
"If combined with `@t{r}', `@t{R}', `@t{i}' or `@t{I}', makes them begin at the @var{n}th or @var{n}th last element, word, or character (if @var{expr} evaluates to @var{n}).  This flag is ignored when the "
"array is associative.  The delimiter character @t{:} is arbitrary; see above."
msgstr ""
"如果与 `@t{r}', `@t{R}', `@t{i}' 或 `@t{I}' 结合使用，会使它们从第 @var{n} 个或后数第 @var{n} 个元素、单词或字符（如果 @var{expr} 值为 @var{n}）开始。 如果数组是关联数组，该标志将被忽略。 分隔符 @t{:} 是任"
"意的；见上文。"

#. type: table
#: zsh.texi:8251
msgid ""
"This flag causes any pattern matching that would be performed on the subscript to use plain string matching instead.  Hence `@t{$@{array[(re)*]@}}' matches only the array element whose value is @t{*}.  "
"Note that other forms of substitution such as parameter substitution are not inhibited."
msgstr "该标志会使任何对下标执行的模式匹配改用纯字符串匹配。 因此， `@t{$@{array[(re)*]@}}' 只匹配值为 @t{*} 的数组元素。 请注意，其他形式的替换（如参数替换）并不受限制。"

#. type: table
#: zsh.texi:8256
msgid "This flag can also be used to force @t{*} or @t{@@} to be interpreted as a single key rather than as a reference to all values.  It may be used for either purpose on the left side of an assignment."
msgstr "该标记还可用于强制将 @t{*} 或 @t{@@} 解释为单键，而不是对所有值的引用。 在赋值的左侧，它可以用于这两种目的。"

#. type: Plain text
#: zsh.texi:8261
msgid "See @emph{Parameter Expansion Flags} (@ref{Parameter Expansion}) for additional ways to manipulate the results of array subscripting."
msgstr "请参阅 @emph{参数扩展标志} (@ref{参数扩展})，了解操作数组下标结果的其他方法。"

#. type: subsection
#: zsh.texi:8264
#, no-wrap
msgid "Subscript Parsing"
msgstr "下标解析"

#. type: Plain text
#: zsh.texi:8272
msgid ""
"This discussion applies mainly to associative array key strings and to patterns used for reverse subscripting (the `@t{r}', `@t{R}', `@t{i}', etc. flags), but it may also affect parameter substitutions "
"that appear as part of an arithmetic expression in an ordinary subscript."
msgstr "本讨论主要适用于关联数组键字符串和用于反转下标的模式（ `@t{r}', `@t{R}', `@t{i}' 等标志），但也可能影响作为算术表达式的一部分出现在普通下标中的参数替换。"

#. type: Plain text
#: zsh.texi:8276
msgid "To avoid subscript parsing limitations in assignments to associative array elements, use the append syntax:"
msgstr "在对关联数组元素赋值时，为避免下标解析的限制，可使用追加语法："

#. type: example
#: zsh.texi:8280
#, no-wrap
msgid "aa+=('key with \"*strange*\" characters' 'value string')\n"
msgstr "aa+=('key with \"*strange*\" characters' 'value string')\n"

#. type: Plain text
#: zsh.texi:8289
msgid ""
"The basic rule to remember when writing a subscript expression is that all text between the opening `@t{[}' and the closing `@t{]}' is interpreted @emph{as if} it were in double quotes (@ref{Quoting}).  "
"However, unlike double quotes which normally cannot nest, subscript expressions may appear inside double-quoted strings or inside other subscript expressions (or both!), so the rules have two important "
"differences."
msgstr ""
"编写下标表达式时要记住的基本规则是，开头的 `@t{[}' 和结尾的 `@t{]}' 之间的所有文本都被@emph{解释为}双引号引用（@ref{引用}）。 不过，与通常不能嵌套的双引号不同，下标表达式可能出现在双引号引用字符串内部，也"
"可能出现在其他下标表达式内部（或两者兼而有之！），因此这些规则有两个重要区别。"

#. type: Plain text
#: zsh.texi:8301
msgid ""
"The first difference is that brackets (`@t{[}' and `@t{]}') must appear as balanced pairs in a subscript expression unless they are preceded by a backslash (`@t{\\}').  Therefore, within a subscript "
"expression (and unlike true double-quoting) the sequence `@t{\\[}' becomes `@t{[}', and similarly `@t{\\]}' becomes `@t{]}'.  This applies even in cases where a backslash is not normally required; for "
"example, the pattern `@t{[^[]}' (to match any character other than an open bracket) should be written `@t{[^\\[]}' in a reverse-subscript pattern.  However, note that `@t{\\[^\\[\\]}' and even "
"`@t{\\[^[]}' mean the @emph{same} thing, because backslashes are always stripped when they appear before brackets!"
msgstr ""
"第一个区别是，括号（`@t{[}' 和 `@t{]}'）必须作为平衡对出现在下标表达式中，除非它们前面有反斜线（`@t{\\}'）。 因此，在下标表达式中（与真正的双引号不同）， `@t{\\[}' 序列变为 `@t{[}'，同样， `@t{\\]}' 变为 "
"`@t{]}' 。 这甚至适用于通常不需要反斜线的情况；例如，模式 `@t{[^[]}'（匹配开放括号以外的任何字符）在反向下标模式中应写成` @t{[^\\[]}' 。 不过，请注意， `@t{\\[^\\[\\]}' 甚至 `@t{\\[^[]}' 都是 @emph{一样} "
"的意思，因为反斜线出现在括号前时总是会被去掉！"

#. type: Plain text
#: zsh.texi:8309
msgid ""
"The same rule applies to parentheses (`@t{(}' and `@t{)}') and braces (`@t{@{}' and `@t{@}}'): they must appear either in balanced pairs or preceded by a backslash, and backslashes that protect "
"parentheses or braces are removed during parsing.  This is because parameter expansions may be surrounded by balanced braces, and subscript flags are introduced by balanced parentheses."
msgstr ""
"同样的规则也适用于小括号（`@t{(}' 和 `@t{)}'）和大括号（`@t{@{}' 和 `@t{@}}'）：它们必须以平衡对形式出现，或在前面加上反斜线，在解析过程中，保护小括号或大括号的反斜线会被删除。 这是因为参数扩展可以用平衡大"
"括号包围，而下标标志则由平衡小括号引入。"

#. type: Plain text
#: zsh.texi:8321
msgid ""
"The second difference is that a double-quote (`@t{\"}') may appear as part of a subscript expression without being preceded by a backslash, and therefore that the two characters `@t{\\\"}' remain as two "
"characters in the subscript (in true double-quoting, `@t{\\\"}' becomes `@t{\"}').  However, because of the standard shell quoting rules, any double-quotes that appear must occur in balanced pairs unless "
"preceded by a backslash.  This makes it more difficult to write a subscript expression that contains an odd number of double-quote characters, but the reason for this difference is so that when a "
"subscript expression appears inside true double-quotes, one can still write `@t{\\\"}' (rather than `@t{\\\\\\\"}') for `@t{\"}'."
msgstr ""
"第二个区别是，双引号 (`@t{\"}')可以作为下标表达式的一部分出现，而不需要在前面加上反斜线，因此 `@t{\\\"}' 这两个字符仍然是下标中的两个字符（在真正的双引号中，`@t{\\\"}' 变成了`@t{\"}'）。 然而，由于标准的 "
"shell 引用规则，任何出现的双引号都必须成对出现，除非前面有反斜线。 这就增加了编写包含奇数双引号字符的下标表达式的难度，但之所以存在这种差异，是因为当下标表达式出现在真正的双引号内时，我们仍然可以把 `@t{\\"
"\"}' 写成 `@t{\\\"}'（而不是 `@t{\\\\\\\"}' ）。"

#. type: Plain text
#: zsh.texi:8326
msgid "To use an odd number of double quotes as a key in an assignment, use the @t{typeset} builtin and an enclosing pair of double quotes; to refer to the value of that key, again use double quotes:"
msgstr "要在赋值中使用奇数双引号作为键，请使用 @t{typeset} 内置命令和一对双引号；要引用该键的值，同样使用双引号："

#. type: example
#: zsh.texi:8332
#, no-wrap
msgid ""
"typeset -A aa\n"
"typeset \"aa[one\\\"two\\\"three\\\"quotes]\"=QQQ\n"
"print \"$aa[one\\\"two\\\"three\\\"quotes]\"\n"
msgstr ""
"typeset -A aa\n"
"typeset \"aa[one\\\"two\\\"three\\\"quotes]\"=QQQ\n"
"print \"$aa[one\\\"two\\\"three\\\"quotes]\"\n"

#. type: Plain text
#: zsh.texi:8342
msgid ""
"It is important to note that the quoting rules do not change when a parameter expansion with a subscript is nested inside another subscript expression.  That is, it is not necessary to use additional "
"backslashes within the inner subscript expression; they are removed only once, from the innermost subscript outwards.  Parameters are also expanded from the innermost subscript first, as each expansion is "
"encountered left to right in the outer expression."
msgstr ""
"值得注意的是，当带有下标的参数扩展嵌套在另一个下标表达式中时，引用规则不会改变。 也就是说，不需要在内部下标表达式中使用额外的反斜线；只需从最内层下标向外删除一次反斜线。 参数也是先从最内层的下标开始展开，"
"因为在外层表达式中，每次展开都是从左向右进行的。"

#. type: Plain text
#: zsh.texi:8349
msgid ""
"A further complication arises from a way in which subscript parsing is @emph{not} different from double quote parsing.  As in true double-quoting, the sequences `@t{\\*}', and `@t{\\@@}' remain as two "
"characters when they appear in a subscript expression.  To use a literal `@t{*}' or `@t{@@}' as an associative array key, the `@t{e}' flag must be used:"
msgstr ""
"下标解析与双引号解析@emph{并没有不同} （not different），这就造成了进一步的复杂性。 与真正的双引号一样， `@t{\\*}' 和`@t{\\@@}' 序列在下标表达式中出现时仍是两个字符。 要使用字面的  `@t{*}' 或 `@t{@@}' 作为"
"关联数组的键，必须使用 `@t{e}' 标志："

#. type: example
#: zsh.texi:8355
#, no-wrap
msgid ""
"typeset -A aa\n"
"aa[(e)*]=star\n"
"print $aa[(e)*]\n"
msgstr ""
"typeset -A aa\n"
"aa[(e)*]=star\n"
"print $aa[(e)*]\n"

#. type: Plain text
#: zsh.texi:8372
msgid ""
"A last detail must be considered when reverse subscripting is performed.  Parameters appearing in the subscript expression are first expanded and then the complete expression is interpreted as a pattern.  "
"This has two effects: first, parameters behave as if @t{GLOB_SUBST} were on (and it cannot be turned off); second, backslashes are interpreted twice, once when parsing the array subscript and again when "
"parsing the pattern.  In a reverse subscript, it's necessary to use @emph{four} backslashes to cause a single backslash to match literally in the pattern.  For complex patterns, it is often easiest to "
"assign the desired pattern to a parameter and then refer to that parameter in the subscript, because then the backslashes, brackets, parentheses, etc., are seen only when the complete expression is "
"converted to a pattern.  To match the value of a parameter literally in a reverse subscript, rather than as a pattern, use `@t{$@{(q}@t{)}@var{name}@t{@}}' (@ref{Parameter Expansion}) to quote the "
"expanded value."
msgstr ""
"在执行反向下标时，必须考虑最后一个细节。 下标表达式中出现的参数首先会被展开，然后整个表达式会被解释为一个模式。 这有两个影响：首先，参数的行为就好像 @t{GLOB_SUBST} 是开启的一样（而且无法关闭）；其次，反斜"
"线会被解释两次，一次是在解析数组下标时，另一次是在解析模式时。 在反向下标中，必须使用 @emph{四个} 反斜线，才能使单个反斜线与模式中的字面意思相匹配。 对于复杂的模式，通常最简单的做法是将所需模式指定给一个参"
"数，然后在下标中引用该参数，因为只有在将完整表达式转换为模式时才会看到反斜线、花括号、小括号等。 要匹配反向下标中的参数字面值而不是模式，可使用 `@t{$@{(q}@t{)}@var{name}@t{@}}' （@ref{参数扩展}）来为扩展后"
"的值加引用。"

#. type: Plain text
#: zsh.texi:8379
msgid ""
"Note that the `@t{k}' and `@t{K}' flags are reverse subscripting for an ordinary array, but are @emph{not} reverse subscripting for an associative array! (For an associative array, the keys in the array "
"itself are interpreted as patterns by those flags; the subscript is a plain string in that case.)"
msgstr "请注意，`@t{k}' 和 `@t{K}' 标志对于普通数组来说是反向下标，但对于关联数组来说是 @emph{不是} 反向下标！(对于关联数组，数组本身的键被这些标志解释为模式；在这种情况下，下标是一个纯字符串）。"

#. type: Plain text
#: zsh.texi:8389
msgid ""
"One final note, not directly related to subscripting: the numeric names of positional parameters (@ref{Positional Parameters}) are parsed specially, so for example `@t{$2foo}' is equivalent to `@t{$@{2@}"
"foo}'.  Therefore, to use subscript syntax to extract a substring from a positional parameter, the expansion must be surrounded by braces; for example, `@t{$@{2[3,5]@}}' evaluates to the third through "
"fifth characters of the second positional parameter, but `@t{$2[3,5]}' is the entire second parameter concatenated with the filename generation pattern `@t{[3,5]}'."
msgstr ""
"最后注意一点,与下标语法没有直接关系：位置参数（@ref{位置参数}）的数字名称会被特殊解析，例如， `@t{$2foo}' 等同于 `@t{$@{2@}foo}' 。 因此，要使用下标语法从位置参数中提取子串，必须用大括号括起来；例如， "
"`@t{$@{2[3,5]@}}' 的值是第二个位置参数的第三到第五个字符，但 `@t{$2[3,5]}' 是整个第二个参数与文件名生成模式 `@t{[3,5]}' 的连接。"

#. type: node
#: zsh.texi:8391 zsh.texi:8423 zsh.texi:8425 zsh.texi:8468
#, no-wrap
msgid "Local Parameters"
msgstr "局部参数"

#. type: Plain text
#: zsh.texi:8402
msgid ""
"The positional parameters provide access to the command-line arguments of a shell function, shell script, or the shell itself; see @ref{Invocation}, and also @ref{Functions}.  The parameter @var{n}, where "
"@var{n} is a number, is the @var{n}th positional parameter.  The parameter `@t{$0}' is a special case, see @ref{Parameters Set By The Shell}."
msgstr ""
"位置参数用于访问 shell 函数、shell 脚本或 shell 本身的命令行参数；参见 @ref{调用}，以及 @ref{函数}。 参数 @var{n} 是第 @var{n} 个位置参数，其中 @var{n} 是一个数字。 参数 `@t{$0}' 是一个特例，参见 @ref{由 "
"Shell 设置的参数}。"

#. type: Plain text
#: zsh.texi:8410
msgid ""
"The parameters @t{*}, @t{@@} and @t{argv} are arrays containing all the positional parameters; thus `@t{$argv[}@var{n}@t{]}', etc., is equivalent to simply `@t{$}@var{n}'.  Note that the options "
"@t{KSH_ARRAYS} or @t{KSH_ZERO_SUBSCRIPT} apply to these arrays as well, so with either of those options set, `@t{$@{argv[0]@}}' is equivalent to `@t{$1}' and so on."
msgstr ""
"参数 @t{*}, @t{@@} 和 @t{argv} 是包含所有位置参数的数组；因此 `@t{$argv[}@var{n}@t{]}' 等，等同于 `@t{$}@var{n}' 。 需要注意的是，选项 @t{KSH_ARRAYS} 或 @t{KSH_ZERO_SUBSCRIPT} 也适用于这些数组，因此在设置"
"了这两个选项之一的情况下，`@t{$@{argv[0]@}}' 等价于 `@t{$1}' ，以此类推。"

#. type: Plain text
#: zsh.texi:8421
msgid ""
"Positional parameters may be changed after the shell or function starts by using the @t{set} builtin, by assigning to the @t{argv} array, or by direct assignment of the form `@var{n}@t{=}@var{value}' "
"where @var{n} is the number of the positional parameter to be changed.  This also creates (with empty values) any of the positions from 1 to @var{n} that do not already have values.  Note that, because "
"the positional parameters form an array, an array assignment of the form `@var{n}@t{=(}@var{value} ...@t{)}' is allowed, and has the effect of shifting all the values at positions greater than @var{n} by "
"as many positions as necessary to accommodate the new values."
msgstr ""
"位置参数可以在 shell 或函数启动后通过 @t{set} 内置命令、赋值给 @t{argv} 数组或 `@var{n}@t{=}@var{value}' 的形式直接赋值进行修改，其中 @var{n} 是要修改的位置参数的编号。 这也会创建（用空值）从 1 到 @var{n} "
"尚未有值的任何位置。 需要注意的是，由于位置参数组成了一个数组，因此允许使用形式为 `@var{n}@t{=(}@var{value} ...@t{)}' 的数组赋值，其效果是将所有大于 @var{n} 的位置值移动需要的位置，以容纳新值。"

#. type: node
#: zsh.texi:8423 zsh.texi:8468 zsh.texi:8470 zsh.texi:8930
#, no-wrap
msgid "Parameters Set By The Shell"
msgstr "由 Shell 设置的参数"

#. type: Plain text
#: zsh.texi:8432
msgid ""
"Shell function executions delimit scopes for shell parameters.  (Parameters are dynamically scoped.)  The @t{typeset} builtin, and its alternative forms @t{declare}, @t{integer}, @t{local} and "
"@t{readonly} (but not @t{export}), can be used to declare a parameter as being local to the innermost scope."
msgstr ""
"shell 函数的执行为 shell 参数限定了作用域（参数是动态作用域）。 (参数是动态作用域的。）@t{typeset} 内置命令及其替代形式 @t{declare}、@t{integer}、@t{local} 和 @t{readonly}（但不包括 @t{export}）可用于将参"
"数声明为最内层作用域的局部参数。"

#. type: Plain text
#: zsh.texi:8439
msgid ""
"When a parameter is read or assigned to, the innermost existing parameter of that name is used.  (That is, the local parameter hides any less-local parameter.)  However, assigning to a non-existent "
"parameter, or declaring a new parameter with @t{export}, causes it to be created in the @emph{outer}most scope."
msgstr ""
"当读取或赋值一个参数时，会使用该参数名的最内层现有参数（也就是说，局部参数会隐藏任何外层（less-local）参数）。 (不过，如果赋值给一个不存在的参数，或使用 @t{export} 声明一个新参数，则会在 @emph{最外层}"
"（outermost）作用域创建该参数。"

#. type: Plain text
#: zsh.texi:8444
msgid "Local parameters disappear when their scope ends.  @t{unset} can be used to delete a parameter while it is still in scope; any outer parameter of the same name remains hidden."
msgstr "局部参数会在其作用域结束时消失。 @t{unset} 可用于删除仍在作用域中的参数；任何同名的外层参数仍会被隐藏。"

#. type: Plain text
#: zsh.texi:8453
msgid ""
"Special parameters may also be made local; they retain their special attributes unless either the existing or the newly-created parameter has the @t{-h} (hide) attribute.  This may have unexpected "
"effects: there is no default value, so if there is no assignment at the point the variable is made local, it will be set to an empty value (or zero in the case of integers).  The following:"
msgstr ""
"特殊参数也可以设置为局部参数；除非现有参数或新创建的参数具有 @t{-h}（hide）属性，否则特殊参数将保留其特殊属性。 这可能会产生意想不到的效果：变量没有默认值，因此如果在变量局部化时没有赋值，它将被设置为空值"
"（如果是整数，则为零）。 下面是"

#. type: example
#: zsh.texi:8457
#, no-wrap
msgid "typeset PATH=/new/directory:$PATH\n"
msgstr "typeset PATH=/new/directory:$PATH\n"

#. type: Plain text
#: zsh.texi:8462
msgid "is valid for temporarily allowing the shell or programmes called from it to find the programs in @t{/new/directory} inside a function."
msgstr "可以暂时允许 shell 或从 shell 调用的程序在函数内查找 @t{/new/directory} 中的程序。"

#. type: Plain text
#: zsh.texi:8466
msgid "Note that the restriction in older versions of zsh that local parameters were never exported has been removed."
msgstr "请注意，旧版本的 zsh 中关于永不导出局部参数的限制已被删除。"

#. type: Plain text
#: zsh.texi:8475
msgid ""
"In the parameter lists that follow, the mark `<S>' indicates that the parameter is special.  `<Z>' indicates that the parameter does not exist when the shell initializes in @t{sh} or @t{ksh} emulation "
"mode."
msgstr "在后面的参数列表中，标记 `<S>'  表示参数是特殊的。 `<Z>' 表示 shell 在 @t{sh} 或 @t{ksh} 模拟模式下初始化时该参数不存在。"

#. type: Plain text
#: zsh.texi:8484
msgid ""
"The parameters `@t{!}', `@t{#}', `@t{*}', `@t{-}', `@t{?}', `@t{@@}', `@t{$}', `@t{ARGC}', `@t{HISTCMD}', `@t{LINENO}', `@t{PPID}', `@t{status}', `@t{TTYIDLE}', `@t{zsh_eval_context}', "
"`@t{ZSH_EVAL_CONTEXT}', and `@t{ZSH_SUBSHELL}' are read-only and thus cannot be restored by the user, so they are not output by `@t{typeset -p}'.  This also applies to many read-only parameters loaded "
"from modules."
msgstr ""
"参数 `@t{!}', `@t{#}', `@t{*}', `@t{-}', `@t{?}', `@t{@@}', `@t{$}', `@t{ARGC}', `@t{HISTCMD}', `@t{LINENO}', `@t{PPID}', `@t{status}', `@t{TTYIDLE}', `@t{zsh_eval_context}', `@t{ZSH_EVAL_CONTEXT}',和 "
"`@t{ZSH_SUBSHELL}' 是只读的因此用户无法恢复（restore）, 所以它们不能通过 `@t{typeset -p}' 输出。 这也适用于从模块加载的许多只读参数。"

#. type: Plain text
#: zsh.texi:8487
msgid "The following parameters are automatically set by the shell:"
msgstr "以下参数由 shell 自动设置："

#. type: item
#: zsh.texi:8491
#, no-wrap
msgid "@t{!} <S>"
msgstr "@t{!} <S>"

#. type: table
#: zsh.texi:8494
msgid "The process ID of the last command started in the background with @t{&}, put into the background with the @t{bg} builtin, or spawned with @t{coproc}."
msgstr "使用 @t{&} 在后台启动、使用 @t{bg} 内置命令进入后台或使用 @t{coproc} 生成的最后一条命令的进程 ID。"

#. type: item
#: zsh.texi:8496
#, no-wrap
msgid "@t{#} <S>"
msgstr "@t{#} <S>"

#. type: table
#: zsh.texi:8502
msgid ""
"The number of positional parameters in decimal.  Note that some confusion may occur with the syntax @t{$#}@var{param} which substitutes the length of @var{param}.  Use @t{$@{#@}} to resolve ambiguities.  "
"In particular, the sequence `@t{$#-}@var{...}' in an arithmetic expression is interpreted as the length of the parameter @t{-}, q.v."
msgstr ""
"位置参数的个数（十进制）。 请注意， @t{$#}@var{param}  的语法可能会与 @var{param} 的长度产生混淆。 请使用 @t{$@{#@}} 来消除歧义。 特别是，算术表达式中的序列 `@t{$#-}@var{...}' 会被解释为参数 @t{-} 的长度，"
"参阅"

#. type: vindex
#: zsh.texi:8503
#, no-wrap
msgid "ARGC"
msgstr "ARGC"

#. type: item
#: zsh.texi:8504
#, no-wrap
msgid "@t{ARGC} <S> <Z>"
msgstr "@t{ARGC} <S> <Z>"

#. type: table
#: zsh.texi:8506
msgid "Same as @t{#}."
msgstr "与 @t{#} 一样。"

#. type: item
#: zsh.texi:8508
#, no-wrap
msgid "@t{$} <S>"
msgstr "@t{$} <S>"

#. type: table
#: zsh.texi:8514
msgid ""
"The process ID of this shell, set when the shell initializes.  Processes forked from the shell without executing a new program, such as command substitutions and commands grouped with @t{(}@var{...}@t{)}, "
"are subshells that duplicate the current shell, and thus substitute the same value for @t{$$} as their parent shell."
msgstr ""
"此 shell 的进程 ID，在 shell 初始化时设置。 在不执行新程序的情况下从 shell 分支出来的进程，如命令替换和以 @t{(}@var{...}@t{)} 分组的命令，都是复制当前 shell 的子 shell，因此其 @t{$$} 值与父 shell 相同。"

#. type: item
#: zsh.texi:8516
#, no-wrap
msgid "@t{-} <S>"
msgstr "@t{-} <S>"

#. type: table
#: zsh.texi:8519
msgid "Flags supplied to the shell on invocation or by the @t{set} or @t{setopt} commands."
msgstr "调用 shell 时或通过 @t{set} 或 @t{setopt} 命令提供给 shell 的标志。"

#. type: item
#: zsh.texi:8521
#, no-wrap
msgid "@t{*} <S>"
msgstr "@t{*} <S>"

#. type: table
#: zsh.texi:8523
msgid "An array containing the positional parameters."
msgstr "包含位置参数的数组。"

#. type: vindex
#: zsh.texi:8524
#, no-wrap
msgid "argv"
msgstr "argv"

#. type: item
#: zsh.texi:8525
#, no-wrap
msgid "@t{argv} <S> <Z>"
msgstr "@t{argv} <S> <Z>"

#. type: table
#: zsh.texi:8531
msgid ""
"Same as @t{*}.  Assigning to @t{argv} changes the local positional parameters, but @t{argv} is @emph{not} itself a local parameter.  Deleting @t{argv} with @t{unset} in any function deletes it everywhere, "
"although only the innermost positional parameter array is deleted (so @t{*} and @t{@@} in other scopes are not affected)."
msgstr ""
"与 @t{*} 相同。 向 @t{argv} 赋值会改变局部位置参数，但 @t{argv} 本身 @emph{不是} 局部参数。 在任何函数中使用 @t{unset} 删除 @t{argv} 都会把它从所有位置删除，但只删除最内层的位置参数数组（因此其他作用域中"
"的 @t{*} 和 @t{@@} 不受影响）。"

#. type: item
#: zsh.texi:8533
#, no-wrap
msgid "@t{@@} <S>"
msgstr "@t{@@} <S>"

#. type: table
#: zsh.texi:8535
msgid "Same as @t{argv[@@]}, even when @t{argv} is not set."
msgstr "与 @t{argv[@@]}相同，即使 @t{argv} 未设置。"

#. type: item
#: zsh.texi:8537
#, no-wrap
msgid "@t{?} <S>"
msgstr "@t{?} <S>"

#. type: table
#: zsh.texi:8539
msgid "The exit status returned by the last command."
msgstr "最后一条命令返回的退出状态。"

#. type: item
#: zsh.texi:8541
#, no-wrap
msgid "@t{0} <S>"
msgstr "@t{0} <S>"

#. type: table
#: zsh.texi:8547
msgid ""
"The name used to invoke the current shell, or as set by the @t{-c} command line option upon invocation.  If the @t{FUNCTION_ARGZERO} option is set, @t{$0} is set upon entry to a shell function to the name "
"of the function, and upon entry to a sourced script to the name of the script, and reset to its previous value when the function or script returns."
msgstr ""
"调用当前 shell 时使用的名称，或由 @t{-c} 命令行选项在调用时设置的名称。 如果设置了 @t{FUNCTION_ARGZERO} 选项，在进入 shell 函数时 @t{$0} 将被设置为该函数的名称，在进入引入（sourced）的脚本时 @t{$0} 将被设"
"置为该脚本的名称，并在函数或脚本返回时重置为之前的值。"

#. type: vindex
#: zsh.texi:8548
#, no-wrap
msgid "status"
msgstr "status"

#. type: item
#: zsh.texi:8549
#, no-wrap
msgid "@t{status} <S> <Z>"
msgstr "@t{status} <S> <Z>"

#. type: table
#: zsh.texi:8551
msgid "Same as @t{?}."
msgstr "与 @t{?} 一样。"

#. type: vindex
#: zsh.texi:8552
#, no-wrap
msgid "pipestatus"
msgstr "pipestatus"

#. type: item
#: zsh.texi:8553
#, no-wrap
msgid "@t{pipestatus} <S> <Z>"
msgstr "@t{pipestatus} <S> <Z>"

#. type: table
#: zsh.texi:8556
msgid "An array containing the exit statuses returned by all commands in the last pipeline."
msgstr "数组，包含最后一条管道中所有命令返回的退出状态。"

#. type: item
#: zsh.texi:8558
#, no-wrap
msgid "@t{_} <S>"
msgstr "@t{_} <S>"

#. type: table
#: zsh.texi:8562
msgid "The last argument of the previous command.  Also, this parameter is set in the environment of every command executed to the full pathname of the command."
msgstr "上一条命令的最后一个参数。 此外，在执行每条命令时，该参数都会在环境中设置为命令的完整路径名。"

#. type: t{#1}
#: zsh.texi:8563 zsh.texi:8564
#, no-wrap
msgid "CPUTYPE"
msgstr "CPUTYPE"

#. type: table
#: zsh.texi:8567
msgid "The machine type (microprocessor class or machine model), as determined at run time."
msgstr "运行时确定的机器类型（微处理器类别或机器型号）。"

#. type: vindex
#: zsh.texi:8568
#, no-wrap
msgid "EGID"
msgstr "EGID"

#. type: item
#: zsh.texi:8569
#, no-wrap
msgid "@t{EGID} <S>"
msgstr "@t{EGID} <S>"

#. type: table
#: zsh.texi:8575
msgid ""
"The effective group ID of the shell process.  If you have sufficient privileges, you may change the effective group ID of the shell process by assigning to this parameter.  Also (assuming sufficient "
"privileges), you may start a single command with a different effective group ID by `@t{(EGID=}@var{gid}@t{; command)}'"
msgstr "shell 进程的有效组 ID。 如果您有足够的权限，可以通过指定此参数来更改 shell 进程的有效组 ID。 此外（假设有足够权限），还可以通过 `@t{(EGID=}@var{gid}@t{; command)}' 以不同的有效组 ID 启动单个命令。"

#. type: table
#: zsh.texi:8579 zsh.texi:8591 zsh.texi:8625 zsh.texi:8772 zsh.texi:9103 zsh.texi:9410
msgid "If this is made local, it is not implicitly set to 0, but may be explicitly set locally."
msgstr "如果将其设置为局部的，则不会隐式设置为 0，但是可以显式且局部地设置为0。"

#. type: vindex
#: zsh.texi:8580
#, no-wrap
msgid "EUID"
msgstr "EUID"

#. type: item
#: zsh.texi:8581
#, no-wrap
msgid "@t{EUID} <S>"
msgstr "@t{EUID} <S>"

#. type: table
#: zsh.texi:8587
msgid ""
"The effective user ID of the shell process.  If you have sufficient privileges, you may change the effective user ID of the shell process by assigning to this parameter.  Also (assuming sufficient "
"privileges), you may start a single command with a different effective user ID by `@t{(EUID=}@var{uid}@t{; command)}'"
msgstr ""
"shell 进程的有效用户 ID。 如果您有足够的权限，可以通过指定此参数来更改 shell 进程的有效用户 ID。 此外（假设有足够权限），还可以通过 `@t{(EUID=}@var{uid}@t{; command)}' 以不同的有效用户 ID 启动单个命令。"

#. type: vindex
#: zsh.texi:8592
#, no-wrap
msgid "ERRNO"
msgstr "ERRNO"

#. type: item
#: zsh.texi:8593
#, no-wrap
msgid "@t{ERRNO} <S>"
msgstr "@t{ERRNO} <S>"

#. type: table
#: zsh.texi:8599
msgid ""
"The value of @t{errno} (see errno(3))  as set by the most recently failed system call.  This value is system dependent and is intended for debugging purposes.  It is also useful with the @t{zsh/system} "
"module which allows the number to be turned into a name or message."
msgstr "最近一次失败的系统调用所设置的 @t{errno}（参见 errno(3)）值。 该值取决于系统，用于调试目的。 在与 @t{zsh/system} 模块一起使用时也很有用，该模块允许将数字转换为名称或信息。"

#. type: table
#: zsh.texi:8603
msgid "To use this parameter, it must first be assigned a value (typically 0 (zero)).  It is initially unset for scripting compatibility."
msgstr "要使用该参数，必须先为其赋值（通常为 0（零））。 为了与脚本兼容，该参数最初未设置。"

#. type: vindex
#: zsh.texi:8604
#, no-wrap
msgid "FUNCNEST"
msgstr "FUNCNEST"

#. type: item
#: zsh.texi:8605
#, no-wrap
msgid "@t{FUNCNEST} <S>"
msgstr "@t{FUNCNEST} <S>"

#. type: table
#: zsh.texi:8613
msgid ""
"Integer.  If greater than or equal to zero, the maximum nesting depth of shell functions.  When it is exceeded, an error is raised at the point where a function is called.  The default value is determined "
"when the shell is configured, but is typically 500.  Increasing the value increases the danger of a runaway function recursion causing the shell to crash.  Setting a negative value turns off the check."
msgstr ""
"整数。 如果大于或等于零，则为 shell 函数的最大嵌套深度。 超过该值时，将在调用函数时出错。 默认值在配置 shell 时确定，但通常为 500。 增加该值会增加函数递归失控导致 shell 崩溃的危险。 设置负值则会关闭检查。"

#. type: vindex
#: zsh.texi:8614
#, no-wrap
msgid "GID"
msgstr "GID"

#. type: item
#: zsh.texi:8615
#, no-wrap
msgid "@t{GID} <S>"
msgstr "@t{GID} <S>"

#. type: table
#: zsh.texi:8621
msgid ""
"The real group ID of the shell process.  If you have sufficient privileges, you may change the group ID of the shell process by assigning to this parameter.  Also (assuming sufficient privileges), you may "
"start a single command under a different group ID by `@t{(GID=}@var{gid}@t{; command)}'"
msgstr "shell 进程的真实组 ID。 如果您有足够的权限，可以通过为该参数赋值来更改 shell 进程的组 ID。 此外（假设有足够权限），还可以通过 `@t{(GID=}@var{gid}@t{; command)}' 在不同的组 ID 下启动一条命令。"

#. type: t{#1}
#: zsh.texi:8626 zsh.texi:8627
#, no-wrap
msgid "HISTCMD"
msgstr "HISTCMD"

#. type: table
#: zsh.texi:8632
msgid ""
"The current history event number in an interactive shell, in other words the event number for the command that caused @t{$HISTCMD} to be read.  If the current history event modifies the history, "
"@t{HISTCMD} changes to the new maximum history event number."
msgstr "交互式 shell 中的当前历史事件编号，换句话说，就是导致 @t{$HISTCMD} 被读取的命令的事件编号。 如果当前历史事件修改了历史记录，@t{HISTCMD} 将更改为新的最大历史事件编号。"

#. type: t{#1}
#: zsh.texi:8633 zsh.texi:8634
#, no-wrap
msgid "HOST"
msgstr "HOST"

#. type: table
#: zsh.texi:8636
msgid "The current hostname."
msgstr "当前主机名。"

#. type: vindex
#: zsh.texi:8637
#, no-wrap
msgid "LINENO"
msgstr "LINENO"

#. type: item
#: zsh.texi:8638
#, no-wrap
msgid "@t{LINENO} <S>"
msgstr "@t{LINENO} <S>"

#. type: table
#: zsh.texi:8644
msgid ""
"The line number of the current line within the current script, sourced file, or shell function being executed, whichever was started most recently.  Note that in the case of shell functions the line "
"number refers to the function as it appeared in the original definition, not necessarily as displayed by the @t{functions} builtin."
msgstr "当前脚本、源文件或正在执行的 shell 函数（以最近启动者为准）中当前行的行号。 请注意，对于 shell 函数，行号指的是函数在原始定义中的行号，而不一定是 @t{functions} 内置命令所显示的行号。"

#. type: t{#1}
#: zsh.texi:8645 zsh.texi:8646
#, no-wrap
msgid "LOGNAME"
msgstr "LOGNAME"

#. type: table
#: zsh.texi:8653
msgid ""
"If the corresponding variable is not set in the environment of the shell, it is initialized to the login name corresponding to the current login session. This parameter is exported by default but this can "
"be disabled using the @t{typeset} builtin.  The value is set to the string returned by the getlogin(3) system call if that is available."
msgstr ""
"如果 shell 环境中未设置相应变量，则会将其初始化为当前登录会话对应的登录名。默认情况下会导出此参数，但可以使用 @t{typeset} 内置命令禁用。 如果 getlogin(3) 系统调用返回的字符串可用，该值将被设置为该字符串。"

#. type: t{#1}
#: zsh.texi:8654 zsh.texi:8655
#, no-wrap
msgid "MACHTYPE"
msgstr "MACHTYPE"

#. type: table
#: zsh.texi:8658
msgid "The machine type (microprocessor class or machine model), as determined at compile time."
msgstr "编译时确定的机器类型（微处理器类别或机器型号）。"

#. type: t{#1}
#: zsh.texi:8659 zsh.texi:8660
#, no-wrap
msgid "OLDPWD"
msgstr "OLDPWD"

#. type: table
#: zsh.texi:8663
msgid "The previous working directory.  This is set when the shell initializes and whenever the directory changes."
msgstr "上一个工作目录。 它在 shell 初始化和目录更改时设置。"

#. type: vindex
#: zsh.texi:8664
#, no-wrap
msgid "OPTARG"
msgstr "OPTARG"

#. type: item
#: zsh.texi:8665
#, no-wrap
msgid "@t{OPTARG} <S>"
msgstr "@t{OPTARG} <S>"

#. type: table
#: zsh.texi:8668
msgid "The value of the last option argument processed by the @t{getopts} command."
msgstr "@t{getopts} 命令处理的最后一个选项参数的值。"

#. type: vindex
#: zsh.texi:8669
#, no-wrap
msgid "OPTIND"
msgstr "OPTIND"

#. type: item
#: zsh.texi:8670
#, no-wrap
msgid "@t{OPTIND} <S>"
msgstr "@t{OPTIND} <S>"

#. type: table
#: zsh.texi:8673
msgid "The index of the last option argument processed by the @t{getopts} command."
msgstr "@t{getopts} 命令处理的最后一个选项参数的索引。"

#. type: t{#1}
#: zsh.texi:8674 zsh.texi:8675
#, no-wrap
msgid "OSTYPE"
msgstr "OSTYPE"

#. type: table
#: zsh.texi:8677
msgid "The operating system, as determined at compile time."
msgstr "编译时确定的操作系统。"

#. type: vindex
#: zsh.texi:8678
#, no-wrap
msgid "PPID"
msgstr "PPID"

#. type: item
#: zsh.texi:8679
#, no-wrap
msgid "@t{PPID} <S>"
msgstr "@t{PPID} <S>"

#. type: table
#: zsh.texi:8683
msgid "The process ID of the parent of the shell, set when the shell initializes.  As with @t{$$}, the value does not change in subshells created as a duplicate of the current shell."
msgstr "shell 初始化时设置的 shell 父进程 ID。 与 @t{$$} 一样，在作为当前 shell 的副本创建的子 shell 中，该值不会改变。"

#. type: t{#1}
#: zsh.texi:8684 zsh.texi:8685
#, no-wrap
msgid "PWD"
msgstr "PWD"

#. type: table
#: zsh.texi:8688
msgid "The present working directory.  This is set when the shell initializes and whenever the directory changes."
msgstr "当前工作目录。 它在 shell 初始化和目录更改时设置。"

#. type: vindex
#: zsh.texi:8689
#, no-wrap
msgid "RANDOM"
msgstr "RANDOM"

#. type: item
#: zsh.texi:8690
#, no-wrap
msgid "@t{RANDOM} <S>"
msgstr "@t{RANDOM} <S>"

#. type: table
#: zsh.texi:8694
msgid "A pseudo-random integer from 0 to 32767, newly generated each time this parameter is referenced.  The random number generator can be seeded by assigning a numeric value to @t{RANDOM}."
msgstr "一个从 0 到 32767 的伪随机整数，每次引用该参数时都会新生成。 可以通过为 @t{RANDOM} 赋值来给随机数生成器一个随机数种子。"

#. type: table
#: zsh.texi:8700
msgid ""
"The values of @t{RANDOM} form an intentionally-repeatable pseudo-random sequence; subshells that reference @t{RANDOM} will result in identical pseudo-random values unless the value of @t{RANDOM} is "
"referenced or seeded in the parent shell in between subshell invocations."
msgstr "@t{RANDOM} 的值构成了一个可有意重复的伪随机序列；引用 @t{RANDOM} 的子 shell 将产生完全相同的伪随机值，除非在子 shell 调用之间引用 @t{RANDOM} 的值或在父 shell 中设置（seed） @t{RANDOM} 的值。"

#. type: vindex
#: zsh.texi:8701
#, no-wrap
msgid "SECONDS"
msgstr "SECONDS"

#. type: item
#: zsh.texi:8702
#, no-wrap
msgid "@t{SECONDS} <S>"
msgstr "@t{SECONDS} <S>"

#. type: table
#: zsh.texi:8707
msgid ""
"The number of seconds since shell invocation.  If this parameter is assigned a value, then the value returned upon reference will be the value that was assigned plus the number of seconds since the "
"assignment."
msgstr "调用 shell 后的秒数。 如果为该参数赋值，则引用后返回的值将是赋值的值加上赋值后的秒数。"

#. type: table
#: zsh.texi:8718
msgid ""
"Unlike other special parameters, the type of the @t{SECONDS} parameter can be changed using the @t{typeset} command.  The type may be changed only to one of the floating point types or back to integer.  "
"For example, `@t{typeset -F SECONDS}' causes the value to be reported as a floating point number.  The value is available to microsecond accuracy, although the shell may show more or fewer digits "
"depending on the use of @t{typeset}.  See the documentation for the builtin @t{typeset} in @ref{Shell Builtin Commands} for more details."
msgstr ""
"与其他特殊参数不同，@t{SECONDS} 参数的类型可以通过 @t{typeset} 命令来更改。 类型只能改为浮点类型或整数类型。 例如， `@t{typeset -F SECONDS}' 会将数值报告为浮点数。 虽然 shell 可能会根据 @t{typeset} 的使用"
"显示更多或更少的位数，但数值的精度可以达到微秒级。 更多详情，请参阅 @ref{Shell 内置命令} 中的 @t{typeset} 文档。"

#. type: vindex
#: zsh.texi:8719
#, no-wrap
msgid "SHLVL"
msgstr "SHLVL"

#. type: item
#: zsh.texi:8720
#, no-wrap
msgid "@t{SHLVL} <S>"
msgstr "@t{SHLVL} <S>"

#. type: table
#: zsh.texi:8722
msgid "Incremented by one each time a new shell is started."
msgstr "每次启动一个新 shell 时递增 1。"

#. type: t{#1}
#: zsh.texi:8723 zsh.texi:8724 zsh.texi:21720
#, no-wrap
msgid "signals"
msgstr "signals"

#. type: table
#: zsh.texi:8732
msgid ""
"An array containing the names of the signals.  Note that with the standard zsh numbering of array indices, where the first element has index 1, the signals are offset by 1 from the signal number used by "
"the operating system.  For example, on typical Unix-like systems @t{HUP} is signal number 1, but is referred to as @t{$signals[2]}.  This is because of @t{EXIT} at position 1 in the array, which is used "
"internally by zsh but is not known to the operating system."
msgstr ""
"包含信号名称的数组。 请注意，按照标准的 zsh 数组索引编号（第一个元素的索引为 1），信号与操作系统使用的信号编号相差 1。 例如，在典型的类 Unix 系统中 @t{HUP} 是信号编号 1，但这里引用为 @t{$signals[2]}。 这是"
"因为 @t{EXIT} 位于数组的第 1 位，zsh 在内部使用它，但操作系统并不知道它。"

#. type: vindex
#: zsh.texi:8733
#, no-wrap
msgid "TRY_BLOCK_ERROR"
msgstr "TRY_BLOCK_ERROR"

#. type: item
#: zsh.texi:8734
#, no-wrap
msgid "@t{TRY_BLOCK_ERROR} <S>"
msgstr "@t{TRY_BLOCK_ERROR} <S>"

#. type: table
#: zsh.texi:8739
msgid ""
"In an @t{always} block, indicates whether the preceding list of code caused an error.  The value is 1 to indicate an error, 0 otherwise.  It may be reset, clearing the error condition.  See @ref{Complex "
"Commands}"
msgstr "在 @t{always} 块中，表示前面的代码列表是否导致错误。 值为 1 表示出错，否则为 0。 可以重置该值，清除错误条件。 参见 @ref{复杂命令}"

#. type: vindex
#: zsh.texi:8740
#, no-wrap
msgid "TRY_BLOCK_INTERRUPT"
msgstr "TRY_BLOCK_INTERRUPT"

#. type: item
#: zsh.texi:8741
#, no-wrap
msgid "@t{TRY_BLOCK_INTERRUPT} <S>"
msgstr "@t{TRY_BLOCK_INTERRUPT} <S>"

#. type: table
#: zsh.texi:8747
msgid ""
"This variable works in a similar way to @t{TRY_BLOCK_ERROR}, but represents the status of an interrupt from the signal SIGINT, which typically comes from the keyboard when the user types @t{^C}.  If set "
"to 0, any such interrupt will be reset; otherwise, the interrupt is propagated after the @t{always} block."
msgstr "该变量的工作方式与 @t{TRY_BLOCK_ERROR} 类似，但它代表来自 SIGINT 信号的中断状态，通常在用户从键盘键入 @t{^C} 时。 如果设置为 0，任何此类中断都将被重置；否则，中断将在 @t{always} 代码块之后传播。"

#. type: table
#: zsh.texi:8751
msgid "Note that it is possible that an interrupt arrives during the execution of the @t{always} block; this interrupt is also propagated."
msgstr "需要注意的是，在 @t{always} 块执行过程中可能会出现中断；该中断也会被传播。"

#. type: t{#1}
#: zsh.texi:8752 zsh.texi:8753
#, no-wrap
msgid "TTY"
msgstr "TTY"

#. type: table
#: zsh.texi:8755
msgid "The name of the tty associated with the shell, if any."
msgstr "与 shell 关联的 tty 的名称（如果有）。"

#. type: vindex
#: zsh.texi:8756
#, no-wrap
msgid "TTYIDLE"
msgstr "TTYIDLE"

#. type: item
#: zsh.texi:8757
#, no-wrap
msgid "@t{TTYIDLE} <S>"
msgstr "@t{TTYIDLE} <S>"

#. type: table
#: zsh.texi:8760
msgid "The idle time of the tty associated with the shell in seconds or -1 if there is no such tty."
msgstr "与 shell 关联的 tty 的空闲时间（以秒为单位），如果没有此类 tty，则为-1。"

#. type: vindex
#: zsh.texi:8761
#, no-wrap
msgid "UID"
msgstr "UID"

#. type: item
#: zsh.texi:8762
#, no-wrap
msgid "@t{UID} <S>"
msgstr "@t{UID} <S>"

#. type: table
#: zsh.texi:8768
msgid ""
"The real user ID of the shell process.  If you have sufficient privileges, you may change the user ID of the shell by assigning to this parameter.  Also (assuming sufficient privileges), you may start a "
"single command under a different user ID by `@t{(UID=}@var{uid}@t{; command)}'"
msgstr "shell 进程的真实用户 ID。 如果您有足够的权限，可以通过为该参数赋值来更改 shell 的用户 ID。 此外（假设有足够权限），还可以通过   `@t{(UID=}@var{uid}@t{; command)}' 以不同的用户 ID 启动一条命令。"

#. type: vindex
#: zsh.texi:8773
#, no-wrap
msgid "USERNAME"
msgstr "USERNAME"

#. type: item
#: zsh.texi:8774
#, no-wrap
msgid "@t{USERNAME} <S>"
msgstr "@t{USERNAME} <S>"

#. type: table
#: zsh.texi:8781
msgid ""
"The username corresponding to the real user ID of the shell process.  If you have sufficient privileges, you may change the username (and also the user ID and group ID) of the shell by assigning to this "
"parameter.  Also (assuming sufficient privileges), you may start a single command under a different username (and user ID and group ID)  by `@t{(USERNAME=}@var{username}@t{; command)}'"
msgstr ""
"与 shell 进程真实用户 ID 相对应的用户名。 如果您有足够的权限，可以通过指定该参数来更改 shell 的用户名（以及用户 ID 和组 ID）。 此外（假设有足够权限），还可以通过  `@t{(USERNAME=}@var{username}@t{; "
"command)}' 以不同的用户名（以及用户 ID 和组 ID）启动单个命令。"

#. type: t{#1}
#: zsh.texi:8782 zsh.texi:8783
#, no-wrap
msgid "VENDOR"
msgstr "VENDOR"

#. type: table
#: zsh.texi:8785
msgid "The vendor, as determined at compile time."
msgstr "编译时确定的供应商。"

#. type: vindex
#: zsh.texi:8786
#, no-wrap
msgid "zsh_eval_context"
msgstr "zsh_eval_context"

#. type: vindex
#: zsh.texi:8787
#, no-wrap
msgid "ZSH_EVAL_CONTEXT"
msgstr "ZSH_EVAL_CONTEXT"

#. type: item
#: zsh.texi:8788
#, no-wrap
msgid "@t{zsh_eval_context} <S> <Z> (@t{ZSH_EVAL_CONTEXT} <S>)"
msgstr "@t{zsh_eval_context} <S> <Z> (@t{ZSH_EVAL_CONTEXT} <S>)"

#. type: table
#: zsh.texi:8795
msgid ""
"An array (colon-separated list) indicating the context of shell code that is being run.  Each time a piece of shell code that is stored within the shell is executed a string is temporarily appended to the "
"array to indicate the type of operation that is being performed.  Read in order the array gives an indication of the stack of operations being performed with the most immediate context last."
msgstr ""
"一个数组（以冒号分隔的列表），表示正在运行的 shell 代码的上下文。 每次执行一段存储在 shell 中的 shell 代码时，都会在数组中临时添加一个字符串，以指示正在执行的操作类型。 按顺序读取时，数组会显示正在执行的操"
"作堆栈，最近的操作放在最后。"

#. type: table
#: zsh.texi:8799
msgid "Note that the variable does not give information on syntactic context such as pipelines or subshells.  Use @t{$ZSH_SUBSHELL} to detect subshells."
msgstr "需要注意的是，该变量不提供诸如管道或子 shell 等语法上下文信息。 请使用 @t{$ZSH_SUBSHELL} 来检测子 shell。"

#. type: table
#: zsh.texi:8802
msgid "The context is one of the following:"
msgstr "上下文是以下情况之一："

#. type: t{#1}
#: zsh.texi:8803
#, no-wrap
msgid "cmdarg"
msgstr "cmdarg"

#. type: table
#: zsh.texi:8806
msgid "Code specified by the @t{-c} option to the command line that invoked the shell."
msgstr "由 @t{-c} 选项指定的调用 shell 的命令行代码。"

#. type: t{#1}
#: zsh.texi:8807
#, no-wrap
msgid "cmdsubst"
msgstr "cmdsubst"

#. type: table
#: zsh.texi:8810
msgid "Command substitution using the @t{`}@var{...}@t{`} or @t{$(}@var{...}@t{)} construct."
msgstr "使用 @t{`}@var{...}@t{`} or @t{$(}@var{...}@t{)} 结构进行的命令替换。"

#. type: t{#1}
#: zsh.texi:8811
#, no-wrap
msgid "equalsubst"
msgstr "equalsubst"

#. type: table
#: zsh.texi:8813
msgid "File substitution using the @t{=(}@var{...}@t{)} construct."
msgstr "使用 @t{=(}@var{...}@t{)} 结构进行的文件替换。"

#. type: findex
#: zsh.texi:8814 zsh.texi:13478
#, no-wrap
msgid "eval"
msgstr "eval"

#. type: table
#: zsh.texi:8816
msgid "Code executed by the @t{eval} builtin."
msgstr "由 @t{eval} 内置命令执行的代码。"

#. type: t{#1}
#: zsh.texi:8817
#, no-wrap
msgid "evalautofunc"
msgstr "evalautofunc"

#. type: table
#: zsh.texi:8820
msgid "Code executed with the @t{KSH_AUTOLOAD} mechanism in order to define an autoloaded function."
msgstr "使用 @t{KSH_AUTOLOAD} 机制执行的代码，用于定义自动加载函数。"

#. type: findex
#: zsh.texi:8821 zsh.texi:13538
#, no-wrap
msgid "fc"
msgstr "fc"

#. type: table
#: zsh.texi:8824
msgid "Code from the shell history executed by the @t{-e} option to the @t{fc} builtin."
msgstr "通过 @t{fc} 内置命令的 @t{-e} 选项执行的 shell 历史代码。"

#. type: t{#1}
#: zsh.texi:8825
#, no-wrap
msgid "file"
msgstr "file"

#. type: table
#: zsh.texi:8828
msgid "Lines of code being read directly from a file, for example by the @t{source} builtin."
msgstr "直接从文件（例如 @t{source} 内置命令）读取的代码行。"

#. type: t{#1}
#: zsh.texi:8829
#, no-wrap
msgid "filecode"
msgstr "filecode"

#. type: table
#: zsh.texi:8832
msgid "Lines of code being read from a @t{.zwc} file instead of directly from the source file."
msgstr "从 @t{.zwc} 文件而不是直接从源文件中读取的代码行。"

#. type: t{#1}
#: zsh.texi:8833
#, no-wrap
msgid "globqual"
msgstr "globqual"

#. type: table
#: zsh.texi:8835
msgid "Code executed by the @t{e} or @t{+} glob qualifier."
msgstr "由 glob 限定符 @t{e} 或 @t{+} 执行的代码。"

#. type: t{#1}
#: zsh.texi:8836
#, no-wrap
msgid "globsort"
msgstr "globsort"

#. type: table
#: zsh.texi:8838
msgid "Code executed to order files by the @t{o} glob qualifier."
msgstr "根据glob 限定符 @t{o} 对文件进行排序的代码。"

#. type: t{#1}
#: zsh.texi:8839
#, no-wrap
msgid "insubst"
msgstr "insubst"

#. type: table
#: zsh.texi:8841
msgid "File substitution using the @t{<(}@var{...}@t{)} construct."
msgstr "使用 @t{<(}@var{...}@t{)} 结构的文件替换。"

#. type: t{#1}
#: zsh.texi:8842
#, no-wrap
msgid "loadautofunc"
msgstr "loadautofunc"

#. type: table
#: zsh.texi:8844
msgid "Code read directly from a file to define an autoloaded function."
msgstr "直接从文件中读取以便定义自动加载函数的代码。"

#. type: t{#1}
#: zsh.texi:8845
#, no-wrap
msgid "outsubst"
msgstr "outsubst"

#. type: table
#: zsh.texi:8847
msgid "File substitution using the @t{>(}@var{...}@t{)} construct."
msgstr "使用 @t{>(}@var{...}@t{)} 结构进行文件替换。"

#. type: findex
#: zsh.texi:8848 zsh.texi:14584 zsh.texi:30175
#, no-wrap
msgid "sched"
msgstr "sched"

#. type: table
#: zsh.texi:8850
msgid "Code executed by the @t{sched} builtin."
msgstr "由 @t{sched} 内置命令执行的代码。"

#. type: t{#1}
#: zsh.texi:8851
#, no-wrap
msgid "shfunc"
msgstr "shfunc"

#. type: table
#: zsh.texi:8853
msgid "A shell function."
msgstr "一个 shell 函数。"

#. type: t{#1}
#: zsh.texi:8854
#, no-wrap
msgid "stty"
msgstr "stty"

#. type: table
#: zsh.texi:8858
msgid "Code passed to @t{stty} by the @t{STTY} environment variable.  Normally this is passed directly to the system's @t{stty} command, so this value is unlikely to be seen in practice."
msgstr "由 @t{STTY} 环境变量传递给 @t{stty} 的代码。 通常情况下，该值会直接传递给系统的 @t{stty} 命令，因此在实际应用中不太可能看到这个值。"

#. type: t{#1}
#: zsh.texi:8859
#, no-wrap
msgid "style"
msgstr "style"

#. type: table
#: zsh.texi:8862
msgid "Code executed as part of a style retrieved by the @t{zstyle} builtin from the @t{zsh/zutil} module."
msgstr "作为 @t{zsh/zutil} 模块中 @t{zstyle} 内置命令获取的样式的一部分执行的代码。"

#. type: t{#1}
#: zsh.texi:8863
#, no-wrap
msgid "toplevel"
msgstr "toplevel"

#. type: table
#: zsh.texi:8865
msgid "The highest execution level of a script or interactive shell."
msgstr "脚本或交互式 shell 的最高执行级别。"

#. type: findex
#: zsh.texi:8866 zsh.texi:14742
#, no-wrap
msgid "trap"
msgstr "trap"

#. type: table
#: zsh.texi:8871
msgid "Code executed as a trap defined by the @t{trap} builtin.  Traps defined as functions have the context @t{shfunc}.  As traps are asynchronous they may have a different hierarchy from other code."
msgstr "以 @t{trap} 内置命令定义的陷阱形式执行的代码。 定义为函数的陷阱上下文为 @t{shfunc}。 由于陷阱是异步的，它们的层次结构可能与其他代码不同。"

#. type: findex
#: zsh.texi:8872 zsh.texi:16061 zsh.texi:31969
#, no-wrap
msgid "zpty"
msgstr "zpty"

#. type: table
#: zsh.texi:8874
msgid "Code executed by the @t{zpty} builtin from the @t{zsh/zpty} module."
msgstr "由 @t{zsh/zpty} 模块中的 @t{zpty} 内置命令执行的代码。"

#. type: t{#1}
#: zsh.texi:8875
#, no-wrap
msgid "zregexparse-guard"
msgstr "zregexparse-guard"

#. type: table
#: zsh.texi:8878
msgid "Code executed as a guard by the @t{zregexparse} command from the @t{zsh/zutil} module."
msgstr "@t{zsh/zutil} 模块中的 @t{zregexparse} 命令执行时，会被作为保护代码执行。"

#. type: t{#1}
#: zsh.texi:8879
#, no-wrap
msgid "zregexparse-action"
msgstr "zregexparse-action"

#. type: table
#: zsh.texi:8882
msgid "Code executed as an action by the @t{zregexparse} command from the @t{zsh/zutil} module."
msgstr "由 @t{zsh/zutil} 模块中的 @t{zregexparse} 命令作为操作（action）执行的代码。"

#. type: t{#1}
#: zsh.texi:8885 zsh.texi:8886
#, no-wrap
msgid "ZSH_ARGZERO"
msgstr "ZSH_ARGZERO"

#. type: table
#: zsh.texi:8891
msgid ""
"If zsh was invoked to run a script, this is the name of the script.  Otherwise, it is the name used to invoke the current shell.  This is the same as the value of @t{$0} when the @t{POSIX_ARGZERO} option "
"is set, but is always available."
msgstr "如果调用 zsh 是为了运行脚本，则这是脚本的名称。 否则，它就是用于调用当前 shell 的名称。 这与设置 @t{POSIX_ARGZERO} 选项时 @t{$0} 的值相同，但始终可用。"

#. type: t{#1}
#: zsh.texi:8892 zsh.texi:8893
#, no-wrap
msgid "ZSH_EXECUTION_STRING"
msgstr "ZSH_EXECUTION_STRING"

#. type: table
#: zsh.texi:8896
msgid "If the shell was started with the option @t{-c}, this contains the argument passed to the option.  Otherwise it is not set."
msgstr "如果 shell 是使用 @t{-c} 选项启动的，则此处包含该选项传递的参数。 否则不设置。"

#. type: t{#1}
#: zsh.texi:8897 zsh.texi:8898
#, no-wrap
msgid "ZSH_NAME"
msgstr "ZSH_NAME"

#. type: table
#: zsh.texi:8901
msgid "Expands to the basename of the command used to invoke this instance of zsh."
msgstr "扩展为用于调用此 zsh 实例的命令的基名。"

#. type: t{#1}
#: zsh.texi:8902 zsh.texi:8903
#, no-wrap
msgid "ZSH_PATCHLEVEL"
msgstr "ZSH_PATCHLEVEL"

#. type: table
#: zsh.texi:8909
msgid ""
"The output of `@t{git describe --tags --long}' for the zsh repository used to build the shell.  This is most useful in order to keep track of versions of the shell during development between releases; "
"hence most users should not use it and should instead rely on @t{$ZSH_VERSION}."
msgstr "用于构建 shell 的 zsh 仓库的 `@t{git describe --tags --long}' 输出。 在开发过程中，为了跟踪 shell 的发布版本，这个输出是最有用的；因此大多数用户不应使用它，而应依赖 @t{$ZSH_VERSION}。"

#. type: t{#1}
#: zsh.texi:8910 zsh.texi:30226 zsh.texi:30227
#, no-wrap
msgid "zsh_scheduled_events"
msgstr "zsh_scheduled_events"

#. type: table
#: zsh.texi:8912 zsh.texi:14586
msgid "See @ref{The zsh/sched Module}."
msgstr "参见 @ref{zsh/sched 模块}."

#. type: t{#1}
#: zsh.texi:8913 zsh.texi:8914
#, no-wrap
msgid "ZSH_SCRIPT"
msgstr "ZSH_SCRIPT"

#. type: table
#: zsh.texi:8917
msgid "If zsh was invoked to run a script, this is the name of the script, otherwise it is unset."
msgstr "如果调用 zsh 是为了运行脚本，则这是脚本的名称，否则不设置。"

#. type: vindex
#: zsh.texi:8918
#, no-wrap
msgid "ZSH_SUBSHELL <S>"
msgstr "ZSH_SUBSHELL <S>"

#. type: t{#1}
#: zsh.texi:8919
#, no-wrap
msgid "ZSH_SUBSHELL"
msgstr "ZSH_SUBSHELL"

#. type: table
#: zsh.texi:8924
msgid ""
"Readonly integer.  Initially zero, incremented each time the shell forks to create a subshell for executing code.  Hence `@t{(print $ZSH_SUBSHELL)}' and `@t{print $(print $ZSH_SUBSHELL)}' output 1, while "
"`@t{( (print $ZSH_SUBSHELL) )}' outputs 2."
msgstr ""
"只读整数。 初始值为 0，每次 shell 分叉创建用于执行代码的子 shell 时都会递增。 因此， `@t{(print $ZSH_SUBSHELL)}' 和 `@t{print $(print $ZSH_SUBSHELL)}' 输出 1，而 `@t{( (print $ZSH_SUBSHELL) )}' 输出 2。"

#. type: t{#1}
#: zsh.texi:8925 zsh.texi:8926
#, no-wrap
msgid "ZSH_VERSION"
msgstr "ZSH_VERSION"

#. type: table
#: zsh.texi:8928
msgid "The version number of the release of zsh."
msgstr "zsh 版本的版本号。"

#. type: Plain text
#: zsh.texi:8937
msgid ""
"The following parameters are used by the shell.  Again, `<S>' indicates that the parameter is special and `<Z>' indicates that the parameter does not exist when the shell initializes in @t{sh} or @t{ksh} "
"emulation mode."
msgstr "shell 会使用下列参数。 同样， `<S>' 表示该参数是特殊的， `<Z>'  表示当 shell 在 @t{sh} 或 @t{ksh} 模拟模式下初始化时，该参数不存在。"

#. type: Plain text
#: zsh.texi:8948
msgid ""
"In cases where there are two parameters with an upper- and lowercase form of the same name, such as @t{path} and @t{PATH}, the lowercase form is an array and the uppercase form is a scalar with the "
"elements of the array joined together by colons.  These are similar to tied parameters created via `@t{typeset -T}'.  The normal use for the colon-separated form is for exporting to the environment, while "
"the array form is easier to manipulate within the shell.  Note that unsetting either of the pair will unset the other; they retain their special properties when recreated, and recreating one of the pair "
"will recreate the other."
msgstr ""
"如果两个参数的是同一个名称的大小写版本，例如 @t{path} 和 @t{PATH}，则小写形式的参数是一个数组，大写形式的参数是一个标量（以数组中的元素用冒号连接在一起组成）。 这些参数类似于通过 `@t{typeset -T}' 创建的绑"
"定参数。 以冒号分隔的形式通常用于导出到环境中，而数组形式则更易于在 shell 中操作。 需要注意的是，取消设置这对参数中的任何一个都会取消设置另一个；它们在重新创建时会保留各自的特殊属性，重新创建这对参数中的一"
"个也会重新创建另一个。"

#. type: t{#1}
#: zsh.texi:8951 zsh.texi:8952
#, no-wrap
msgid "ARGV0"
msgstr "ARGV0"

#. type: table
#: zsh.texi:8955
msgid "If exported, its value is used as the @t{argv[0]} of external commands.  Usually used in constructs like `@t{ARGV0=emacs nethack}'."
msgstr "如果导出，其值将用作外部命令的 @t{argv[0]}。 通常用于 `@t{ARGV0=emacs nethack}' 等结构体。"

#. type: cindex
#: zsh.texi:8956
#, no-wrap
msgid "editing over slow connection"
msgstr "通过慢速连接进行编辑"

#. type: cindex
#: zsh.texi:8957
#, no-wrap
msgid "slow connection, editing over"
msgstr "慢速连接, 编辑"

#. type: t{#1}
#: zsh.texi:8958 zsh.texi:8959
#, no-wrap
msgid "BAUD"
msgstr "BAUD"

#. type: table
#: zsh.texi:8965
msgid ""
"The rate in bits per second at which data reaches the terminal.  The line editor will use this value in order to compensate for a slow terminal by delaying updates to the display until necessary.  If the "
"parameter is unset or the value is zero the compensation mechanism is turned off.  The parameter is not set by default."
msgstr "数据到达终端的速率（比特/秒）。 行编辑器将使用该值对缓慢的终端进行补偿，在必要时延迟更新显示内容。 如果参数未设置或值为零，补偿机制将被关闭。 默认情况下不设置该参数。"

#. type: table
#: zsh.texi:8971
msgid ""
"This parameter may be profitably set in some circumstances, e.g.  for slow modems dialing into a communications server, or on a slow wide area network.  It should be set to the baud rate of the slowest "
"part of the link for best performance."
msgstr "在某些情况下，例如对于拨号到通信服务器的慢速调制解调器或在慢速广域网中，设置该参数可能是有益的。 应将其设置为链路最慢部分的波特率，以获得最佳性能。"

#. type: vindex
#: zsh.texi:8972
#, no-wrap
msgid "cdpath"
msgstr "cdpath"

#. type: vindex
#: zsh.texi:8973
#, no-wrap
msgid "CDPATH"
msgstr "CDPATH"

#. type: item
#: zsh.texi:8974
#, no-wrap
msgid "@t{cdpath} <S> <Z> (@t{CDPATH} <S>)"
msgstr "@t{cdpath} <S> <Z> (@t{CDPATH} <S>)"

#. type: table
#: zsh.texi:8977
msgid "An array (colon-separated list)  of directories specifying the search path for the @t{cd} command."
msgstr "指定 @t{cd} 命令搜索路径的目录数组（以冒号分隔的列表）。"

#. type: vindex
#: zsh.texi:8978
#, no-wrap
msgid "COLUMNS"
msgstr "COLUMNS"

#. type: item
#: zsh.texi:8979
#, no-wrap
msgid "@t{COLUMNS} <S>"
msgstr "@t{COLUMNS} <S>"

#. type: table
#: zsh.texi:8982
msgid "The number of columns for this terminal session.  Used for printing select lists and for the line editor."
msgstr "该终端会话的列数。 用于打印选择列表和行编辑器。"

#. type: t{#1}
#: zsh.texi:8983 zsh.texi:8984
#, no-wrap
msgid "CORRECT_IGNORE"
msgstr "CORRECT_IGNORE"

#. type: table
#: zsh.texi:8993
msgid ""
"If set, is treated as a pattern during spelling correction.  Any potential correction that matches the pattern is ignored.  For example, if the value is `@t{_*}' then completion functions (which, by "
"convention, have names beginning with `@t{_}') will never be offered as spelling corrections.  The pattern does not apply to the correction of file names, as applied by the @t{CORRECT_ALL} option (so with "
"the example just given files beginning with `@t{_}' in the current directory would still be completed)."
msgstr ""
"如果设置，则在拼写纠错过程中被视为模式。 任何与该模式匹配的潜在纠错都会被忽略。 例如，如果值为 `@t{_*}' ，则补全函数（按照惯例，其名称以 `@t{_}' 开头）将永远不会作为拼写纠错提供。 该模式不适用于 "
"@t{CORRECT_ALL} 选项对文件名的纠错（因此，在刚才的例子中，当前目录中以 `@t{_}' 开头的文件仍会被补全）。"

#. type: t{#1}
#: zsh.texi:8994 zsh.texi:8995
#, no-wrap
msgid "CORRECT_IGNORE_FILE"
msgstr "CORRECT_IGNORE_FILE"

#. type: table
#: zsh.texi:9001
msgid ""
"If set, is treated as a pattern during spelling correction of file names.  Any file name that matches the pattern is never offered as a correction.  For example, if the value is `@t{.*}' then dot file "
"names will never be offered as spelling corrections.  This is useful with the @t{CORRECT_ALL} option."
msgstr "如果设置，在文件名拼写纠错时将被视为模式。 任何与该模式匹配的文件名都不会作为纠错提供。 例如，如果值为 `@t{.*}' ，则点文件名永远不会作为拼写纠错提供。 这对于和 @t{CORRECT_ALL} 选项一起使用非常有用。"

#. type: t{#1}
#: zsh.texi:9002 zsh.texi:9003
#, no-wrap
msgid "DIRSTACKSIZE"
msgstr "DIRSTACKSIZE"

#. type: table
#: zsh.texi:9007
msgid "The maximum size of the directory stack, by default there is no limit.  If the stack gets larger than this, it will be truncated automatically.  This is useful with the @t{AUTO_PUSHD} option."
msgstr "目录堆栈的最大大小，默认情况下没有限制。 如果目录栈大于此值，将自动截断。 这和 @t{AUTO_PUSHD} 选项一起使用非常有用。"

#. type: pindex
#: zsh.texi:9007
#, no-wrap
msgid "AUTO_PUSHD, use of"
msgstr "AUTO_PUSHD, use of"

#. type: t{#1}
#: zsh.texi:9009 zsh.texi:9010
#, no-wrap
msgid "ENV"
msgstr "ENV"

#. type: table
#: zsh.texi:9017
msgid ""
"If the @t{ENV} environment variable is set when zsh is invoked as @t{sh} or @t{ksh}, @t{$ENV} is sourced after the profile scripts.  The value of @t{ENV} is subjected to parameter expansion, command "
"substitution, and arithmetic expansion before being interpreted as a pathname.  Note that @t{ENV} is @emph{not} used unless the shell is interactive and zsh is emulating @cite{sh} or @cite{ksh}."
msgstr ""
"如果在以 @t{sh} 或 @t{ksh} 的方式调用 zsh 时设置了 @t{ENV} 环境变量，则 @t{$ENV} 将在 profile 脚本之后引入。 在将 @t{ENV} 的值解释为路径名之前，会对其进行参数扩展、命令替换和算术扩展。 请注意，除非 shell "
"是交互式的，并且 zsh 正在模拟 @cite{sh} 或 @cite{ksh}，否则 @t{ENV}是 @emph{不}被使用的。"

#. type: t{#1}
#: zsh.texi:9018 zsh.texi:9019
#, no-wrap
msgid "FCEDIT"
msgstr "FCEDIT"

#. type: table
#: zsh.texi:9023
msgid "The default editor for the @t{fc} builtin.  If @t{FCEDIT} is not set, the parameter @t{EDITOR} is used; if that is not set either, a builtin default, usually @t{vi}, is used."
msgstr "@t{fc} 内置编辑器的默认编辑器。 如果未设置 @t{FCEDIT}，则使用参数 @t{EDITOR}；如果也未设置 ，则使用内置默认编辑器，通常是 @t{vi}。"

#. type: vindex
#: zsh.texi:9024
#, no-wrap
msgid "fignore"
msgstr "fignore"

#. type: vindex
#: zsh.texi:9025
#, no-wrap
msgid "FIGNORE"
msgstr "FIGNORE"

#. type: item
#: zsh.texi:9026
#, no-wrap
msgid "@t{fignore} <S> <Z> (@t{FIGNORE} <S>)"
msgstr "@t{fignore} <S> <Z> (@t{FIGNORE} <S>)"

#. type: table
#: zsh.texi:9031
msgid ""
"An array (colon separated list)  containing the suffixes of files to be ignored during filename completion.  However, if completion only generates files with suffixes in this list, then these files are "
"completed anyway."
msgstr "数组（冒号分隔的列表），包含在文件名补全过程中要忽略的文件后缀。 不过，如果补全在此列表中只生成带后缀的文件，那么这些文件还是会被补全。"

#. type: vindex
#: zsh.texi:9032
#, no-wrap
msgid "fpath"
msgstr "fpath"

#. type: vindex
#: zsh.texi:9033
#, no-wrap
msgid "FPATH"
msgstr "FPATH"

#. type: item
#: zsh.texi:9034
#, no-wrap
msgid "@t{fpath} <S> <Z> (@t{FPATH} <S>)"
msgstr "@t{fpath} <S> <Z> (@t{FPATH} <S>)"

#. type: table
#: zsh.texi:9040
msgid ""
"An array (colon separated list)  of directories specifying the search path for function definitions.  This path is searched when a function with the @t{-u} attribute is referenced.  If an executable file "
"is found, then it is read and executed in the current environment."
msgstr "指定函数定义搜索路径的目录数组（冒号分隔列表）。 当带有 @t{-u} 属性的函数被引用时，将搜索该路径。 如果找到可执行文件，则在当前环境下读取并执行该文件。"

#. type: vindex
#: zsh.texi:9041
#, no-wrap
msgid "histchars"
msgstr "histchars"

#. type: item
#: zsh.texi:9042
#, no-wrap
msgid "@t{histchars} <S>"
msgstr "@t{histchars} <S>"

#. type: table
#: zsh.texi:9048
msgid ""
"Three characters used by the shell's history and lexical analysis mechanism.  The first character signals the start of a history expansion (default `@t{!}').  The second character signals the start of a "
"quick history substitution (default `@t{^}').  The third character is the comment character (default `@t{#}')."
msgstr "shell 的历史和词法分析机制使用的三个字符。 第一个字符表示历史扩展的开始（默认为 `@t{!}' ）。 第二个字符表示快速历史替换的开始（默认为`@t{^}'）。 第三个字符是注释字符（默认为`@t{#}'）。"

#. type: table
#: zsh.texi:9053
msgid "The characters must be in the ASCII character set; any attempt to set @t{histchars} to characters with a locale-dependent meaning will be rejected with an error message."
msgstr "字符必须是 ASCII 字符集中的字符；任何将 @t{histchars} 设置为具有区域相关（locale-dependent）的字符的尝试都会被拒绝，并显示错误信息。"

#. type: vindex
#: zsh.texi:9054
#, no-wrap
msgid "HISTCHARS"
msgstr "HISTCHARS"

#. type: item
#: zsh.texi:9055
#, no-wrap
msgid "@t{HISTCHARS} <S> <Z>"
msgstr "@t{HISTCHARS} <S> <Z>"

#. type: table
#: zsh.texi:9057
msgid "Same as @t{histchars}.  (Deprecated.)"
msgstr "与 @t{histchars} 相同。 (已废弃）。"

#. type: t{#1}
#: zsh.texi:9058 zsh.texi:9059
#, no-wrap
msgid "HISTFILE"
msgstr "HISTFILE"

#. type: table
#: zsh.texi:9062
msgid "The file to save the history in when an interactive shell exits.  If unset, the history is not saved."
msgstr "交互式 shell 退出时保存历史记录的文件。 如果未设置，则不保存历史记录。"

#. type: t{#1}
#: zsh.texi:9063 zsh.texi:9064
#, no-wrap
msgid "HISTORY_IGNORE"
msgstr "HISTORY_IGNORE"

#. type: table
#: zsh.texi:9069
msgid ""
"If set, is treated as a pattern at the time history files are written.  Any potential history entry that matches the pattern is skipped.  For example, if the value is `@t{fc *}' then commands that invoke "
"the interactive history editor are never written to the history file."
msgstr "如果设置，则在写入历史文件时被视为一种模式。 任何与该模式匹配的潜在历史条目都会被跳过。 例如，如果值为 `@t{fc *}' ，则调用交互式历史编辑器的命令永远不会写入历史文件。"

#. type: table
#: zsh.texi:9074
msgid "Note that @t{HISTORY_IGNORE} defines a single pattern: to specify alternatives use the `@t{(}@var{first}@t{|}@var{second}@t{|}@var{...}@t{)}' syntax."
msgstr "请注意，@t{HISTORY_IGNORE} 只定义了一种模式：要指定其他模式，请使用 `@t{(}@var{first}@t{|}@var{second}@t{|}@var{...}@t{)}' 语法。"

#. type: table
#: zsh.texi:9081
msgid ""
"Compare the @t{HIST_NO_STORE} option or the @t{zshaddhistory} hook, either of which would prevent such commands from being added to the interactive history at all.  If you wish to use @t{HISTORY_IGNORE} "
"to stop history being added in the first place, you can define the following hook:"
msgstr "对比 @t{HIST_NO_STORE} 选项或 @t{zshaddhistory} 钩子，这两种方法都会阻止此类命令被添加到交互式历史记录中。 如果希望使用 @t{HISTORY_IGNORE} 来阻止历史记录的添加，可以定义以下钩子："

#. type: example
#: zsh.texi:9091
#, no-wrap
msgid ""
"zshaddhistory() @{\n"
"  emulate -L zsh\n"
"  ## uncomment if HISTORY_IGNORE\n"
"  ## should use EXTENDED_GLOB syntax\n"
"  # setopt extendedglob\n"
"  [[ $1 != $@{~HISTORY_IGNORE@} ]]\n"
"@}\n"
msgstr ""
"zshaddhistory() @{\n"
"  emulate -L zsh\n"
"  ## uncomment if HISTORY_IGNORE\n"
"  ## should use EXTENDED_GLOB syntax\n"
"  # setopt extendedglob\n"
"  [[ $1 != $@{~HISTORY_IGNORE@} ]]\n"
"@}\n"

#. type: vindex
#: zsh.texi:9093
#, no-wrap
msgid "HISTSIZE"
msgstr "HISTSIZE"

#. type: item
#: zsh.texi:9094
#, no-wrap
msgid "@t{HISTSIZE} <S>"
msgstr "@t{HISTSIZE} <S>"

#. type: table
#: zsh.texi:9099
msgid ""
"The maximum number of events stored in the internal history list.  If you use the @t{HIST_EXPIRE_DUPS_FIRST} option, setting this value larger than the @t{SAVEHIST} size will give you the difference as a "
"cushion for saving duplicated history events."
msgstr "存储在内部历史列表中的最大事件数。 如果使用 @t{HIST_EXPIRE_DUPS_FIRST} 选项，将此值设置为大于 @t{SAVEHIST} 大小，就能获得差值作为保存重复历史事件的缓冲。"

#. type: vindex
#: zsh.texi:9104
#, no-wrap
msgid "HOME"
msgstr "HOME"

#. type: item
#: zsh.texi:9105
#, no-wrap
msgid "@t{HOME} <S>"
msgstr "@t{HOME} <S>"

#. type: table
#: zsh.texi:9110
msgid ""
"The default argument for the @t{cd} command.  This is not set automatically by the shell in @t{sh}, @t{ksh} or @t{csh} emulation, but it is typically present in the environment anyway, and if it becomes "
"set it has its usual special behaviour."
msgstr "@t{cd} 命令的默认参数。在 @t{sh}、@t{ksh} 或 @t{csh} 模拟中，shell 不会自动设置该参数，但通常它会存在于环境中，如果被设置，那么通常会出现特殊行为。"

#. type: vindex
#: zsh.texi:9111
#, no-wrap
msgid "IFS"
msgstr "IFS"

#. type: item
#: zsh.texi:9112
#, no-wrap
msgid "@t{IFS} <S>"
msgstr "@t{IFS} <S>"

#. type: table
#: zsh.texi:9123
msgid ""
"Internal field separators (by default space, tab, newline and NUL), that are used to separate words which result from command or parameter expansion and words read by the @t{read} builtin.  Any characters "
"from the set space, tab and newline that appear in the IFS are called @emph{IFS white space}.  One or more IFS white space characters or one non-IFS white space character together with any adjacent IFS "
"white space character delimit a field.  If an IFS white space character appears twice consecutively in the IFS, this character is treated as if it were not an IFS white space character."
msgstr ""
"内部字段分隔符（默认为空格、制表符、换行符和 NUL），用于分隔命令或参数扩展产生的字和 @t{read} 内置命令读取的词。 在 IFS 中出现的空格、制表符和换行符中的任何字符都称为 @emph{IFS空白字符}。 一个或多个 IFS 空"
"白字符或一个非 IFS 空白字符连同任何相邻的 IFS 空格字符构成一个字段的分界。 如果一个 IFS 空白字符在 IFS 中连续出现两次，该字符不会被视为  IFS 空格字符。"

#. type: table
#: zsh.texi:9127
msgid "If the parameter is unset, the default is used.  Note this has a different effect from setting the parameter to an empty string."
msgstr "如果参数未设置，则使用默认值。 请注意，这与将参数设置为空字符串的效果不同。"

#. type: t{#1}
#: zsh.texi:9128 zsh.texi:9129
#, no-wrap
msgid "KEYBOARD_HACK"
msgstr "KEYBOARD_HACK"

#. type: table
#: zsh.texi:9137
msgid ""
"This variable defines a character to be removed from the end of the command line before interpreting it (interactive shells only). It is intended to fix the problem with keys placed annoyingly close to "
"return and replaces the @t{SUNKEYBOARDHACK} option which did this for backquotes only.  Should the chosen character be one of singlequote, doublequote or backquote, there must also be an odd number of "
"them on the command line for the last one to be removed."
msgstr ""
"该变量定义了在解释命令行（仅限交互式 shell）之前从命令行末尾移除的字符。它的目的是解决按键与回车键距离过近的问题，并取代 @t{SUNKEYBOARDHACK} 选项，后者只针对反引号。 如果选择的字符是单引号、双引号或反引号"
"之一，那么命令行中必须有奇数个单引号、双引号或反引号，最后一个才会被移除。"

#. type: table
#: zsh.texi:9142
msgid ""
"For backward compatibility, if the @t{SUNKEYBOARDHACK} option is explicitly set, the value of @t{KEYBOARD_HACK} reverts to backquote.  If the option is explicitly unset, this variable is set to empty."
msgstr "为了向后兼容，如果 @t{SUNKEYBOARDHACK} 选项被明确设置，@t{KEYBOARD_HACK} 的值将恢复为反引号。 如果明确未设置该选项，则该变量将被设置为空。"

#. type: t{#1}
#: zsh.texi:9143 zsh.texi:9144
#, no-wrap
msgid "KEYTIMEOUT"
msgstr "KEYTIMEOUT"

#. type: table
#: zsh.texi:9147
msgid "The time the shell waits, in hundredths of seconds, for another key to be pressed when reading bound multi-character sequences."
msgstr "shell 等待的时间， 在读取绑定的多字符序列时等待按下另一个键的时间，以百分之一秒为单位。"

#. type: vindex
#: zsh.texi:9148
#, no-wrap
msgid "LANG"
msgstr "LANG"

#. type: item
#: zsh.texi:9149
#, no-wrap
msgid "@t{LANG} <S>"
msgstr "@t{LANG} <S>"

#. type: table
#: zsh.texi:9152
msgid "This variable determines the locale category for any category not specifically selected via a variable starting with `@t{LC_}'."
msgstr "对于未通过以 `@t{LC_}' 开头的变量具体选择的区域类别，该变量将决定其本地化类别。"

#. type: vindex
#: zsh.texi:9153
#, no-wrap
msgid "LC_ALL"
msgstr "LC_ALL"

#. type: item
#: zsh.texi:9154
#, no-wrap
msgid "@t{LC_ALL} <S>"
msgstr "@t{LC_ALL} <S>"

#. type: table
#: zsh.texi:9157
msgid "This variable overrides the value of the `@t{LANG}' variable and the value of any of the other variables starting with `@t{LC_}'."
msgstr "该变量会覆盖 `@t{LANG}' 变量和其他以 `@t{LC_}' 开头的变量的值。"

#. type: vindex
#: zsh.texi:9158
#, no-wrap
msgid "LC_COLLATE"
msgstr "LC_COLLATE"

#. type: item
#: zsh.texi:9159
#, no-wrap
msgid "@t{LC_COLLATE} <S>"
msgstr "@t{LC_COLLATE} <S>"

#. type: table
#: zsh.texi:9162
msgid "This variable determines the locale category for character collation information within ranges in glob brackets and for sorting."
msgstr "该变量用于确定 glob 括弧范围内字符对比信息和排序的本地化类别。"

#. type: vindex
#: zsh.texi:9163
#, no-wrap
msgid "LC_CTYPE"
msgstr "LC_CTYPE"

#. type: item
#: zsh.texi:9164
#, no-wrap
msgid "@t{LC_CTYPE} <S>"
msgstr "@t{LC_CTYPE} <S>"

#. type: table
#: zsh.texi:9172
msgid ""
"This variable determines the locale category for character handling functions.  If the @t{MULTIBYTE} option is in effect this variable or @t{LANG} should contain a value that reflects the character set in "
"use, even if it is a single-byte character set, unless only the 7-bit subset (ASCII) is used.  For example, if the character set is ISO-8859-1, a suitable value might be @t{en_US.iso88591} (certain Linux "
"distributions) or @t{en_US.ISO8859-1} (MacOS)."
msgstr ""
"该变量决定字符处理功能的本地化类别。 如果使用 @t{MULTIBYTE} 选项，则该变量或 @t{LANG} 应包含一个能反映所用字符集的值，即使是单字节字符集，除非只使用 7 位子集（ASCII）。 例如，如果字符集是 ISO-8859-1，合适"
"的值可能是 @t{en_US.iso88591}（某些 Linux 发行版）或 @t{en_US.ISO8859-1}（MacOS）。"

#. type: vindex
#: zsh.texi:9173
#, no-wrap
msgid "LC_MESSAGES"
msgstr "LC_MESSAGES"

#. type: item
#: zsh.texi:9174
#, no-wrap
msgid "@t{LC_MESSAGES} <S>"
msgstr "@t{LC_MESSAGES} <S>"

#. type: table
#: zsh.texi:9177
msgid "This variable determines the language in which messages should be written.  Note that zsh does not use message catalogs."
msgstr "该变量决定了信息的编写语言。 请注意，zsh 不使用消息类。"

#. type: vindex
#: zsh.texi:9178
#, no-wrap
msgid "LC_NUMERIC"
msgstr "LC_NUMERIC"

#. type: item
#: zsh.texi:9179
#, no-wrap
msgid "@t{LC_NUMERIC} <S>"
msgstr "@t{LC_NUMERIC} <S>"

#. type: table
#: zsh.texi:9184
msgid ""
"This variable affects the decimal point character and thousands separator character for the formatted input/output functions and string conversion functions.  Note that zsh ignores this setting when "
"parsing floating point mathematical expressions."
msgstr "此变量会影响格式化输入/输出函数和字符串转换函数的小数点字符和千位分隔符。 请注意，在解析浮点数学表达式时，zsh 会忽略此设置。"

#. type: vindex
#: zsh.texi:9185
#, no-wrap
msgid "LC_TIME"
msgstr "LC_TIME"

#. type: item
#: zsh.texi:9186
#, no-wrap
msgid "@t{LC_TIME} <S>"
msgstr "@t{LC_TIME} <S>"

#. type: table
#: zsh.texi:9189
msgid "This variable determines the locale category for date and time formatting in prompt escape sequences."
msgstr "该变量决定提示符转义序列中日期和时间格式化的本地化类别。"

#. type: vindex
#: zsh.texi:9190
#, no-wrap
msgid "LINES"
msgstr "LINES"

#. type: item
#: zsh.texi:9191
#, no-wrap
msgid "@t{LINES} <S>"
msgstr "@t{LINES} <S>"

#. type: table
#: zsh.texi:9194
msgid "The number of lines for this terminal session.  Used for printing select lists and for the line editor."
msgstr "该终端会话的行数。 用于打印选择列表和行编辑器。"

#. type: t{#1}
#: zsh.texi:9195 zsh.texi:9196
#, no-wrap
msgid "LISTMAX"
msgstr "LISTMAX"

#. type: table
#: zsh.texi:9202
msgid ""
"In the line editor, the number of matches to list without asking first. If the value is negative, the list will be shown if it spans at most as many lines as given by the absolute value.  If set to zero, "
"the shell asks only if the top of the listing would scroll off the screen."
msgstr "在行编辑器中，无需先询问即可列出的匹配条数。如果该值为负数，则最多只能显示与绝对值相同行数的列表。 如果设置为零，则 shell 仅在列表顶部会滚动出屏幕时才会询问。"

#. type: t{#1}
#: zsh.texi:9203 zsh.texi:9204
#, no-wrap
msgid "MAIL"
msgstr "MAIL"

#. type: table
#: zsh.texi:9207
msgid "If this parameter is set and @t{mailpath} is not set, the shell looks for mail in the specified file."
msgstr "如果设置了该参数，而 @t{mailpath} 未设置，shell 会在指定文件中查找邮件。"

#. type: t{#1}
#: zsh.texi:9208 zsh.texi:9209
#, no-wrap
msgid "MAILCHECK"
msgstr "MAILCHECK"

#. type: table
#: zsh.texi:9211
msgid "The interval in seconds between checks for new mail."
msgstr "检查新邮件的间隔时间（秒）。"

#. type: vindex
#: zsh.texi:9212
#, no-wrap
msgid "mailpath"
msgstr "mailpath"

#. type: vindex
#: zsh.texi:9213
#, no-wrap
msgid "MAILPATH"
msgstr "MAILPATH"

#. type: item
#: zsh.texi:9214
#, no-wrap
msgid "@t{mailpath} <S> <Z> (@t{MAILPATH} <S>)"
msgstr "@t{mailpath} <S> <Z> (@t{MAILPATH} <S>)"

#. type: table
#: zsh.texi:9224
msgid ""
"An array (colon-separated list) of filenames to check for new mail.  Each filename can be followed by a `@t{?}' and a message that will be printed.  The message will undergo parameter expansion, command "
"substitution and arithmetic expansion with the variable @t{$_} defined as the name of the file that has changed.  The default message is `@t{You have new mail}'.  If an element is a directory instead of a "
"file the shell will recursively check every file in every subdirectory of the element."
msgstr ""
"用于检查新邮件的文件名数组（以冒号分隔的列表）。 每个文件名后可跟一个 `@t{?}' 和一条将被打印的信息。 信息将进行参数扩展、命令替换和算术扩展，变量 @t{$_} 被定义为已更改的文件名。 默认信息为 `@t{You have "
"new mail}' 。 如果元素是目录而不是文件，shell 将递归检查元素的每个子目录中的每个文件。"

#. type: vindex
#: zsh.texi:9225
#, no-wrap
msgid "manpath"
msgstr "manpath"

#. type: vindex
#: zsh.texi:9226
#, no-wrap
msgid "MANPATH"
msgstr "MANPATH"

#. type: item
#: zsh.texi:9227
#, no-wrap
msgid "@t{manpath} <S> <Z> (@t{MANPATH} <S> <Z>)"
msgstr "@t{manpath} <S> <Z> (@t{MANPATH} <S> <Z>)"

#. type: table
#: zsh.texi:9232
msgid "An array (colon-separated list)  whose value is not used by the shell.  The @t{manpath} array can be useful, however, since setting it also sets @t{MANPATH}, and vice versa."
msgstr "数组（以冒号分隔的列表），其值不被 shell 使用。 不过，@t{manpath} 数组可能很有用，因为设置它也会设置 @t{MANPATH}，反之亦然。"

#. type: table
#: zsh.texi:9239
msgid "Arrays set by the shell when the @t{b} globbing flag is used in pattern matches.  See the subsection @emph{Globbing flags} in @ref{Filename Generation}."
msgstr "在模式匹配中使用 @t{b} globbing 标志时由 shell 设置的数组。 参见 @ref{文件名生成} 中的 @emph{Globbing 标志} 小节。"

#. type: table
#: zsh.texi:9246
msgid "Set by the shell when the @t{m} globbing flag is used in pattern matches.  See the subsection @emph{Globbing flags} in @ref{Filename Generation}."
msgstr "在模式匹配中使用 @t{m} globbing 标志时由 shell 设置。 参见 @ref{文件名生成} 中的 @emph{Globbing 标志} 小节。"

#. type: vindex
#: zsh.texi:9247
#, no-wrap
msgid "module_path"
msgstr "module_path"

#. type: vindex
#: zsh.texi:9248
#, no-wrap
msgid "MODULE_PATH"
msgstr "MODULE_PATH"

#. type: item
#: zsh.texi:9249
#, no-wrap
msgid "@t{module_path} <S> <Z> (@t{MODULE_PATH} <S>)"
msgstr "@t{module_path} <S> <Z> (@t{MODULE_PATH} <S>)"

#. type: table
#: zsh.texi:9258
msgid ""
"An array (colon-separated list)  of directories that @t{zmodload} searches for dynamically loadable modules.  This is initialized to a standard pathname, usually `@t{/usr/local/lib/zsh/$ZSH_VERSION}'.  "
"(The `@t{/usr/local/lib}' part varies from installation to installation.)  For security reasons, any value set in the environment when the shell is started will be ignored."
msgstr ""
"一个数组（以冒号分隔的列表），包含 @t{zmodload} 用于搜索动态加载模块的目录。 它被初始化为一个标准路径名，通常是 `@t{/usr/local/lib/zsh/$ZSH_VERSION}'。 ( `@t{/usr/local/lib}'  部分因安装情况而异）。出于安"
"全考虑，启动 shell 时在环境中设置的任何值都将被忽略。"

#. type: table
#: zsh.texi:9262
msgid "These parameters only exist if the installation supports dynamic module loading."
msgstr "只有当安装支持动态模块加载时，这些参数才会存在。"

#. type: vindex
#: zsh.texi:9263
#, no-wrap
msgid "NULLCMD"
msgstr "NULLCMD"

#. type: cindex
#: zsh.texi:9264
#, no-wrap
msgid "null command style"
msgstr "空命令样式"

#. type: cindex
#: zsh.texi:9265
#, no-wrap
msgid "csh, null command style"
msgstr "csh, 空命令样式"

#. type: cindex
#: zsh.texi:9266
#, no-wrap
msgid "ksh, null command style"
msgstr "ksh, 空命令样式"

#. type: item
#: zsh.texi:9267
#, no-wrap
msgid "@t{NULLCMD} <S>"
msgstr "@t{NULLCMD} <S>"

#. type: table
#: zsh.texi:9273
msgid ""
"The command name to assume if a redirection is specified with no command.  Defaults to @t{cat}.  For @cite{sh}/@cite{ksh} behavior, change this to @t{:}.  For @cite{csh}-like behavior, unset this "
"parameter; the shell will print an error message if null commands are entered."
msgstr ""
"如果重定向未指定命令，使用的假定的命令名称。 默认为 @t{cat}。 若要使用 @cite{sh}/@cite{ksh} 行为，请将其更改为 @t{:}。 对于 @cite{csh} 风格的行为，请取消设置此参数；如果输入了空命令，shell 将打印错误信息。"

#. type: t{#1}
#: zsh.texi:9274 zsh.texi:23208
#, no-wrap
msgid "path"
msgstr "path"

#. type: vindex
#: zsh.texi:9275
#, no-wrap
msgid "PATH"
msgstr "PATH"

#. type: item
#: zsh.texi:9276
#, no-wrap
msgid "@t{path} <S> <Z> (@t{PATH} <S>)"
msgstr "@t{path} <S> <Z> (@t{PATH} <S>)"

#. type: table
#: zsh.texi:9281
msgid "An array (colon-separated list)  of directories to search for commands.  When this parameter is set, each directory is scanned and all files found are put in a hash table."
msgstr "用于搜索命令的目录数组（以冒号分隔的列表）。 设置该参数后，将扫描每个目录，并将找到的所有文件放入哈希表中。"

#. type: vindex
#: zsh.texi:9282
#, no-wrap
msgid "POSTEDIT"
msgstr "POSTEDIT"

#. type: item
#: zsh.texi:9283
#, no-wrap
msgid "@t{POSTEDIT} <S>"
msgstr "@t{POSTEDIT} <S>"

#. type: table
#: zsh.texi:9286
msgid "This string is output whenever the line editor exits.  It usually contains termcap strings to reset the terminal."
msgstr "该字符串在行编辑器退出时输出。 它通常包含重置终端的 termcap 字符串。"

#. type: vindex
#: zsh.texi:9287
#, no-wrap
msgid "PROMPT"
msgstr "PROMPT"

#. type: item
#: zsh.texi:9288
#, no-wrap
msgid "@t{PROMPT} <S> <Z>"
msgstr "@t{PROMPT} <S> <Z>"

#. type: vindex
#: zsh.texi:9289
#, no-wrap
msgid "PROMPT2"
msgstr "PROMPT2"

#. type: itemx
#: zsh.texi:9290
#, no-wrap
msgid "@t{PROMPT2} <S> <Z>"
msgstr "@t{PROMPT2} <S> <Z>"

#. type: vindex
#: zsh.texi:9291
#, no-wrap
msgid "PROMPT3"
msgstr "PROMPT3"

#. type: itemx
#: zsh.texi:9292
#, no-wrap
msgid "@t{PROMPT3} <S> <Z>"
msgstr "@t{PROMPT3} <S> <Z>"

#. type: vindex
#: zsh.texi:9293
#, no-wrap
msgid "PROMPT4"
msgstr "PROMPT4"

#. type: itemx
#: zsh.texi:9294
#, no-wrap
msgid "@t{PROMPT4} <S> <Z>"
msgstr "@t{PROMPT4} <S> <Z>"

#. type: table
#: zsh.texi:9297
msgid "Same as @t{PS1}, @t{PS2}, @t{PS3} and @t{PS4}, respectively."
msgstr "分别与 @t{PS1}、@t{PS2}、@t{PS3} 和 @t{PS4} 相同。"

#. type: t{#1}
#: zsh.texi:9298 zsh.texi:39726 zsh.texi:41255
#, no-wrap
msgid "prompt"
msgstr "prompt"

#. type: item
#: zsh.texi:9299
#, no-wrap
msgid "@t{prompt} <S> <Z>"
msgstr "@t{prompt} <S> <Z>"

#. type: table
#: zsh.texi:9301
msgid "Same as @t{PS1}."
msgstr "与 @t{PS1} 相同。"

#. type: t{#1}
#: zsh.texi:9302 zsh.texi:9303
#, no-wrap
msgid "PROMPT_EOL_MARK"
msgstr "PROMPT_EOL_MARK"

#. type: table
#: zsh.texi:9309
msgid ""
"When the @t{PROMPT_CR} and @t{PROMPT_SP} options are set, the @t{PROMPT_EOL_MARK} parameter can be used to customize how the end of partial lines are shown.  This parameter undergoes prompt expansion, "
"with the @t{PROMPT_PERCENT} option set.  If not set, the default behavior is equivalent to the value `@t{%B%S%#%s%b}'."
msgstr ""
"设置 @t{PROMPT_CR} 和 @t{PROMPT_SP} 选项后，可以使用 @t{PROMPT_EOL_MARK} 参数自定义部分行结束符的显示方式。 在设置 @t{PROMPT_PERCENT} 选项后，该参数会进行提示符扩展。 如果未设置，默认行为等同于值 "
"`@t{%B%S%#%s%b}'。"

#. type: vindex
#: zsh.texi:9310
#, no-wrap
msgid "PS1"
msgstr "PS1"

#. type: item
#: zsh.texi:9311
#, no-wrap
msgid "@t{PS1} <S>"
msgstr "@t{PS1} <S>"

#. type: table
#: zsh.texi:9316
msgid "The primary prompt string, printed before a command is read.  It undergoes a special form of expansion before being displayed; see @ref{Prompt Expansion}.  The default is `@t{%m%# }'."
msgstr "主要提示符字符串，在读取命令前打印。 在显示之前，它会经过特殊形式的扩展；请参阅 @ref{提示符扩展}。 默认值为`@t{%m%# }'。"

#. type: vindex
#: zsh.texi:9317
#, no-wrap
msgid "PS2"
msgstr "PS2"

#. type: item
#: zsh.texi:9318
#, no-wrap
msgid "@t{PS2} <S>"
msgstr "@t{PS2} <S>"

#. type: table
#: zsh.texi:9324
msgid ""
"The secondary prompt, printed when the shell needs more information to complete a command.  It is expanded in the same way as @t{PS1}.  The default is `@t{%_> }', which displays any shell constructs or "
"quotation marks which are currently being processed."
msgstr "次级提示符，在 shell 需要更多信息来完成命令时打印。 其展开方式与 @t{PS1} 相同。 默认值为 `@t{%_> }'，显示当前正在处理的任何 shell 结构或引号。"

#. type: vindex
#: zsh.texi:9325
#, no-wrap
msgid "PS3"
msgstr "PS3"

#. type: item
#: zsh.texi:9326
#, no-wrap
msgid "@t{PS3} <S>"
msgstr "@t{PS3} <S>"

#. type: table
#: zsh.texi:9330
msgid "Selection prompt used within a @t{select} loop.  It is expanded in the same way as @t{PS1}.  The default is `@t{?# }'."
msgstr "在 @t{select} 循环中使用的选择提示符。 其展开方式与 @t{PS1} 相同。 默认为 `@t{?# }'。"

#. type: vindex
#: zsh.texi:9331
#, no-wrap
msgid "PS4"
msgstr "PS4"

#. type: item
#: zsh.texi:9332
#, no-wrap
msgid "@t{PS4} <S>"
msgstr "@t{PS4} <S>"

#. type: table
#: zsh.texi:9336
msgid "The execution trace prompt.  Default is `@t{+%N:%i> }', which displays the name of the current shell structure and the line number within it.  In sh or ksh emulation, the default is `@t{+ }'."
msgstr "执行跟踪提示符。 默认为 `@t{+%N:%i> }'，显示当前 shell 结构的名称及其中的行号。 在 sh 或 ksh 模拟中，默认为 `@t{+ }'。"

#. type: vindex
#: zsh.texi:9337
#, no-wrap
msgid "psvar"
msgstr "psvar"

#. type: vindex
#: zsh.texi:9338
#, no-wrap
msgid "PSVAR"
msgstr "PSVAR"

#. type: item
#: zsh.texi:9339
#, no-wrap
msgid "@t{psvar} <S> <Z> (@t{PSVAR} <S>)"
msgstr "@t{psvar} <S> <Z> (@t{PSVAR} <S>)"

#. type: table
#: zsh.texi:9343
msgid "An array (colon-separated list) whose elements can be used in @t{PROMPT} strings.  Setting @t{psvar} also sets @t{PSVAR}, and vice versa."
msgstr "数组（以冒号分隔的列表），其元素可用于 @t{PROMPT} 字符串。 设置 @t{psvar} 也会设置 @t{PSVAR}，反之亦然。"

#. type: vindex
#: zsh.texi:9344
#, no-wrap
msgid "READNULLCMD"
msgstr "READNULLCMD"

#. type: item
#: zsh.texi:9345
#, no-wrap
msgid "@t{READNULLCMD} <S>"
msgstr "@t{READNULLCMD} <S>"

#. type: table
#: zsh.texi:9348
msgid "The command name to assume if a single input redirection is specified with no command.  Defaults to @t{more}."
msgstr "如果指定的是无命令的单输入重定向时，假定的命令名称。 默认为 @t{more}。"

#. type: t{#1}
#: zsh.texi:9349 zsh.texi:9350
#, no-wrap
msgid "REPORTMEMORY"
msgstr "REPORTMEMORY"

#. type: table
#: zsh.texi:9362
msgid ""
"If nonnegative, commands whose maximum resident set size (roughly speaking, main memory usage) in kilobytes is greater than this value have timing statistics reported.  The format used to output "
"statistics is the value of the @t{TIMEFMT} parameter, which is the same as for the @t{REPORTTIME} variable and the @t{time} builtin; note that by default this does not output memory usage.  Appending "
"@t{\" max RSS %M\"} to the value of @t{TIMEFMT} causes it to output the value that triggered the report.  If @t{REPORTTIME} is also in use, at most a single report is printed for both triggers.  This "
"feature requires the @t{getrusage()} system call, commonly supported by modern Unix-like systems."
msgstr ""
"如果是非负值，则以千字节为单位的最大驻留集大小（粗略地说，就是主内存使用量）大于此值的命令将被报告计时统计信息。 输出统计信息的格式是 @t{TIMEFMT} 参数的值，与 @t{REPORTTIME} 变量和 @t{time} 内置命令相同；"
"注意，默认情况下不输出内存使用情况。 在 @t{TIMEFMT} 值后面加上  @t{\" max RSS %M\"}，就会输出触发报告的值。 如果 @t{REPORTTIME} 也在使用中，则两个触发器最多只能打印一份报告。 此功能需要使用 @t{getrusage()}"
"系统调用，现代类 Unix 系统通常都支持该调用。"

#. type: t{#1}
#: zsh.texi:9363 zsh.texi:9364
#, no-wrap
msgid "REPORTTIME"
msgstr "REPORTTIME"

#. type: table
#: zsh.texi:9371
msgid ""
"If nonnegative, commands whose combined user and system execution times (measured in seconds) are greater than this value have timing statistics printed for them.  Output is suppressed for commands "
"executed within the line editor, including completion; commands explicitly marked with the @t{time} keyword still cause the summary to be printed in this case."
msgstr ""
"如果是非负值，则用户和系统执行时间（以秒为单位）之和大于此值的命令将被打印计时统计数据。 在行编辑器中执行的命令（包括补全）的输出将被抑制（suppressed）；在这种情况下，用 @t{time} 关键字明确标记的命令仍会打"
"印摘要。"

#. type: t{#1}
#: zsh.texi:9372 zsh.texi:9373
#, no-wrap
msgid "REPLY"
msgstr "REPLY"

#. type: table
#: zsh.texi:9380
msgid ""
"This parameter is reserved by convention to pass string values between shell scripts and shell builtins in situations where a function call or redirection are impossible or undesirable.  The @t{read} "
"builtin and the @t{select} complex command may set @t{REPLY}, and filename generation both sets and examines its value when evaluating certain expressions.  Some modules also employ @t{REPLY} for similar "
"purposes."
msgstr ""
"按照惯例，该参数用于在不可能或不希望调用函数或重定向的情况下，在 shell 脚本和 shell 内置命令之间传递字符串值。 @t{read} 内置命令和 @t{select} 复杂命令可以设置 @t{REPLY}，而文件名生成器在计算某些表达式时，"
"既可以设置也可以检查其值。 某些模块也使用 @t{REPLY} 来达到类似目的。"

#. type: t{#1}
#: zsh.texi:9381 zsh.texi:9382
#, no-wrap
msgid "reply"
msgstr "reply"

#. type: table
#: zsh.texi:9384
msgid "As @t{REPLY}, but for array values rather than strings."
msgstr "与 @t{REPLY}相同，但用于数组值而非字符串。"

#. type: vindex
#: zsh.texi:9385
#, no-wrap
msgid "RPROMPT"
msgstr "RPROMPT"

#. type: item
#: zsh.texi:9386
#, no-wrap
msgid "@t{RPROMPT} <S>"
msgstr "@t{RPROMPT} <S>"

#. type: vindex
#: zsh.texi:9387
#, no-wrap
msgid "RPS1"
msgstr "RPS1"

#. type: itemx
#: zsh.texi:9388
#, no-wrap
msgid "@t{RPS1} <S>"
msgstr "@t{RPS1} <S>"

#. type: table
#: zsh.texi:9393
msgid ""
"This prompt is displayed on the right-hand side of the screen when the primary prompt is being displayed on the left.  This does not work if the @t{SINGLE_LINE_ZLE} option is set.  It is expanded in the "
"same way as @t{PS1}."
msgstr "当主提示符显示在屏幕左侧时，该提示将符显示在屏幕右侧。 如果设置了 @t{SINGLE_LINE_ZLE} 选项，则此提示符不起作用。 其扩展方式与 @t{PS1} 相同。"

#. type: vindex
#: zsh.texi:9394
#, no-wrap
msgid "RPROMPT2"
msgstr "RPROMPT2"

#. type: item
#: zsh.texi:9395
#, no-wrap
msgid "@t{RPROMPT2} <S>"
msgstr "@t{RPROMPT2} <S>"

#. type: vindex
#: zsh.texi:9396
#, no-wrap
msgid "RPS2"
msgstr "RPS2"

#. type: itemx
#: zsh.texi:9397
#, no-wrap
msgid "@t{RPS2} <S>"
msgstr "@t{RPS2} <S>"

#. type: table
#: zsh.texi:9402
msgid ""
"This prompt is displayed on the right-hand side of the screen when the secondary prompt is being displayed on the left.  This does not work if the @t{SINGLE_LINE_ZLE} option is set.  It is expanded in the "
"same way as @t{PS2}."
msgstr "当次级提示符显示在屏幕左侧时，该提示将显示在屏幕右侧。 如果设置了 @t{SINGLE_LINE_ZLE} 选项，则此提示符不起作用。 其扩展方式与 @t{PS2} 相同。"

#. type: t{#1}
#: zsh.texi:9403 zsh.texi:9404
#, no-wrap
msgid "SAVEHIST"
msgstr "SAVEHIST"

#. type: table
#: zsh.texi:9406
msgid "The maximum number of history events to save in the history file."
msgstr "要保存在历史文件中的历史事件的最大数量。"

#. type: vindex
#: zsh.texi:9411
#, no-wrap
msgid "SPROMPT"
msgstr "SPROMPT"

#. type: item
#: zsh.texi:9412
#, no-wrap
msgid "@t{SPROMPT} <S>"
msgstr "@t{SPROMPT} <S>"

#. type: table
#: zsh.texi:9417
msgid ""
"The prompt used for spelling correction.  The sequence `@t{%R}' expands to the string which presumably needs spelling correction, and `@t{%r}' expands to the proposed correction.  All other prompt escapes "
"are also allowed."
msgstr "用于拼写更正的提示符。 序列 `@t{%R}' 扩展为需要拼写更正的字符串，`@t{%r}'  展开为建议更正的字符串。 还允许使用所有其他提示符转义。"

#. type: table
#: zsh.texi:9420
msgid "The actions available at the prompt are @t{[nyae]}:"
msgstr "提示符下可用的操作是 @t{[nyae]}："

#. type: item
#: zsh.texi:9421
#, no-wrap
msgid "@t{n} (`no') (default)"
msgstr "@t{n} (`no') (default)"

#. type: table
#: zsh.texi:9423
msgid "Discard the correction and run the command."
msgstr "放弃更正并运行命令。"

#. type: item
#: zsh.texi:9423
#, no-wrap
msgid "@t{y} (`yes')"
msgstr "@t{y} (`yes')"

#. type: table
#: zsh.texi:9425
msgid "Make the correction and run the command."
msgstr "更正并运行命令。"

#. type: item
#: zsh.texi:9425
#, no-wrap
msgid "@t{a} (`abort')"
msgstr "@t{a} (`abort')"

#. type: table
#: zsh.texi:9427
msgid "Discard the entire command line without running it."
msgstr "不运行命令行，直接丢弃整个命令行。"

#. type: item
#: zsh.texi:9427
#, no-wrap
msgid "@t{e} (`edit')"
msgstr "@t{e} (`edit')"

#. type: table
#: zsh.texi:9429
msgid "Resume editing the command line."
msgstr "继续编辑命令行。"

#. type: t{#1}
#: zsh.texi:9431 zsh.texi:9432
#, no-wrap
msgid "STTY"
msgstr "STTY"

#. type: table
#: zsh.texi:9445
msgid ""
"If this parameter is set in a command's environment, the shell runs the @t{stty} command with the value of this parameter as arguments in order to set up the terminal before executing the command. The "
"modes apply only to the command, and are reset when it finishes or is suspended. If the command is suspended and continued later with the @t{fg} or @t{wait} builtins it will see the modes specified by "
"@t{STTY}, as if it were not suspended.  This (intentionally) does not apply if the command is continued via `@t{kill -CONT}'.  @t{STTY} is ignored if the command is run in the background, or if it is in "
"the environment of the shell but not explicitly assigned to in the input line. This avoids running stty at every external command by accidentally exporting it. Also note that @t{STTY} should not be used "
"for window size specifications; these will not be local to the command."
msgstr ""
"如果在命令的环境中设置了该参数，shell 将以该参数的值为参数运行 @t{stty} 命令，以便在执行命令前设置终端。模式仅适用于命令，并在命令结束或暂停时重置。如果命令被暂停，随后使用 @t{fg} 或 @t{wait} 内置命令继续"
"执行，则会看到 @t{STTY} 指定的模式，就好像命令没有被暂停一样。 如果通过 `@t{kill -CONT}' 继续执行命令，则（故意）不适用此规定。 如果命令在后台运行，或者命令在 shell 环境中但未在输入行中明确指定，则 "
"@t{STTY} 将被忽略。这样可以避免在每条外部命令中运行 stty 时意外导出它。还要注意的是，@t{STTY} 不应被用于指定窗口大小，因为这些指定并不是命令的本地化指定。"

#. type: table
#: zsh.texi:9451
msgid ""
"If the parameter is set and empty, all of the above applies except that @t{stty} is not run. This can be useful as a way to freeze the tty around a single command, blocking its changes to tty settings, "
"similar to the @t{ttyctl} builtin."
msgstr "如果参数被设置为空，除了 @t{stty} 不被运行外，上述所有功能都适用。这可以用来冻结单个命令周围的 tty，阻止命令对 tty 设置的更改，类似于 @t{ttyctl} 内置命令。"

#. type: vindex
#: zsh.texi:9452
#, no-wrap
msgid "TERM"
msgstr "TERM"

#. type: item
#: zsh.texi:9453
#, no-wrap
msgid "@t{TERM} <S>"
msgstr "@t{TERM} <S>"

#. type: table
#: zsh.texi:9460
msgid ""
"The type of terminal in use.  This is used when looking up termcap sequences.  An assignment to @t{TERM} causes zsh to re-initialize the terminal, even if the value does not change (e.g., "
"`@t{TERM=$TERM}').  It is necessary to make such an assignment upon any change to the terminal definition database or terminal type in order for the new settings to take effect."
msgstr ""
"使用的终端类型。 在查找 termcap 序列时使用。 赋值给 @t{TERM} 会导致 zsh 重新初始化终端，即使值没有改变（例如，`@t{TERM=$TERM}' ）。 有必要在终端定义数据库或终端类型发生任何更改时进行这样的赋值，以使新设置"
"生效。"

#. type: vindex
#: zsh.texi:9461
#, no-wrap
msgid "TERMINFO"
msgstr "TERMINFO"

#. type: item
#: zsh.texi:9462
#, no-wrap
msgid "@t{TERMINFO} <S>"
msgstr "@t{TERMINFO} <S>"

#. type: table
#: zsh.texi:9467
msgid ""
"A reference to your terminfo database, used by the `terminfo' library when the system has it; see terminfo(5).  If set, this causes the shell to reinitialise the terminal, making the workaround "
"`@t{TERM=$TERM}' unnecessary."
msgstr "terminfo 数据库的引用，当系统有该数据库时，`terminfo' 库会使用它；参见 terminfo(5)。 如果设置了这个参数，shell 就会重新初始化终端，这样就不需要使用 `@t{TERM=$TERM}' 。"

#. type: vindex
#: zsh.texi:9468
#, no-wrap
msgid "TERMINFO_DIRS"
msgstr "TERMINFO_DIRS"

#. type: item
#: zsh.texi:9469
#, no-wrap
msgid "@t{TERMINFO_DIRS} <S>"
msgstr "@t{TERMINFO_DIRS} <S>"

#. type: table
#: zsh.texi:9477
msgid ""
"A colon-seprarated list of terminfo databases, used by the `terminfo' library when the system has it; see terminfo(5). This variable is only used by certain terminal libraries, in particular ncurses; see "
"terminfo(5) to check support on your system.  If set, this causes the shell to reinitialise the terminal, making the workaround `@t{TERM=$TERM}' unnecessary.  Note that unlike other colon-separated arrays "
"this is not tied to a zsh array."
msgstr ""
"以冒号为分隔符的 terminfo 数据库列表，在系统有 `terminfo' 库时使用；参见 terminfo(5)。该变量仅用于某些终端库，尤其是 ncurses；请参见 terminfo(5) 检查系统是否支持该变量。 如果设置了该变量，shell 将重新初始"
"化终端，从而无需使用 `@t{TERM=$TERM}'。 请注意，与其他以冒号分隔的数组不同，它并没有绑定到一个 zsh 数组。"

#. type: t{#1}
#: zsh.texi:9478 zsh.texi:9479
#, no-wrap
msgid "TIMEFMT"
msgstr "TIMEFMT"

#. type: table
#: zsh.texi:9485
msgid ""
"The format of process time reports with the @t{time} keyword.  The default is `@t{%J %U user %S system %P cpu %*E total}'.  Recognizes the following escape sequences, although not all may be available on "
"all systems, and some that are available may not be useful:"
msgstr "使用 @t{time} 关键字的进程时间报告格式。 默认格式为 `@t{%J %U user %S system %P cpu %*E total}' 。 可识别下列转义序列，但并非所有系统都能使用所有这些转义序列，而且有些转义序列可能并不实用："

#. type: t{#1}
#: zsh.texi:9490
#, no-wrap
msgid "%U"
msgstr "%U"

#. type: table
#: zsh.texi:9492
msgid "CPU seconds spent in user mode."
msgstr "用户模式下花费的 CPU 秒数。"

#. type: t{#1}
#: zsh.texi:9492 zsh.texi:37081
#, no-wrap
msgid "%S"
msgstr "%S"

#. type: table
#: zsh.texi:9494
msgid "CPU seconds spent in kernel mode."
msgstr "在内核模式下占用的 CPU 秒数。"

#. type: table
#: zsh.texi:9496
msgid "Elapsed time in seconds."
msgstr "所用时间（秒）。"

#. type: t{#1}
#: zsh.texi:9496
#, no-wrap
msgid "%P"
msgstr "%P"

#. type: table
#: zsh.texi:9499
msgid "The CPU percentage, computed as 100*(@t{%U}+@t{%S})/@t{%E}."
msgstr "CPU 百分比，计算公式为 100*(@t{%U}+@t{%S})/@t{%E}。"

#. type: table
#: zsh.texi:9501
msgid "Number of times the process was swapped."
msgstr "进程被交换的次数。"

#. type: t{#1}
#: zsh.texi:9501
#, no-wrap
msgid "%X"
msgstr "%X"

#. type: table
#: zsh.texi:9503
msgid "The average amount in (shared) text space used in kilobytes."
msgstr "使用的（共享）文本空间的平均数量（千字节）。"

#. type: table
#: zsh.texi:9506
msgid "The average amount in (unshared) data/stack space used in kilobytes."
msgstr "使用的（非共享）数据/堆栈空间的平均数量（千字节）。"

#. type: table
#: zsh.texi:9508
msgid "The total space used (@t{%X}+@t{%D}) in kilobytes."
msgstr "使用的总空间（@t{%X}+@t{%D}），单位为千字节。"

#. type: table
#: zsh.texi:9511
msgid "The maximum memory the process had in use at any time in kilobytes."
msgstr "进程在任何时候使用的最大内存（千字节）。"

#. type: t{#1}
#: zsh.texi:9511
#, no-wrap
msgid "%F"
msgstr "%F"

#. type: table
#: zsh.texi:9514
msgid "The number of major page faults (page needed to be brought from disk)."
msgstr "主要页面故障（需要从磁盘调用页面）的数量。"

#. type: t{#1}
#: zsh.texi:9514 zsh.texi:37076
#, no-wrap
msgid "%R"
msgstr "%R"

#. type: table
#: zsh.texi:9516
msgid "The number of minor page faults."
msgstr "次要页面故障的数量。"

#. type: table
#: zsh.texi:9518
msgid "The number of input operations."
msgstr "输入操作的数量。"

#. type: t{#1}
#: zsh.texi:9518
#, no-wrap
msgid "%O"
msgstr "%O"

#. type: table
#: zsh.texi:9520
msgid "The number of output operations."
msgstr "输出操作的次数。"

#. type: t{#1}
#: zsh.texi:9520 zsh.texi:37078 zsh.texi:37128 zsh.texi:37138
#, no-wrap
msgid "%r"
msgstr "%r"

#. type: table
#: zsh.texi:9522
msgid "The number of socket messages received."
msgstr "收到的套接字消息数量。"

#. type: t{#1}
#: zsh.texi:9522 zsh.texi:34383 zsh.texi:37060 zsh.texi:39747
#, no-wrap
msgid "%s"
msgstr "%s"

#. type: table
#: zsh.texi:9524
msgid "The number of socket messages sent."
msgstr "发送的套接字消息数量。"

#. type: t{#1}
#: zsh.texi:9524
#, no-wrap
msgid "%k"
msgstr "%k"

#. type: table
#: zsh.texi:9526
msgid "The number of signals received."
msgstr "接收到的信号数量。"

#. type: table
#: zsh.texi:9528
msgid "Number of voluntary context switches (waits)."
msgstr "自愿上下文切换（等待）的次数。"

#. type: table
#: zsh.texi:9530
msgid "Number of involuntary context switches."
msgstr "非自愿上下文切换次数。"

#. type: t{#1}
#: zsh.texi:9530
#, no-wrap
msgid "%J"
msgstr "%J"

#. type: table
#: zsh.texi:9532
msgid "The name of this job."
msgstr "这个作业的名字。"

#. type: table
#: zsh.texi:9541
msgid ""
"A star may be inserted between the percent sign and flags printing time (e.g., `@t{%*E}'); this causes the time to be printed in `@var{hh}@t{:}@var{mm}@t{:}@var{ss}@t{.}@var{ttt}' format (hours and "
"minutes are only printed if they are not zero).  Alternatively, `@t{m}' or `@t{u}' may be used (e.g., `@t{%mE}') to produce time output in milliseconds or microseconds, respectively."
msgstr ""
"打印时间j时，可以在百分号和标志之间插入星号（例如，`@t{%*E}'）；这将导致时间以 `@var{hh}@t{:}@var{mm}@t{:}@var{ss}@t{.}@var{ttt}' 格式打印（小时和分钟仅在不为零时才打印）。 也可以使用 `@t{m}' 或 "
"`@t{u}'（例如 `@t{%mE}' ）分别以毫秒或微秒为单位输出时间。"

#. type: t{#1}
#: zsh.texi:9542 zsh.texi:9543
#, no-wrap
msgid "TMOUT"
msgstr "TMOUT"

#. type: table
#: zsh.texi:9552
msgid ""
"If this parameter is nonzero, the shell will receive an @t{ALRM} signal if a command is not entered within the specified number of seconds after issuing a prompt. If there is a trap on @t{SIGALRM}, it "
"will be executed and a new alarm is scheduled using the value of the @t{TMOUT} parameter after executing the trap.  If no trap is set, and the idle time of the terminal is not less than the value of the "
"@t{TMOUT} parameter, zsh terminates.  Otherwise a new alarm is scheduled to @t{TMOUT} seconds after the last keypress."
msgstr ""
"如果该参数非零，则在发出提示符后的指定秒数内未输入命令，shell 将收到 @t{ALRM} 信号。如果 @t{SIGALRM} 上有陷阱，则会执行该陷阱，并在执行陷阱后使用 @t{TMOUT} 参数的值调度新的警报。 如果没有设置陷阱，并且终端"
"的空闲时间不小于 @t{TMOUT} 参数的值，zsh 就会终止。 否则会在最后一次按键后的 @t{TMOUT} 秒内发出新的警报。"

#. type: t{#1}
#: zsh.texi:9553 zsh.texi:9554
#, no-wrap
msgid "TMPPREFIX"
msgstr "TMPPREFIX"

#. type: table
#: zsh.texi:9558
msgid "A pathname prefix which the shell will use for all temporary files.  Note that this should include an initial part for the file name as well as any directory names.  The default is `@t{/tmp/zsh}'."
msgstr "路径名前缀，shell 会用于所有临时文件。 请注意，这应包括文件名的首部以及任何目录名。 默认值为 `@t{/tmp/zsh}'。"

#. type: t{#1}
#: zsh.texi:9559 zsh.texi:9560
#, no-wrap
msgid "TMPSUFFIX"
msgstr "TMPSUFFIX"

#. type: table
#: zsh.texi:9567
msgid ""
"A filename suffix which the shell will use for temporary files created by process substitutions (e.g., `@t{=(@var{list})}').  Note that the value should include a leading dot `@t{.}' if intended to be "
"interpreted as a file extension.  The default is not to append any suffix, thus this parameter should be assigned only when needed and then unset again."
msgstr ""
"文件名后缀，shell 会将其用于进程替换创建的临时文件（例如，`@t{=(@var{list})}'）。 请注意，如果要将该值解释为文件扩展名，则应包含一个前导点 `@t{.}'。 默认情况下不附加任何后缀，因此只有在需要时才分配该参数，"
"然后再取消设置。"

#. type: vindex
#: zsh.texi:9568
#, no-wrap
msgid "WORDCHARS"
msgstr "WORDCHARS"

#. type: item
#: zsh.texi:9569
#, no-wrap
msgid "@t{WORDCHARS} <S>"
msgstr "@t{WORDCHARS} <S>"

#. type: table
#: zsh.texi:9572
msgid "A list of non-alphanumeric characters considered part of a word by the line editor."
msgstr "行编辑器认为属于单词一部分的非字母数字字符列表。"

#. type: t{#1}
#: zsh.texi:9573 zsh.texi:9574
#, no-wrap
msgid "ZBEEP"
msgstr "ZBEEP"

#. type: table
#: zsh.texi:9583
msgid ""
"If set, this gives a string of characters, which can use all the same codes as the @t{bindkey} command as described in @ref{The zsh/zle Module}, that will be output to the terminal instead of beeping.  "
"This may have a visible instead of an audible effect; for example, the string `@t{\\e[?5h\\e[?5l}' on a vt100 or xterm will have the effect of flashing reverse video on and off (if you usually use reverse "
"video, you should use the string `@t{\\e[?5l\\e[?5h}' instead).  This takes precedence over the @t{NOBEEP} option."
msgstr ""
"如果设置了该选项，就会向终端输出一串字符，这串字符可以使用 @ref{zsh/zle 模块} 中描述的 @t{bindkey} 命令的所有相同代码，而不是发出蜂鸣声。 例如，在 vt100 或 xterm 上使用字符串 `@t{\\e[?5h\\e[?5l}' 会产生反"
"向视频闪烁的效果（如果通常使用反向视频，则应使用字符串 `@t{\\e[?5l\\e[?5h}'）。 该选项优先于 @t{NOBEEP} 选项。"

#. type: t{#1}
#: zsh.texi:9584 zsh.texi:9585
#, no-wrap
msgid "ZDOTDIR"
msgstr "ZDOTDIR"

#. type: table
#: zsh.texi:9588
msgid "The directory to search for shell startup files (.zshrc, etc), if not @t{$HOME}."
msgstr "如果不是 @t{$HOME}，则为搜索 shell 启动文件（.zshrc 等）的目录。"

#. type: t{#1}
#: zsh.texi:9589 zsh.texi:9592
#, no-wrap
msgid "zle_bracketed_paste"
msgstr "zle_bracketed_paste"

#. type: cindex
#: zsh.texi:9590
#, no-wrap
msgid "bracketed paste"
msgstr "括号粘贴"

#. type: cindex
#: zsh.texi:9591
#, no-wrap
msgid "enabling bracketed paste"
msgstr "启用括号粘贴"

#. type: table
#: zsh.texi:9599
msgid ""
"Many terminal emulators have a feature that allows applications to identify when text is pasted into the terminal rather than being typed normally. For ZLE, this means that special characters such as tabs "
"and newlines can be inserted instead of invoking editor commands.  Furthermore, pasted text forms a single undo event and if the region is active, pasted text will replace the region."
msgstr ""
"许多终端模拟器都有一项功能，允许应用程序识别文本是何时粘贴到终端而不是正常键入的。对于 ZLE 来说，这意味着可以插入制表符和换行符等特殊字符，而不是调用编辑器命令。 此外，粘贴的文本会形成单个撤销事件，如果区"
"域处于活动状态，粘贴的文本将取代区域。"

#. type: table
#: zsh.texi:9606
msgid ""
"This two-element array contains the terminal escape sequences for enabling and disabling the feature. These escape sequences are used to enable bracketed paste when ZLE is active and disable it at other "
"times.  Unsetting the parameter has the effect of ensuring that bracketed paste remains disabled."
msgstr "该双元素数组包含用于启用和禁用该功能的终端转义序列。这些转义序列用于在 ZLE 处于活动状态时启用括号粘贴功能，而在其他时间禁用该功能。 取消设置该参数可确保括号粘贴功能保持禁用状态。"

#. type: t{#1}
#: zsh.texi:9607 zsh.texi:9608
#, no-wrap
msgid "zle_highlight"
msgstr "zle_highlight"

#. type: table
#: zsh.texi:9611
msgid "An array describing contexts in which ZLE should highlight the input text.  See @ref{Character Highlighting}."
msgstr "一个数组，用于描述 ZLE 应高亮显示输入文本的上下文。 请参阅 @ref{字符高亮}。"

#. type: t{#1}
#: zsh.texi:9612 zsh.texi:9613
#, no-wrap
msgid "ZLE_LINE_ABORTED"
msgstr "ZLE_LINE_ABORTED"

#. type: table
#: zsh.texi:9618
msgid ""
"This parameter is set by the line editor when an error occurs.  It contains the line that was being edited at the point of the error.  `@t{print -zr -- $ZLE_LINE_ABORTED}' can be used to recover the "
"line.  Only the most recent line of this kind is remembered."
msgstr "该参数由行编辑器在发生错误时设置。 它包含发生错误时正在编辑的行。 可以使用 `@t{print -zr -- $ZLE_LINE_ABORTED}' 来恢复该行。 只有最近的一行才会被记住。"

#. type: t{#1}
#: zsh.texi:9619 zsh.texi:9621
#, no-wrap
msgid "ZLE_REMOVE_SUFFIX_CHARS"
msgstr "ZLE_REMOVE_SUFFIX_CHARS"

#. type: t{#1}
#: zsh.texi:9620 zsh.texi:9622
#, no-wrap
msgid "ZLE_SPACE_SUFFIX_CHARS"
msgstr "ZLE_SPACE_SUFFIX_CHARS"

#. type: table
#: zsh.texi:9628
msgid ""
"These parameters are used by the line editor.  In certain circumstances suffixes (typically space or slash) added by the completion system will be removed automatically, either because the next editing "
"command was not an insertable character, or because the character was marked as requiring the suffix to be removed."
msgstr "行编辑器会使用这些参数。 在某些情况下，补全系统添加的后缀（通常是空格或斜线）会自动删除，这可能是因为下一个编辑命令不是可插入字符，也可能是因为该字符被标记为需要删除后缀。"

#. type: table
#: zsh.texi:9635
msgid ""
"These variables can contain the sets of characters that will cause the suffix to be removed.  If @t{ZLE_REMOVE_SUFFIX_CHARS} is set, those characters will cause the suffix to be removed; if "
"@t{ZLE_SPACE_SUFFIX_CHARS} is set, those characters will cause the suffix to be removed and replaced by a space."
msgstr "这些变量可以包含会导致后缀被移除的字符集。 如果设置了 @t{ZLE_REMOVE_SUFFIX_CHARS}，这些字符会导致后缀被移除；如果设置了 @t{ZLE_SPACE_SUFFIX_CHARS}，这些字符会导致后缀被移除并替换为空格。"

#. type: table
#: zsh.texi:9639
msgid "If @t{ZLE_REMOVE_SUFFIX_CHARS} is not set, the default behaviour is equivalent to:"
msgstr "如果未设置 @t{ZLE_REMOVE_SUFFIX_CHARS}，则默认行为等同于："

#. type: example
#: zsh.texi:9643
#, no-wrap
msgid "ZLE_REMOVE_SUFFIX_CHARS=$' \\t\\n;&|'\n"
msgstr "ZLE_REMOVE_SUFFIX_CHARS=$' \\t\\n;&|'\n"

#. type: table
#: zsh.texi:9649
msgid "If @t{ZLE_REMOVE_SUFFIX_CHARS} is set but is empty, no characters have this behaviour.  @t{ZLE_SPACE_SUFFIX_CHARS} takes precedence, so that the following:"
msgstr "如果 @t{ZLE_REMOVE_SUFFIX_CHARS} 已设置但为空，则没有字符具有这种行为。 @t{ZLE_SPACE_SUFFIX_CHARS}优先，因此下面的内容："

#. type: example
#: zsh.texi:9653
#, no-wrap
msgid "ZLE_SPACE_SUFFIX_CHARS=$'&|'\n"
msgstr "ZLE_SPACE_SUFFIX_CHARS=$'&|'\n"

#. type: table
#: zsh.texi:9658
msgid "causes the characters `@t{&}' and `@t{|}' to remove the suffix but to replace it with a space."
msgstr "会导致字符 `@t{&}' 和 `@t{|}' 删除后缀，但用空格代替。"

#. type: table
#: zsh.texi:9666
msgid ""
"To illustrate the difference, suppose that the option @t{AUTO_REMOVE_SLASH} is in effect and the directory @t{DIR} has just been completed, with an appended @t{/}, following which the user types `@t{&}'.  "
"The default result is `@t{DIR&}'.  With @t{ZLE_REMOVE_SUFFIX_CHARS} set but without including `@t{&}' the result is `@t{DIR/&}'.  With @t{ZLE_SPACE_SUFFIX_CHARS} set to include `@t{&}' the result is "
"`@t{DIR &}'."
msgstr ""
"为了说明两者的区别，假设 @t{AUTO_REMOVE_SLASH} 选项有效，目录 @t{DIR} 刚刚补全，并附加了 @t{/}，用户随后键入了 `@t{&}'。 默认结果为 `@t{DIR&}'。 如果设置了 @t{ZLE_REMOVE_SUFFIX_CHARS}，但未包含 `@t{&}' ，"
"则结果为 `@t{DIR/&}'。 设置了 @t{ZLE_SPACE_SUFFIX_CHARS} 并包含 `@t{&}' ，结果是  `@t{DIR &}'。"

#. type: table
#: zsh.texi:9672
msgid ""
"Note that certain completions may provide their own suffix removal or replacement behaviour which overrides the values described here.  See the completion system documentation in @ref{Completion System}."
msgstr "请注意，某些补全可能会提供自己的后缀移除或替换行为，从而覆盖此处描述的值。 请参阅 @ref{补全系统} 中的补全系统文档。"

#. type: vindex
#: zsh.texi:9673
#, no-wrap
msgid "ZLE_RPROMPT_INDENT"
msgstr "ZLE_RPROMPT_INDENT"

#. type: item
#: zsh.texi:9674
#, no-wrap
msgid "@t{ZLE_RPROMPT_INDENT} <S>"
msgstr "@t{ZLE_RPROMPT_INDENT} <S>"

#. type: table
#: zsh.texi:9678
msgid ""
"If set, used to give the indentation between the right hand side of the right prompt in the line editor as given by @t{RPS1} or @t{RPROMPT} and the right hand side of the screen.  If not set, the value 1 "
"is used."
msgstr "如果设置，用于给出 @t{RPS1} 或 @t{RPROMPT} 所给出的行编辑器右侧提示符与屏幕右侧之间的缩进。 如果未设置，则使用值 1。"

#. type: table
#: zsh.texi:9686
msgid ""
"Typically this will be used to set the value to 0 so that the prompt appears flush with the right hand side of the screen.  This is not the default as many terminals do not handle this correctly, in "
"particular when the prompt appears at the extreme bottom right of the screen.  Recent virtual terminals are more likely to handle this case correctly.  Some experimentation is necessary."
msgstr ""
"通常情况下，可以将该值设置为 0，这样提示符就会与屏幕右侧齐平。 这不是默认值，因为许多终端无法正确处理这种情况，尤其是当提示出现在屏幕右下方时。 最新的虚拟终端更有可能正确处理这种情况。 有必要进行一些试验。"

#. type: node
#: zsh.texi:9690 zsh.texi:12712 zsh.texi:12714 zsh.texi:16079
#, no-wrap
msgid "Shell Builtin Commands"
msgstr "Shell 内置命令"

#. type: t{#1}
#: zsh.texi:9694 zsh.texi:21655 zsh.texi:29613 zsh.texi:29614 zsh.texi:35802
#, no-wrap
msgid "options"
msgstr "选项"

#. type: node
#: zsh.texi:9701 zsh.texi:9703 zsh.texi:9746
#, no-wrap
msgid "Specifying Options"
msgstr "指定选项"

#. type: node
#: zsh.texi:9701 zsh.texi:9746 zsh.texi:9748 zsh.texi:12428
#, no-wrap
msgid "Description of Options"
msgstr "选项说明"

#. type: cindex
#: zsh.texi:9705
#, no-wrap
msgid "options, specifying"
msgstr "选项, 指定"

#. type: Plain text
#: zsh.texi:9709
msgid "Options are primarily referred to by name.  These names are case insensitive and underscores are ignored.  For example, `@t{allexport}' is equivalent to `@t{A__lleXP_ort}'."
msgstr "选项主要用名称表示。 这些名称不区分大小写，下划线将被忽略。 例如，`@t{allexport}' 等同于 `@t{A__lleXP_ort}'。"

#. type: Plain text
#: zsh.texi:9716
msgid ""
"The sense of an option name may be inverted by preceding it with `@t{no}', so `@t{setopt No_Beep}' is equivalent to `@t{unsetopt beep}'.  This inversion can only be done once, so `@t{nonobeep}' is "
"@emph{not} a synonym for `@t{beep}'.  Similarly, `@t{tify}' is not a synonym for `@t{nonotify}' (the inversion of `@t{notify}')."
msgstr ""
"选项名称的含义可以通过在其前面加上 `@t{no}' 来反转，因此 `@t{setopt No_Beep}' 等同 `@t{unsetopt beep}' 。 这种反转只能进行一次，所以 `@t{nonobeep}' 不是 `@t{beep}' 的同义词。 同样，`@t{tify}' 也不是 "
"`@t{nonotify}' （ `@t{notify}' 的反义词）的同义词。"

#. type: Plain text
#: zsh.texi:9725
msgid ""
"Some options also have one or more single letter names.  There are two sets of single letter options: one used by default, and another used to emulate @cite{sh}/@cite{ksh} (used when the "
"@t{SH_OPTION_LETTERS} option is set).  The single letter options can be used on the shell command line, or with the @t{set}, @t{setopt} and @t{unsetopt} builtins, as normal Unix options preceded by "
"`@t{-}'."
msgstr ""
"有些选项还有一个或多个单字母名称。 有两组单字母选项：一组默认使用，另一组用于模拟 @cite{sh}/@cite{ksh}（当设置了 @t{SH_OPTION_LETTERS} 选项时使用）。 单字母选项可以在 shell 命令行中使用，也可以与 @t{set}、"
"@t{setopt} 和 @t{unsetopt} 内置命令一起使用，就像以 `@t{-}' 为前缀的普通 Unix 选项一样。"

#. type: Plain text
#: zsh.texi:9733
msgid ""
"The sense of the single letter options may be inverted by using `@t{+}' instead of `@t{-}'.  Some of the single letter option names refer to an option being off, in which case the inversion of that name "
"refers to the option being on.  For example, `@t{+n}' is the short name of `@t{exec}', and `@t{-n}' is the short name of its inversion, `@t{noexec}'."
msgstr ""
"使用 `@t{+}' 而不是 `@t{-}' 可以反转单字母选项的含义。 有些单字母选项名称指的是关闭选项，在这种情况下，该名称的反义词指的是开启选项。 例如， `@t{+n}' 是  `@t{exec}' 的简称，而 `@t{-n}'  是其反义词 "
"`@t{noexec}' 的简称。"

#. type: Plain text
#: zsh.texi:9740
msgid ""
"In strings of single letter options supplied to the shell at startup, trailing whitespace will be ignored; for example the string `@t{-f }' will be treated just as `@t{-f}', but the string `@t{-f i}' is "
"an error.  This is because many systems which implement the `@t{#!}' mechanism for calling scripts do not strip trailing whitespace."
msgstr ""
"在启动时提供给 shell 的单字母选项字符串中，尾部空白将被忽略；例如，字符串 `@t{-f }' 将被视为 `@t{-f}'，但字符串 `@t{-f i}' 则是一个错误。 这是因为许多采用 `@t{#!}' 机制调用脚本的系统并不清除尾部空白。"

#. type: Plain text
#: zsh.texi:9744
msgid "It is possible for options to be set within a function scope.  See the description of the option @t{LOCAL_OPTIONS} below."
msgstr "可以在函数作用域内设置选项。 请参阅下文对 @t{LOCAL_OPTIONS} 选项的描述。"

#. type: node
#: zsh.texi:9746 zsh.texi:12428 zsh.texi:12430 zsh.texi:12533
#, no-wrap
msgid "Option Aliases"
msgstr "Option 别名"

#. type: cindex
#: zsh.texi:9750
#, no-wrap
msgid "options, description"
msgstr "选项, 描述"

#. type: Plain text
#: zsh.texi:9758
msgid ""
"In the following list, options set by default in all emulations are marked <D>; those set by default only in csh, ksh, sh, or zsh emulations are marked <C>, <K>, <S>, <Z> as appropriate.  When listing "
"options (by `@t{setopt}', `@t{unsetopt}', `@t{set -o}' or `@t{set +o}'), those turned on by default appear in the list prefixed with `@t{no}'.  Hence (unless @t{KSH_OPTION_PRINT} is set), `@t{setopt}' "
"shows all options whose settings are changed from the default."
msgstr ""
"在以下列表中，所有模拟中默认设置的选项都标为 <D>；仅在 csh、ksh、sh 或 zsh 模拟中默认设置的选项则根据情况标为 <C>、<K>、<S>、<Z>。 在列出选项（通过`@t{setopt}', `@t{unsetopt}', `@t{set -o}' 或 `@t{set "
"+o}'）时，默认开启的选项会以 `@t{no}' 为前缀出现在列表中。 因此（除非设置了 @t{KSH_OPTION_PRINT}），`@t{setopt}' 会显示所有设置与默认值不同的选项。"

#. type: subsection
#: zsh.texi:9761
#, no-wrap
msgid "Changing Directories"
msgstr "改变目录"

#. type: table
#: zsh.texi:9764 zsh.texi:12581
#, no-wrap
msgid "AUTO_CD"
msgstr "AUTO_CD"

#. type: pindex
#: zsh.texi:9765
#, no-wrap
msgid "NO_AUTO_CD"
msgstr "NO_AUTO_CD"

#. type: pindex
#: zsh.texi:9766
#, no-wrap
msgid "AUTOCD"
msgstr "AUTOCD"

#. type: pindex
#: zsh.texi:9767
#, no-wrap
msgid "NOAUTOCD"
msgstr "NOAUTOCD"

#. type: cindex
#: zsh.texi:9768
#, no-wrap
msgid "cd, automatic"
msgstr "cd, 自动"

#. type: item
#: zsh.texi:9769
#, no-wrap
msgid "@t{AUTO_CD} (@t{-J})"
msgstr "@t{AUTO_CD} (@t{-J})"

#. type: table
#: zsh.texi:9777
msgid ""
"If a command is issued that can't be executed as a normal command, and the command is the name of a directory, perform the @t{cd} command to that directory.  This option is only applicable if the option "
"@t{SHIN_STDIN} is set, i.e. if commands are being read from standard input.  The option is designed for interactive use; it is recommended that @t{cd} be used explicitly in scripts to avoid ambiguity."
msgstr ""
"如果发出的命令不能作为普通命令执行，且该命令是一个目录的名称，则执行 @t{cd} 命令以进入该目录。 只有设置了 @t{SHIN_STDIN}，即从标准输入读取命令时，该选项才适用。 该选项专为交互式使用而设计；建议在脚本中明确"
"使用 @t{cd}，以避免歧义。"

#. type: table
#: zsh.texi:9778 zsh.texi:12589
#, no-wrap
msgid "AUTO_PUSHD"
msgstr "AUTO_PUSHD"

#. type: pindex
#: zsh.texi:9779
#, no-wrap
msgid "NO_AUTO_PUSHD"
msgstr "NO_AUTO_PUSHD"

#. type: pindex
#: zsh.texi:9780
#, no-wrap
msgid "AUTOPUSHD"
msgstr "AUTOPUSHD"

#. type: pindex
#: zsh.texi:9781
#, no-wrap
msgid "NOAUTOPUSHD"
msgstr "NOAUTOPUSHD"

#. type: cindex
#: zsh.texi:9782
#, no-wrap
msgid "cd, behaving like pushd"
msgstr "cd, 像 pushd 一样"

#. type: cindex
#: zsh.texi:9783
#, no-wrap
msgid "pushd, making cd behave like"
msgstr "pushd, 使用 cd 像"

#. type: item
#: zsh.texi:9784
#, no-wrap
msgid "@t{AUTO_PUSHD} (@t{-N})"
msgstr "@t{AUTO_PUSHD} (@t{-N})"

#. type: table
#: zsh.texi:9786
msgid "Make @t{cd} push the old directory onto the directory stack."
msgstr "让 @t{cd} 将旧目录推送到目录栈。"

#. type: table
#: zsh.texi:9787 zsh.texi:12601
#, no-wrap
msgid "CDABLE_VARS"
msgstr "CDABLE_VARS"

#. type: pindex
#: zsh.texi:9788
#, no-wrap
msgid "NO_CDABLE_VARS"
msgstr "NO_CDABLE_VARS"

#. type: pindex
#: zsh.texi:9789
#, no-wrap
msgid "CDABLEVARS"
msgstr "CDABLEVARS"

#. type: pindex
#: zsh.texi:9790
#, no-wrap
msgid "NOCDABLEVARS"
msgstr "NOCDABLEVARS"

#. type: cindex
#: zsh.texi:9791
#, no-wrap
msgid "cd, to parameter"
msgstr "cd, to parameter"

#. type: item
#: zsh.texi:9792
#, no-wrap
msgid "@t{CDABLE_VARS} (@t{-T})"
msgstr "@t{CDABLE_VARS} (@t{-T})"

#. type: table
#: zsh.texi:9797
msgid ""
"If the argument to a @t{cd} command (or an implied @t{cd} with the @t{AUTO_CD} option set) is not a directory, and does not begin with a slash, try to expand the expression as if it were preceded by a "
"`@t{~}' (see @ref{Filename Expansion})."
msgstr "如果 @t{cd} 命令（或设置了 @t{AUTO_CD} 选项的隐式 @t{cd}）的参数不是目录，也不是以斜线开头的，则尝试扩展表达式，就好像在表达式前面加上了 `@t{~}'（参见 @ref{文件名扩展}）。"

#. type: t{#1}
#: zsh.texi:9798 zsh.texi:9804
#, no-wrap
msgid "CD_SILENT"
msgstr "CD_SILENT"

#. type: pindex
#: zsh.texi:9799
#, no-wrap
msgid "NO_CD_SILENT"
msgstr "NO_CD_SILENT"

#. type: pindex
#: zsh.texi:9800
#, no-wrap
msgid "CDSILENT"
msgstr "CDSILENT"

#. type: pindex
#: zsh.texi:9801
#, no-wrap
msgid "NOCDSILENT"
msgstr "NOCDSILENT"

#. type: cindex
#: zsh.texi:9802
#, no-wrap
msgid "cd, silencing"
msgstr "cd, 静默"

#. type: cindex
#: zsh.texi:9803
#, no-wrap
msgid "autocd, silencing"
msgstr "autocd, 静默"

#. type: table
#: zsh.texi:9812
msgid ""
"Never print the working directory after a @t{cd} (whether explicit or implied with the @t{AUTO_CD} option set). @t{cd} normally prints the working directory when the argument given to it was @t{-}, a "
"stack entry, or the name of a directory found under @t{CDPATH}. Note that this is distinct from @t{pushd}'s stack-printing behaviour, which is controlled by @t{PUSHD_SILENT}. This option overrides the "
"printing-related effects of @t{POSIX_CD}."
msgstr ""
"切勿在 @t{cd}（无论是显式还是通过设置 @t{AUTO_CD} 选项隐含）之后打印工作目录。当 @t{cd} 的参数是 @t{-}、堆栈条目或 @t{CDPATH} 下的目录名时，@t{cd} 通常会打印工作目录。请注意，这与 @t{pushd} 的堆栈打印行为"
"不同，后者由 @t{PUSHD_SILENT} 控制。此选项会覆盖 @t{POSIX_CD} 的打印相关效果。"

#. type: t{#1}
#: zsh.texi:9813 zsh.texi:9818
#, no-wrap
msgid "CHASE_DOTS"
msgstr "CHASE_DOTS"

#. type: pindex
#: zsh.texi:9814
#, no-wrap
msgid "NO_CHASE_DOTS"
msgstr "NO_CHASE_DOTS"

#. type: pindex
#: zsh.texi:9815
#, no-wrap
msgid "CHASEDOTS"
msgstr "CHASEDOTS"

#. type: pindex
#: zsh.texi:9816
#, no-wrap
msgid "NOCHASEDOTS"
msgstr "NOCHASEDOTS"

#. type: cindex
#: zsh.texi:9817
#, no-wrap
msgid "cd, with .. in argument"
msgstr "cd, 在参数中使用.."

#. type: table
#: zsh.texi:9825
msgid ""
"When changing to a directory containing a path segment `@t{..}' which would otherwise be treated as canceling the previous segment in the path (in other words, `@t{foo/..}' would be removed from the path, "
"or if `@t{..}' is the first part of the path, the last part of the current working directory would be removed), instead resolve the path to the physical directory.  This option is overridden by "
"@t{CHASE_LINKS}."
msgstr ""
"当切换到一个目录时，如果该目录中包含路径段 `@t{..}'，这通常会被认为是取消前一个路径段的意思（也就是说，`@t{foo/..}' 会在路径中被移除，或者如果 `@t{..}' 是路径的第一部分，那么当前工作目录的最后一部分会被移"
"除。），而不是解析物理目录的路径。 该选项被 @t{CHASE_LINKS} 覆盖。"

#. type: table
#: zsh.texi:9832
msgid ""
"For example, suppose @t{/foo/bar} is a link to the directory @t{/alt/rod}.  Without this option set, `@t{cd /foo/bar/..}' changes to @t{/foo}; with it set, it changes to @t{/alt}.  The same applies if the "
"current directory is @t{/foo/bar} and `@t{cd ..}' is used.  Note that all other symbolic links in the path will also be resolved."
msgstr ""
"例如，假设 @t{/foo/bar} 是指向 @t{/alt/rod} 目录的链接。 如果没有设置该选项，`@t{cd /foo/bar/..}' 会更改为 @t{/foo}；如果设置了该选项，则会更改为 @t{/alt}。 如果当前目录是 @t{/foo/bar}，并使用了 "
"`@t{cd ..}' ，情况也一样。 请注意，路径中的所有其他符号链接也将被解析。"

#. type: table
#: zsh.texi:9833 zsh.texi:12647
#, no-wrap
msgid "CHASE_LINKS"
msgstr "CHASE_LINKS"

#. type: pindex
#: zsh.texi:9834
#, no-wrap
msgid "NO_CHASE_LINKS"
msgstr "NO_CHASE_LINKS"

#. type: pindex
#: zsh.texi:9835
#, no-wrap
msgid "CHASELINKS"
msgstr "CHASELINKS"

#. type: pindex
#: zsh.texi:9836
#, no-wrap
msgid "NOCHASELINKS"
msgstr "NOCHASELINKS"

#. type: cindex
#: zsh.texi:9837
#, no-wrap
msgid "links, symbolic"
msgstr "链接, 符号"

#. type: item
#: zsh.texi:9839
#, no-wrap
msgid "@t{CHASE_LINKS} (@t{-w})"
msgstr "@t{CHASE_LINKS} (@t{-w})"

#. type: table
#: zsh.texi:9844
msgid ""
"Resolve symbolic links to their true values when changing directory.  This also has the effect of @t{CHASE_DOTS}, i.e. a `@t{..}' path segment will be treated as referring to the physical parent, even if "
"the preceding path segment is a symbolic link."
msgstr "更改目录时，将符号链接转换为其真实值。 这也具有 @t{CHASE_DOTS} 的效果，即 `@t{..}' 路径段将被视为指向物理父目录，即使前面的路径段是符号链接。"

#. type: pindex
#: zsh.texi:9845
#, no-wrap
msgid "POSIX_CD"
msgstr "POSIX_CD"

#. type: pindex
#: zsh.texi:9846
#, no-wrap
msgid "POSIXCD"
msgstr "POSIXCD"

#. type: pindex
#: zsh.texi:9847
#, no-wrap
msgid "NO_POSIX_CD"
msgstr "NO_POSIX_CD"

#. type: pindex
#: zsh.texi:9848
#, no-wrap
msgid "NOPOSIXCD"
msgstr "NOPOSIXCD"

#. type: cindex
#: zsh.texi:9849
#, no-wrap
msgid "CDPATH, order of checking"
msgstr "CDPATH, 检查的顺序"

#. type: item
#: zsh.texi:9850
#, no-wrap
msgid "@t{POSIX_CD} <K> <S>"
msgstr "@t{POSIX_CD} <K> <S>"

#. type: table
#: zsh.texi:9860
msgid ""
"Modifies the behaviour of @t{cd}, @t{chdir} and @t{pushd} commands to make them more compatible with the POSIX standard. The behaviour with the option unset is described in the documentation for the "
"@t{cd} builtin in @ref{Shell Builtin Commands}.  If the option is set, the shell does not test for directories beneath the local directory (`@t{.}') until after all directories in @t{cdpath} have been "
"tested, and the @t{cd} and @t{chdir} commands do not recognise arguments of the form `@{@t{+}|@t{-}@}@var{n}' as directory stack entries."
msgstr ""
"修改 @t{cd}、@t{chdir} 和 @t{pushd} 命令的行为，使其更符合 POSIX 标准。未设置该选项时的行为，参见 @ref{Shell 内置命令} 中 @t{cd} 内置命令的文档。 如果设置了该选项，在 @t{cdpath} 中的所有目录都测试完毕之"
"前，shell 不会测试本地目录 ( `@t{.}' )下的目录，并且 @t{cd} 和 @t{chdir} 命令不会将形式为 `@{@t{+}|@t{-}@}@var{n}' 的参数视为目录栈条目。"

#. type: table
#: zsh.texi:9869
msgid ""
"Also, if the option is set, the conditions under which the shell prints the new directory after changing to it are modified.  It is no longer restricted to interactive shells (although printing of the "
"directory stack with @t{pushd} is still limited to interactive shells); and any use of a component of @t{CDPATH}, including a `@t{.}' but excluding an empty component that is otherwise treated as `@t{.}', "
"causes the directory to be printed."
msgstr ""
"此外，如果设置了该选项，shell 打印新目录的条件也会发生变化。 它不再仅限于交互式 shell（尽管使用 @t{pushd} 打印目录堆栈仍仅限于交互式 shell）；任何使用 @t{CDPATH} 的组件，包括 `@t{.}' ，但不包括空组件（空组"
"件在其他情况下被视为 `@t{.}' ），都会导致目录被打印。"

#. type: t{#1}
#: zsh.texi:9870 zsh.texi:9875
#, no-wrap
msgid "PUSHD_IGNORE_DUPS"
msgstr "PUSHD_IGNORE_DUPS"

#. type: pindex
#: zsh.texi:9871
#, no-wrap
msgid "NO_PUSHD_IGNORE_DUPS"
msgstr "NO_PUSHD_IGNORE_DUPS"

#. type: pindex
#: zsh.texi:9872
#, no-wrap
msgid "PUSHDIGNOREDUPS"
msgstr "PUSHDIGNOREDUPS"

#. type: pindex
#: zsh.texi:9873
#, no-wrap
msgid "NOPUSHDIGNOREDUPS"
msgstr "NOPUSHDIGNOREDUPS"

#. type: cindex
#: zsh.texi:9874
#, no-wrap
msgid "directory stack, ignoring duplicates"
msgstr "目录栈, 忽略重复"

#. type: table
#: zsh.texi:9877
msgid "Don't push multiple copies of the same directory onto the directory stack."
msgstr "不要将同一目录的多个副本推送到目录堆栈中。"

#. type: t{#1}
#: zsh.texi:9878 zsh.texi:9883
#, no-wrap
msgid "PUSHD_MINUS"
msgstr "PUSHD_MINUS"

#. type: pindex
#: zsh.texi:9879
#, no-wrap
msgid "NO_PUSHD_MINUS"
msgstr "NO_PUSHD_MINUS"

#. type: pindex
#: zsh.texi:9880
#, no-wrap
msgid "PUSHDMINUS"
msgstr "PUSHDMINUS"

#. type: pindex
#: zsh.texi:9881
#, no-wrap
msgid "NOPUSHDMINUS"
msgstr "NOPUSHDMINUS"

#. type: cindex
#: zsh.texi:9882
#, no-wrap
msgid "directory stack, controlling syntax"
msgstr "目录栈, 控制语法"

#. type: table
#: zsh.texi:9886
msgid "Exchanges the meanings of `@t{+}' and `@t{-}' when used with a number to specify a directory in the stack."
msgstr "在使用数字指定堆栈中的目录时，交换 `@t{+}' 和 `@t{-}' 的含义。"

#. type: table
#: zsh.texi:9887 zsh.texi:12571
#, no-wrap
msgid "PUSHD_SILENT"
msgstr "PUSHD_SILENT"

#. type: pindex
#: zsh.texi:9888
#, no-wrap
msgid "NO_PUSHD_SILENT"
msgstr "NO_PUSHD_SILENT"

#. type: pindex
#: zsh.texi:9889
#, no-wrap
msgid "PUSHDSILENT"
msgstr "PUSHDSILENT"

#. type: pindex
#: zsh.texi:9890
#, no-wrap
msgid "NOPUSHDSILENT"
msgstr "NOPUSHDSILENT"

#. type: cindex
#: zsh.texi:9891
#, no-wrap
msgid "directory stack, silencing"
msgstr "目录栈, 静默"

#. type: item
#: zsh.texi:9892
#, no-wrap
msgid "@t{PUSHD_SILENT} (@t{-E})"
msgstr "@t{PUSHD_SILENT} (@t{-E})"

#. type: table
#: zsh.texi:9894
msgid "Do not print the directory stack after @t{pushd} or @t{popd}."
msgstr "不在 @t{pushd} 或 @t{popd} 之后打印目录堆栈。"

#. type: table
#: zsh.texi:9895 zsh.texi:12569
#, no-wrap
msgid "PUSHD_TO_HOME"
msgstr "PUSHD_TO_HOME"

#. type: pindex
#: zsh.texi:9896
#, no-wrap
msgid "NO_PUSHD_TO_HOME"
msgstr "NO_PUSHD_TO_HOME"

#. type: pindex
#: zsh.texi:9897
#, no-wrap
msgid "PUSHDTOHOME"
msgstr "PUSHDTOHOME"

#. type: pindex
#: zsh.texi:9898
#, no-wrap
msgid "NOPUSHDTOHOME"
msgstr "NOPUSHDTOHOME"

#. type: cindex
#: zsh.texi:9899
#, no-wrap
msgid "pushd, to home"
msgstr "pushd, 到 home"

#. type: item
#: zsh.texi:9900
#, no-wrap
msgid "@t{PUSHD_TO_HOME} (@t{-D})"
msgstr "@t{PUSHD_TO_HOME} (@t{-D})"

#. type: table
#: zsh.texi:9902
msgid "Have @t{pushd} with no arguments act like `@t{pushd $HOME}'."
msgstr "让不带参数的 @t{pushd} 像 `@t{pushd $HOME}' 一样运行。"

#. type: pindex
#: zsh.texi:9910
#, no-wrap
msgid "ALWAYS_LAST_PROMPT"
msgstr "ALWAYS_LAST_PROMPT"

#. type: pindex
#: zsh.texi:9911
#, no-wrap
msgid "NO_ALWAYS_LAST_PROMPT"
msgstr "NO_ALWAYS_LAST_PROMPT"

#. type: pindex
#: zsh.texi:9912
#, no-wrap
msgid "ALWAYSLASTPROMPT"
msgstr "ALWAYSLASTPROMPT"

#. type: pindex
#: zsh.texi:9913
#, no-wrap
msgid "NOALWAYSLASTPROMPT"
msgstr "NOALWAYSLASTPROMPT"

#. type: item
#: zsh.texi:9914
#, no-wrap
msgid "@t{ALWAYS_LAST_PROMPT} <D>"
msgstr "@t{ALWAYS_LAST_PROMPT} <D>"

#. type: table
#: zsh.texi:9918
msgid ""
"If unset, key functions that list completions try to return to the last prompt if given a numeric argument. If set these functions try to return to the last prompt if given @emph{no} numeric argument."
msgstr "如果未设置，则列出补全的关键函数会在给出数字参数时尝试返回最后一个提示符。如果设置，这些函数在@emph{没有}数字参数的情况下会尝试返回最后一个提示符。"

#. type: t{#1}
#: zsh.texi:9919 zsh.texi:9923
#, no-wrap
msgid "ALWAYS_TO_END"
msgstr "ALWAYS_TO_END"

#. type: pindex
#: zsh.texi:9920
#, no-wrap
msgid "NO_ALWAYS_TO_END"
msgstr "NO_ALWAYS_TO_END"

#. type: pindex
#: zsh.texi:9921
#, no-wrap
msgid "ALWAYSTOEND"
msgstr "ALWAYSTOEND"

#. type: pindex
#: zsh.texi:9922
#, no-wrap
msgid "NOALWAYSTOEND"
msgstr "NOALWAYSTOEND"

#. type: table
#: zsh.texi:9928
msgid ""
"If a completion is performed with the cursor within a word, and a full completion is inserted, the cursor is moved to the end of the word.  That is, the cursor is moved to the end of the word if either a "
"single match is inserted or menu completion is performed."
msgstr "如果光标在单词内执行了补全操作，并且插入了完整补全，则光标会移动到单词的末尾。 也就是说，如果插入了单个匹配或执行了菜单补全，光标就会移动到单词的末尾。"

#. type: table
#: zsh.texi:9929 zsh.texi:12563
#, no-wrap
msgid "AUTO_LIST"
msgstr "AUTO_LIST"

#. type: pindex
#: zsh.texi:9930
#, no-wrap
msgid "NO_AUTO_LIST"
msgstr "NO_AUTO_LIST"

#. type: pindex
#: zsh.texi:9931
#, no-wrap
msgid "AUTOLIST"
msgstr "AUTOLIST"

#. type: pindex
#: zsh.texi:9932
#, no-wrap
msgid "NOAUTOLIST"
msgstr "NOAUTOLIST"

#. type: cindex
#: zsh.texi:9933
#, no-wrap
msgid "completion, listing choices"
msgstr "补全, 列出选择"

#. type: item
#: zsh.texi:9934
#, no-wrap
msgid "@t{AUTO_LIST} (@t{-9}) <D>"
msgstr "@t{AUTO_LIST} (@t{-9}) <D>"

#. type: table
#: zsh.texi:9936
msgid "Automatically list choices on an ambiguous completion."
msgstr "自动列出模棱两可的补全选项。"

#. type: pindex
#: zsh.texi:9937
#, no-wrap
msgid "AUTO_MENU"
msgstr "AUTO_MENU"

#. type: pindex
#: zsh.texi:9938
#, no-wrap
msgid "NO_AUTO_MENU"
msgstr "NO_AUTO_MENU"

#. type: pindex
#: zsh.texi:9939
#, no-wrap
msgid "AUTOMENU"
msgstr "AUTOMENU"

#. type: pindex
#: zsh.texi:9940
#, no-wrap
msgid "NOAUTOMENU"
msgstr "NOAUTOMENU"

#. type: cindex
#: zsh.texi:9941 zsh.texi:10111
#, no-wrap
msgid "completion, menu"
msgstr "补全, 菜单"

#. type: item
#: zsh.texi:9942
#, no-wrap
msgid "@t{AUTO_MENU} <D>"
msgstr "@t{AUTO_MENU} <D>"

#. type: table
#: zsh.texi:9946
msgid "Automatically use menu completion after the second consecutive request for completion, for example by pressing the tab key repeatedly. This option is overridden by @t{MENU_COMPLETE}."
msgstr "在连续两次请求补全（例如重复按下制表符键）后自动使用菜单完成。该选项被 @t{MENU_COMPLETE} 覆盖。"

#. type: t{#1}
#: zsh.texi:9947 zsh.texi:9952
#, no-wrap
msgid "AUTO_NAME_DIRS"
msgstr "AUTO_NAME_DIRS"

#. type: pindex
#: zsh.texi:9948
#, no-wrap
msgid "NO_AUTO_NAME_DIRS"
msgstr "NO_AUTO_NAME_DIRS"

#. type: pindex
#: zsh.texi:9949
#, no-wrap
msgid "AUTONAMEDIRS"
msgstr "AUTONAMEDIRS"

#. type: pindex
#: zsh.texi:9950
#, no-wrap
msgid "NOAUTONAMEDIRS"
msgstr "NOAUTONAMEDIRS"

#. type: cindex
#: zsh.texi:9951
#, no-wrap
msgid "directories, named"
msgstr "目录, 命名的"

#. type: table
#: zsh.texi:9959
msgid ""
"Any parameter that is set to the absolute name of a directory immediately becomes a name for that directory, that will be used by the `@t{%~}' and related prompt sequences, and will be available when "
"completion is performed on a word starting with `@t{~}'.  (Otherwise, the parameter must be used in the form `@t{~}@var{param}' first.)"
msgstr "任何被设置为目录绝对名称的参数都会立即成为该目录的名称，将被 `@t{%~}' 和相关提示符序列使用，并在对以  `@t{~}' 开头的单词进行补全时可用（否则，必须先以 `@t{~}@var{param}' 的形式使用该参数）。"

#. type: pindex
#: zsh.texi:9960
#, no-wrap
msgid "AUTO_PARAM_KEYS"
msgstr "AUTO_PARAM_KEYS"

#. type: pindex
#: zsh.texi:9961
#, no-wrap
msgid "NO_AUTO_PARAM_KEYS"
msgstr "NO_AUTO_PARAM_KEYS"

#. type: pindex
#: zsh.texi:9962
#, no-wrap
msgid "AUTOPARAMKEYS"
msgstr "AUTOPARAMKEYS"

#. type: pindex
#: zsh.texi:9963
#, no-wrap
msgid "NOAUTOPARAMKEYS"
msgstr "NOAUTOPARAMKEYS"

#. type: item
#: zsh.texi:9964
#, no-wrap
msgid "@t{AUTO_PARAM_KEYS} <D>"
msgstr "@t{AUTO_PARAM_KEYS} <D>"

#. type: table
#: zsh.texi:9973
msgid ""
"If a parameter name was completed and a following character (normally a space) automatically inserted, and the next character typed is one of those that have to come directly after the name (like "
"`@t{@}}', `@t{:}', etc.), the automatically added character is deleted, so that the character typed comes immediately after the parameter name.  Completion in a brace expansion is affected similarly: the "
"added character is a `@t{,}', which will be removed if `@t{@}}' is typed next."
msgstr ""
"如果参数名称补全后，后面的字符（通常是空格）被自动插入，而下一个输入的字符必须直接位于参数名称之后（如 `@t{@}}', `@t{:}'等），则自动添加的字符将被删除，这样输入的字符将紧接在参数名称之后。 在括号扩展中补全"
"也会受到类似影响：添加的字符是`@t{,}'，如果接下来输入 `@t{@}}'，该字符将被删除。"

#. type: pindex
#: zsh.texi:9974
#, no-wrap
msgid "AUTO_PARAM_SLASH"
msgstr "AUTO_PARAM_SLASH"

#. type: pindex
#: zsh.texi:9975
#, no-wrap
msgid "NO_AUTO_PARAM_SLASH"
msgstr "NO_AUTO_PARAM_SLASH"

#. type: pindex
#: zsh.texi:9976
#, no-wrap
msgid "AUTOPARAMSLASH"
msgstr "AUTOPARAMSLASH"

#. type: pindex
#: zsh.texi:9977
#, no-wrap
msgid "NOAUTOPARAMSLASH"
msgstr "NOAUTOPARAMSLASH"

#. type: item
#: zsh.texi:9978
#, no-wrap
msgid "@t{AUTO_PARAM_SLASH} <D>"
msgstr "@t{AUTO_PARAM_SLASH} <D>"

#. type: table
#: zsh.texi:9981
msgid "If a parameter is completed whose content is the name of a directory, then add a trailing slash instead of a space."
msgstr "如果补全的参数内容是一个目录的名称，则在后面加上斜线而不是空格。"

#. type: pindex
#: zsh.texi:9982
#, no-wrap
msgid "AUTO_REMOVE_SLASH"
msgstr "AUTO_REMOVE_SLASH"

#. type: pindex
#: zsh.texi:9983
#, no-wrap
msgid "NO_AUTO_REMOVE_SLASH"
msgstr "NO_AUTO_REMOVE_SLASH"

#. type: pindex
#: zsh.texi:9984
#, no-wrap
msgid "AUTOREMOVESLASH"
msgstr "AUTOREMOVESLASH"

#. type: pindex
#: zsh.texi:9985
#, no-wrap
msgid "NOAUTOREMOVESLASH"
msgstr "NOAUTOREMOVESLASH"

#. type: cindex
#: zsh.texi:9986
#, no-wrap
msgid "slash, removing trailing"
msgstr "斜线, 去掉尾部的"

#. type: item
#: zsh.texi:9987
#, no-wrap
msgid "@t{AUTO_REMOVE_SLASH} <D>"
msgstr "@t{AUTO_REMOVE_SLASH} <D>"

#. type: table
#: zsh.texi:9991
msgid ""
"When the last character resulting from a completion is a slash and the next character typed is a word delimiter, a slash, or a character that ends a command (such as a semicolon or an ampersand), remove "
"the slash."
msgstr "如果补全后的最后一个字符是斜线，而输入的下一个字符是单词分隔符、斜线或命令结束符（如分号或括弧），则删除斜线。"

#. type: t{#1}
#: zsh.texi:9992 zsh.texi:9997
#, no-wrap
msgid "BASH_AUTO_LIST"
msgstr "BASH_AUTO_LIST"

#. type: pindex
#: zsh.texi:9993
#, no-wrap
msgid "NO_BASH_AUTO_LIST"
msgstr "NO_BASH_AUTO_LIST"

#. type: pindex
#: zsh.texi:9994
#, no-wrap
msgid "BASHAUTOLIST"
msgstr "BASHAUTOLIST"

#. type: pindex
#: zsh.texi:9995
#, no-wrap
msgid "NOBASHAUTOLIST"
msgstr "NOBASHAUTOLIST"

#. type: cindex
#: zsh.texi:9996
#, no-wrap
msgid "completion, listing choices, bash style"
msgstr "补全, 列出选择, bash 风格"

#. type: table
#: zsh.texi:10005
msgid ""
"On an ambiguous completion, automatically list choices when the completion function is called twice in succession.  This takes precedence over @t{AUTO_LIST}.  The setting of @t{LIST_AMBIGUOUS} is "
"respected.  If @t{AUTO_MENU} is set, the menu behaviour will then start with the third press.  Note that this will not work with @t{MENU_COMPLETE}, since repeated completion calls immediately cycle "
"through the list in that case."
msgstr ""
"在补全模棱两可时，如果补全函数被连续调用两次时，会自动列出选项。 这优先于 @t{AUTO_LIST}。 将尊重 @t{LIST_AMBIGUOUS} 的设置。 如果设置了 @t{AUTO_MENU}，则菜单行为将从第三次按下时开始。 请注意，在使用 "
"@t{MENU_COMPLETE} 时，此功能将无法正常工作，因为在这种情况下，重复执行的补全调用会立即在列表中循环。"

#. type: t{#1}
#: zsh.texi:10006 zsh.texi:10011
#, no-wrap
msgid "COMPLETE_ALIASES"
msgstr "COMPLETE_ALIASES"

#. type: pindex
#: zsh.texi:10007
#, no-wrap
msgid "NO_COMPLETE_ALIASES"
msgstr "NO_COMPLETE_ALIASES"

#. type: pindex
#: zsh.texi:10008
#, no-wrap
msgid "COMPLETEALIASES"
msgstr "COMPLETEALIASES"

#. type: pindex
#: zsh.texi:10009
#, no-wrap
msgid "NOCOMPLETEALIASES"
msgstr "NOCOMPLETEALIASES"

#. type: cindex
#: zsh.texi:10010
#, no-wrap
msgid "aliases, completion of"
msgstr "别名, 补全"

#. type: table
#: zsh.texi:10015
msgid "Prevents aliases on the command line from being internally substituted before completion is attempted.  The effect is to make the alias a distinct command for completion purposes."
msgstr "防止命令行上的别名在尝试补全前被内部替换。 这样做的目的是使别名成为一个独立的命令。"

#. type: t{#1}
#: zsh.texi:10016 zsh.texi:10020
#, no-wrap
msgid "COMPLETE_IN_WORD"
msgstr "COMPLETE_IN_WORD"

#. type: pindex
#: zsh.texi:10017
#, no-wrap
msgid "NO_COMPLETE_IN_WORD"
msgstr "NO_COMPLETE_IN_WORD"

#. type: pindex
#: zsh.texi:10018
#, no-wrap
msgid "COMPLETEINWORD"
msgstr "COMPLETEINWORD"

#. type: pindex
#: zsh.texi:10019
#, no-wrap
msgid "NOCOMPLETEINWORD"
msgstr "NOCOMPLETEINWORD"

#. type: table
#: zsh.texi:10023
msgid "If unset, the cursor is set to the end of the word if completion is started. Otherwise it stays there and completion is done from both ends."
msgstr "如果未设置，则在开始补全时将光标设置到字尾。否则，光标将停留在该处，并从两端开始补全。"

#. type: t{#1}
#: zsh.texi:10024 zsh.texi:10028
#, no-wrap
msgid "GLOB_COMPLETE"
msgstr "GLOB_COMPLETE"

#. type: pindex
#: zsh.texi:10025
#, no-wrap
msgid "NO_GLOB_COMPLETE"
msgstr "NO_GLOB_COMPLETE"

#. type: pindex
#: zsh.texi:10026
#, no-wrap
msgid "GLOBCOMPLETE"
msgstr "GLOBCOMPLETE"

#. type: pindex
#: zsh.texi:10027
#, no-wrap
msgid "NOGLOBCOMPLETE"
msgstr "NOGLOBCOMPLETE"

#. type: table
#: zsh.texi:10036
msgid ""
"When the current word has a glob pattern, do not insert all the words resulting from the expansion but generate matches as for completion and cycle through them like @t{MENU_COMPLETE}. The matches are "
"generated as if a `@t{*}' was added to the end of the word, or inserted at the cursor when @t{COMPLETE_IN_WORD} is set.  This actually uses pattern matching, not globbing, so it works not only for files "
"but for any completion, such as options, user names, etc."
msgstr ""
"当当前单词包含一个 glob 模式时，不会插入扩展后的所有单词，而是像 @t{MENU_COMPLETE} 一样生成补全匹配并循环播放。在生成匹配时，就好像在单词末尾添加了一个 `@t{*}'，或者在设置 @t{COMPLETE_IN_WORD} 时在光标处插"
"入了一个 `@t{*}'。 这实际上使用的是模式匹配，而不是 globbing 匹配，因此它不仅适用于文件，也适用于任何补全，如选项、用户名等。"

#. type: table
#: zsh.texi:10042
msgid ""
"Note that when the pattern matcher is used, matching control (for example, case-insensitive or anchored matching) cannot be used.  This limitation only applies when the current word contains a pattern; "
"simply turning on the @t{GLOB_COMPLETE} option does not have this effect."
msgstr "请注意，在使用模式匹配器时，不能使用匹配控制（例如，不区分大小写或锚定匹配）。 这一限制仅适用于当前单词包含模式的情况；简单地打开 @t{GLOB_COMPLETE} 选项不会产生这种效果。"

#. type: pindex
#: zsh.texi:10043
#, no-wrap
msgid "HASH_LIST_ALL"
msgstr "HASH_LIST_ALL"

#. type: pindex
#: zsh.texi:10044
#, no-wrap
msgid "NO_HASH_LIST_ALL"
msgstr "NO_HASH_LIST_ALL"

#. type: pindex
#: zsh.texi:10045
#, no-wrap
msgid "HASHLISTALL"
msgstr "HASHLISTALL"

#. type: pindex
#: zsh.texi:10046
#, no-wrap
msgid "NOHASHLISTALL"
msgstr "NOHASHLISTALL"

#. type: item
#: zsh.texi:10047
#, no-wrap
msgid "@t{HASH_LIST_ALL} <D>"
msgstr "@t{HASH_LIST_ALL} <D>"

#. type: table
#: zsh.texi:10051
msgid ""
"Whenever a command completion or spelling correction is attempted, make sure the entire command path is hashed first.  This makes the first completion slower but avoids false reports of spelling errors."
msgstr "无论何时尝试命令补全或拼写更正，都要确保先对整个命令路径进行散列(hash)。 这样会降低首次补全的速度，但可以避免拼写错误的错误报告。"

#. type: pindex
#: zsh.texi:10052
#, no-wrap
msgid "LIST_AMBIGUOUS"
msgstr "LIST_AMBIGUOUS"

#. type: pindex
#: zsh.texi:10053
#, no-wrap
msgid "NO_LIST_AMBIGUOUS"
msgstr "NO_LIST_AMBIGUOUS"

#. type: pindex
#: zsh.texi:10054
#, no-wrap
msgid "LISTAMBIGUOUS"
msgstr "LISTAMBIGUOUS"

#. type: pindex
#: zsh.texi:10055
#, no-wrap
msgid "NOLISTAMBIGUOUS"
msgstr "NOLISTAMBIGUOUS"

#. type: cindex
#: zsh.texi:10056
#, no-wrap
msgid "ambiguous completion"
msgstr "不明确的补全"

#. type: cindex
#: zsh.texi:10057
#, no-wrap
msgid "completion, ambiguous"
msgstr "补全, 不明确的"

#. type: item
#: zsh.texi:10058
#, no-wrap
msgid "@t{LIST_AMBIGUOUS} <D>"
msgstr "@t{LIST_AMBIGUOUS} <D>"

#. type: table
#: zsh.texi:10065
msgid ""
"This option works when @t{AUTO_LIST} or @t{BASH_AUTO_LIST} is also set.  If there is an unambiguous prefix to insert on the command line, that is done without a completion list being displayed; in other "
"words, auto-listing behaviour only takes place when nothing would be inserted.  In the case of @t{BASH_AUTO_LIST}, this means that the list will be delayed to the third call of the function."
msgstr ""
"当 @t{AUTO_LIST} 或 @t{BASH_AUTO_LIST} 也被设置时，该选项才会起作用。 如果要在命令行中插入一个明确的前缀，则无需显示补全列表即可完成；换句话说，只有在不会插入任何前缀的情况下，才会执行自动列表行为。 在 "
"@t{BASH_AUTO_LIST} 的情况下，这意味着列表将延迟到函数的第三次调用。"

#. type: pindex
#: zsh.texi:10066
#, no-wrap
msgid "LIST_BEEP"
msgstr "LIST_BEEP"

#. type: pindex
#: zsh.texi:10067
#, no-wrap
msgid "NO_LIST_BEEP"
msgstr "NO_LIST_BEEP"

#. type: pindex
#: zsh.texi:10068
#, no-wrap
msgid "LISTBEEP"
msgstr "LISTBEEP"

#. type: pindex
#: zsh.texi:10069
#, no-wrap
msgid "NOLISTBEEP"
msgstr "NOLISTBEEP"

#. type: cindex
#: zsh.texi:10070
#, no-wrap
msgid "beep, ambiguous completion"
msgstr "beep, 不明确的补全"

#. type: cindex
#: zsh.texi:10071
#, no-wrap
msgid "completion, beep on ambiguous"
msgstr "补全, 不明确时 beep"

#. type: item
#: zsh.texi:10072
#, no-wrap
msgid "@t{LIST_BEEP} <D>"
msgstr "@t{LIST_BEEP} <D>"

#. type: table
#: zsh.texi:10077
msgid ""
"Beep on an ambiguous completion.  More accurately, this forces the completion widgets to return status 1 on an ambiguous completion, which causes the shell to beep if the option @t{BEEP} is also set; this "
"may be modified if completion is called from a user-defined widget."
msgstr ""
"在模棱两可的补全时发出蜂鸣声。 更准确地说，如果同时设置了选项 @t{BEEP}，这将强制补全小部件在模棱两可的补全时返回状态 1，从而导致 shell 发出蜂鸣声；如果补全是从用户自定义的小部件调用的，这一点可以修改。"

#. type: t{#1}
#: zsh.texi:10078 zsh.texi:10083
#, no-wrap
msgid "LIST_PACKED"
msgstr "LIST_PACKED"

#. type: pindex
#: zsh.texi:10079
#, no-wrap
msgid "NO_LIST_PACKED"
msgstr "NO_LIST_PACKED"

#. type: pindex
#: zsh.texi:10080
#, no-wrap
msgid "LISTPACKED"
msgstr "LISTPACKED"

#. type: pindex
#: zsh.texi:10081
#, no-wrap
msgid "NOLISTPACKED"
msgstr "NOLISTPACKED"

#. type: cindex
#: zsh.texi:10082 zsh.texi:27957
#, no-wrap
msgid "completion, listing"
msgstr "补全, 列表"

#. type: table
#: zsh.texi:10086
msgid "Try to make the completion list smaller (occupying less lines) by printing the matches in columns with different widths."
msgstr "尝试将匹配项打印在不同宽度的列中，使补全列表更小（占用的行数更少）。"

#. type: t{#1}
#: zsh.texi:10087 zsh.texi:10092
#, no-wrap
msgid "LIST_ROWS_FIRST"
msgstr "LIST_ROWS_FIRST"

#. type: pindex
#: zsh.texi:10088
#, no-wrap
msgid "NO_LIST_ROWS_FIRST"
msgstr "NO_LIST_ROWS_FIRST"

#. type: pindex
#: zsh.texi:10089
#, no-wrap
msgid "LISTROWSFIRST"
msgstr "LISTROWSFIRST"

#. type: pindex
#: zsh.texi:10090
#, no-wrap
msgid "NOLISTROWSFIRST"
msgstr "NOLISTROWSFIRST"

#. type: cindex
#: zsh.texi:10091
#, no-wrap
msgid "completion, listing order"
msgstr "补全, 列表顺序"

#. type: table
#: zsh.texi:10096
msgid "Lay out the matches in completion lists sorted horizontally, that is, the second match is to the right of the first one, not under it as usual."
msgstr "在补全列表中按水平排序排列匹配项，即第二个匹配项在第一个匹配项的右边，而不是像往常一样在第一个匹配项的下面。"

#. type: table
#: zsh.texi:10097 zsh.texi:12609
#, no-wrap
msgid "LIST_TYPES"
msgstr "LIST_TYPES"

#. type: pindex
#: zsh.texi:10098
#, no-wrap
msgid "NO_LIST_TYPES"
msgstr "NO_LIST_TYPES"

#. type: pindex
#: zsh.texi:10099
#, no-wrap
msgid "LISTTYPES"
msgstr "LISTTYPES"

#. type: pindex
#: zsh.texi:10100
#, no-wrap
msgid "NOLISTTYPES"
msgstr "NOLISTTYPES"

#. type: cindex
#: zsh.texi:10101
#, no-wrap
msgid "marking file types"
msgstr "标记文件类型"

#. type: cindex
#: zsh.texi:10102
#, no-wrap
msgid "files, marking type of"
msgstr "文件, 标记类型"

#. type: item
#: zsh.texi:10103
#, no-wrap
msgid "@t{LIST_TYPES} (@t{-X}) <D>"
msgstr "@t{LIST_TYPES} (@t{-X}) <D>"

#. type: table
#: zsh.texi:10106
msgid "When listing files that are possible completions, show the type of each file with a trailing identifying mark."
msgstr "在列出可能补全的文件时，用尾部识别标记显示每个文件的类型。"

#. type: table
#: zsh.texi:10107 zsh.texi:12611
#, no-wrap
msgid "MENU_COMPLETE"
msgstr "MENU_COMPLETE"

#. type: pindex
#: zsh.texi:10108
#, no-wrap
msgid "NO_MENU_COMPLETE"
msgstr "NO_MENU_COMPLETE"

#. type: pindex
#: zsh.texi:10109
#, no-wrap
msgid "MENUCOMPLETE"
msgstr "MENUCOMPLETE"

#. type: pindex
#: zsh.texi:10110
#, no-wrap
msgid "NOMENUCOMPLETE"
msgstr "NOMENUCOMPLETE"

#. type: item
#: zsh.texi:10112
#, no-wrap
msgid "@t{MENU_COMPLETE} (@t{-Y})"
msgstr "@t{MENU_COMPLETE} (@t{-Y})"

#. type: table
#: zsh.texi:10119
msgid ""
"On an ambiguous completion, instead of listing possibilities or beeping, insert the first match immediately.  Then when completion is requested again, remove the first match and insert the second match, "
"etc.  When there are no more matches, go back to the first one again.  @t{reverse-menu-complete} may be used to loop through the list in the other direction. This option overrides @t{AUTO_MENU}."
msgstr ""
"在出现模棱两可的补全时，不要列出可能性或发出蜂鸣声，而是立即插入第一个匹配项。 然后，当再次要求补全时，移除第一个匹配项，插入第二个匹配项，等等。 当没有匹配项时，再返回第一个匹配项。 @t{reverse-menu-"
"complete} 可用来从另一个方向循环浏览列表。该选项覆盖 @t{AUTO_MENU}。"

#. type: table
#: zsh.texi:10120 zsh.texi:12599
#, no-wrap
msgid "REC_EXACT"
msgstr "REC_EXACT"

#. type: pindex
#: zsh.texi:10121
#, no-wrap
msgid "NO_REC_EXACT"
msgstr "NO_REC_EXACT"

#. type: pindex
#: zsh.texi:10122
#, no-wrap
msgid "RECEXACT"
msgstr "RECEXACT"

#. type: pindex
#: zsh.texi:10123
#, no-wrap
msgid "NORECEXACT"
msgstr "NORECEXACT"

#. type: cindex
#: zsh.texi:10124
#, no-wrap
msgid "completion, exact matches"
msgstr "补全, 精确匹配"

#. type: item
#: zsh.texi:10125
#, no-wrap
msgid "@t{REC_EXACT} (@t{-S})"
msgstr "@t{REC_EXACT} (@t{-S})"

#. type: table
#: zsh.texi:10129
msgid "If the string on the command line exactly matches one of the possible completions, it is accepted, even if there is another completion (i.e. that string with something else added) that also matches."
msgstr "如果命令行上的字符串与其中一个可能的补全完全匹配，这个补全会被接受（即使有另一个补全<即该字符串添加了其他内容>也匹配）。"

#. type: subsection
#: zsh.texi:10134
#, no-wrap
msgid "Expansion and Globbing"
msgstr "扩展和 Globbing"

#. type: pindex
#: zsh.texi:10137
#, no-wrap
msgid "BAD_PATTERN"
msgstr "BAD_PATTERN"

#. type: pindex
#: zsh.texi:10138
#, no-wrap
msgid "NO_BAD_PATTERN"
msgstr "NO_BAD_PATTERN"

#. type: pindex
#: zsh.texi:10139
#, no-wrap
msgid "BADPATTERN"
msgstr "BADPATTERN"

#. type: pindex
#: zsh.texi:10140
#, no-wrap
msgid "NOBADPATTERN"
msgstr "NOBADPATTERN"

#. type: cindex
#: zsh.texi:10141
#, no-wrap
msgid "globbing, bad pattern"
msgstr "globbing, 坏模式"

#. type: cindex
#: zsh.texi:10142
#, no-wrap
msgid "filename generation, bad pattern"
msgstr "文件名生成, 坏模式"

#. type: item
#: zsh.texi:10143
#, no-wrap
msgid "@t{BAD_PATTERN} (@t{+2}) <C> <Z>"
msgstr "@t{BAD_PATTERN} (@t{+2}) <C> <Z>"

#. type: table
#: zsh.texi:10146
msgid "If a pattern for filename generation is badly formed, print an error message.  (If this option is unset, the pattern will be left unchanged.)"
msgstr "如果文件名生成的模式不正确，则打印错误信息。 (如果未设置该选项，则模式将保持不变）。"

#. type: pindex
#: zsh.texi:10147
#, no-wrap
msgid "BARE_GLOB_QUAL"
msgstr "BARE_GLOB_QUAL"

#. type: pindex
#: zsh.texi:10148
#, no-wrap
msgid "NO_BARE_GLOB_QUAL"
msgstr "NO_BARE_GLOB_QUAL"

#. type: pindex
#: zsh.texi:10149
#, no-wrap
msgid "BAREGLOBQUAL"
msgstr "BAREGLOBQUAL"

#. type: pindex
#: zsh.texi:10150
#, no-wrap
msgid "NOBAREGLOBQUAL"
msgstr "NOBAREGLOBQUAL"

#. type: cindex
#: zsh.texi:10151
#, no-wrap
msgid "globbing qualifiers, enable"
msgstr "globbing 限定符, 启用"

#. type: cindex
#: zsh.texi:10152
#, no-wrap
msgid "enable globbing qualifiers"
msgstr "启用 globbing 限定符"

#. type: item
#: zsh.texi:10153
#, no-wrap
msgid "@t{BARE_GLOB_QUAL} <Z>"
msgstr "@t{BARE_GLOB_QUAL} <Z>"

#. type: table
#: zsh.texi:10157
msgid "In a glob pattern, treat a trailing set of parentheses as a qualifier list, if it contains no `@t{|}', `@t{(}' or (if special) `@t{~}' characters.  See @ref{Filename Generation}."
msgstr "在 glob 模式中，如果尾部的括号不包含 `@t{|}', `@t{(}' 或（如果指定） `@t{~}' 字符，则将其视为限定符列表。 参见 @ref{文件名生成}。"

#. type: t{#1}
#: zsh.texi:10158 zsh.texi:10164
#, no-wrap
msgid "BRACE_CCL"
msgstr "BRACE_CCL"

#. type: pindex
#: zsh.texi:10159
#, no-wrap
msgid "NO_BRACE_CCL"
msgstr "NO_BRACE_CCL"

#. type: pindex
#: zsh.texi:10160
#, no-wrap
msgid "BRACECCL"
msgstr "BRACECCL"

#. type: pindex
#: zsh.texi:10161
#, no-wrap
msgid "NOBRACECCL"
msgstr "NOBRACECCL"

#. type: cindex
#: zsh.texi:10162
#, no-wrap
msgid "brace expansion, extending"
msgstr "括号扩展, 扩展（extending）"

#. type: cindex
#: zsh.texi:10163
#, no-wrap
msgid "expansion, brace, extending"
msgstr "扩展, 括号, 扩展（extending）"

#. type: table
#: zsh.texi:10168
msgid "Expand expressions in braces which would not otherwise undergo brace expansion to a lexically ordered list of all the characters.  See @ref{Brace Expansion}."
msgstr "将括号中的表达式扩展为一个包含所有字符的字面顺序的列表，否则这些表达式不会进行括号扩展。 参见 @ref{括号扩展}。"

#. type: pindex
#: zsh.texi:10169
#, no-wrap
msgid "CASE_GLOB"
msgstr "CASE_GLOB"

#. type: pindex
#: zsh.texi:10170
#, no-wrap
msgid "NO_CASE_GLOB"
msgstr "NO_CASE_GLOB"

#. type: pindex
#: zsh.texi:10171
#, no-wrap
msgid "CASEGLOB"
msgstr "CASEGLOB"

#. type: pindex
#: zsh.texi:10172
#, no-wrap
msgid "NOCASEGLOB"
msgstr "NOCASEGLOB"

#. type: cindex
#: zsh.texi:10173
#, no-wrap
msgid "case-insensitive globbing, option"
msgstr "不区分大小写的 globbing, 选项"

#. type: item
#: zsh.texi:10174
#, no-wrap
msgid "@t{CASE_GLOB} <D>"
msgstr "@t{CASE_GLOB} <D>"

#. type: table
#: zsh.texi:10181
msgid ""
"Make globbing (filename generation) sensitive to case.  Note that other uses of patterns are always sensitive to case.  If the option is unset, the presence of any character which is special to filename "
"generation will cause case-insensitive matching.  For example, @t{cvs(/)} can match the directory @t{CVS} owing to the presence of the globbing flag (unless the option @t{BARE_GLOB_QUAL} is unset)."
msgstr ""
"使 globbing（文件名生成）对大小写敏感。 请注意，模式的其他用法始终对大小写敏感。 如果未设置该选项，则文件名生成过程中出现的任何特殊字符都将导致不区分大小写的匹配。 例如，由于存在 globbing 标志，@t{cvs(/)} "
"可以匹配目录 @t{CVS}（除非未设置选项 @t{BARE_GLOB_QUAL}）。"

#. type: pindex
#: zsh.texi:10182
#, no-wrap
msgid "CASE_MATCH"
msgstr "CASE_MATCH"

#. type: pindex
#: zsh.texi:10183 zsh.texi:29981
#, no-wrap
msgid "NO_CASE_MATCH"
msgstr "NO_CASE_MATCH"

#. type: pindex
#: zsh.texi:10184
#, no-wrap
msgid "CASEMATCH"
msgstr "CASEMATCH"

#. type: pindex
#: zsh.texi:10185
#, no-wrap
msgid "NOCASEMATCH"
msgstr "NOCASEMATCH"

#. type: cindex
#: zsh.texi:10186
#, no-wrap
msgid "case-insensitive regular expression matches, option"
msgstr "不区分大小写的正则表达式匹配, 选项"

#. type: cindex
#: zsh.texi:10187
#, no-wrap
msgid "regular expressions, case-insensitive matching, option"
msgstr "正则表达式, 不区分大小写匹配, 选项"

#. type: item
#: zsh.texi:10188
#, no-wrap
msgid "@t{CASE_MATCH} <D>"
msgstr "@t{CASE_MATCH} <D>"

#. type: table
#: zsh.texi:10191
msgid "Make regular expressions using the @t{zsh/regex} module (including matches with @t{=~}) sensitive to case."
msgstr "使使用 @t{zsh/regex} 模块的正则表达式（包括使用 @t{=~} 的匹配）对大小写敏感。"

#. type: t{#1}
#: zsh.texi:10192 zsh.texi:10197
#, no-wrap
msgid "CASE_PATHS"
msgstr "CASE_PATHS"

#. type: pindex
#: zsh.texi:10193
#, no-wrap
msgid "NO_CASE_PATHS"
msgstr "NO_CASE_PATHS"

#. type: pindex
#: zsh.texi:10194
#, no-wrap
msgid "CASEPATHS"
msgstr "CASEPATHS"

#. type: pindex
#: zsh.texi:10195
#, no-wrap
msgid "NOCASEPATHS"
msgstr "NOCASEPATHS"

#. type: cindex
#: zsh.texi:10196
#, no-wrap
msgid "case-sensitive globbing, option"
msgstr "大小写敏感的 globbing, 选项"

#. type: table
#: zsh.texi:10204
msgid ""
"If @t{CASE_PATHS} is not set (the default), @t{CASE_GLOB} affects the interpretation of @emph{every} path component, whenever a special character appears in @emph{any} component.  When @t{CASE_PATHS} is "
"set, file path components that do @emph{not} contain special filename generation characters are always sensitive to case, thus restricting @t{NO_CASE_GLOB} to components that contain globbing characters."
msgstr ""
"如果未设置 @t{CASE_PATHS}（默认值），只要 @emph{任意} 组件中出现特殊字符，@t{CASE_GLOB} 就会影响 @emph{每一个} 路径组件的解释。 设置 @t{CASE_PATHS} 后，@emph{不} 包含特殊文件名生成字符的文件路径组件始终对"
"大小写敏感，因此 @t{NO_CASE_GLOB} 只适用于包含 globing 字符的组件。"

#. type: table
#: zsh.texi:10208
msgid "Note that if the filesystem itself is not sensitive to case, then @t{CASE_PATHS} has no effect."
msgstr "请注意，如果文件系统本身对大小写不敏感，那么 @t{CASE_PATHS} 就没有任何作用。"

#. type: pindex
#: zsh.texi:10209
#, no-wrap
msgid "CSH_NULL_GLOB"
msgstr "CSH_NULL_GLOB"

#. type: pindex
#: zsh.texi:10210
#, no-wrap
msgid "NO_CSH_NULL_GLOB"
msgstr "NO_CSH_NULL_GLOB"

#. type: pindex
#: zsh.texi:10211
#, no-wrap
msgid "CSHNULLGLOB"
msgstr "CSHNULLGLOB"

#. type: pindex
#: zsh.texi:10212
#, no-wrap
msgid "NOCSHNULLGLOB"
msgstr "NOCSHNULLGLOB"

#. type: cindex
#: zsh.texi:10213
#, no-wrap
msgid "csh, null globbing style"
msgstr "csh, 空 globbing 风格"

#. type: cindex
#: zsh.texi:10214
#, no-wrap
msgid "null globbing style, csh"
msgstr "空 globbing 风格, csh"

#. type: cindex
#: zsh.texi:10215
#, no-wrap
msgid "globbing, null, style, csh"
msgstr "globbing, 空, 风格, csh"

#. type: item
#: zsh.texi:10216
#, no-wrap
msgid "@t{CSH_NULL_GLOB} <C>"
msgstr "@t{CSH_NULL_GLOB} <C>"

#. type: table
#: zsh.texi:10222
msgid "If a pattern for filename generation has no matches, delete the pattern from the argument list; do not report an error unless all the patterns in a command have no matches.  Overrides @t{NOMATCH}."
msgstr "如果生成文件名的模式没有匹配项，则从参数列表中删除该模式；除非命令中的所有模式都没有匹配项，否则不报错。 覆盖 @t{NOMATCH}。"

#. type: pindex
#: zsh.texi:10223
#, no-wrap
msgid "EQUALS"
msgstr "EQUALS"

#. type: pindex
#: zsh.texi:10224
#, no-wrap
msgid "NO_EQUALS"
msgstr "NO_EQUALS"

#. type: pindex
#: zsh.texi:10225
#, no-wrap
msgid "NOEQUALS"
msgstr "NOEQUALS"

#. type: cindex
#: zsh.texi:10226
#, no-wrap
msgid "filename expansion, ="
msgstr "文件名扩展, ="

#. type: item
#: zsh.texi:10227
#, no-wrap
msgid "@t{EQUALS} <Z>"
msgstr "@t{EQUALS} <Z>"

#. type: table
#: zsh.texi:10230
msgid "Perform @t{=} filename expansion.  (See @ref{Filename Expansion}.)"
msgstr "执行 @t{=} 文件名扩展。 (参见 @ref{文件名扩展}）。"

#. type: t{#1}
#: zsh.texi:10231 zsh.texi:10236
#, no-wrap
msgid "EXTENDED_GLOB"
msgstr "EXTENDED_GLOB"

#. type: pindex
#: zsh.texi:10232
#, no-wrap
msgid "NO_EXTENDED_GLOB"
msgstr "NO_EXTENDED_GLOB"

#. type: pindex
#: zsh.texi:10233
#, no-wrap
msgid "EXTENDEDGLOB"
msgstr "EXTENDEDGLOB"

#. type: pindex
#: zsh.texi:10234
#, no-wrap
msgid "NOEXTENDEDGLOB"
msgstr "NOEXTENDEDGLOB"

#. type: cindex
#: zsh.texi:10235
#, no-wrap
msgid "globbing, extended"
msgstr "globbing, 扩展的"

#. type: table
#: zsh.texi:10240
msgid "Treat the `@t{#}', `@t{~}' and `@t{^}' characters as part of patterns for filename generation, etc.  (An initial unquoted `@t{~}' always produces named directory expansion.)"
msgstr "将 `@t{#}', `@t{~}' 和 `@t{^}' 字符视为文件名生成等的模式的一部分（初始的无引号的 `@t{~}' 总是产生命名目录扩展）。"

#. type: t{#1}
#: zsh.texi:10241 zsh.texi:10247
#, no-wrap
msgid "FORCE_FLOAT"
msgstr "FORCE_FLOAT"

#. type: pindex
#: zsh.texi:10242
#, no-wrap
msgid "NO_FORCE_FLOAT"
msgstr "NO_FORCE_FLOAT"

#. type: pindex
#: zsh.texi:10243
#, no-wrap
msgid "FORCEFLOAT"
msgstr "FORCEFLOAT"

#. type: pindex
#: zsh.texi:10244
#, no-wrap
msgid "NOFORCEFLOAT"
msgstr "NOFORCEFLOAT"

#. type: cindex
#: zsh.texi:10245
#, no-wrap
msgid "floating point, forcing use of"
msgstr "浮点, 强制使用"

#. type: cindex
#: zsh.texi:10246
#, no-wrap
msgid "forcing use of floating point"
msgstr "强制使用浮点"

#. type: table
#: zsh.texi:10252
msgid ""
"Constants in arithmetic evaluation will be treated as floating point even without the use of a decimal point; the values of integer variables will be converted to floating point when used in arithmetic "
"expressions.  Integers in any base will be converted."
msgstr "即使不使用小数点，算术运算中的常量也将被视为浮点数；整数变量在算术表达式中使用时，其值将转换为浮点数。 任何基数的整数都会被转换。"

#. type: pindex
#: zsh.texi:10253
#, no-wrap
msgid "GLOB"
msgstr "GLOB"

#. type: pindex
#: zsh.texi:10254
#, no-wrap
msgid "NO_GLOB"
msgstr "NO_GLOB"

#. type: pindex
#: zsh.texi:10255
#, no-wrap
msgid "NOGLOB"
msgstr "NOGLOB"

#. type: cindex
#: zsh.texi:10256
#, no-wrap
msgid "globbing, enabling"
msgstr "globbing, 启用"

#. type: cindex
#: zsh.texi:10257
#, no-wrap
msgid "enabling globbing"
msgstr "启用 globbing"

#. type: item
#: zsh.texi:10258
#, no-wrap
msgid "@t{GLOB} (@t{+F}, ksh: @t{+f}) <D>"
msgstr "@t{GLOB} (@t{+F}, ksh: @t{+f}) <D>"

#. type: table
#: zsh.texi:10261
msgid "Perform filename generation (globbing).  (See @ref{Filename Generation}.)"
msgstr "执行文件名生成（globbing）。 (参见 @ref{文件名生成}）。"

#. type: pindex
#: zsh.texi:10262
#, no-wrap
msgid "GLOB_ASSIGN"
msgstr "GLOB_ASSIGN"

#. type: pindex
#: zsh.texi:10263
#, no-wrap
msgid "NO_GLOB_ASSIGN"
msgstr "NO_GLOB_ASSIGN"

#. type: pindex
#: zsh.texi:10264
#, no-wrap
msgid "GLOBASSIGN"
msgstr "GLOBASSIGN"

#. type: pindex
#: zsh.texi:10265
#, no-wrap
msgid "NOGLOBASSIGN"
msgstr "NOGLOBASSIGN"

#. type: item
#: zsh.texi:10266
#, no-wrap
msgid "@t{GLOB_ASSIGN} <C>"
msgstr "@t{GLOB_ASSIGN} <C>"

#. type: table
#: zsh.texi:10277
msgid ""
"If this option is set, filename generation (globbing) is performed on the right hand side of scalar parameter assignments of the form `@var{name}@t{=}@var{pattern} (e.g. `@t{foo=*}').  If the result has "
"more than one word the parameter will become an array with those words as arguments. This option is provided for backwards compatibility only: globbing is always performed on the right hand side of array "
"assignments of the form `@var{name}@t{=(}@var{value}@t{)}' (e.g. `@t{foo=(*)}') and this form is recommended for clarity; with this option set, it is not possible to predict whether the result will be an "
"array or a scalar."
msgstr ""
"如果设置了该选项，文件名生成（globbing）将在`@var{name}@t{=}@var{pattern} '(例如 `@t{foo=*}')形式的标量参数赋值的右侧进行。 如果结果有多个单词，参数将变成一个数组，并以这些单词作为参数。提供该选项只是为了"
"向后兼容：globbing 总是在形式为  `@var{name}@t{=(}@var{value}@t{)}' (e.g. `@t{foo=(*)}') 的数组赋值的右侧执行，为了清晰起见，推荐使用这种形式；设置该选项后，无法预测结果是数组还是标量。"

#. type: table
#: zsh.texi:10278 zsh.texi:12553
#, no-wrap
msgid "GLOB_DOTS"
msgstr "GLOB_DOTS"

#. type: pindex
#: zsh.texi:10279
#, no-wrap
msgid "NO_GLOB_DOTS"
msgstr "NO_GLOB_DOTS"

#. type: pindex
#: zsh.texi:10280
#, no-wrap
msgid "GLOBDOTS"
msgstr "GLOBDOTS"

#. type: pindex
#: zsh.texi:10281
#, no-wrap
msgid "NOGLOBDOTS"
msgstr "NOGLOBDOTS"

#. type: cindex
#: zsh.texi:10282
#, no-wrap
msgid "globbing, of . files"
msgstr "globbing, of . files"

#. type: item
#: zsh.texi:10283
#, no-wrap
msgid "@t{GLOB_DOTS} (@t{-4})"
msgstr "@t{GLOB_DOTS} (@t{-4})"

#. type: table
#: zsh.texi:10285
msgid "Do not require a leading `@t{.}' in a filename to be matched explicitly."
msgstr "不要求明确匹配文件名中的前导 `@t{.}'。"

#. type: t{#1}
#: zsh.texi:10286 zsh.texi:10292
#, no-wrap
msgid "GLOB_STAR_SHORT"
msgstr "GLOB_STAR_SHORT"

#. type: pindex
#: zsh.texi:10287
#, no-wrap
msgid "NO_GLOB_STAR_SHORT"
msgstr "NO_GLOB_STAR_SHORT"

#. type: pindex
#: zsh.texi:10288
#, no-wrap
msgid "GLOBSTARSHORT"
msgstr "GLOBSTARSHORT"

#. type: pindex
#: zsh.texi:10289
#, no-wrap
msgid "NOGLOBSTARSHORT"
msgstr "NOGLOBSTARSHORT"

#. type: cindex
#: zsh.texi:10290
#, no-wrap
msgid "globbing, short forms"
msgstr "globbing, 简短形式"

#. type: cindex
#: zsh.texi:10291
#, no-wrap
msgid "globbing, ** special"
msgstr "globbing, ** special"

#. type: table
#: zsh.texi:10300
msgid ""
"When this option is set and the default zsh-style globbing is in effect, the pattern `@t{**/*}' can be abbreviated to `@t{**}' and the pattern `@t{***/*}' can be abbreviated to @t{***}.  Hence `@t{**.c}' "
"finds a file ending in @t{.c} in any subdirectory, and `@t{***.c}' does the same while also following symbolic links.  A @t{/} immediately after the `@t{**}' or `@t{***}' forces the pattern to be treated "
"as the unabbreviated form."
msgstr ""
"当设置了该选项且默认的 zsh 风格 globbing 有效时，`@t{**/*}' 模式可缩写为 `@t{**}' ，而 `@t{***/*}' 模式可缩写为 @t{***}。 因此， `@t{**.c}' 可以在任何子目录中找到以 @t{.c} 结尾的文件，而 `@t{***.c}' 也可以"
"在跟踪符号链接的同时找到以 @t{***.c} 结尾的文件。 紧跟在`@t{**}' 或  `@t{***}'  之后的 @t{/} 会强制将模式视为未缩写形式。"

#. type: pindex
#: zsh.texi:10301
#, no-wrap
msgid "GLOB_SUBST"
msgstr "GLOB_SUBST"

#. type: pindex
#: zsh.texi:10302
#, no-wrap
msgid "NO_GLOB_SUBST"
msgstr "NO_GLOB_SUBST"

#. type: pindex
#: zsh.texi:10303
#, no-wrap
msgid "GLOBSUBST"
msgstr "GLOBSUBST"

#. type: pindex
#: zsh.texi:10304
#, no-wrap
msgid "NOGLOBSUBST"
msgstr "NOGLOBSUBST"

#. type: item
#: zsh.texi:10305
#, no-wrap
msgid "@t{GLOB_SUBST} <C> <K> <S>"
msgstr "@t{GLOB_SUBST} <C> <K> <S>"

#. type: table
#: zsh.texi:10311
msgid ""
"Treat any characters resulting from parameter expansion as being eligible for filename expansion and filename generation, and any characters resulting from command substitution as being eligible for "
"filename generation.  Braces (and commas in between) do not become eligible for expansion."
msgstr "将参数扩展产生的任何字符视为符合文件名扩展和文件名生成条件，将命令替换产生的任何字符视为符合文件名生成条件。 括号（和中间的逗号）不符合扩展条件。"

#. type: t{#1}
#: zsh.texi:10312 zsh.texi:10316
#, no-wrap
msgid "HIST_SUBST_PATTERN"
msgstr "HIST_SUBST_PATTERN"

#. type: pindex
#: zsh.texi:10313
#, no-wrap
msgid "NO_HIST_SUBST_PATTERN"
msgstr "NO_HIST_SUBST_PATTERN"

#. type: pindex
#: zsh.texi:10314
#, no-wrap
msgid "HISTSUBSTPATTERN"
msgstr "HISTSUBSTPATTERN"

#. type: pindex
#: zsh.texi:10315
#, no-wrap
msgid "NOHISTSUBSTPATTERN"
msgstr "NOHISTSUBSTPATTERN"

#. type: table
#: zsh.texi:10322
msgid ""
"Substitutions using the @t{:s} and @t{:&} history modifiers are performed with pattern matching instead of string matching.  This occurs wherever history modifiers are valid, including glob qualifiers and "
"parameters.  See @ref{Modifiers}."
msgstr "使用 @t{:s} 和  @t{:&} 历史修饰符的替换的执行，是使用模式匹配而不是字符串匹配。只要历史修饰符（包括glob限定符和参数）有效，就会发生这种情况。请参见 @ref{修饰符}。"

#. type: table
#: zsh.texi:10323 zsh.texi:12579
#, no-wrap
msgid "IGNORE_BRACES"
msgstr "IGNORE_BRACES"

#. type: pindex
#: zsh.texi:10324
#, no-wrap
msgid "NO_IGNORE_BRACES"
msgstr "NO_IGNORE_BRACES"

#. type: pindex
#: zsh.texi:10325
#, no-wrap
msgid "IGNOREBRACES"
msgstr "IGNOREBRACES"

#. type: pindex
#: zsh.texi:10326
#, no-wrap
msgid "NOIGNOREBRACES"
msgstr "NOIGNOREBRACES"

#. type: cindex
#: zsh.texi:10327
#, no-wrap
msgid "disabling brace expansion"
msgstr "禁用括号扩展"

#. type: cindex
#: zsh.texi:10328
#, no-wrap
msgid "brace expansion, disabling"
msgstr "括号扩展, 禁用"

#. type: cindex
#: zsh.texi:10329
#, no-wrap
msgid "expansion, brace, disabling"
msgstr "扩展, 括号, 禁用"

#. type: item
#: zsh.texi:10330
#, no-wrap
msgid "@t{IGNORE_BRACES} (@t{-I}) <S>"
msgstr "@t{IGNORE_BRACES} (@t{-I}) <S>"

#. type: table
#: zsh.texi:10333
msgid "Do not perform brace expansion.  For historical reasons this also includes the effect of the @t{IGNORE_CLOSE_BRACES} option."
msgstr "不执行括号扩展。 由于历史原因，这也包括 @t{IGNORE_CLOSE_BRACES} 选项的效果。"

#. type: t{#1}
#: zsh.texi:10334 zsh.texi:10338
#, no-wrap
msgid "IGNORE_CLOSE_BRACES"
msgstr "IGNORE_CLOSE_BRACES"

#. type: pindex
#: zsh.texi:10335
#, no-wrap
msgid "NO_IGNORE_CLOSE_BRACES"
msgstr "NO_IGNORE_CLOSE_BRACES"

#. type: pindex
#: zsh.texi:10336
#, no-wrap
msgid "IGNORECLOSEBRACES"
msgstr "IGNORECLOSEBRACES"

#. type: pindex
#: zsh.texi:10337
#, no-wrap
msgid "NOIGNORECLOSEBRACES"
msgstr "NOIGNORECLOSEBRACES"

#. type: table
#: zsh.texi:10346
msgid ""
"When neither this option nor @t{IGNORE_BRACES} is set, a sole close brace character `@t{@}}' is syntactically significant at any point on a command line.  This has the effect that no semicolon or newline "
"is necessary before the brace terminating a function or current shell construct.  When either option is set, a closing brace is syntactically significant only in command position.  Unlike "
"@t{IGNORE_BRACES}, this option does not disable brace expansion."
msgstr ""
"如果既未设置该选项，也未设置 @t{IGNORE_BRACES}，那么在命令行的任何位置，单一的封闭括号字符 `@t{@}}' 都具有语法意义。 这样一来，在结束函数或当前 shell 结构的括号前就不需要分号或换行符了。 如果设置了这两个选"
"项中的任何一个，则结尾大括号只在命令行位置有语法意义。 与 @t{IGNORE_BRACES} 不同，该选项不会禁用括号扩展。"

#. type: table
#: zsh.texi:10350
msgid "For example, with both options unset a function may be defined in the following fashion:"
msgstr "例如，在两个选项都未设置的情况下，可以按以下方式定义一个函数："

#. type: example
#: zsh.texi:10354
#, no-wrap
msgid "args() @{ echo $# @}\n"
msgstr "args() @{ echo $# @}\n"

#. type: table
#: zsh.texi:10359
msgid "while if either option is set, this does not work and something equivalent to the following is required:"
msgstr "而如果设置了这两个选项中的任何一个，则不起作用，需要类似下面的设置："

#. type: example
#: zsh.texi:10363
#, no-wrap
msgid "args() @{ echo $#; @}\n"
msgstr "args() @{ echo $#; @}\n"

#. type: pindex
#: zsh.texi:10367
#, no-wrap
msgid "KSH_GLOB"
msgstr "KSH_GLOB"

#. type: pindex
#: zsh.texi:10368
#, no-wrap
msgid "NO_KSH_GLOB"
msgstr "NO_KSH_GLOB"

#. type: pindex
#: zsh.texi:10369
#, no-wrap
msgid "KSHGLOB"
msgstr "KSHGLOB"

#. type: pindex
#: zsh.texi:10370
#, no-wrap
msgid "NOKSHGLOB"
msgstr "NOKSHGLOB"

#. type: item
#: zsh.texi:10371
#, no-wrap
msgid "@t{KSH_GLOB} <K>"
msgstr "@t{KSH_GLOB} <K>"

#. type: table
#: zsh.texi:10375
msgid "In pattern matching, the interpretation of parentheses is affected by a preceding `@t{@@}', `@t{*}', `@t{+}', `@t{?}' or `@t{!}'.  See @ref{Filename Generation}."
msgstr "在模式匹配中，括号的解释受前面的 `@t{@@}', `@t{*}', `@t{+}', `@t{?}' 或 `@t{!}' 的影响。 参见 @ref{文件名生成}。"

#. type: t{#1}
#: zsh.texi:10376 zsh.texi:10380
#, no-wrap
msgid "MAGIC_EQUAL_SUBST"
msgstr "MAGIC_EQUAL_SUBST"

#. type: pindex
#: zsh.texi:10377
#, no-wrap
msgid "NO_MAGIC_EQUAL_SUBST"
msgstr "NO_MAGIC_EQUAL_SUBST"

#. type: pindex
#: zsh.texi:10378
#, no-wrap
msgid "MAGICEQUALSUBST"
msgstr "MAGICEQUALSUBST"

#. type: pindex
#: zsh.texi:10379
#, no-wrap
msgid "NOMAGICEQUALSUBST"
msgstr "NOMAGICEQUALSUBST"

#. type: table
#: zsh.texi:10389
msgid ""
"All unquoted arguments of the form `@var{anything}@t{=}@var{expression}' appearing after the command name have filename expansion (that is, where @var{expression} has a leading `@t{~}' or `@t{=}') "
"performed on @var{expression} as if it were a parameter assignment.  The argument is not otherwise treated specially; it is passed to the command as a single argument, and not used as an actual parameter "
"assignment.  For example, in @t{echo foo=~/bar:~/rod}, both occurrences of @t{~} would be replaced.  Note that this happens anyway with @t{typeset} and similar statements."
msgstr ""
"在命令名之后出现的所有未加引号的参数，其形式为 `@var{anything}@t{=}@var{expression}'，其文件名扩展（即 @var{expression} 带有前导 `@t{~}' 或 `@t{=}' ）在 @var{expression} 上执行，如同这是参数赋值。 参数不会"
"受到其他特殊处理；它将作为单个参数传递给命令，而不是用作实际的参数赋值。 例如，在 @t{echo foo=~/bar:~/rod} 中，@t{~} 的两次出现都会被替换。 请注意，@t{typeset} 和类似语句都会出现这种情况。"

#. type: table
#: zsh.texi:10394
msgid "This option respects the setting of the @t{KSH_TYPESET} option.  In other words, if both options are in effect, arguments looking like assignments will not undergo word splitting."
msgstr "该选项尊守 @t{KSH_TYPESET} 选项的设置。 换句话说，如果两个选项都有效，看起来像赋值的参数将不会被分词。"

#. type: table
#: zsh.texi:10395 zsh.texi:12561 zsh.texi:12662
#, no-wrap
msgid "MARK_DIRS"
msgstr "MARK_DIRS"

#. type: pindex
#: zsh.texi:10396
#, no-wrap
msgid "NO_MARK_DIRS"
msgstr "NO_MARK_DIRS"

#. type: pindex
#: zsh.texi:10397
#, no-wrap
msgid "MARKDIRS"
msgstr "MARKDIRS"

#. type: pindex
#: zsh.texi:10398
#, no-wrap
msgid "NOMARKDIRS"
msgstr "NOMARKDIRS"

#. type: cindex
#: zsh.texi:10399
#, no-wrap
msgid "directories, marking"
msgstr "目录, 标记"

#. type: cindex
#: zsh.texi:10400
#, no-wrap
msgid "marking directories"
msgstr "标记目录"

#. type: item
#: zsh.texi:10401
#, no-wrap
msgid "@t{MARK_DIRS} (@t{-8}, ksh: @t{-X})"
msgstr "@t{MARK_DIRS} (@t{-8}, ksh: @t{-X})"

#. type: table
#: zsh.texi:10404
msgid "Append a trailing `@t{/}' to all directory names resulting from filename generation (globbing)."
msgstr "在文件名生成（globbing）过程中产生的所有目录名后添加尾部 `@t{/}' 。"

#. type: pindex
#: zsh.texi:10405
#, no-wrap
msgid "MULTIBYTE"
msgstr "MULTIBYTE"

#. type: pindex
#: zsh.texi:10406
#, no-wrap
msgid "NO_MULTIBYTE"
msgstr "NO_MULTIBYTE"

#. type: pindex
#: zsh.texi:10407
#, no-wrap
msgid "NOMULTIBYTE"
msgstr "NOMULTIBYTE"

#. type: cindex
#: zsh.texi:10408
#, no-wrap
msgid "characters, multibyte, in expansion and globbing"
msgstr "字符, 多字节, 在扩展和 globbing 中"

#. type: cindex
#: zsh.texi:10409
#, no-wrap
msgid "multibyte characters, in expansion and globbing"
msgstr "多字节字符, 在扩展和 globbing 中"

#. type: item
#: zsh.texi:10410
#, no-wrap
msgid "@t{MULTIBYTE} <D>"
msgstr "@t{MULTIBYTE} <D>"

#. type: table
#: zsh.texi:10416
msgid ""
"Respect multibyte characters when found in strings.  When this option is set, strings are examined using the system library to determine how many bytes form a character, depending on the current locale.  "
"This affects the way characters are counted in pattern matching, parameter values and various delimiters."
msgstr "当字符串中出现多字节字符时，尊守多字节字符。 设置该选项后，将使用系统库检查字符串，以确定一个字符由多少个字节组成，具体取决于当前的本地语言。 这将影响字符在模式匹配、参数值和各种分隔符中的计数方式。"

#. type: table
#: zsh.texi:10421
msgid "The option is on by default if the shell was compiled with @t{MULTIBYTE_SUPPORT}; otherwise it is off by default and has no effect if turned on."
msgstr "如果 shell 在编译时使用了 @t{MULTIBYTE_SUPPORT}，则默认开启该选项；否则默认关闭，开启后也不会有任何影响。"

#. type: table
#: zsh.texi:10429
msgid ""
"If the option is off a single byte is always treated as a single character.  This setting is designed purely for examining strings known to contain raw bytes or other values that may not be characters in "
"the current locale.  It is not necessary to unset the option merely because the character set for the current locale does not contain multibyte characters."
msgstr ""
"如果关闭该选项，单字节将始终被视为单字符。 这一设置纯粹是为了检查已知包含原始字节或其他值的字符串，这些字节或值在当前本地语言中可能不是字符。 没有必要仅仅因为当前语言的字符集不包含多字节字符而取消设置该选"
"项。"

#. type: table
#: zsh.texi:10435
msgid ""
"The option does not affect the shell's editor, which always uses the locale to determine multibyte characters.  This is because the character set displayed by the terminal emulator is independent of shell "
"settings."
msgstr "该选项不会影响 shell 的编辑器，它始终使用本地设置来确定多字节字符。 这是因为终端模拟器显示的字符集与 shell 设置无关。"

#. type: pindex
#: zsh.texi:10436
#, no-wrap
msgid "NOMATCH"
msgstr "NOMATCH"

#. type: pindex
#: zsh.texi:10437
#, no-wrap
msgid "NO_NOMATCH"
msgstr "NO_NOMATCH"

#. type: pindex
#: zsh.texi:10438
#, no-wrap
msgid "NONOMATCH"
msgstr "NONOMATCH"

#. type: cindex
#: zsh.texi:10439 zsh.texi:10451
#, no-wrap
msgid "globbing, no matches"
msgstr "globbing, 没有匹配"

#. type: item
#: zsh.texi:10440
#, no-wrap
msgid "@t{NOMATCH} (@t{+3}) <C> <Z>"
msgstr "@t{NOMATCH} (@t{+3}) <C> <Z>"

#. type: table
#: zsh.texi:10446
msgid "If a pattern for filename generation has no matches, print an error, instead of leaving it unchanged in the argument list.  This also applies to file expansion of an initial `@t{~}' or `@t{=}'."
msgstr "如果文件名生成的模式没有匹配项，则打印错误信息，而不是在参数列表中保持不变。 这也适用于起始为 `@t{~}' 或 `@t{=}'的文件扩展。"

#. type: table
#: zsh.texi:10447 zsh.texi:12575
#, no-wrap
msgid "NULL_GLOB"
msgstr "NULL_GLOB"

#. type: pindex
#: zsh.texi:10448
#, no-wrap
msgid "NO_NULL_GLOB"
msgstr "NO_NULL_GLOB"

#. type: pindex
#: zsh.texi:10449
#, no-wrap
msgid "NULLGLOB"
msgstr "NULLGLOB"

#. type: pindex
#: zsh.texi:10450
#, no-wrap
msgid "NONULLGLOB"
msgstr "NONULLGLOB"

#. type: item
#: zsh.texi:10452
#, no-wrap
msgid "@t{NULL_GLOB} (@t{-G})"
msgstr "@t{NULL_GLOB} (@t{-G})"

#. type: table
#: zsh.texi:10456
msgid "If a pattern for filename generation has no matches, delete the pattern from the argument list instead of reporting an error.  Overrides @t{NOMATCH}."
msgstr "如果文件名生成的模式没有匹配项，则从参数列表中删除该模式，而不是报错。 覆盖 @t{NOMATCH}。"

#. type: t{#1}
#: zsh.texi:10457 zsh.texi:10462
#, no-wrap
msgid "NUMERIC_GLOB_SORT"
msgstr "NUMERIC_GLOB_SORT"

#. type: pindex
#: zsh.texi:10458
#, no-wrap
msgid "NO_NUMERIC_GLOB_SORT"
msgstr "NO_NUMERIC_GLOB_SORT"

#. type: pindex
#: zsh.texi:10459
#, no-wrap
msgid "NUMERICGLOBSORT"
msgstr "NUMERICGLOBSORT"

#. type: pindex
#: zsh.texi:10460
#, no-wrap
msgid "NONUMERICGLOBSORT"
msgstr "NONUMERICGLOBSORT"

#. type: cindex
#: zsh.texi:10461
#, no-wrap
msgid "globbing, sorting numerically"
msgstr "globbing, 按数值排序"

#. type: table
#: zsh.texi:10465
msgid "If numeric filenames are matched by a filename generation pattern, sort the filenames numerically rather than lexicographically."
msgstr "如果数字文件名与文件名生成模式相匹配，则按数字而不是按词法对文件名进行排序。"

#. type: table
#: zsh.texi:10466 zsh.texi:12593
#, no-wrap
msgid "RC_EXPAND_PARAM"
msgstr "RC_EXPAND_PARAM"

#. type: pindex
#: zsh.texi:10467
#, no-wrap
msgid "NO_RC_EXPAND_PARAM"
msgstr "NO_RC_EXPAND_PARAM"

#. type: pindex
#: zsh.texi:10468
#, no-wrap
msgid "RCEXPANDPARAM"
msgstr "RCEXPANDPARAM"

#. type: pindex
#: zsh.texi:10469
#, no-wrap
msgid "NORCEXPANDPARAM"
msgstr "NORCEXPANDPARAM"

#. type: cindex
#: zsh.texi:10470
#, no-wrap
msgid "rc, parameter expansion style"
msgstr "rc, 参数扩展风格"

#. type: cindex
#: zsh.texi:10471
#, no-wrap
msgid "parameter expansion style, rc"
msgstr "参数扩展风格, rc"

#. type: item
#: zsh.texi:10472
#, no-wrap
msgid "@t{RC_EXPAND_PARAM} (@t{-P})"
msgstr "@t{RC_EXPAND_PARAM} (@t{-P})"

#. type: table
#: zsh.texi:10479
msgid ""
"Array expansions of the form `@var{foo}@t{$@{}@var{xx}@t{@}}@var{bar}', where the parameter @var{xx} is set to @t{(}@var{a b c}@t{)}, are substituted with `@var{fooabar foobbar foocbar}' instead of the "
"default `@var{fooa b cbar}'.  Note that an empty array will therefore cause all arguments to be removed."
msgstr ""
"格式为  `@var{foo}@t{$@{}@var{xx}@t{@}}@var{bar}' 的数组扩展形式（其中参数 @var{xx} 被设置为  @t{(}@var{a b c}@t{)} ）, 将被替换为 `@var{fooabar foobbar foocbar}' ，而不是默认的 `@var{fooa b cbar}'。 请注"
"意，如果数组为空，所有参数都会被移除。"

#. type: pindex
#: zsh.texi:10480 zsh.texi:10486 zsh.texi:29980
#, no-wrap
msgid "REMATCH_PCRE"
msgstr "REMATCH_PCRE"

#. type: pindex
#: zsh.texi:10481
#, no-wrap
msgid "NO_REMATCH_PCRE"
msgstr "NO_REMATCH_PCRE"

#. type: pindex
#: zsh.texi:10482
#, no-wrap
msgid "REMATCHPCRE"
msgstr "REMATCHPCRE"

#. type: pindex
#: zsh.texi:10483
#, no-wrap
msgid "NOREMATCHPCRE"
msgstr "NOREMATCHPCRE"

#. type: cindex
#: zsh.texi:10484
#, no-wrap
msgid "regexp, PCRE"
msgstr "regexp, PCRE"

#. type: cindex
#: zsh.texi:10485
#, no-wrap
msgid "PCRE, regexp"
msgstr "PCRE, regexp"

#. type: table
#: zsh.texi:10492
msgid ""
"If set, regular expression matching with the @t{=~} operator will use Perl-Compatible Regular Expressions from the PCRE library.  (The @t{zsh/pcre} module must be available.)  If not set, regular "
"expressions will use the extended regexp syntax provided by the system libraries."
msgstr "如果设置，使用 @t{=~} 操作符匹配的正则表达式将使用 PCRE 库中的 Perl 兼容正则表达式（@t{zsh/pcre} 模块必须可用）。 如果未设置，正则表达式将使用系统库提供的扩展 regexp 语法。"

#. type: pindex
#: zsh.texi:10493
#, no-wrap
msgid "SH_GLOB"
msgstr "SH_GLOB"

#. type: pindex
#: zsh.texi:10494
#, no-wrap
msgid "NO_SH_GLOB"
msgstr "NO_SH_GLOB"

#. type: pindex
#: zsh.texi:10495
#, no-wrap
msgid "SHGLOB"
msgstr "SHGLOB"

#. type: pindex
#: zsh.texi:10496
#, no-wrap
msgid "NOSHGLOB"
msgstr "NOSHGLOB"

#. type: cindex
#: zsh.texi:10497
#, no-wrap
msgid "sh, globbing style"
msgstr "sh, globbing 风格"

#. type: cindex
#: zsh.texi:10498
#, no-wrap
msgid "globbing style, sh"
msgstr "globbing 风格, sh"

#. type: item
#: zsh.texi:10499
#, no-wrap
msgid "@t{SH_GLOB} <K> <S>"
msgstr "@t{SH_GLOB} <K> <S>"

#. type: table
#: zsh.texi:10509
msgid ""
"Disables the special meaning of `@t{(}', `@t{|}', `@t{)}' and '@t{<}' for globbing the result of parameter and command substitutions, and in some other places where the shell accepts patterns.  If "
"@t{SH_GLOB} is set but @t{KSH_GLOB} is not, the shell allows the interpretation of subshell expressions enclosed in parentheses in some cases where there is no space before the opening parenthesis, e.g. "
"@t{!(true)} is interpreted as if there were a space after the @t{!}.  This option is set by default if zsh is invoked as @t{sh} or @t{ksh}."
msgstr ""
"在参数和命令替换的结果进行通配符匹配（globbing） ，以及其它一些 shell 接受模式的地方，禁用 `@t{(}', `@t{|}', `@t{)}' 和 '@t{<}' 的特殊含义。 如果设置了 @t{SH_GLOB}，但未设置 @t{KSH_GLOB}，则 shell 允许在某"
"些情况下解释括号中的子 shell 表达式，这些情况下括号前没有空格，例如 @t{!(true)} 被解释为 @t{!} 后有空格。 如果以 @t{sh} 或 @t{ksh} 模拟方式调用 zsh，则默认设置该选项。"

#. type: pindex
#: zsh.texi:10510
#, no-wrap
msgid "UNSET"
msgstr "UNSET"

#. type: pindex
#: zsh.texi:10511
#, no-wrap
msgid "NO_UNSET"
msgstr "NO_UNSET"

#. type: pindex
#: zsh.texi:10512
#, no-wrap
msgid "NOUNSET"
msgstr "NOUNSET"

#. type: cindex
#: zsh.texi:10513
#, no-wrap
msgid "parameters, substituting unset"
msgstr "参数，用未设置代替"

#. type: cindex
#: zsh.texi:10514
#, no-wrap
msgid "unset parameters, substituting"
msgstr "未设置参数, 替换"

#. type: item
#: zsh.texi:10515
#, no-wrap
msgid "@t{UNSET} (@t{+u}, ksh: @t{+u}) <K> <S> <Z>"
msgstr "@t{UNSET} (@t{+u}, ksh: @t{+u}) <K> <S> <Z>"

#. type: table
#: zsh.texi:10520
msgid ""
"Treat unset parameters as if they were empty when substituting, and as if they were zero when reading their values in arithmetic expansion and arithmetic commands.  Otherwise they are treated as an error."
msgstr "在替换参数时，将未设置参数视为空参数；在算术扩展和算术命令中读取参数值时，将未设置参数视为零。 否则将作为错误处理。"

#. type: t{#1}
#: zsh.texi:10521 zsh.texi:10526
#, no-wrap
msgid "WARN_CREATE_GLOBAL"
msgstr "WARN_CREATE_GLOBAL"

#. type: pindex
#: zsh.texi:10522
#, no-wrap
msgid "NO_WARN_CREATE_GLOBAL"
msgstr "NO_WARN_CREATE_GLOBAL"

#. type: pindex
#: zsh.texi:10523
#, no-wrap
msgid "WARNCREATEGLOBAL"
msgstr "WARNCREATEGLOBAL"

#. type: pindex
#: zsh.texi:10524
#, no-wrap
msgid "NOWARNCREATEGLOBAL"
msgstr "NOWARNCREATEGLOBAL"

#. type: cindex
#: zsh.texi:10525
#, no-wrap
msgid "parameters, warning when created globally"
msgstr "参数, 全局创建时发出警告"

#. type: table
#: zsh.texi:10534
msgid ""
"Print a warning message when a global parameter is created in a function by an assignment or in math context.  This often indicates that a parameter has not been declared local when it should have been.  "
"Parameters explicitly declared global from within a function using @t{typeset -g} do not cause a warning.  Note that there is no warning when a local parameter is assigned to in a nested function, which "
"may also indicate an error."
msgstr ""
"当函数中通过赋值或 在数学上下文中创建全局参数时，打印警告信息。 这通常表明某个参数本应声明为本地参数，但却未声明。 在函数中使用 @t{typeset -g} 明确声明的全局参数不会导致警告。 需要注意的是，在嵌套函数中赋"
"值给局部参数时也不会发出警告，这也可能表明存在错误。"

#. type: t{#1}
#: zsh.texi:10535 zsh.texi:10540
#, no-wrap
msgid "WARN_NESTED_VAR"
msgstr "WARN_NESTED_VAR"

#. type: pindex
#: zsh.texi:10536
#, no-wrap
msgid "NO_WARN_NESTED_VAR"
msgstr "NO_WARN_NESTED_VAR"

#. type: pindex
#: zsh.texi:10537
#, no-wrap
msgid "WARNNESTEDVAR"
msgstr "WARNNESTEDVAR"

#. type: pindex
#: zsh.texi:10538
#, no-wrap
msgid "NO_WARNNESTEDVAR"
msgstr "NO_WARNNESTEDVAR"

#. type: cindex
#: zsh.texi:10539
#, no-wrap
msgid "parameters, warning when setting in enclosing scope"
msgstr "参数, 在闭合作用域中设置时发出警告"

#. type: table
#: zsh.texi:10551
msgid ""
"Print a warning message when an existing parameter from an enclosing function scope, or global, is set in a function by an assignment or in math context.  Assignment to shell special parameters does not "
"cause a warning.  This is the companion to @t{WARN_CREATE_GLOBAL} as in this case the warning is only printed when a parameter is @emph{not} created.  Where possible, use of @t{typeset -g} to set the "
"parameter suppresses the error, but note that this needs to be used every time the parameter is set.  To restrict the effect of this option to a single function scope, use `@t{functions -W}'."
msgstr ""
"在函数中通过赋值或在数学上下文中设置闭合函数作用域或全局的现有参数时，打印警告信息。 对 shell 特殊参数赋值不会引起警告。 这与 @t{WARN_CREATE_GLOBAL} 类似，因为在这种情况下，只有在 @emph{没有} 创建参数时才"
"会打印警告信息。 在可能的情况下，使用 @t{typeset -g} 设置参数可以抑制错误，但需要注意的是，每次设置参数时都需要使用该方式。 要将此选项的作用限制在单个函数作用域内，请使用 `@t{functions -W}'。"

#. type: table
#: zsh.texi:10556
msgid "For example, the following code produces a warning for the assignment inside the function @t{nested} as that overrides the value within @t{toplevel}"
msgstr "例如，以下代码会对@t{nested} 函数内的赋值产生警告，因为该赋值会覆盖 @t{toplevel} 内的值"

#. type: example
#: zsh.texi:10568
#, no-wrap
msgid ""
"toplevel() @{\n"
"  local foo=\"in fn\"\n"
"  nested\n"
"@}\n"
"nested() @{\n"
"     foo=\"in nested\"\n"
"@}\n"
"setopt warn_nested_var\n"
"toplevel\n"
msgstr ""
"toplevel() @{\n"
"  local foo=\"in fn\"\n"
"  nested\n"
"@}\n"
"nested() @{\n"
"     foo=\"in nested\"\n"
"@}\n"
"setopt warn_nested_var\n"
"toplevel\n"

#. type: subsection
#: zsh.texi:10574
#, no-wrap
msgid "History"
msgstr "历史"

#. type: pindex
#: zsh.texi:10577
#, no-wrap
msgid "APPEND_HISTORY"
msgstr "APPEND_HISTORY"

#. type: pindex
#: zsh.texi:10578
#, no-wrap
msgid "NO_APPEND_HISTORY"
msgstr "NO_APPEND_HISTORY"

#. type: pindex
#: zsh.texi:10579
#, no-wrap
msgid "APPENDHISTORY"
msgstr "APPENDHISTORY"

#. type: pindex
#: zsh.texi:10580
#, no-wrap
msgid "NOAPPENDHISTORY"
msgstr "NOAPPENDHISTORY"

#. type: cindex
#: zsh.texi:10581
#, no-wrap
msgid "history, appending to a file"
msgstr "历史, 追加到文件"

#. type: item
#: zsh.texi:10582
#, no-wrap
msgid "@t{APPEND_HISTORY} <D>"
msgstr "@t{APPEND_HISTORY} <D>"

#. type: table
#: zsh.texi:10590
msgid ""
"If this is set, zsh sessions will append their history list to the history file, rather than replace it. Thus, multiple parallel zsh sessions will all have the new entries from their history lists added "
"to the history file, in the order that they exit.  The file will still be periodically re-written to trim it when the number of lines grows 20% beyond the value specified by @t{$SAVEHIST} (see also the "
"@t{HIST_SAVE_BY_COPY} option)."
msgstr ""
"如果设置了此项，zsh 会话将会把它们的历史列表追加到历史文件中，而不是替换它。因此，多个并行的 zsh 会话都会按照退出的顺序，将其历史列表中的新条目添加到历史文件中。 当文件行数增长超过 @t{$SAVEHIST} 指定值的 "
"20% 时，文件仍会定期重写以进行修剪（另请参阅 @t{HIST_SAVE_BY_COPY} 选项）。"

#. type: pindex
#: zsh.texi:10591
#, no-wrap
msgid "BANG_HIST"
msgstr "BANG_HIST"

#. type: pindex
#: zsh.texi:10592
#, no-wrap
msgid "NO_BANG_HIST"
msgstr "NO_BANG_HIST"

#. type: pindex
#: zsh.texi:10593
#, no-wrap
msgid "BANGHIST"
msgstr "BANGHIST"

#. type: pindex
#: zsh.texi:10594
#, no-wrap
msgid "NOBANGHIST"
msgstr "NOBANGHIST"

#. type: cindex
#: zsh.texi:10595
#, no-wrap
msgid "history, enable substitution"
msgstr "历史, 启用替换"

#. type: cindex
#: zsh.texi:10596
#, no-wrap
msgid "enable history substitution"
msgstr "启用历史替换"

#. type: item
#: zsh.texi:10597
#, no-wrap
msgid "@t{BANG_HIST} (@t{+K}) <C> <Z>"
msgstr "@t{BANG_HIST} (@t{+K}) <C> <Z>"

#. type: table
#: zsh.texi:10600
msgid "Perform textual history expansion, @cite{csh}-style, treating the character `@t{!}' specially."
msgstr "以 @cite{csh} 风格执行文本性历史扩展，对字符 `@t{!}' 进行特别处理。"

#. type: pindex
#: zsh.texi:10601
#, no-wrap
msgid "EXTENDED_HISTORY"
msgstr "EXTENDED_HISTORY"

#. type: pindex
#: zsh.texi:10602
#, no-wrap
msgid "NO_EXTENDED_HISTORY"
msgstr "NO_EXTENDED_HISTORY"

#. type: pindex
#: zsh.texi:10603
#, no-wrap
msgid "EXTENDEDHISTORY"
msgstr "EXTENDEDHISTORY"

#. type: pindex
#: zsh.texi:10604
#, no-wrap
msgid "NOEXTENDEDHISTORY"
msgstr "NOEXTENDEDHISTORY"

#. type: cindex
#: zsh.texi:10605
#, no-wrap
msgid "history, timestamping"
msgstr "历史, 时间戳"

#. type: item
#: zsh.texi:10606
#, no-wrap
msgid "@t{EXTENDED_HISTORY} <C>"
msgstr "@t{EXTENDED_HISTORY} <C>"

#. type: table
#: zsh.texi:10610
msgid "Save each command's beginning timestamp (in seconds since the epoch)  and the duration (in seconds) to the history file.  The format of this prefixed data is:"
msgstr "将每条命令的起始时间戳（以秒为单位，从纪元<epoch>开始）和持续时间（以秒为单位）保存到历史文件中。 这些前缀数据的格式为:"

#. type: table
#: zsh.texi:10613
msgid "`@t{: }@var{<beginning time>}@t{:}@var{<elapsed seconds>}@t{;}@var{<command>}'."
msgstr "`@t{: }@var{<beginning time>}@t{:}@var{<elapsed seconds>}@t{;}@var{<command>}'."

#. type: t{#1}
#: zsh.texi:10614 zsh.texi:10618
#, no-wrap
msgid "HIST_ALLOW_CLOBBER"
msgstr "HIST_ALLOW_CLOBBER"

#. type: pindex
#: zsh.texi:10615
#, no-wrap
msgid "NO_HIST_ALLOW_CLOBBER"
msgstr "NO_HIST_ALLOW_CLOBBER"

#. type: pindex
#: zsh.texi:10616
#, no-wrap
msgid "HISTALLOWCLOBBER"
msgstr "HISTALLOWCLOBBER"

#. type: pindex
#: zsh.texi:10617
#, no-wrap
msgid "NOHISTALLOWCLOBBER"
msgstr "NOHISTALLOWCLOBBER"

#. type: table
#: zsh.texi:10621
msgid "Add `@t{|}' to output redirections in the history.  This allows history references to clobber files even when @t{CLOBBER} is unset."
msgstr "添加 `@t{|}' 以在历史记录中输出重定向。 这样，即使 @t{CLOBBER} 未设置，也能引用历史记录中的 clobber （强制覆盖？重定向？）文件。"

#. type: pindex
#: zsh.texi:10622
#, no-wrap
msgid "HIST_BEEP"
msgstr "HIST_BEEP"

#. type: pindex
#: zsh.texi:10623
#, no-wrap
msgid "NO_HIST_BEEP"
msgstr "NO_HIST_BEEP"

#. type: pindex
#: zsh.texi:10624
#, no-wrap
msgid "HISTBEEP"
msgstr "HISTBEEP"

#. type: pindex
#: zsh.texi:10625
#, no-wrap
msgid "NOHISTBEEP"
msgstr "NOHISTBEEP"

#. type: cindex
#: zsh.texi:10626
#, no-wrap
msgid "history beeping"
msgstr "history beeping"

#. type: cindex
#: zsh.texi:10627
#, no-wrap
msgid "beep, history"
msgstr "蜂鸣, 历史"

#. type: item
#: zsh.texi:10628
#, no-wrap
msgid "@t{HIST_BEEP} <D>"
msgstr "@t{HIST_BEEP} <D>"

#. type: table
#: zsh.texi:10631
msgid "Beep in ZLE when a widget attempts to access a history entry which isn't there."
msgstr "当小部件试图访问不存在的历史条目时，在 ZLE 中发出提示音。"

#. type: t{#1}
#: zsh.texi:10632 zsh.texi:10637
#, no-wrap
msgid "HIST_EXPIRE_DUPS_FIRST"
msgstr "HIST_EXPIRE_DUPS_FIRST"

#. type: pindex
#: zsh.texi:10633
#, no-wrap
msgid "NO_HIST_EXPIRE_DUPS_FIRST"
msgstr "NO_HIST_EXPIRE_DUPS_FIRST"

#. type: pindex
#: zsh.texi:10634
#, no-wrap
msgid "HISTEXPIREDUPSFIRST"
msgstr "HISTEXPIREDUPSFIRST"

#. type: pindex
#: zsh.texi:10635
#, no-wrap
msgid "NOHISTEXPIREDUPSFIRST"
msgstr "NOHISTEXPIREDUPSFIRST"

#. type: cindex
#: zsh.texi:10636
#, no-wrap
msgid "history, expiring duplicates"
msgstr "历史, 即将到期的副本"

#. type: table
#: zsh.texi:10645
msgid ""
"If the internal history needs to be trimmed to add the current command line, setting this option will cause the oldest history event that has a duplicate to be lost before losing a unique event from the "
"list.  You should be sure to set the value of @t{HISTSIZE} to a larger number than @t{SAVEHIST} in order to give you some room for the duplicated events, otherwise this option will behave just like "
"@t{HIST_IGNORE_ALL_DUPS} once the history fills up with unique events."
msgstr ""
"如果需要对内部历史记录进行修剪以添加当前命令行，则在丢失列表中的唯一事件之前，设置此选项将导致丢失有重复记录的最旧的历史事件。 请确保 @t{HISTSIZE} 的值大于 @t{SAVEHIST} 的值，以便为重复事件留出一定的空间，"
"否则一旦历史记录被唯一事件填满，该选项的作用就和 @t{HIST_IGNORE_ALL_DUPS} 一样了。"

#. type: t{#1}
#: zsh.texi:10646 zsh.texi:10650
#, no-wrap
msgid "HIST_FCNTL_LOCK"
msgstr "HIST_FCNTL_LOCK"

#. type: pindex
#: zsh.texi:10647
#, no-wrap
msgid "NO_HIST_FCNTL_LOCK"
msgstr "NO_HIST_FCNTL_LOCK"

#. type: pindex
#: zsh.texi:10648
#, no-wrap
msgid "HISTFCNTLLOCK"
msgstr "HISTFCNTLLOCK"

#. type: pindex
#: zsh.texi:10649
#, no-wrap
msgid "NOHISTFCNTLLOCK"
msgstr "NOHISTFCNTLLOCK"

#. type: table
#: zsh.texi:10657
msgid ""
"When writing out the history file, by default zsh uses ad-hoc file locking to avoid known problems with locking on some operating systems.  With this option locking is done by means of the system's "
"@t{fcntl} call, where this method is available.  On recent operating systems this may provide better performance, in particular avoiding history corruption when files are stored on NFS."
msgstr ""
"在写出历史文件时，zsh 默认使用临时（ad-hoc)文件锁定，以避免在某些操作系统上出现已知的锁定问题。 使用该选项时，锁定是通过系统的 @t{fcntl} 调用（如果该方法可用）来完成的。 在最新的操作系统上，这可能会提供更"
"好的性能，尤其是当文件存储在 NFS 上时，可以避免历史损坏。"

#. type: t{#1}
#: zsh.texi:10658 zsh.texi:10663
#, no-wrap
msgid "HIST_FIND_NO_DUPS"
msgstr "HIST_FIND_NO_DUPS"

#. type: pindex
#: zsh.texi:10659
#, no-wrap
msgid "NO_HIST_FIND_NO_DUPS"
msgstr "NO_HIST_FIND_NO_DUPS"

#. type: pindex
#: zsh.texi:10660
#, no-wrap
msgid "HISTFINDNODUPS"
msgstr "HISTFINDNODUPS"

#. type: pindex
#: zsh.texi:10661
#, no-wrap
msgid "NOHISTFINDNODUPS"
msgstr "NOHISTFINDNODUPS"

#. type: cindex
#: zsh.texi:10662
#, no-wrap
msgid "history, ignoring duplicates in search"
msgstr "历史, 搜索中忽略重复"

#. type: table
#: zsh.texi:10667
msgid "When searching for history entries in the line editor, do not display duplicates of a line previously found, even if the duplicates are not contiguous."
msgstr "在行编辑器中搜索历史条目时，不要显示与之前找到的行重复的内容，即使重复的内容并不连续。"

#. type: t{#1}
#: zsh.texi:10668 zsh.texi:10673
#, no-wrap
msgid "HIST_IGNORE_ALL_DUPS"
msgstr "HIST_IGNORE_ALL_DUPS"

#. type: pindex
#: zsh.texi:10669
#, no-wrap
msgid "NO_HIST_IGNORE_ALL_DUPS"
msgstr "NO_HIST_IGNORE_ALL_DUPS"

#. type: pindex
#: zsh.texi:10670
#, no-wrap
msgid "HISTIGNOREALLDUPS"
msgstr "HISTIGNOREALLDUPS"

#. type: pindex
#: zsh.texi:10671
#, no-wrap
msgid "NOHISTIGNOREALLDUPS"
msgstr "NOHISTIGNOREALLDUPS"

#. type: cindex
#: zsh.texi:10672
#, no-wrap
msgid "history, ignoring all duplicates"
msgstr "历史, 忽略所有重复"

#. type: table
#: zsh.texi:10677
msgid "If a new command line being added to the history list duplicates an older one, the older command is removed from the list (even if it is not the previous event)."
msgstr "如果添加到历史记录列表中的新命令行与旧命令行重复，旧命令行将从列表中删除（即使它不是上一个事件）。"

#. type: table
#: zsh.texi:10678 zsh.texi:12623
#, no-wrap
msgid "HIST_IGNORE_DUPS"
msgstr "HIST_IGNORE_DUPS"

#. type: pindex
#: zsh.texi:10679
#, no-wrap
msgid "NO_HIST_IGNORE_DUPS"
msgstr "NO_HIST_IGNORE_DUPS"

#. type: pindex
#: zsh.texi:10680
#, no-wrap
msgid "HISTIGNOREDUPS"
msgstr "HISTIGNOREDUPS"

#. type: pindex
#: zsh.texi:10681
#, no-wrap
msgid "NOHISTIGNOREDUPS"
msgstr "NOHISTIGNOREDUPS"

#. type: cindex
#: zsh.texi:10682
#, no-wrap
msgid "history, ignoring duplicates"
msgstr "历史, 忽略重复"

#. type: item
#: zsh.texi:10683
#, no-wrap
msgid "@t{HIST_IGNORE_DUPS} (@t{-h})"
msgstr "@t{HIST_IGNORE_DUPS} (@t{-h})"

#. type: table
#: zsh.texi:10686
msgid "Do not enter command lines into the history list if they are duplicates of the previous event."
msgstr "如果命令行与前一个事件重复，不将其输入历史记录列表。"

#. type: table
#: zsh.texi:10687 zsh.texi:12621
#, no-wrap
msgid "HIST_IGNORE_SPACE"
msgstr "HIST_IGNORE_SPACE"

#. type: pindex
#: zsh.texi:10688
#, no-wrap
msgid "NO_HIST_IGNORE_SPACE"
msgstr "NO_HIST_IGNORE_SPACE"

#. type: pindex
#: zsh.texi:10689
#, no-wrap
msgid "HISTIGNORESPACE"
msgstr "HISTIGNORESPACE"

#. type: pindex
#: zsh.texi:10690
#, no-wrap
msgid "NOHISTIGNORESPACE"
msgstr "NOHISTIGNORESPACE"

#. type: cindex
#: zsh.texi:10691
#, no-wrap
msgid "history, ignoring spaces"
msgstr "历史, 忽略空格"

#. type: item
#: zsh.texi:10692
#, no-wrap
msgid "@t{HIST_IGNORE_SPACE} (@t{-g})"
msgstr "@t{HIST_IGNORE_SPACE} (@t{-g})"

#. type: table
#: zsh.texi:10701
msgid ""
"Remove command lines from the history list when the first character on the line is a space, or when one of the expanded aliases contains a leading space.  Only normal aliases (not global or suffix "
"aliases)  have this behaviour.  Note that the command lingers in the internal history until the next command is entered before it vanishes, allowing you to briefly reuse or edit the line.  If you want to "
"make it vanish right away without entering another command, type a space and press return."
msgstr ""
"当命令行的第一个字符是空格，或扩展后的别名之一包含前导空格时，从历史记录列表中删除命令行。 只有普通别名（不是全局别名或后缀别名）才有这种行为。 需要注意的是，该命令会在内部历史记录中停留，直到输入下一条命"
"令后才会消失，因此可以短暂重用或编辑该行。 如果想在不输入其他命令的情况下让该命令立即消失，请键入空格并按回车键。"

#. type: t{#1}
#: zsh.texi:10702 zsh.texi:10706
#, no-wrap
msgid "HIST_LEX_WORDS"
msgstr "HIST_LEX_WORDS"

#. type: pindex
#: zsh.texi:10703
#, no-wrap
msgid "NO_HIST_LEX_WORDS"
msgstr "NO_HIST_LEX_WORDS"

#. type: pindex
#: zsh.texi:10704
#, no-wrap
msgid "HISTLEXWORDS"
msgstr "HISTLEXWORDS"

#. type: pindex
#: zsh.texi:10705
#, no-wrap
msgid "NOHISTLEXWORDS"
msgstr "NOHISTLEXWORDS"

#. type: table
#: zsh.texi:10716
msgid ""
"By default, shell history that is read in from files is split into words on all white space.  This means that arguments with quoted whitespace are not correctly handled, with the consequence that "
"references to words in history lines that have been read from a file may be inaccurate.  When this option is set, words read in from a history file are divided up in a similar fashion to normal shell "
"command line handling.  Although this produces more accurately delimited words, if the size of the history file is large this can be slow.  Trial and error is necessary to decide."
msgstr ""
"默认情况下，从文件读入的 shell 历史记录会在所有空白处分割成单词。 这意味着有带引号的空白的参数不会被正确处理，结果是从文件读入的历史行中的单词引用可能会不准确。 设置该选项后，从历史文件读入的单词将以类似于"
"正常 shell 命令行处理的方式分割。 虽然这样分隔的字词更准确，但如果历史文件很大，分隔速度可能会很慢。 这需要反复试验才能决定。"

#. type: t{#1}
#: zsh.texi:10717 zsh.texi:10721
#, no-wrap
msgid "HIST_NO_FUNCTIONS"
msgstr "HIST_NO_FUNCTIONS"

#. type: pindex
#: zsh.texi:10718
#, no-wrap
msgid "NO_HIST_NO_FUNCTIONS"
msgstr "NO_HIST_NO_FUNCTIONS"

#. type: pindex
#: zsh.texi:10719
#, no-wrap
msgid "HISTNOFUNCTIONS"
msgstr "HISTNOFUNCTIONS"

#. type: pindex
#: zsh.texi:10720
#, no-wrap
msgid "NOHISTNOFUNCTIONS"
msgstr "NOHISTNOFUNCTIONS"

#. type: table
#: zsh.texi:10726
msgid ""
"Remove function definitions from the history list.  Note that the function lingers in the internal history until the next command is entered before it vanishes, allowing you to briefly reuse or edit the "
"definition."
msgstr "从历史记录列表中删除函数定义。 请注意，该函数会一直保留在内部历史记录中，直到输入下一条命令后才会消失，因此您可以短暂重用或编辑该定义。"

#. type: t{#1}
#: zsh.texi:10727 zsh.texi:10731
#, no-wrap
msgid "HIST_NO_STORE"
msgstr "HIST_NO_STORE"

#. type: pindex
#: zsh.texi:10728
#, no-wrap
msgid "NO_HIST_NO_STORE"
msgstr "NO_HIST_NO_STORE"

#. type: pindex
#: zsh.texi:10729
#, no-wrap
msgid "HISTNOSTORE"
msgstr "HISTNOSTORE"

#. type: pindex
#: zsh.texi:10730
#, no-wrap
msgid "NOHISTNOSTORE"
msgstr "NOHISTNOSTORE"

#. type: table
#: zsh.texi:10737
msgid ""
"Remove the @t{history} (@t{fc -l}) command from the history list when invoked.  Note that the command lingers in the internal history until the next command is entered before it vanishes, allowing you to "
"briefly reuse or edit the line."
msgstr "从历史记录列表中移除 @t{history} （@t{fc -l}）命令。(@t{fc -l})命令。 请注意，该命令会一直保留在内部历史记录中，直到输入下一条命令后才会消失，因此您可以短暂重用或编辑该行。"

#. type: t{#1}
#: zsh.texi:10738 zsh.texi:10742
#, no-wrap
msgid "HIST_REDUCE_BLANKS"
msgstr "HIST_REDUCE_BLANKS"

#. type: pindex
#: zsh.texi:10739
#, no-wrap
msgid "NO_HIST_REDUCE_BLANKS"
msgstr "NO_HIST_REDUCE_BLANKS"

#. type: pindex
#: zsh.texi:10740
#, no-wrap
msgid "HISTREDUCEBLANKS"
msgstr "HISTREDUCEBLANKS"

#. type: pindex
#: zsh.texi:10741
#, no-wrap
msgid "NOHISTREDUCEBLANKS"
msgstr "NOHISTREDUCEBLANKS"

#. type: table
#: zsh.texi:10745
msgid "Remove superfluous blanks from each command line being added to the history list."
msgstr "删除添加到历史记录列表的每行命令中多余的空白。"

#. type: pindex
#: zsh.texi:10746
#, no-wrap
msgid "HIST_SAVE_BY_COPY"
msgstr "HIST_SAVE_BY_COPY"

#. type: pindex
#: zsh.texi:10747
#, no-wrap
msgid "NO_HIST_SAVE_BY_COPY"
msgstr "NO_HIST_SAVE_BY_COPY"

#. type: pindex
#: zsh.texi:10748
#, no-wrap
msgid "HISTSAVEBYCOPY"
msgstr "HISTSAVEBYCOPY"

#. type: pindex
#: zsh.texi:10749
#, no-wrap
msgid "NOHISTSAVEBYCOPY"
msgstr "NOHISTSAVEBYCOPY"

#. type: item
#: zsh.texi:10750
#, no-wrap
msgid "@t{HIST_SAVE_BY_COPY} <D>"
msgstr "@t{HIST_SAVE_BY_COPY} <D>"

#. type: table
#: zsh.texi:10760
msgid ""
"When the history file is re-written, we normally write out a copy of the file named @t{$HISTFILE.new} and then rename it over the old one.  However, if this option is unset, we instead truncate the old "
"history file and write out the new version in-place.  If one of the history-appending options is enabled, this option only has an effect when the enlarged history file needs to be re-written to trim it "
"down to size.  Disable this only if you have special needs, as doing so makes it possible to lose history entries if zsh gets interrupted during the save."
msgstr ""
"重写历史文件时，我们通常会写出一个名为 @t{$HISTFILE.new} 的文件副本，然后将其重命名为旧版本。 但如果未设置该选项，我们就会截断旧的历史文件，然后就地写出新版本。 如果启用了其中一个历史附加选项，那么只有在需"
"要重新写入扩大的历史文件以缩小其大小时，该选项才会起作用。 只有在有特殊需要时才禁用此选项，因为这样做如果在保存过程中 zsh 被中断，则可能会丢失历史条目。"

#. type: table
#: zsh.texi:10765
msgid "When writing out a copy of the history file, zsh preserves the old file's permissions and group information, but will refuse to write out a new file if it would change the history file's owner."
msgstr "在写出历史文件副本时，zsh 会保留旧文件的权限和组信息，但如果会更改历史文件的所有者，则会拒绝写出新文件。"

#. type: t{#1}
#: zsh.texi:10766 zsh.texi:10770
#, no-wrap
msgid "HIST_SAVE_NO_DUPS"
msgstr "HIST_SAVE_NO_DUPS"

#. type: pindex
#: zsh.texi:10767
#, no-wrap
msgid "NO_HIST_SAVE_NO_DUPS"
msgstr "NO_HIST_SAVE_NO_DUPS"

#. type: pindex
#: zsh.texi:10768
#, no-wrap
msgid "HISTSAVENODUPS"
msgstr "HISTSAVENODUPS"

#. type: pindex
#: zsh.texi:10769
#, no-wrap
msgid "NOHISTSAVENODUPS"
msgstr "NOHISTSAVENODUPS"

#. type: table
#: zsh.texi:10773
msgid "When writing out the history file, older commands that duplicate newer ones are omitted."
msgstr "在写出历史文件时，会省略与新命令重复的旧命令。"

#. type: t{#1}
#: zsh.texi:10774 zsh.texi:10779
#, no-wrap
msgid "HIST_VERIFY"
msgstr "HIST_VERIFY"

#. type: pindex
#: zsh.texi:10775
#, no-wrap
msgid "NO_HIST_VERIFY"
msgstr "NO_HIST_VERIFY"

#. type: pindex
#: zsh.texi:10776
#, no-wrap
msgid "HISTVERIFY"
msgstr "HISTVERIFY"

#. type: pindex
#: zsh.texi:10777
#, no-wrap
msgid "NOHISTVERIFY"
msgstr "NOHISTVERIFY"

#. type: cindex
#: zsh.texi:10778
#, no-wrap
msgid "history, verifying substitution"
msgstr "历史, 验证替换"

#. type: table
#: zsh.texi:10783
msgid "Whenever the user enters a line with history expansion, don't execute the line directly; instead, perform history expansion and reload the line into the editing buffer."
msgstr "每当用户输入带有历史扩展的行时，不要直接执行该行，而是执行历史扩展并将该行重新载入编辑缓冲区。"

#. type: t{#1}
#: zsh.texi:10784 zsh.texi:10789
#, no-wrap
msgid "INC_APPEND_HISTORY"
msgstr "INC_APPEND_HISTORY"

#. type: pindex
#: zsh.texi:10785
#, no-wrap
msgid "NO_INC_APPEND_HISTORY"
msgstr "NO_INC_APPEND_HISTORY"

#. type: pindex
#: zsh.texi:10786
#, no-wrap
msgid "INCAPPENDHISTORY"
msgstr "INCAPPENDHISTORY"

#. type: pindex
#: zsh.texi:10787
#, no-wrap
msgid "NOINCAPPENDHISTORY"
msgstr "NOINCAPPENDHISTORY"

#. type: cindex
#: zsh.texi:10788
#, no-wrap
msgid "history, incremental appending to a file"
msgstr "历史, 增量追加到文件"

#. type: table
#: zsh.texi:10796
msgid ""
"This option works like @t{APPEND_HISTORY} except that new history lines are added to the @t{$HISTFILE} incrementally (as soon as they are entered), rather than waiting until the shell exits.  The file "
"will still be periodically re-written to trim it when the number of lines grows 20% beyond the value specified by @t{$SAVEHIST} (see also the @t{HIST_SAVE_BY_COPY} option)."
msgstr ""
"此选项的作用与 @t{APPEND_HISTORY} 类似，只是新的历史行会以增量方式添加到 @t{$HISTFILE} 中（一旦输入），而不是等到 shell 退出。 当文件行数增长超过 @t{$SAVEHIST} 指定值的 20% 时，仍会定期重写文件以修剪行数"
"（参见 @t{HIST_SAVE_BY_COPY} 选项）。"

#. type: t{#1}
#: zsh.texi:10797 zsh.texi:10802
#, no-wrap
msgid "INC_APPEND_HISTORY_TIME"
msgstr "INC_APPEND_HISTORY_TIME"

#. type: pindex
#: zsh.texi:10798
#, no-wrap
msgid "NO_INC_APPEND_HISTORY_TIME"
msgstr "NO_INC_APPEND_HISTORY_TIME"

#. type: pindex
#: zsh.texi:10799
#, no-wrap
msgid "INCAPPENDHISTORYTIME"
msgstr "INCAPPENDHISTORYTIME"

#. type: pindex
#: zsh.texi:10800
#, no-wrap
msgid "NOINCAPPENDHISTORYTIME"
msgstr "NOINCAPPENDHISTORYTIME"

#. type: cindex
#: zsh.texi:10801
#, no-wrap
msgid "history, incremental appending to a file with time"
msgstr "历史记录，对文件进行增量追加(附加时间）"

#. type: table
#: zsh.texi:10809
msgid ""
"This option is a variant of @t{INC_APPEND_HISTORY} in which, where possible, the history entry is written out to the file after the command is finished, so that the time taken by the command is recorded "
"correctly in the history file in @t{EXTENDED_HISTORY} format.  This means that the history entry will not be available immediately from other instances of the shell that are using the same history file."
msgstr ""
"该选项是 @t{INC_APPEND_HISTORY} 的一个变体，在可能的情况下，历史条目会在命令执行完毕后写出到文件，这样命令所花费的时间就会以 @t{EXTENDED_HISTORY} 的格式被正确地记录在历史文件中。 这意味着使用同一历史文件的"
"其他 shell 实例无法立即获得该历史条目。"

#. type: table
#: zsh.texi:10814
msgid "This option is only useful if @t{INC_APPEND_HISTORY} and @t{SHARE_HISTORY} are turned off.  The three options should be considered mutually exclusive."
msgstr "该选项只有在 @t{INC_APPEND_HISTORY} 和 @t{SHARE_HISTORY} 关闭时才有用。 这三个选项应视为相互排斥。"

#. type: pindex
#: zsh.texi:10815
#, no-wrap
msgid "SHARE_HISTORY"
msgstr "SHARE_HISTORY"

#. type: pindex
#: zsh.texi:10816
#, no-wrap
msgid "NO_SHARE_HISTORY"
msgstr "NO_SHARE_HISTORY"

#. type: pindex
#: zsh.texi:10817
#, no-wrap
msgid "SHAREHISTORY"
msgstr "SHAREHISTORY"

#. type: pindex
#: zsh.texi:10818
#, no-wrap
msgid "NOSHAREHISTORY"
msgstr "NOSHAREHISTORY"

#. type: cindex
#: zsh.texi:10819
#, no-wrap
msgid "share history"
msgstr "共享历史记录"

#. type: cindex
#: zsh.texi:10820
#, no-wrap
msgid "history, sharing"
msgstr "历史记录, 共享"

#. type: item
#: zsh.texi:10821
#, no-wrap
msgid "@t{SHARE_HISTORY} <K>"
msgstr "@t{SHARE_HISTORY} <K>"

#. type: table
#: zsh.texi:10830
msgid ""
"This option both imports new commands from the history file, and also causes your typed commands to be appended to the history file (the latter is like specifying @t{INC_APPEND_HISTORY}, which should be "
"turned off if this option is in effect).  The history lines are also output with timestamps ala @t{EXTENDED_HISTORY} (which makes it easier to find the spot where we left off reading the file after it "
"gets re-written)."
msgstr ""
"该选项既可以从历史文件中导入新命令，也可以将输入的命令添加到历史文件中（后者就像指定 @t{INC_APPEND_HISTORY}，如果使用该选项，则应关闭 @t{INC_APPEND_HISTORY}选项）。 历史记录行还会输出时间戳，如 "
"@t{EXTENDED_HISTORY}（这样就能在重写文件后更容易地找到我们停止读取文件的位置）。"

#. type: table
#: zsh.texi:10837
msgid ""
"By default, history movement commands visit the imported lines as well as the local lines, but you can toggle this on and off with the set-local-history zle binding.  It is also possible to create a zle "
"widget that will make some commands ignore imported commands, and some include them."
msgstr "默认情况下，历史移动命令会同时访问导入的行和本地的行，但你可以使用 set-local-history zle 绑定打开或关闭这一功能。 也可以创建一个 zle 小部件，让某些命令忽略导入的命令，而另一些命令则包含导入的命令。"

#. type: table
#: zsh.texi:10844
msgid ""
"If you find that you want more control over when commands get imported, you may wish to turn @t{SHARE_HISTORY} off, @t{INC_APPEND_HISTORY} or @t{INC_APPEND_HISTORY_TIME} (see above) on, and then manually "
"import commands whenever you need them using `@t{fc -RI}'."
msgstr "如果你想对命令的导入时间有更多控制，不妨关闭 @t{SHARE_HISTORY}、打开@t{INC_APPPEND_HISTORY} 或 @t{INC_APPPEND_HISTORY_TIME}（见上文），然后在需要时使用 `@t{fc -RI}' 手动导入命令。"

#. type: subsection
#: zsh.texi:10849
#, no-wrap
msgid "Initialisation"
msgstr "初始设置"

#. type: table
#: zsh.texi:10852 zsh.texi:12615 zsh.texi:12664
#, no-wrap
msgid "ALL_EXPORT"
msgstr "ALL_EXPORT"

#. type: pindex
#: zsh.texi:10853
#, no-wrap
msgid "NO_ALL_EXPORT"
msgstr "NO_ALL_EXPORT"

#. type: pindex
#: zsh.texi:10854
#, no-wrap
msgid "ALLEXPORT"
msgstr "ALLEXPORT"

#. type: pindex
#: zsh.texi:10855
#, no-wrap
msgid "NOALLEXPORT"
msgstr "NOALLEXPORT"

#. type: cindex
#: zsh.texi:10856
#, no-wrap
msgid "export, automatic"
msgstr "导出, 自动"

#. type: item
#: zsh.texi:10857
#, no-wrap
msgid "@t{ALL_EXPORT} (@t{-a}, ksh: @t{-a})"
msgstr "@t{ALL_EXPORT} (@t{-a}, ksh: @t{-a})"

#. type: table
#: zsh.texi:10859
msgid "All parameters subsequently defined are automatically exported."
msgstr "随后定义的所有参数都会自动导出。"

#. type: pindex
#: zsh.texi:10860
#, no-wrap
msgid "GLOBAL_EXPORT"
msgstr "GLOBAL_EXPORT"

#. type: pindex
#: zsh.texi:10861
#, no-wrap
msgid "NO_GLOBAL_EXPORT"
msgstr "NO_GLOBAL_EXPORT"

#. type: pindex
#: zsh.texi:10862
#, no-wrap
msgid "GLOBALEXPORT"
msgstr "GLOBALEXPORT"

#. type: pindex
#: zsh.texi:10863
#, no-wrap
msgid "NOGLOBALEXPORT"
msgstr "NOGLOBALEXPORT"

#. type: cindex
#: zsh.texi:10864
#, no-wrap
msgid "environment, and local parameters"
msgstr "环境, 和本地参数"

#. type: item
#: zsh.texi:10865
#, no-wrap
msgid "@t{GLOBAL_EXPORT} <Z>"
msgstr "@t{GLOBAL_EXPORT} <Z>"

#. type: table
#: zsh.texi:10873
msgid ""
"If this option is set, passing the @t{-x} flag to the builtins @t{declare}, @t{float}, @t{integer}, @t{readonly} and @t{typeset} (but not @t{local})  will also set the @t{-g} flag; hence parameters "
"exported to the environment will not be made local to the enclosing function, unless they were already or the flag @t{+g} is given explicitly.  If the option is unset, exported parameters will be made "
"local in just the same way as any other parameter."
msgstr ""
"如果设置了该选项，向内置函数 @t{declare}、@t{float}、@t{integer}、@t{readonly} 和 @t{typeset}（但不包括 @t{local}）传递 @t{-x} 标志时，也会设置 @t{-g} 标志；因此，导出到环境中的参数将不会在封闭"
"（enclosing）函数中本地化，除非这些参数已经本地化或明确给出了 @t{+g} 标志。 如果未设置该选项，导出参数将与其他参数一样被本地化。"

#. type: table
#: zsh.texi:10880
msgid ""
"This option is set by default for backward compatibility; it is not recommended that its behaviour be relied upon.  Note that the builtin @t{export} always sets both the @t{-x} and @t{-g} flags, and hence "
"its effect extends beyond the scope of the enclosing function; this is the most portable way to achieve this behaviour."
msgstr "默认设置该选项是为了向后兼容；不建议依赖其行为。 请注意，内置的 @t{export} 总是同时设置 @t{-x} 和 @t{-g} 标志，因此其作用超出了封闭函数的范围；这是实现这一行为的最便携（portable）的方法。"

#. type: cindex
#: zsh.texi:10881
#, no-wrap
msgid "exporting, and local parameters"
msgstr "导出, 和本地参数"

#. type: pindex
#: zsh.texi:10882
#, no-wrap
msgid "GLOBAL_RCS"
msgstr "GLOBAL_RCS"

#. type: pindex
#: zsh.texi:10883
#, no-wrap
msgid "NO_GLOBAL_RCS"
msgstr "NO_GLOBAL_RCS"

#. type: pindex
#: zsh.texi:10884
#, no-wrap
msgid "GLOBALRCS"
msgstr "GLOBALRCS"

#. type: pindex
#: zsh.texi:10885
#, no-wrap
msgid "NOGLOBALRCS"
msgstr "NOGLOBALRCS"

#. type: cindex
#: zsh.texi:10886
#, no-wrap
msgid "startup files, global, inhibiting"
msgstr "启动文件, 全局, 抑制"

#. type: cindex
#: zsh.texi:10887
#, no-wrap
msgid "files, global startup, inhibiting"
msgstr "文件, 全局启动, 抑制"

#. type: item
#: zsh.texi:10888
#, no-wrap
msgid "@t{GLOBAL_RCS} (@t{+d}) <D>"
msgstr "@t{GLOBAL_RCS} (@t{+d}) <D>"

#. type: table
#: zsh.texi:10893
msgid ""
"If this option is unset, the startup files @t{/etc/zprofile}, @t{/etc/zshrc}, @t{/etc/zlogin} and @t{/etc/zlogout} will not be run.  It can be disabled and re-enabled at any time, including inside local "
"startup files (@t{.zshrc}, etc.)."
msgstr "如果未设置该选项，则不会运行启动文件 @t{/etc/zprofile}、@t{/etc/zshrc}、@t{/etc/zlogin} 和 @t{/etc/zlogout}。 可以随时禁用和重新启用，包括在本地启动文件（@t{.zshrc}等）中禁用和重新启用。"

#. type: pindex
#: zsh.texi:10894
#, no-wrap
msgid "RCS"
msgstr "RCS"

#. type: pindex
#: zsh.texi:10895
#, no-wrap
msgid "NO_RCS"
msgstr "NO_RCS"

#. type: pindex
#: zsh.texi:10896
#, no-wrap
msgid "NORCS"
msgstr "NORCS"

#. type: cindex
#: zsh.texi:10897
#, no-wrap
msgid "startup files, sourcing"
msgstr "启动文件, 引入"

#. type: item
#: zsh.texi:10898
#, no-wrap
msgid "@t{RCS} (@t{+f}) <D>"
msgstr "@t{RCS} (@t{+f}) <D>"

#. type: table
#: zsh.texi:10907
msgid ""
"After @t{/etc/zshenv} is sourced on startup, source the @t{.zshenv}, @t{/etc/zprofile}, @t{.zprofile}, @t{/etc/zshrc}, @t{.zshrc}, @t{/etc/zlogin}, @t{.zlogin}, and @t{.zlogout} files, as described in "
"@ref{Files}.  If this option is unset, the @t{/etc/zshenv} file is still sourced, but any of the others will not be; it can be set at any time to prevent the remaining startup files after the currently "
"executing one from being sourced."
msgstr ""
"启动时引入（sourced） @t{/etc/zshenv}后，将按照 @ref{文件} 中的说明，引入 @t{.zshenv}、@t{/etc/zprofile}、@t{.zprofile}、@t{/etc/zshrc}、@t{.zshrc}、@t{/etc/zlogin}、@t{.zlogin} 和 @t{.zlogout} 文件。 如果"
"未设置该选项，@t{/etc/zshenv} 文件仍会被引入，但其他文件将不会被引入；也可随时设置该选项，以防止当前执行文件之后的其他启动文件被引入。"

#. type: subsection
#: zsh.texi:10912
#, no-wrap
msgid "Input/Output"
msgstr "输入/输出"

#. type: pindex
#: zsh.texi:10915
#, no-wrap
msgid "ALIASES"
msgstr "ALIASES"

#. type: pindex
#: zsh.texi:10916
#, no-wrap
msgid "NO_ALIASES"
msgstr "NO_ALIASES"

#. type: pindex
#: zsh.texi:10917
#, no-wrap
msgid "NOALIASES"
msgstr "NOALIASES"

#. type: cindex
#: zsh.texi:10918
#, no-wrap
msgid "aliases, expansion"
msgstr "别名, 扩展"

#. type: item
#: zsh.texi:10919
#, no-wrap
msgid "@t{ALIASES} <D>"
msgstr "@t{ALIASES} <D>"

#. type: table
#: zsh.texi:10921
msgid "Expand aliases."
msgstr "扩展别名。"

#. type: pindex
#: zsh.texi:10922
#, no-wrap
msgid "CLOBBER"
msgstr "CLOBBER"

#. type: pindex
#: zsh.texi:10923
#, no-wrap
msgid "NO_CLOBBER"
msgstr "NO_CLOBBER"

#. type: pindex
#: zsh.texi:10924
#, no-wrap
msgid "NOCLOBBER"
msgstr "NOCLOBBER"

#. type: cindex
#: zsh.texi:10925
#, no-wrap
msgid "clobbering, of files"
msgstr "clobbering, 文件"

#. type: cindex
#: zsh.texi:10926
#, no-wrap
msgid "file clobbering, allowing"
msgstr "文件 clobbering, 允许"

#. type: item
#: zsh.texi:10927
#, no-wrap
msgid "@t{CLOBBER} (@t{+C}, ksh: @t{+C}) <D>"
msgstr "@t{CLOBBER} (@t{+C}, ksh: @t{+C}) <D>"

#. type: table
#: zsh.texi:10930
msgid "Allows `@t{>}' redirection to truncate existing files.  Otherwise `@t{>!}' or `@t{>|}' must be used to truncate a file."
msgstr "允许使用 `@t{>}' 重定向来截断现有文件。 否则，必须使用 `@t{>!}' 或 `@t{>|}' 来截断文件。"

#. type: table
#: zsh.texi:10935
msgid "If the option is not set, and the option @t{APPEND_CREATE} is also not set, `@t{>>!}' or `@t{>>|}' must be used to create a file.  If either option is set, `@t{>>}' may be used."
msgstr "如果未设置该选项，且选项 @t{APPEND_CREATE} 也未设置，则必须使用 `@t{>>!}' 或 `@t{>>|}' 来创建文件。 如果设置了其中一个选项，则可以使用 `@t{>>}' 。"

#. type: t{#1}
#: zsh.texi:10936 zsh.texi:10942
#, no-wrap
msgid "CLOBBER_EMPTY"
msgstr "CLOBBER_EMPTY"

#. type: pindex
#: zsh.texi:10937
#, no-wrap
msgid "NO_CLOBBER_EMPTY"
msgstr "NO_CLOBBER_EMPTY"

#. type: pindex
#: zsh.texi:10938
#, no-wrap
msgid "CLOBBEREMPTY"
msgstr "CLOBBEREMPTY"

#. type: pindex
#: zsh.texi:10939
#, no-wrap
msgid "NOCLOBBEREMPTY"
msgstr "NOCLOBBEREMPTY"

#. type: cindex
#: zsh.texi:10940
#, no-wrap
msgid "clobbering, of empty files"
msgstr "clobbering, 空文件"

#. type: cindex
#: zsh.texi:10941
#, no-wrap
msgid "file clobbering, of empty files"
msgstr "文件 clobbering, 空文件"

#. type: table
#: zsh.texi:10945
msgid "This option is only used if the option @t{CLOBBER} is not set: note that it is set by default."
msgstr "只有在未设置 @t{CLOBBER} 选项时，才会使用该选项：注意，默认情况下是设置该选项的。"

#. type: table
#: zsh.texi:10952
msgid ""
"If this option is set, then regular files of zero length may be ovewritten (`clobbered').  Note that it is possible another process has written to the file between this test and use of the file by the "
"current process.  This option should therefore not be used in cases where files to be clobbered may be written to asynchronously."
msgstr ""
"如果设置了该选项，那么长度为零的常规文件可能会被改写（`clobbered'）。 需要注意的是，在本次测试和当前进程使用该文件两个时间之间，可能会有另一个进程写入该文件。 因此，如果要被 `clobbered' 的文件可能被异步写"
"入，则不应使用此选项。"

#. type: table
#: zsh.texi:10953 zsh.texi:12545
#, no-wrap
msgid "CORRECT"
msgstr "CORRECT"

#. type: pindex
#: zsh.texi:10954
#, no-wrap
msgid "NO_CORRECT"
msgstr "NO_CORRECT"

#. type: pindex
#: zsh.texi:10955
#, no-wrap
msgid "NOCORRECT"
msgstr "NOCORRECT"

#. type: cindex
#: zsh.texi:10956
#, no-wrap
msgid "correction, spelling"
msgstr "更正, 拼写"

#. type: cindex
#: zsh.texi:10957
#, no-wrap
msgid "spelling correction"
msgstr "拼写更正"

#. type: item
#: zsh.texi:10958
#, no-wrap
msgid "@t{CORRECT} (@t{-0})"
msgstr "@t{CORRECT} (@t{-0})"

#. type: table
#: zsh.texi:10963
msgid ""
"Try to correct the spelling of commands.  Note that, when the @t{HASH_LIST_ALL} option is not set or when some directories in the path are not readable, this may falsely report spelling errors the first "
"time some commands are used."
msgstr "尝试纠正命令的拼写错误。 请注意，如果未设置 @t{HASH_LIST_ALL} 选项，或路径中的某些目录不可读，在首次使用某些命令时，可能会错误地报告拼写错误。"

#. type: table
#: zsh.texi:10967
msgid "The shell variable @t{CORRECT_IGNORE} may be set to a pattern to match words that will never be offered as corrections."
msgstr "shell 变量 @t{CORRECT_IGNORE} 可以设置为一个模式，以匹配永远不会作为更正提供的词语。"

#. type: table
#: zsh.texi:10968 zsh.texi:12591
#, no-wrap
msgid "CORRECT_ALL"
msgstr "CORRECT_ALL"

#. type: pindex
#: zsh.texi:10969
#, no-wrap
msgid "NO_CORRECT_ALL"
msgstr "NO_CORRECT_ALL"

#. type: pindex
#: zsh.texi:10970
#, no-wrap
msgid "CORRECTALL"
msgstr "CORRECTALL"

#. type: pindex
#: zsh.texi:10971
#, no-wrap
msgid "NOCORRECTALL"
msgstr "NOCORRECTALL"

#. type: item
#: zsh.texi:10972
#, no-wrap
msgid "@t{CORRECT_ALL} (@t{-O})"
msgstr "@t{CORRECT_ALL} (@t{-O})"

#. type: table
#: zsh.texi:10974
msgid "Try to correct the spelling of all arguments in a line."
msgstr "尝试纠正一行中所有参数的拼写。"

#. type: table
#: zsh.texi:10978
msgid "The shell variable @t{CORRECT_IGNORE_FILE} may be set to a pattern to match file names that will never be offered as corrections."
msgstr "shell 变量 @t{CORRECT_IGNORE_FILE} 可以设置为一个模式，以匹配永远不会作为更正提供的文件名。"

#. type: t{#1}
#: zsh.texi:10979 zsh.texi:10982
#, no-wrap
msgid "DVORAK"
msgstr "DVORAK"

#. type: pindex
#: zsh.texi:10980
#, no-wrap
msgid "NO_DVORAK"
msgstr "NO_DVORAK"

#. type: pindex
#: zsh.texi:10981
#, no-wrap
msgid "NODVORAK"
msgstr "NODVORAK"

#. type: table
#: zsh.texi:10986
msgid "Use the Dvorak keyboard instead of the standard qwerty keyboard as a basis for examining spelling mistakes for the @t{CORRECT} and @t{CORRECT_ALL} options and the @t{spell-word} editor command."
msgstr "为 @t{CORRECT} 和 @t{CORRECT_ALL} 选项以及 @t{spell-word} 编辑器命令，使用 Dvorak 键盘而非标准 qwerty 键盘来检查拼写错误。"

#. type: pindex
#: zsh.texi:10987
#, no-wrap
msgid "FLOW_CONTROL"
msgstr "FLOW_CONTROL"

#. type: pindex
#: zsh.texi:10988
#, no-wrap
msgid "NO_FLOW_CONTROL"
msgstr "NO_FLOW_CONTROL"

#. type: pindex
#: zsh.texi:10989
#, no-wrap
msgid "FLOWCONTROL"
msgstr "FLOWCONTROL"

#. type: pindex
#: zsh.texi:10990
#, no-wrap
msgid "NOFLOWCONTROL"
msgstr "NOFLOWCONTROL"

#. type: cindex
#: zsh.texi:10991
#, no-wrap
msgid "flow control"
msgstr "流控制"

#. type: item
#: zsh.texi:10992
#, no-wrap
msgid "@t{FLOW_CONTROL} <D>"
msgstr "@t{FLOW_CONTROL} <D>"

#. type: table
#: zsh.texi:10996
msgid "If this option is unset, output flow control via start/stop characters (usually assigned to ^S/^Q) is disabled in the shell's editor."
msgstr "如果未设置该选项，则 shell 编辑器中通过开始/停止字符（通常分配给 ^S/^Q）进行的输出流控制将被禁用。"

#. type: table
#: zsh.texi:10997 zsh.texi:12559
#, no-wrap
msgid "IGNORE_EOF"
msgstr "IGNORE_EOF"

#. type: pindex
#: zsh.texi:10998
#, no-wrap
msgid "NO_IGNORE_EOF"
msgstr "NO_IGNORE_EOF"

#. type: pindex
#: zsh.texi:10999
#, no-wrap
msgid "IGNOREEOF"
msgstr "IGNOREEOF"

#. type: pindex
#: zsh.texi:11000
#, no-wrap
msgid "NOIGNOREEOF"
msgstr "NOIGNOREEOF"

#. type: cindex
#: zsh.texi:11001
#, no-wrap
msgid "EOF, ignoring"
msgstr "EOF, 忽略"

#. type: item
#: zsh.texi:11002
#, no-wrap
msgid "@t{IGNORE_EOF} (@t{-7})"
msgstr "@t{IGNORE_EOF} (@t{-7})"

#. type: table
#: zsh.texi:11007
msgid "Do not exit on end-of-file.  Require the use of @t{exit} or @t{logout} instead.  However, ten consecutive EOFs will cause the shell to exit anyway, to avoid the shell hanging if its tty goes away."
msgstr "文件结束（end-of-file)时不退出。 要求使用 @t{exit} 或 @t{logout} 代替。 不过，连续十次 EOF 还是会导致 shell 退出，以避免在 tty 消失时 shell 挂起。"

#. type: table
#: zsh.texi:11013
msgid ""
"Also, if this option is set and the Zsh Line Editor is used, widgets implemented by shell functions can be bound to EOF (normally Control-D) without printing the normal warning message.  This works only "
"for normal widgets, not for completion widgets."
msgstr "此外，如果设置了该选项并使用 Zsh 行编辑器，由 shell 函数实现的小部件可以绑定到 EOF（通常为 Control-D），而不会打印正常的警告信息。 这只适用于普通小部件，不适用于补全小部件。"

#. type: table
#: zsh.texi:11014 zsh.texi:12627
#, no-wrap
msgid "INTERACTIVE_COMMENTS"
msgstr "INTERACTIVE_COMMENTS"

#. type: pindex
#: zsh.texi:11015
#, no-wrap
msgid "NO_INTERACTIVE_COMMENTS"
msgstr "NO_INTERACTIVE_COMMENTS"

#. type: pindex
#: zsh.texi:11016
#, no-wrap
msgid "INTERACTIVECOMMENTS"
msgstr "INTERACTIVECOMMENTS"

#. type: pindex
#: zsh.texi:11017
#, no-wrap
msgid "NOINTERACTIVECOMMENTS"
msgstr "NOINTERACTIVECOMMENTS"

#. type: cindex
#: zsh.texi:11018
#, no-wrap
msgid "comments, in interactive shells"
msgstr "注释, 在交互 shell 中"

#. type: item
#: zsh.texi:11019
#, no-wrap
msgid "@t{INTERACTIVE_COMMENTS} (@t{-k}) <K> <S>"
msgstr "@t{INTERACTIVE_COMMENTS} (@t{-k}) <K> <S>"

#. type: table
#: zsh.texi:11021
msgid "Allow comments even in interactive shells."
msgstr "即使在交互式 shell 中也允许注释。"

#. type: pindex
#: zsh.texi:11022
#, no-wrap
msgid "HASH_CMDS"
msgstr "HASH_CMDS"

#. type: pindex
#: zsh.texi:11023
#, no-wrap
msgid "NO_HASH_CMDS"
msgstr "NO_HASH_CMDS"

#. type: pindex
#: zsh.texi:11024
#, no-wrap
msgid "HASHCMDS"
msgstr "HASHCMDS"

#. type: pindex
#: zsh.texi:11025
#, no-wrap
msgid "NOHASHCMDS"
msgstr "NOHASHCMDS"

#. type: cindex
#: zsh.texi:11026
#, no-wrap
msgid "hashing, of commands"
msgstr "哈希, 命令的"

#. type: cindex
#: zsh.texi:11027
#, no-wrap
msgid "command hashing"
msgstr "命令哈希"

#. type: item
#: zsh.texi:11028
#, no-wrap
msgid "@t{HASH_CMDS} <D>"
msgstr "@t{HASH_CMDS} <D>"

#. type: table
#: zsh.texi:11036
msgid ""
"Note the location of each command the first time it is executed.  Subsequent invocations of the same command will use the saved location, avoiding a path search.  If this option is unset, no path hashing "
"is done at all.  However, when @t{CORRECT} is set, commands whose names do not appear in the functions or aliases hash tables are hashed in order to avoid reporting them as spelling errors."
msgstr ""
"首次执行每条命令时，请注意其位置。 以后调用同一命令时将使用保存的位置，避免路径搜索。 如果未设置该选项，则根本不会进行路径散列。 不过，如果设置了 @t{CORRECT}，则会对名称未出现在函数或别名哈希表中的命令进行"
"哈希处理，以避免将其报告为拼写错误。"

#. type: pindex
#: zsh.texi:11037
#, no-wrap
msgid "HASH_DIRS"
msgstr "HASH_DIRS"

#. type: pindex
#: zsh.texi:11038
#, no-wrap
msgid "NO_HASH_DIRS"
msgstr "NO_HASH_DIRS"

#. type: pindex
#: zsh.texi:11039
#, no-wrap
msgid "HASHDIRS"
msgstr "HASHDIRS"

#. type: pindex
#: zsh.texi:11040
#, no-wrap
msgid "NOHASHDIRS"
msgstr "NOHASHDIRS"

#. type: cindex
#: zsh.texi:11041
#, no-wrap
msgid "hashing, of directories"
msgstr "哈希, 目录的"

#. type: cindex
#: zsh.texi:11042
#, no-wrap
msgid "directories, hashing"
msgstr "目录, 哈希"

#. type: item
#: zsh.texi:11043
#, no-wrap
msgid "@t{HASH_DIRS} <D>"
msgstr "@t{HASH_DIRS} <D>"

#. type: table
#: zsh.texi:11047
msgid "Whenever a command name is hashed, hash the directory containing it, as well as all directories that occur earlier in the path.  Has no effect if neither @t{HASH_CMDS} nor @t{CORRECT} is set."
msgstr "每当对命令名进行散列时，都会对包含该命令名的目录以及路径中前面出现的所有目录进行散列。 如果未设置 @t{HASH_CMDS} 和 @t{CORRECT}，则不会产生任何影响。"

#. type: t{#1}
#: zsh.texi:11048 zsh.texi:11054
#, no-wrap
msgid "HASH_EXECUTABLES_ONLY"
msgstr "HASH_EXECUTABLES_ONLY"

#. type: pindex
#: zsh.texi:11049
#, no-wrap
msgid "NO_HASH_EXECUTABLES_ONLY"
msgstr "NO_HASH_EXECUTABLES_ONLY"

#. type: pindex
#: zsh.texi:11050
#, no-wrap
msgid "HASHEXECUTABLESONLY"
msgstr "HASHEXECUTABLESONLY"

#. type: pindex
#: zsh.texi:11051
#, no-wrap
msgid "NOHASHEXECUTABLESONLY"
msgstr "NOHASHEXECUTABLESONLY"

#. type: cindex
#: zsh.texi:11052
#, no-wrap
msgid "hashing, of executables"
msgstr "哈希, 可执行的"

#. type: cindex
#: zsh.texi:11053
#, no-wrap
msgid "executables, hashing"
msgstr "可执行的, 哈希"

#. type: table
#: zsh.texi:11061
msgid ""
"When hashing commands because of @t{HASH_CMDS}, check that the file to be hashed is actually an executable.  This option is unset by default as if the path contains a large number of commands, or consists "
"of many remote files, the additional tests can take a long time.  Trial and error is needed to show if this option is beneficial."
msgstr ""
"当因为 @t{HASH_CMDS} 对命令进行散列时，请检查要散列的文件是否为可执行文件。 默认情况下未设置此选项，因为如果路径包含大量命令，或由许多远程文件组成，额外的测试可能会花费很长时间。 该选项是否有用，还需要反复"
"试验。"

#. type: table
#: zsh.texi:11062 zsh.texi:12603
#, no-wrap
msgid "MAIL_WARNING"
msgstr "MAIL_WARNING"

#. type: pindex
#: zsh.texi:11063
#, no-wrap
msgid "NO_MAIL_WARNING"
msgstr "NO_MAIL_WARNING"

#. type: pindex
#: zsh.texi:11064
#, no-wrap
msgid "MAILWARNING"
msgstr "MAILWARNING"

#. type: pindex
#: zsh.texi:11065
#, no-wrap
msgid "NOMAILWARNING"
msgstr "NOMAILWARNING"

#. type: cindex
#: zsh.texi:11066
#, no-wrap
msgid "mail, warning of reading"
msgstr "邮件, 读警告"

#. type: item
#: zsh.texi:11067
#, no-wrap
msgid "@t{MAIL_WARNING} (@t{-U})"
msgstr "@t{MAIL_WARNING} (@t{-U})"

#. type: table
#: zsh.texi:11070
msgid "Print a warning message if a mail file has been accessed since the shell last checked."
msgstr "如果自 shell 上次检查以来有人访问过邮件文件，则打印警告信息。"

#. type: table
#: zsh.texi:11071 zsh.texi:12595
#, no-wrap
msgid "PATH_DIRS"
msgstr "PATH_DIRS"

#. type: pindex
#: zsh.texi:11072
#, no-wrap
msgid "NO_PATH_DIRS"
msgstr "NO_PATH_DIRS"

#. type: pindex
#: zsh.texi:11073
#, no-wrap
msgid "PATHDIRS"
msgstr "PATHDIRS"

#. type: pindex
#: zsh.texi:11074
#, no-wrap
msgid "NOPATHDIRS"
msgstr "NOPATHDIRS"

#. type: cindex
#: zsh.texi:11075
#, no-wrap
msgid "path search, extended"
msgstr "路径搜索, 扩展的"

#. type: item
#: zsh.texi:11076
#, no-wrap
msgid "@t{PATH_DIRS} (@t{-Q})"
msgstr "@t{PATH_DIRS} (@t{-Q})"

#. type: table
#: zsh.texi:11084
msgid ""
"Perform a path search even on command names with slashes in them.  Thus if `@t{/usr/local/bin}' is in the user's path, and he or she types `@t{X11/xinit}', the command `@t{/usr/local/bin/X11/xinit}' will "
"be executed (assuming it exists).  Commands explicitly beginning with `@t{/}', `@t{./}' or `@t{../}' are not subject to the path search.  This also applies to the `@t{.}' and @t{source} builtins."
msgstr ""
"即使命令名称中包含斜线，也会执行路径搜索。 因此，如果用户的路径中存在 `@t{/usr/local/bin}' ，而用户输入了 `@t{X11/xinit}' ，则将执行 `@t{/usr/local/bin/X11/xinit}' 命令（假设它存在）。 明确以 `@t{/}', "
"`@t{./}' 或 `@t{../}' 开头的命令不受路径搜索的影响。 这也适用于 `@t{.}' 和 @t{source} 内置程序。"

#. type: table
#: zsh.texi:11090
msgid ""
"Note that subdirectories of the current directory are always searched for executables specified in this form.  This takes place before any search indicated by this option, and regardless of whether "
"`@t{.}' or the current directory appear in the command search path."
msgstr "请注意，以这种形式指定的可执行文件总是搜索当前目录下的子目录。 该搜索会在本选项指定的任何搜索之前进行,无论命令搜索路径中是否出现 `@t{.}' 或当前目录，。"

#. type: pindex
#: zsh.texi:11091
#, no-wrap
msgid "PATH_SCRIPT"
msgstr "PATH_SCRIPT"

#. type: pindex
#: zsh.texi:11092
#, no-wrap
msgid "NO_PATH_SCRIPT"
msgstr "NO_PATH_SCRIPT"

#. type: pindex
#: zsh.texi:11093
#, no-wrap
msgid "PATHSCRIPT"
msgstr "PATHSCRIPT"

#. type: pindex
#: zsh.texi:11094
#, no-wrap
msgid "NOPATHSCRIPT"
msgstr "NOPATHSCRIPT"

#. type: cindex
#: zsh.texi:11095
#, no-wrap
msgid "path search, for script argument to shell"
msgstr "路径搜索, shell 的脚本参数"

#. type: item
#: zsh.texi:11096
#, no-wrap
msgid "@t{PATH_SCRIPT} <K> <S>"
msgstr "@t{PATH_SCRIPT} <K> <S>"

#. type: table
#: zsh.texi:11103
msgid ""
"If this option is not set, a script passed as the first non-option argument to the shell must contain the name of the file to open.  If this option is set, and the script does not specify a directory "
"path, the script is looked for first in the current directory, then in the command path.  See @ref{Invocation}."
msgstr "如果未设置此选项，作为第一个非选项参数传递给 shell 的脚本必须包含要打开的文件名。 如果设置了此选项，且脚本未指定目录路径，则首先在当前目录下查找脚本，然后在命令路径下查找。 参见 @ref{调用}。"

#. type: t{#1}
#: zsh.texi:11104 zsh.texi:11109
#, no-wrap
msgid "PRINT_EIGHT_BIT"
msgstr "PRINT_EIGHT_BIT"

#. type: pindex
#: zsh.texi:11105
#, no-wrap
msgid "NO_PRINT_EIGHT_BIT"
msgstr "NO_PRINT_EIGHT_BIT"

#. type: pindex
#: zsh.texi:11106
#, no-wrap
msgid "PRINTEIGHTBIT"
msgstr "PRINTEIGHTBIT"

#. type: pindex
#: zsh.texi:11107
#, no-wrap
msgid "NOPRINTEIGHTBIT"
msgstr "NOPRINTEIGHTBIT"

#. type: cindex
#: zsh.texi:11108
#, no-wrap
msgid "eight bit characters, printing"
msgstr "8 bit 字符, 打印"

#. type: table
#: zsh.texi:11113
msgid "Print eight bit characters literally in completion lists, etc.  This option is not necessary if your system correctly returns the printability of eight bit characters (see ctype(3))."
msgstr "在补全列表等中按字面打印八位字符。 如果系统能正确返回八位字符的可打印性（参见 ctype(3)），则不需要使用该选项。"

#. type: table
#: zsh.texi:11114 zsh.texi:12547
#, no-wrap
msgid "PRINT_EXIT_VALUE"
msgstr "PRINT_EXIT_VALUE"

#. type: pindex
#: zsh.texi:11115
#, no-wrap
msgid "NO_PRINT_EXIT_VALUE"
msgstr "NO_PRINT_EXIT_VALUE"

#. type: pindex
#: zsh.texi:11116
#, no-wrap
msgid "PRINTEXITVALUE"
msgstr "PRINTEXITVALUE"

#. type: pindex
#: zsh.texi:11117
#, no-wrap
msgid "NOPRINTEXITVALUE"
msgstr "NOPRINTEXITVALUE"

#. type: cindex
#: zsh.texi:11118
#, no-wrap
msgid "exit status, printing"
msgstr "退出状态, 打印"

#. type: item
#: zsh.texi:11119
#, no-wrap
msgid "@t{PRINT_EXIT_VALUE} (@t{-1})"
msgstr "@t{PRINT_EXIT_VALUE} (@t{-1})"

#. type: table
#: zsh.texi:11122
msgid "Print the exit value of programs with non-zero exit status.  This is only available at the command line in interactive shells."
msgstr "打印退出状态为非零的程序的退出值。 这只有在交互式 shell 的命令行中才能使用。"

#. type: t{#1}
#: zsh.texi:11123 zsh.texi:11129
#, no-wrap
msgid "RC_QUOTES"
msgstr "RC_QUOTES"

#. type: pindex
#: zsh.texi:11124
#, no-wrap
msgid "NO_RC_QUOTES"
msgstr "NO_RC_QUOTES"

#. type: pindex
#: zsh.texi:11125
#, no-wrap
msgid "RCQUOTES"
msgstr "RCQUOTES"

#. type: pindex
#: zsh.texi:11126
#, no-wrap
msgid "NORCQUOTES"
msgstr "NORCQUOTES"

#. type: cindex
#: zsh.texi:11127
#, no-wrap
msgid "rc, quoting style"
msgstr "rc, 引号风格"

#. type: cindex
#: zsh.texi:11128
#, no-wrap
msgid "quoting style, rc"
msgstr "引号风格, rc"

#. type: table
#: zsh.texi:11134
msgid ""
"Allow the character sequence `@t{@value{dsq}}' to signify a single quote within singly quoted strings.  Note this does not apply in quoted strings using the format @t{$'}@var{...}@t{'}, where a "
"backslashed single quote can be used."
msgstr "允许使用字符序列 `@t{@value{dsq}}' 表示单引号字符串中的单引号。 请注意，这不适用于使用 @t{$'}@var{...}@t{'} 格式的带引号字符串，在这种字符串中可以使用反斜线单引号。"

#. type: table
#: zsh.texi:11135 zsh.texi:12577
#, no-wrap
msgid "RM_STAR_SILENT"
msgstr "RM_STAR_SILENT"

#. type: pindex
#: zsh.texi:11136
#, no-wrap
msgid "NO_RM_STAR_SILENT"
msgstr "NO_RM_STAR_SILENT"

#. type: pindex
#: zsh.texi:11137
#, no-wrap
msgid "RMSTARSILENT"
msgstr "RMSTARSILENT"

#. type: pindex
#: zsh.texi:11138
#, no-wrap
msgid "NORMSTARSILENT"
msgstr "NORMSTARSILENT"

#. type: cindex
#: zsh.texi:11139
#, no-wrap
msgid "rm *, querying before"
msgstr "rm *, 之前询问"

#. type: cindex
#: zsh.texi:11140
#, no-wrap
msgid "querying before rm *"
msgstr "rm * 之前询问"

#. type: item
#: zsh.texi:11141
#, no-wrap
msgid "@t{RM_STAR_SILENT} (@t{-H}) <K> <S>"
msgstr "@t{RM_STAR_SILENT} (@t{-H}) <K> <S>"

#. type: table
#: zsh.texi:11143
msgid "Do not query the user before executing `@t{rm *}' or `@t{rm path/*}'."
msgstr "在执行 `@t{rm *}' 或 `@t{rm path/*}' 之前不要查询用户。"

#. type: t{#1}
#: zsh.texi:11144 zsh.texi:11150
#, no-wrap
msgid "RM_STAR_WAIT"
msgstr "RM_STAR_WAIT"

#. type: pindex
#: zsh.texi:11145
#, no-wrap
msgid "NO_RM_STAR_WAIT"
msgstr "NO_RM_STAR_WAIT"

#. type: pindex
#: zsh.texi:11146
#, no-wrap
msgid "RMSTARWAIT"
msgstr "RMSTARWAIT"

#. type: pindex
#: zsh.texi:11147
#, no-wrap
msgid "NORMSTARWAIT"
msgstr "NORMSTARWAIT"

#. type: cindex
#: zsh.texi:11148
#, no-wrap
msgid "rm *, waiting before"
msgstr "rm *, 之前等待"

#. type: cindex
#: zsh.texi:11149
#, no-wrap
msgid "waiting before rm *"
msgstr "rm * 之前等待"

#. type: table
#: zsh.texi:11156
msgid ""
"If querying the user before executing `@t{rm *}' or `@t{rm path/*}', first wait ten seconds and ignore anything typed in that time.  This avoids the problem of reflexively answering `yes' to the query "
"when one didn't really mean it.  The wait and query can always be avoided by expanding the `@t{*}' in ZLE (with tab)."
msgstr ""
"如果在执行 `@t{rm *}' 或 `@t{rm path/*}' 之前询问用户，则首先等待十秒钟，并忽略在此期间输入的任何内容。 这就避免了在并非真心实意的情况下条件反射地回答 `是 ' 的问题。 通过在 ZLE 中扩展 `@t{*}' （使用制表"
"符），可以避免等待和查询。"

#. type: pindex
#: zsh.texi:11157
#, no-wrap
msgid "SHORT_LOOPS"
msgstr "SHORT_LOOPS"

#. type: pindex
#: zsh.texi:11158
#, no-wrap
msgid "NO_SHORT_LOOPS"
msgstr "NO_SHORT_LOOPS"

#. type: pindex
#: zsh.texi:11159
#, no-wrap
msgid "SHORTLOOPS"
msgstr "SHORTLOOPS"

#. type: pindex
#: zsh.texi:11160
#, no-wrap
msgid "NOSHORTLOOPS"
msgstr "NOSHORTLOOPS"

#. type: item
#: zsh.texi:11161
#, no-wrap
msgid "@t{SHORT_LOOPS} <C> <Z>"
msgstr "@t{SHORT_LOOPS} <C> <Z>"

#. type: table
#: zsh.texi:11164
msgid "Allow the short forms of @t{for}, @t{repeat}, @t{select}, @t{if}, and @t{function} constructs."
msgstr "允许 @t{for}, @t{repeat}, @t{select}, @t{if}, 和 @t{function} 构造的简短形式."

#. type: t{#1}
#: zsh.texi:11165 zsh.texi:11169
#, no-wrap
msgid "SHORT_REPEAT"
msgstr "SHORT_REPEAT"

#. type: pindex
#: zsh.texi:11166
#, no-wrap
msgid "NO_SHORT_REPEAT"
msgstr "NO_SHORT_REPEAT"

#. type: pindex
#: zsh.texi:11167
#, no-wrap
msgid "SHORTREPEAT"
msgstr "SHORTREPEAT"

#. type: pindex
#: zsh.texi:11168
#, no-wrap
msgid "NOSHORTREPEAT"
msgstr "NOSHORTREPEAT"

#. type: table
#: zsh.texi:11172
msgid "Allow the short form @t{repeat} as @t{SHORT_LOOPS} but without enabling it for the other constructs."
msgstr "像 @t{SHORT_LOOPS} 一样允许使用简短形式 @t{repeat}，但不在其他结构式中启用。"

#. type: table
#: zsh.texi:11173 zsh.texi:12585
#, no-wrap
msgid "SUN_KEYBOARD_HACK"
msgstr "SUN_KEYBOARD_HACK"

#. type: pindex
#: zsh.texi:11174
#, no-wrap
msgid "NO_SUN_KEYBOARD_HACK"
msgstr "NO_SUN_KEYBOARD_HACK"

#. type: pindex
#: zsh.texi:11175
#, no-wrap
msgid "SUNKEYBOARDHACK"
msgstr "SUNKEYBOARDHACK"

#. type: pindex
#: zsh.texi:11176
#, no-wrap
msgid "NOSUNKEYBOARDHACK"
msgstr "NOSUNKEYBOARDHACK"

#. type: cindex
#: zsh.texi:11177
#, no-wrap
msgid "sun keyboard, annoying"
msgstr "sun 键盘, 烦人的"

#. type: cindex
#: zsh.texi:11178
#, no-wrap
msgid "annoying keyboard, sun"
msgstr "烦人的键盘, sun"

#. type: item
#: zsh.texi:11179
#, no-wrap
msgid "@t{SUN_KEYBOARD_HACK} (@t{-L})"
msgstr "@t{SUN_KEYBOARD_HACK} (@t{-L})"

#. type: table
#: zsh.texi:11186
msgid ""
"If a line ends with a backquote, and there are an odd number of backquotes on the line, ignore the trailing backquote.  This is useful on some keyboards where the return key is too small, and the "
"backquote key lies annoyingly close to it.  As an alternative the variable @t{KEYBOARD_HACK} lets you choose the character to be removed."
msgstr "如果一行以反引号结束，而该行的反引号数目为奇数，则忽略尾部的反引号。 在某些键盘上，回车键太小，而反引号键离回车键很近，这时会很有用。 作为替代，变量 @t{KEYBOARD_HACK} 可以让你选择要删除的字符。"

#. type: subsection
#: zsh.texi:11191
#, no-wrap
msgid "Job Control"
msgstr "作业控制"

#. type: t{#1}
#: zsh.texi:11194 zsh.texi:11200
#, no-wrap
msgid "AUTO_CONTINUE"
msgstr "AUTO_CONTINUE"

#. type: pindex
#: zsh.texi:11195
#, no-wrap
msgid "NO_AUTO_CONTINUE"
msgstr "NO_AUTO_CONTINUE"

#. type: pindex
#: zsh.texi:11196
#, no-wrap
msgid "AUTOCONTINUE"
msgstr "AUTOCONTINUE"

#. type: pindex
#: zsh.texi:11197
#, no-wrap
msgid "NOAUTOCONTINUE"
msgstr "NOAUTOCONTINUE"

#. type: cindex
#: zsh.texi:11198
#, no-wrap
msgid "jobs, continuing automatically"
msgstr "作业, 自动继续"

#. type: cindex
#: zsh.texi:11199
#, no-wrap
msgid "continuing jobs automatically"
msgstr "自动继续作业"

#. type: table
#: zsh.texi:11204
msgid "With this option set, stopped jobs that are removed from the job table with the @t{disown} builtin command are automatically sent a @t{CONT} signal to make them running."
msgstr "设置该选项后，使用 @t{disown} 内置命令从作业表中删除的已停止作业会自动被发送 @t{CONT} 信号，使其恢复运行。"

#. type: table
#: zsh.texi:11205 zsh.texi:12607
#, no-wrap
msgid "AUTO_RESUME"
msgstr "AUTO_RESUME"

#. type: pindex
#: zsh.texi:11206
#, no-wrap
msgid "NO_AUTO_RESUME"
msgstr "NO_AUTO_RESUME"

#. type: pindex
#: zsh.texi:11207
#, no-wrap
msgid "AUTORESUME"
msgstr "AUTORESUME"

#. type: pindex
#: zsh.texi:11208
#, no-wrap
msgid "NOAUTORESUME"
msgstr "NOAUTORESUME"

#. type: cindex
#: zsh.texi:11209
#, no-wrap
msgid "jobs, resuming automatically"
msgstr "作业, 自动恢复"

#. type: cindex
#: zsh.texi:11210
#, no-wrap
msgid "resuming jobs automatically"
msgstr "自动恢复作业"

#. type: item
#: zsh.texi:11211
#, no-wrap
msgid "@t{AUTO_RESUME} (@t{-W})"
msgstr "@t{AUTO_RESUME} (@t{-W})"

#. type: table
#: zsh.texi:11214
msgid "Treat single word simple commands without redirection as candidates for resumption of an existing job."
msgstr "将没有重定向的单字简单命令视为恢复现有作业的候选命令。"

#. type: table
#: zsh.texi:11215 zsh.texi:12557
#, no-wrap
msgid "BG_NICE"
msgstr "BG_NICE"

#. type: pindex
#: zsh.texi:11216
#, no-wrap
msgid "NO_BG_NICE"
msgstr "NO_BG_NICE"

#. type: pindex
#: zsh.texi:11217
#, no-wrap
msgid "BGNICE"
msgstr "BGNICE"

#. type: pindex
#: zsh.texi:11218
#, no-wrap
msgid "NOBGNICE"
msgstr "NOBGNICE"

#. type: cindex
#: zsh.texi:11219
#, no-wrap
msgid "jobs, background priority"
msgstr "作业, 后台优先级"

#. type: cindex
#: zsh.texi:11220
#, no-wrap
msgid "background jobs, priority of"
msgstr "后台作业, 优先级"

#. type: cindex
#: zsh.texi:11221
#, no-wrap
msgid "priority of background jobs"
msgstr "后台作业的优先级"

#. type: item
#: zsh.texi:11222
#, no-wrap
msgid "@t{BG_NICE} (@t{-6}) <C> <Z>"
msgstr "@t{BG_NICE} (@t{-6}) <C> <Z>"

#. type: table
#: zsh.texi:11225
msgid "Run all background jobs at a lower priority.  This option is set by default."
msgstr "以较低的优先级运行所有后台任务。 该选项为默认设置。"

#. type: pindex
#: zsh.texi:11226
#, no-wrap
msgid "CHECK_JOBS"
msgstr "CHECK_JOBS"

#. type: pindex
#: zsh.texi:11227
#, no-wrap
msgid "NO_CHECK_JOBS"
msgstr "NO_CHECK_JOBS"

#. type: pindex
#: zsh.texi:11228
#, no-wrap
msgid "CHECKJOBS"
msgstr "CHECKJOBS"

#. type: pindex
#: zsh.texi:11229
#, no-wrap
msgid "NOCHECKJOBS"
msgstr "NOCHECKJOBS"

#. type: cindex
#: zsh.texi:11230
#, no-wrap
msgid "exiting, checking jobs when"
msgstr "退出时, 检查作业"

#. type: cindex
#: zsh.texi:11231
#, no-wrap
msgid "logging out, checking jobs when"
msgstr "登出时, 检查作业"

#. type: item
#: zsh.texi:11232
#, no-wrap
msgid "@t{CHECK_JOBS} <Z>"
msgstr "@t{CHECK_JOBS} <Z>"

#. type: table
#: zsh.texi:11237
msgid ""
"Report the status of background and suspended jobs before exiting a shell with job control; a second attempt to exit the shell will succeed.  @t{NO_CHECK_JOBS} is best used only in combination with "
"@t{NO_HUP}, else such jobs will be killed automatically."
msgstr "在退出受作业控制的 shell 之前，报告后台作业和挂起作业的状态；第二次尝试退出 shell 将成功。 @t{NO_CHECK_JOBS} 最好与 @t{NO_HUP} 结合使用，否则此类作业会被自动杀死。"

#. type: table
#: zsh.texi:11245
msgid ""
"The check is omitted if the commands run from the previous command line included a `@t{jobs}' command, since it is assumed the user is aware that there are background or suspended jobs.  A `@t{jobs}' "
"command run from one of the hook functions defined in the section `Special Functions' in @ref{Functions} is not counted for this purpose."
msgstr "如果从上一条命令行运行的命令中包含 `@t{jobs}' 命令，则省略检查，因为我们假定用户知道存在后台作业或暂停作业。 从 @ref{函数} 中 `特殊函数' 一节定义的钩子函数之一运行的 `@t{jobs}' 命令不计算在内。"

#. type: pindex
#: zsh.texi:11246
#, no-wrap
msgid "CHECK_RUNNING_JOBS"
msgstr "CHECK_RUNNING_JOBS"

#. type: pindex
#: zsh.texi:11247
#, no-wrap
msgid "NO_CHECK_RUNNING_JOBS"
msgstr "NO_CHECK_RUNNING_JOBS"

#. type: pindex
#: zsh.texi:11248
#, no-wrap
msgid "CHECKRUNNINGJOBS"
msgstr "CHECKRUNNINGJOBS"

#. type: pindex
#: zsh.texi:11249
#, no-wrap
msgid "NOCHECKRUNNINGJOBS"
msgstr "NOCHECKRUNNINGJOBS"

#. type: cindex
#: zsh.texi:11250
#, no-wrap
msgid "exiting, checking running jobs when"
msgstr "退出时, 检查运行中的作业"

#. type: cindex
#: zsh.texi:11251
#, no-wrap
msgid "logging out, checking running jobs when"
msgstr "登出时, 检查运行中的作业"

#. type: item
#: zsh.texi:11252
#, no-wrap
msgid "@t{CHECK_RUNNING_JOBS} <Z>"
msgstr "@t{CHECK_RUNNING_JOBS} <Z>"

#. type: table
#: zsh.texi:11256
msgid "Check for both running and suspended jobs when @t{CHECK_JOBS} is enabled.  When this option is disabled, zsh checks only for suspended jobs, which matches the default behavior of bash."
msgstr "启用 @t{CHECK_JOBS} 时，会同时检查运行中和暂停中的作业。 禁用此选项后，zsh 只检查暂停的作业，这与 bash 的默认行为一致。"

#. type: table
#: zsh.texi:11259
msgid "This option has no effect unless @t{CHECK_JOBS} is set."
msgstr "除非设置了 @t{CHECK_JOBS}，否则该选项不起作用。"

#. type: pindex
#: zsh.texi:11260
#, no-wrap
msgid "HUP"
msgstr "HUP"

#. type: pindex
#: zsh.texi:11261
#, no-wrap
msgid "NO_HUP"
msgstr "NO_HUP"

#. type: pindex
#: zsh.texi:11262
#, no-wrap
msgid "NOHUP"
msgstr "NOHUP"

#. type: cindex
#: zsh.texi:11263
#, no-wrap
msgid "jobs, HUP"
msgstr "作业, HUP"

#. type: item
#: zsh.texi:11264
#, no-wrap
msgid "@t{HUP} <Z>"
msgstr "@t{HUP} <Z>"

#. type: table
#: zsh.texi:11267
msgid "Send the @t{HUP} signal to running jobs when the shell exits."
msgstr "当 shell 退出时，向正在运行的作业发送 @t{HUP} 信号。"

#. type: table
#: zsh.texi:11268 zsh.texi:12597
#, no-wrap
msgid "LONG_LIST_JOBS"
msgstr "LONG_LIST_JOBS"

#. type: pindex
#: zsh.texi:11269
#, no-wrap
msgid "NO_LONG_LIST_JOBS"
msgstr "NO_LONG_LIST_JOBS"

#. type: pindex
#: zsh.texi:11270
#, no-wrap
msgid "LONGLISTJOBS"
msgstr "LONGLISTJOBS"

#. type: pindex
#: zsh.texi:11271
#, no-wrap
msgid "NOLONGLISTJOBS"
msgstr "NOLONGLISTJOBS"

#. type: cindex
#: zsh.texi:11272
#, no-wrap
msgid "jobs, list format"
msgstr "作业, 列表格式"

#. type: item
#: zsh.texi:11273
#, no-wrap
msgid "@t{LONG_LIST_JOBS} (@t{-R})"
msgstr "@t{LONG_LIST_JOBS} (@t{-R})"

#. type: table
#: zsh.texi:11275
msgid "Print job notifications in the long format by default."
msgstr "默认以长格式打印作业通知。"

#. type: table
#: zsh.texi:11276 zsh.texi:12631 zsh.texi:12676
#, no-wrap
msgid "MONITOR"
msgstr "MONITOR"

#. type: pindex
#: zsh.texi:11277
#, no-wrap
msgid "NO_MONITOR"
msgstr "NO_MONITOR"

#. type: pindex
#: zsh.texi:11278
#, no-wrap
msgid "NOMONITOR"
msgstr "NOMONITOR"

#. type: cindex
#: zsh.texi:11279
#, no-wrap
msgid "job control, allowing"
msgstr "作业控制, 允许"

#. type: item
#: zsh.texi:11280
#, no-wrap
msgid "@t{MONITOR} (@t{-m}, ksh: @t{-m})"
msgstr "@t{MONITOR} (@t{-m}, ksh: @t{-m})"

#. type: table
#: zsh.texi:11282
msgid "Allow job control.  Set by default in interactive shells."
msgstr "允许作业控制。 在交互式 shell 中默认设置。"

#. type: table
#: zsh.texi:11283 zsh.texi:12555 zsh.texi:12666
#, no-wrap
msgid "NOTIFY"
msgstr "NOTIFY"

#. type: pindex
#: zsh.texi:11284
#, no-wrap
msgid "NO_NOTIFY"
msgstr "NO_NOTIFY"

#. type: pindex
#: zsh.texi:11285
#, no-wrap
msgid "NONOTIFY"
msgstr "NONOTIFY"

#. type: cindex
#: zsh.texi:11286
#, no-wrap
msgid "background jobs, notification"
msgstr "后台作业, 通知"

#. type: cindex
#: zsh.texi:11287
#, no-wrap
msgid "notification of background jobs"
msgstr "后台作业通知"

#. type: item
#: zsh.texi:11288
#, no-wrap
msgid "@t{NOTIFY} (@t{-5}, ksh: @t{-b}) <Z>"
msgstr "@t{NOTIFY} (@t{-5}, ksh: @t{-b}) <Z>"

#. type: table
#: zsh.texi:11291
msgid "Report the status of background jobs immediately, rather than waiting until just before printing a prompt."
msgstr "立即报告后台作业的状态，而不是等到打印提示符前才报告。"

#. type: pindex
#: zsh.texi:11292
#, no-wrap
msgid "POSIX_JOBS"
msgstr "POSIX_JOBS"

#. type: pindex
#: zsh.texi:11293
#, no-wrap
msgid "POSIXJOBS"
msgstr "POSIXJOBS"

#. type: pindex
#: zsh.texi:11294
#, no-wrap
msgid "NO_POSIX_JOBS"
msgstr "NO_POSIX_JOBS"

#. type: pindex
#: zsh.texi:11295
#, no-wrap
msgid "NOPOSIXJOBS"
msgstr "NOPOSIXJOBS"

#. type: cindex
#: zsh.texi:11296
#, no-wrap
msgid "bg, output in POSIX format"
msgstr "bg, 以 POSIX 格式输出"

#. type: cindex
#: zsh.texi:11297
#, no-wrap
msgid "fg, output in POSIX format"
msgstr "fg, 以 POSIX 格式输出"

#. type: cindex
#: zsh.texi:11298
#, no-wrap
msgid "job control, in subshell"
msgstr "作业控制, 子 shell 中"

#. type: cindex
#: zsh.texi:11299
#, no-wrap
msgid "jobs, output in subshell"
msgstr "作业, 子 shell 中输出"

#. type: item
#: zsh.texi:11300
#, no-wrap
msgid "@t{POSIX_JOBS} <K> <S>"
msgstr "@t{POSIX_JOBS} <K> <S>"

#. type: table
#: zsh.texi:11302
msgid "This option makes job control more compliant with the POSIX standard."
msgstr "该选项使作业控制更符合 POSIX 标准。"

#. type: table
#: zsh.texi:11309
msgid ""
"When the option is not set, the @t{MONITOR} option is unset on entry to subshells, so that job control is no longer active.  When the option is set, the @t{MONITOR} option and job control remain active in "
"the subshell, but note that the subshell has no access to jobs in the parent shell."
msgstr ""
"未设置该选项时，进入子 shell 时 @t{MONITOR} 选项将被取消设置，因此作业控制不再有效。 设置该选项后，@t{MONITOR} 选项和作业控制在子 shell 中仍然有效，但需要注意的是，子 shell 无法访问父 shell 中的作业。"

#. type: table
#: zsh.texi:11315
msgid ""
"When the option is not set, jobs put in the background or foreground with @t{bg} or @t{fg} are displayed with the same information that would be reported by @t{jobs}.  When the option is set, only the "
"text is printed.  The output from @t{jobs} itself is not affected by the option."
msgstr "不设置该选项时，用 @t{bg} 或 @t{fg} 放在后台或前台的作业会显示与 @t{jobs} 报告的相同信息。 如果设置了该选项，则只打印文本。 @t{jobs} 本身的输出不受该选项影响。"

#. type: table
#: zsh.texi:11321
msgid ""
"When the option is not set, job information from the parent shell is saved for output within a subshell (for example, within a pipeline).  When the option is set, the output of @t{jobs} is empty until a "
"job is started within the subshell."
msgstr "不设置该选项时，父 shell 中的作业信息会保存到子 shell（例如管道）中输出。 设置该选项后，@t{jobs} 的输出将为空，直到子 shell 中启动作业。"

#. type: table
#: zsh.texi:11327
msgid ""
"In previous versions of the shell, it was necessary to enable @t{POSIX_JOBS} in order for the builtin command @t{wait} to return the status of background jobs that had already exited.  This is no longer "
"the case."
msgstr "在以前版本的 shell 中，必须启用 @t{POSIX_JOBS}，内置命令 @t{wait} 才能返回已退出的后台作业的状态。 现在不再需要这样做了。"

#. type: subsection
#: zsh.texi:11332
#, no-wrap
msgid "Prompting"
msgstr "提示"

#. type: pindex
#: zsh.texi:11335
#, no-wrap
msgid "PROMPT_BANG"
msgstr "PROMPT_BANG"

#. type: pindex
#: zsh.texi:11336
#, no-wrap
msgid "NO_PROMPT_BANG"
msgstr "NO_PROMPT_BANG"

#. type: pindex
#: zsh.texi:11337
#, no-wrap
msgid "PROMPTBANG"
msgstr "PROMPTBANG"

#. type: pindex
#: zsh.texi:11338
#, no-wrap
msgid "NOPROMPTBANG"
msgstr "NOPROMPTBANG"

#. type: cindex
#: zsh.texi:11339
#, no-wrap
msgid "prompt, ! expansion"
msgstr "提示符, ! 扩展"

#. type: item
#: zsh.texi:11340
#, no-wrap
msgid "@t{PROMPT_BANG} <K>"
msgstr "@t{PROMPT_BANG} <K>"

#. type: table
#: zsh.texi:11344
msgid "If set, `@t{!}' is treated specially in prompt expansion.  See @ref{Prompt Expansion}."
msgstr "如果设置， `@t{!}'将在提示符扩展中被特殊处理。 请参阅 @ref{提示符扩展}。"

#. type: pindex
#: zsh.texi:11345
#, no-wrap
msgid "PROMPT_CR"
msgstr "PROMPT_CR"

#. type: pindex
#: zsh.texi:11346
#, no-wrap
msgid "NO_PROMPT_CR"
msgstr "NO_PROMPT_CR"

#. type: pindex
#: zsh.texi:11347
#, no-wrap
msgid "PROMPTCR"
msgstr "PROMPTCR"

#. type: pindex
#: zsh.texi:11348
#, no-wrap
msgid "NOPROMPTCR"
msgstr "NOPROMPTCR"

#. type: cindex
#: zsh.texi:11349
#, no-wrap
msgid "prompt, with CR"
msgstr "提示符, 带有 CR"

#. type: item
#: zsh.texi:11350
#, no-wrap
msgid "@t{PROMPT_CR} (@t{+V}) <D>"
msgstr "@t{PROMPT_CR} (@t{+V}) <D>"

#. type: table
#: zsh.texi:11354
msgid "Print a carriage return just before printing a prompt in the line editor.  This is on by default as multi-line editing is only possible if the editor knows where the start of the line appears."
msgstr "在行编辑器中打印提示符前打印回车。 默认情况下是打开的，因为只有编辑器知道行的起始位置，才能进行多行编辑。"

#. type: pindex
#: zsh.texi:11355
#, no-wrap
msgid "PROMPT_SP"
msgstr "PROMPT_SP"

#. type: pindex
#: zsh.texi:11356
#, no-wrap
msgid "NO_PROMPT_SP"
msgstr "NO_PROMPT_SP"

#. type: pindex
#: zsh.texi:11357
#, no-wrap
msgid "PROMPTSP"
msgstr "PROMPTSP"

#. type: pindex
#: zsh.texi:11358
#, no-wrap
msgid "NOPROMPTSP"
msgstr "NOPROMPTSP"

#. type: cindex
#: zsh.texi:11359
#, no-wrap
msgid "prompt, save partial lines"
msgstr "提示符, 保存部分行"

#. type: item
#: zsh.texi:11360
#, no-wrap
msgid "@t{PROMPT_SP} <D>"
msgstr "@t{PROMPT_SP} <D>"

#. type: table
#: zsh.texi:11367
msgid ""
"Attempt to preserve a partial line (i.e. a line that did not end with a newline) that would otherwise be covered up by the command prompt due to the @t{PROMPT_CR} option.  This works by outputting some "
"cursor-control characters, including a series of spaces, that should make the terminal wrap to the next line when a partial line is present (note that this is only successful if your terminal has "
"automatic margins, which is typical)."
msgstr ""
"试图保留因 @t{PROMPT_CR} 选项而被命令提示符遮盖的部分行（partial line)（即未以换行结束的行）。 这将通过输出一些光标控制字符（包括一系列空格）来实现，当出现部分行时，这些字符将使终端换行到下一行（请注意，这"
"只有在终端有自动页边距的情况下才能成功，而自动页边距是典型的）。"

#. type: table
#: zsh.texi:11373
msgid ""
"When a partial line is preserved, by default you will see an inverse+bold character at the end of the partial line: a `@t{%}' for a normal user or a `@t{#}' for root.  If set, the shell parameter "
"@t{PROMPT_EOL_MARK} can be used to customize how the end of partial lines are shown."
msgstr "保留部分行时，默认情况下会在部分行的末尾显示一个反转+粗体字符：普通用户为 `@t{%}' ，root 用户为 `@t{#}' 。 如果设置了 shell 参数 @t{PROMPT_EOL_MARK}，则可以自定义部分行行尾的显示方式。"

#. type: table
#: zsh.texi:11377
msgid "NOTE: if the @t{PROMPT_CR} option is not set, enabling this option will have no effect.  This option is on by default."
msgstr "注意：如果未设置 @t{PROMPT_CR} 选项，启用该选项将没有任何效果。 该选项默认为开启。"

#. type: pindex
#: zsh.texi:11378
#, no-wrap
msgid "PROMPT_PERCENT"
msgstr "PROMPT_PERCENT"

#. type: pindex
#: zsh.texi:11379
#, no-wrap
msgid "NO_PROMPT_PERCENT"
msgstr "NO_PROMPT_PERCENT"

#. type: pindex
#: zsh.texi:11380
#, no-wrap
msgid "PROMPTPERCENT"
msgstr "PROMPTPERCENT"

#. type: pindex
#: zsh.texi:11381
#, no-wrap
msgid "NOPROMPTPERCENT"
msgstr "NOPROMPTPERCENT"

#. type: cindex
#: zsh.texi:11382
#, no-wrap
msgid "prompt, % expansion"
msgstr "提示符, % 扩展"

#. type: item
#: zsh.texi:11383
#, no-wrap
msgid "@t{PROMPT_PERCENT} <C> <Z>"
msgstr "@t{PROMPT_PERCENT} <C> <Z>"

#. type: table
#: zsh.texi:11387
msgid "If set, `@t{%}' is treated specially in prompt expansion.  See @ref{Prompt Expansion}."
msgstr "如果设置了该选项，`@t{%}' 将在提示符扩展中被特殊处理。 请参阅 @ref{提示符扩展}。"

#. type: pindex
#: zsh.texi:11388
#, no-wrap
msgid "PROMPT_SUBST"
msgstr "PROMPT_SUBST"

#. type: pindex
#: zsh.texi:11389
#, no-wrap
msgid "NO_PROMPT_SUBST"
msgstr "NO_PROMPT_SUBST"

#. type: pindex
#: zsh.texi:11390
#, no-wrap
msgid "PROMPTSUBST"
msgstr "PROMPTSUBST"

#. type: pindex
#: zsh.texi:11391
#, no-wrap
msgid "NOPROMPTSUBST"
msgstr "NOPROMPTSUBST"

#. type: cindex
#: zsh.texi:11392
#, no-wrap
msgid "prompt, parameter expansion"
msgstr "提示符, 参数扩展"

#. type: item
#: zsh.texi:11393
#, no-wrap
msgid "@t{PROMPT_SUBST} <K> <S>"
msgstr "@t{PROMPT_SUBST} <K> <S>"

#. type: table
#: zsh.texi:11397
msgid "If set, @emph{parameter expansion}, @emph{command substitution} and @emph{arithmetic expansion} are performed in prompts.  Substitutions within prompts do not affect the command status."
msgstr "如果设置，@emph{参数扩展}、@emph{命令替换}和 @emph{ 算术扩展}将在提示符中执行。 提示符内的替换不会影响命令状态。"

#. type: t{#1}
#: zsh.texi:11398 zsh.texi:11402
#, no-wrap
msgid "TRANSIENT_RPROMPT"
msgstr "TRANSIENT_RPROMPT"

#. type: pindex
#: zsh.texi:11399
#, no-wrap
msgid "NO_TRANSIENT_RPROMPT"
msgstr "NO_TRANSIENT_RPROMPT"

#. type: pindex
#: zsh.texi:11400
#, no-wrap
msgid "TRANSIENTRPROMPT"
msgstr "TRANSIENTRPROMPT"

#. type: pindex
#: zsh.texi:11401
#, no-wrap
msgid "NOTRANSIENTRPROMPT"
msgstr "NOTRANSIENTRPROMPT"

#. type: table
#: zsh.texi:11405
msgid "Remove any right prompt from display when accepting a command line.  This may be useful with terminals with other cut/paste methods."
msgstr "在接受命令行时，移除显示的任何右侧提示符。 这对使用其他剪切/粘贴方法的终端可能有用。"

#. type: subsection
#: zsh.texi:11410
#, no-wrap
msgid "Scripts and Functions"
msgstr "脚本和函数"

#. type: pindex
#: zsh.texi:11413
#, no-wrap
msgid "ALIAS_FUNC_DEF"
msgstr "ALIAS_FUNC_DEF"

#. type: pindex
#: zsh.texi:11414
#, no-wrap
msgid "NO_ALIAS_FUNC_DEF"
msgstr "NO_ALIAS_FUNC_DEF"

#. type: pindex
#: zsh.texi:11415
#, no-wrap
msgid "ALIASFUNCDEF"
msgstr "ALIASFUNCDEF"

#. type: pindex
#: zsh.texi:11416
#, no-wrap
msgid "NOALIASFUNCDEF"
msgstr "NOALIASFUNCDEF"

#. type: cindex
#: zsh.texi:11417
#, no-wrap
msgid "functions, defining with expanded aliases"
msgstr "函数, 用扩展的别名定义的"

#. type: cindex
#: zsh.texi:11418
#, no-wrap
msgid "aliases, expanding in function definition"
msgstr "别名,  在函数定义中扩展的"

#. type: item
#: zsh.texi:11419
#, no-wrap
msgid "@t{ALIAS_FUNC_DEF} <S>"
msgstr "@t{ALIAS_FUNC_DEF} <S>"

#. type: table
#: zsh.texi:11425
msgid ""
"By default, zsh does not allow the definition of functions using the `@var{name} @t{()}' syntax if @var{name} was expanded as an alias: this causes an error.  This is usually the desired behaviour, as "
"otherwise the combination of an alias and a function based on the same definition can easily cause problems."
msgstr "默认情况下，如果 @var{name} 被展开为别名，zsh 不允许使用 `@var{name} @t{()}' 语法定义函数：这将导致错误。 这通常是我们所希望的行为，否则基于相同定义的别名和函数的组合很容易导致问题。"

#. type: table
#: zsh.texi:11428
msgid "When this option is set, aliases can be used for defining functions."
msgstr "设置该选项后，可以使用别名来定义函数。"

#. type: table
#: zsh.texi:11432
msgid "For example, consider the following definitions as they might occur in a startup file."
msgstr "例如，考虑启动文件中可能出现的以下定义。"

#. type: example
#: zsh.texi:11439
#, no-wrap
msgid ""
"alias foo=bar\n"
"foo() @{\n"
"  print This probably does not do what you expect.\n"
"@}\n"
msgstr ""
"alias foo=bar\n"
"foo() @{\n"
"  print This probably does not do what you expect.\n"
"@}\n"

#. type: table
#: zsh.texi:11448
msgid ""
"Here, @t{foo} is expanded as an alias to @t{bar} before the @t{()} is encountered, so the function defined would be named @t{bar}.  By default this is instead an error in native mode.  Note that quoting "
"any part of the function name, or using the keyword @t{function}, avoids the problem, so is recommended when the function name can also be an alias."
msgstr ""
"在这里，@t{foo} 在遇到 @t{()} 之前被扩展为 @t{bar} 的别名，因此定义的函数将被命名为 @t{bar}。 默认情况下，在 native 模式下这反而是一个错误。 需要注意的是，函数名的任何部分加引号或使用关键字 @t{function} 都"
"可以避免这个问题，因此建议在函数名也可以是别名时使用。"

#. type: t{#1}
#: zsh.texi:11449 zsh.texi:11456
#, no-wrap
msgid "C_BASES"
msgstr "C_BASES"

#. type: pindex
#: zsh.texi:11450
#, no-wrap
msgid "NO_C_BASES"
msgstr "NO_C_BASES"

#. type: pindex
#: zsh.texi:11451
#, no-wrap
msgid "CBASES"
msgstr "CBASES"

#. type: pindex
#: zsh.texi:11452
#, no-wrap
msgid "NOCBASES"
msgstr "NOCBASES"

#. type: cindex
#: zsh.texi:11453
#, no-wrap
msgid "bases, output in C format"
msgstr "基数, 以 C 格式输出"

#. type: cindex
#: zsh.texi:11454
#, no-wrap
msgid "hexadecimal, output in C format"
msgstr "十六进制, 以 C 格式输出"

#. type: cindex
#: zsh.texi:11455
#, no-wrap
msgid "octal, output in C format"
msgstr "八进制, 以 C 格式输出"

#. type: table
#: zsh.texi:11464
msgid ""
"Output hexadecimal numbers in the standard C format, for example `@t{0xFF}' instead of the usual `@t{16#FF}'.  If the option @t{OCTAL_ZEROES} is also set (it is not by default), octal numbers will be "
"treated similarly and hence appear as `@t{077}' instead of `@t{8#77}'.  This option has no effect on the choice of the output base, nor on the output of bases other than hexadecimal and octal.  Note that "
"these formats will be understood on input irrespective of the setting of @t{C_BASES}."
msgstr ""
"以标准 C 格式输出十六进制数，例如 `@t{0xFF}' ，而不是通常的 `@t{16#FF}'。 如果同时设置了选项 @t{OCTAL_ZEROES}（默认情况下没有），八进制数也会被类似处理，因此会显示为 `@t{077}'  而不是 `@t{8#77}'。 该选项不"
"会影响输出基数的选择，也不会影响十六进制和八进制以外基数的输出。 请注意，无论 @t{C_BASES} 的设置如何，这些格式在输入时都能被理解。"

#. type: t{#1}
#: zsh.texi:11465 zsh.texi:11471
#, no-wrap
msgid "C_PRECEDENCES"
msgstr "C_PRECEDENCES"

#. type: pindex
#: zsh.texi:11466
#, no-wrap
msgid "NO_C_PRECEDENCES"
msgstr "NO_C_PRECEDENCES"

#. type: pindex
#: zsh.texi:11467
#, no-wrap
msgid "CPRECEDENCES"
msgstr "CPRECEDENCES"

#. type: pindex
#: zsh.texi:11468
#, no-wrap
msgid "NOCPRECEDENCES"
msgstr "NOCPRECEDENCES"

#. type: cindex
#: zsh.texi:11469
#, no-wrap
msgid "precedence, operator"
msgstr "优先级, 操作符"

#. type: cindex
#: zsh.texi:11470
#, no-wrap
msgid "operator precedence"
msgstr "操作符优先级"

#. type: table
#: zsh.texi:11476
msgid "This alters the precedence of arithmetic operators to be more like C and other programming languages; @ref{Arithmetic Evaluation} has an explicit list."
msgstr "这改变了算术运算符的优先级，使其更像 C 语言和其他编程语言；@ref{算术求值}有一个显式列表。"

#. type: pindex
#: zsh.texi:11477
#, no-wrap
msgid "DEBUG_BEFORE_CMD"
msgstr "DEBUG_BEFORE_CMD"

#. type: pindex
#: zsh.texi:11478
#, no-wrap
msgid "NO_DEBUG_BEFORE_CMD"
msgstr "NO_DEBUG_BEFORE_CMD"

#. type: pindex
#: zsh.texi:11479
#, no-wrap
msgid "DEBUGBEFORECMD"
msgstr "DEBUGBEFORECMD"

#. type: pindex
#: zsh.texi:11480
#, no-wrap
msgid "NODEBUGBEFORECMD"
msgstr "NODEBUGBEFORECMD"

#. type: cindex
#: zsh.texi:11481
#, no-wrap
msgid "traps, DEBUG, before or after command"
msgstr "陷井, DEBUG, 在命令前或后"

#. type: cindex
#: zsh.texi:11482
#, no-wrap
msgid "DEBUG trap, before or after command"
msgstr "DEBUG 陷井, 在命令前或后"

#. type: item
#: zsh.texi:11483
#, no-wrap
msgid "@t{DEBUG_BEFORE_CMD} <D>"
msgstr "@t{DEBUG_BEFORE_CMD} <D>"

#. type: table
#: zsh.texi:11487
msgid "Run the @t{DEBUG} trap before each command; otherwise it is run after each command.  Setting this option mimics the behaviour of ksh 93; with the option unset the behaviour is that of ksh 88."
msgstr "在每条命令之前运行 @t{DEBUG}陷阱，否则在每条命令之后运行。 设置该选项后，将模仿 ksh 93 的行为；不设置该选项时，将使用 ksh 88 的行为。"

#. type: table
#: zsh.texi:11488 zsh.texi:12617 zsh.texi:12668
#, no-wrap
msgid "ERR_EXIT"
msgstr "ERR_EXIT"

#. type: pindex
#: zsh.texi:11489
#, no-wrap
msgid "NO_ERR_EXIT"
msgstr "NO_ERR_EXIT"

#. type: pindex
#: zsh.texi:11490
#, no-wrap
msgid "ERREXIT"
msgstr "ERREXIT"

#. type: pindex
#: zsh.texi:11491
#, no-wrap
msgid "NOERREXIT"
msgstr "NOERREXIT"

#. type: cindex
#: zsh.texi:11492
#, no-wrap
msgid "exit status, trapping"
msgstr "退出状态, 陷井捕获"

#. type: item
#: zsh.texi:11493
#, no-wrap
msgid "@t{ERR_EXIT} (@t{-e}, ksh: @t{-e})"
msgstr "@t{ERR_EXIT} (@t{-e}, ksh: @t{-e})"

#. type: table
#: zsh.texi:11497
msgid "If a command has a non-zero exit status, execute the @t{ZERR} trap, if set, and exit.  This is disabled while running initialization scripts."
msgstr "如果命令的退出状态为非零，则执行 @t{ZERR} 陷阱（如果已设置）并退出。 运行初始化脚本时，该功能将被禁用。"

#. type: table
#: zsh.texi:11505
msgid ""
"The behaviour is also disabled inside @t{DEBUG} traps.  In this case the option is handled specially: it is unset on entry to the trap.  If the option @t{DEBUG_BEFORE_CMD} is set, as it is by default, and "
"the option @t{ERR_EXIT} is found to have been set on exit, then the command for which the @t{DEBUG} trap is being executed is skipped.  The option is restored after the trap exits."
msgstr ""
"在 @t{DEBUG} 陷阱中也会禁用该行为。 在这种情况下，会对选项进行特殊处理：在进入陷阱时取消设置。 如果设置了 @t{DEBUG_BEFORE_CMD} 选项（默认情况），并且在退出时发现 @t{ERR_EXIT} 选项已被设置，则跳过 "
"@t{DEBUG} 陷阱正在执行的命令。 该选项会在陷阱退出后恢复。"

#. type: table
#: zsh.texi:11509
msgid "Non-zero status in a command list containing @t{&&} or @t{||} is ignored for commands not at the end of the list.  Hence"
msgstr "包含 @t{&&} 或 @t{||} 的命令列表中，不在命令列表末尾的命令，其非零状态将被忽略。 因此"

#. type: example
#: zsh.texi:11513
#, no-wrap
msgid "false && true\n"
msgstr "false && true\n"

#. type: table
#: zsh.texi:11517
msgid "does not trigger exit."
msgstr "不会触发退出。"

#. type: table
#: zsh.texi:11522
msgid "Exiting due to @t{ERR_EXIT} has certain interactions with asynchronous jobs noted in @ref{Jobs & Signals}."
msgstr "由于 @t{ERR_EXIT} 而退出，会与 @ref{作业和信号} 中提到的异步作业产生某些交互。"

#. type: t{#1}
#: zsh.texi:11523 zsh.texi:11529
#, no-wrap
msgid "ERR_RETURN"
msgstr "ERR_RETURN"

#. type: pindex
#: zsh.texi:11524
#, no-wrap
msgid "NO_ERR_RETURN"
msgstr "NO_ERR_RETURN"

#. type: pindex
#: zsh.texi:11525
#, no-wrap
msgid "ERRRETURN"
msgstr "ERRRETURN"

#. type: pindex
#: zsh.texi:11526
#, no-wrap
msgid "NOERRRETURN"
msgstr "NOERRRETURN"

#. type: cindex
#: zsh.texi:11527
#, no-wrap
msgid "function return, on error"
msgstr "函数返回, 错误时"

#. type: cindex
#: zsh.texi:11528
#, no-wrap
msgid "return from function, on error"
msgstr "从函数返回, 错误时"

#. type: table
#: zsh.texi:11535
msgid ""
"If a command has a non-zero exit status, return immediately from the enclosing function.  The logic is similar to that for @t{ERR_EXIT}, except that an implicit @t{return} statement is executed instead of "
"an @t{exit}.  This will trigger an exit at the outermost level of a non-interactive script."
msgstr "如果命令的退出状态为非零，则立即从闭合函数中返回。 其逻辑与 @t{ERR_EXIT} 类似，只是执行的是隐式 @t{return} 语句而不是 @t{exit}。 这将在非交互式脚本的最外层触发退出。"

#. type: table
#: zsh.texi:11540
msgid "Normally this option inherits the behaviour of @t{ERR_EXIT} that code followed by `@t{&&}' `@t{||}' does not trigger a return.  Hence in the following:"
msgstr "通常，该选项继承了 @t{ERR_EXIT} 的行为，即代码后跟 `@t{&&}' `@t{||}'不会触发返回。 因此，在下面的代码中"

#. type: example
#: zsh.texi:11544
#, no-wrap
msgid "summit || true\n"
msgstr "summit || true\n"

#. type: table
#: zsh.texi:11549
msgid "no return is forced as the combined effect always has a zero return status."
msgstr "不强制返回，因为综合效果始终为零返回状态。"

#. type: table
#: zsh.texi:11556
msgid ""
"Note. however, that if @t{summit} in the above example is itself a function, code inside it is considered separately: it may force a return from @t{summit} (assuming the option remains set within "
"@t{summit}), but not from the enclosing context.  This behaviour is different from @t{ERR_EXIT} which is unaffected by function scope."
msgstr ""
"但请注意，如果上例中的 @t{summit} 本身是一个函数，那么其中的代码将被单独考虑：它可能强制从 @t{summit} 返回（假设选项仍在 @t{summit} 中设置），但不会强制从闭合上下文返回。 这种行为与 @t{ERR_EXIT} 不同，后者"
"不受函数作用域的影响。"

#. type: pindex
#: zsh.texi:11557
#, no-wrap
msgid "EVAL_LINENO"
msgstr "EVAL_LINENO"

#. type: pindex
#: zsh.texi:11558
#, no-wrap
msgid "NO_EVAL_LINENO"
msgstr "NO_EVAL_LINENO"

#. type: pindex
#: zsh.texi:11559
#, no-wrap
msgid "EVALLINENO"
msgstr "EVALLINENO"

#. type: pindex
#: zsh.texi:11560
#, no-wrap
msgid "NOEVALLINENO"
msgstr "NOEVALLINENO"

#. type: cindex
#: zsh.texi:11561
#, no-wrap
msgid "line number, in evaluated expression"
msgstr "行号, 在已计算的表达式中"

#. type: item
#: zsh.texi:11562
#, no-wrap
msgid "@t{EVAL_LINENO} <Z>"
msgstr "@t{EVAL_LINENO} <Z>"

#. type: table
#: zsh.texi:11572
msgid ""
"If set, line numbers of expressions evaluated using the builtin @t{eval} are tracked separately of the enclosing environment.  This applies both to the parameter @t{LINENO} and the line number output by "
"the prompt escape @t{%i}.  If the option is set, the prompt escape @t{%N} will output the string `@t{(eval)}' instead of the script or function name as an indication.  (The two prompt escapes are "
"typically used in the parameter @t{PS4} to be output when the option @t{XTRACE} is set.)  If @t{EVAL_LINENO} is unset, the line number of the surrounding script or function is retained during the "
"evaluation."
msgstr ""
"如果设置了该参数，使用内置 @t{eval} 求值的表达式的行号将与封闭环境分开跟踪。 这同时适用于参数 @t{LINENO} 和提示符 @t{%i} 输出的行号。 如果设置了该选项，提示符转义 @t{%N} 将输出字符串 `@t{(eval)}' ，而不是"
"脚本或函数名称作为提示。 (这两个提示符转义符通常用于设置选项 @t{XTRACE} 时，输出参数 @t{PS4} ）。 如果未设置 @t{EVAL_LINENO}，脚本或函数的行号将在求值过程中保留。"

#. type: pindex
#: zsh.texi:11573
#, no-wrap
msgid "EXEC"
msgstr "EXEC"

#. type: pindex
#: zsh.texi:11574
#, no-wrap
msgid "NO_EXEC"
msgstr "NO_EXEC"

#. type: pindex
#: zsh.texi:11575
#, no-wrap
msgid "NOEXEC"
msgstr "NOEXEC"

#. type: cindex
#: zsh.texi:11576
#, no-wrap
msgid "command execution, enabling"
msgstr "命令执行, 启用"

#. type: item
#: zsh.texi:11577
#, no-wrap
msgid "@t{EXEC} (@t{+n}, ksh: @t{+n}) <D>"
msgstr "@t{EXEC} (@t{+n}, ksh: @t{+n}) <D>"

#. type: table
#: zsh.texi:11582
msgid ""
"Do execute commands.  Without this option, commands are read and checked for syntax errors, but not executed.  This option cannot be turned off in an interactive shell, except when `@t{-n}' is supplied to "
"the shell at startup."
msgstr ""
"Do execute commands.  Without this option, commands are read and checked for syntax errors, but not executed.  This option cannot be turned off in an interactive shell, except when `@t{-n}' is supplied to "
"the shell at startup."

#. type: pindex
#: zsh.texi:11583
#, no-wrap
msgid "FUNCTION_ARGZERO"
msgstr "FUNCTION_ARGZERO"

#. type: pindex
#: zsh.texi:11584
#, no-wrap
msgid "NO_FUNCTION_ARGZERO"
msgstr "NO_FUNCTION_ARGZERO"

#. type: pindex
#: zsh.texi:11585
#, no-wrap
msgid "FUNCTIONARGZERO"
msgstr "FUNCTIONARGZERO"

#. type: pindex
#: zsh.texi:11586
#, no-wrap
msgid "NOFUNCTIONARGZERO"
msgstr "NOFUNCTIONARGZERO"

#. type: cindex
#: zsh.texi:11587
#, no-wrap
msgid "$0, setting"
msgstr "$0, 设置"

#. type: item
#: zsh.texi:11588
#, no-wrap
msgid "@t{FUNCTION_ARGZERO} <C> <Z>"
msgstr "@t{FUNCTION_ARGZERO} <C> <Z>"

#. type: table
#: zsh.texi:11594
msgid ""
"When executing a shell function or sourcing a script, set @t{$0} temporarily to the name of the function/script.  Note that toggling @t{FUNCTION_ARGZERO} from on to off (or off to on) does not change the "
"current value of @t{$0}.  Only the state upon entry to the function or script has an effect.  Compare @t{POSIX_ARGZERO}."
msgstr ""
"执行 shell 函数或引入脚本时，将 @t{$0} 暂时设置为函数/脚本的名称。 请注意，将 @t{FUNCTION_ARGZERO} 从打开切换到关闭（或从关闭切换到打开）并不会改变 @t{$0} 的当前值。 只有进入函数或脚本时的状态才会产生影"
"响。 比较 @t{POSIX_ARGZERO}。"

#. type: t{#1}
#: zsh.texi:11595 zsh.texi:11602
#, no-wrap
msgid "LOCAL_LOOPS"
msgstr "LOCAL_LOOPS"

#. type: pindex
#: zsh.texi:11596
#, no-wrap
msgid "NO_LOCAL_LOOPS"
msgstr "NO_LOCAL_LOOPS"

#. type: pindex
#: zsh.texi:11597
#, no-wrap
msgid "LOCALLOOPS"
msgstr "LOCALLOOPS"

#. type: pindex
#: zsh.texi:11598
#, no-wrap
msgid "NOLOCALLOOPS"
msgstr "NOLOCALLOOPS"

#. type: cindex
#: zsh.texi:11599
#, no-wrap
msgid "break, inside function"
msgstr "break, 在函数内部"

#. type: cindex
#: zsh.texi:11600
#, no-wrap
msgid "continue, inside function"
msgstr "continue, 在函数内部"

#. type: cindex
#: zsh.texi:11601
#, no-wrap
msgid "function, scope of break and continue"
msgstr "函数, break 和 continue 的范围"

#. type: table
#: zsh.texi:11609
msgid ""
"When this option is not set, the effect of @t{break} and @t{continue} commands may propagate outside function scope, affecting loops in calling functions.  When the option is set in a calling function, a "
"@t{break} or a @t{continue} that is not caught within a called function (regardless of the setting of the option within that function)  produces a warning and the effect is cancelled."
msgstr ""
"如果未设置该选项，@t{break} 和 @t{continue} 命令的效果可能会传播到函数作用域之外，影响调用函数中的循环。 如果在(正在)调用的函数中设置了该选项，则未被调用函数捕获的 @t{break} 或 @t{continue}（无论在<已>调用"
"函数中是否设置了该选项）会产生警告并取消效果。"

#. type: pindex
#: zsh.texi:11610
#, no-wrap
msgid "LOCAL_OPTIONS"
msgstr "LOCAL_OPTIONS"

#. type: pindex
#: zsh.texi:11611
#, no-wrap
msgid "NO_LOCAL_OPTIONS"
msgstr "NO_LOCAL_OPTIONS"

#. type: pindex
#: zsh.texi:11612
#, no-wrap
msgid "LOCALOPTIONS"
msgstr "LOCALOPTIONS"

#. type: pindex
#: zsh.texi:11613
#, no-wrap
msgid "NOLOCALOPTIONS"
msgstr "NOLOCALOPTIONS"

#. type: item
#: zsh.texi:11614
#, no-wrap
msgid "@t{LOCAL_OPTIONS} <K>"
msgstr "@t{LOCAL_OPTIONS} <K>"

#. type: table
#: zsh.texi:11625
msgid ""
"If this option is set at the point of return from a shell function, most options (including this one) which were in force upon entry to the function are restored; options that are not restored are "
"@t{PRIVILEGED} and @t{RESTRICTED}.  Otherwise, only this option, and the @t{LOCAL_LOOPS}, @t{XTRACE} and @t{PRINT_EXIT_VALUE} options are restored.  Hence if this is explicitly unset by a shell function "
"the other options in force at the point of return will remain so.  A shell function can also guarantee itself a known shell configuration with a formulation like `@t{emulate -L zsh}'; the @t{-L} activates "
"@t{LOCAL_OPTIONS}."
msgstr ""
"如果在从 shell 函数返回时设置了此选项，则会恢复大多数在进入函数时有效的选项（包括此选项）；不恢复的选项包括 @t{PRIVILEGED} 和 @t{RESTRICTED}。 否则，只有该选项、@t{LOCAL_LOOPS}、@t{XTRACE} 和 "
"@t{PRINT_EXIT_VALUE} 选项会被还原。 因此，如果 shell 函数显式地取消了该选项的设置，返回时有效的其他选项仍将保持不变。 shell 函数也可以通过类似于 `@t{emulate -L zsh}' 的表述来保证自己拥有已知的 shell 配置；"
"@t{-L} 会激活 @t{LOCAL_OPTIONS}。"

#. type: t{#1}
#: zsh.texi:11626 zsh.texi:11630
#, no-wrap
msgid "LOCAL_PATTERNS"
msgstr "LOCAL_PATTERNS"

#. type: pindex
#: zsh.texi:11627
#, no-wrap
msgid "NO_LOCAL_PATTERNS"
msgstr "NO_LOCAL_PATTERNS"

#. type: pindex
#: zsh.texi:11628
#, no-wrap
msgid "LOCALPATTERNS"
msgstr "LOCALPATTERNS"

#. type: pindex
#: zsh.texi:11629
#, no-wrap
msgid "NOLOCALPATTERNS"
msgstr "NOLOCALPATTERNS"

#. type: table
#: zsh.texi:11638
msgid ""
"If this option is set at the point of return from a shell function, the state of pattern disables, as set with the builtin command `@t{disable -p}', is restored to what it was when the function was "
"entered.  The behaviour of this option is similar to the effect of @t{LOCAL_OPTIONS} on options; hence `@t{emulate -L sh}' (or indeed any other emulation with the @t{-L} option) activates "
"@t{LOCAL_PATTERNS}."
msgstr ""
"如果在 shell 函数返回时设置了该选项，则通过内置命令 `@t{disable -p}'设置的模式禁用状态将恢复到进入函数时的状态。 该选项的作用类似于 @t{LOCAL_OPTIONS} 对选项的作用；因此， `@t{emulate -L sh}' （或其他使用 "
"@t{-L} 选项的仿真）会激活 @t{LOCAL_PATTERNS}。"

#. type: pindex
#: zsh.texi:11639
#, no-wrap
msgid "LOCAL_TRAPS"
msgstr "LOCAL_TRAPS"

#. type: pindex
#: zsh.texi:11640
#, no-wrap
msgid "NO_LOCAL_TRAPS"
msgstr "NO_LOCAL_TRAPS"

#. type: pindex
#: zsh.texi:11641
#, no-wrap
msgid "LOCALTRAPS"
msgstr "LOCALTRAPS"

#. type: pindex
#: zsh.texi:11642
#, no-wrap
msgid "NOLOCALTRAPS"
msgstr "NOLOCALTRAPS"

#. type: item
#: zsh.texi:11643
#, no-wrap
msgid "@t{LOCAL_TRAPS} <K>"
msgstr "@t{LOCAL_TRAPS} <K>"

#. type: table
#: zsh.texi:11651
msgid ""
"If this option is set when a signal trap is set inside a function, then the previous status of the trap for that signal will be restored when the function exits.  Note that this option must be set "
"@emph{prior} to altering the trap behaviour in a function; unlike @t{LOCAL_OPTIONS}, the value on exit from the function is irrelevant.  However, it does not need to be set before any global trap for that "
"to be correctly restored by a function.  For example,"
msgstr ""
"如果在函数内部设置信号陷阱时设置了该选项，那么当函数退出时，该信号的陷阱状态将被恢复。请注意，必须在更改函数中的陷阱行为@t{之前}设置该选项；与 @t{LOCAL_OPTIONS} 不同的是，退出函数时的值并不重要。 不过，全"
"局陷阱并不需要在函数正确恢复之前设置。 例如"

#. type: example
#: zsh.texi:11657
#, no-wrap
msgid ""
"unsetopt localtraps\n"
"trap - INT\n"
"fn() @{ setopt localtraps; trap @value{dsq} INT; sleep 3; @}\n"
msgstr ""
"unsetopt localtraps\n"
"trap - INT\n"
"fn() @{ setopt localtraps; trap @value{dsq} INT; sleep 3; @}\n"

#. type: table
#: zsh.texi:11661
msgid "will restore normal handling of @t{SIGINT} after the function exits."
msgstr "将在函数退出后恢复对 @t{SIGINT} 的正常处理。"

#. type: pindex
#: zsh.texi:11662
#, no-wrap
msgid "MULTI_FUNC_DEF"
msgstr "MULTI_FUNC_DEF"

#. type: pindex
#: zsh.texi:11663
#, no-wrap
msgid "NO_MULTI_FUNC_DEF"
msgstr "NO_MULTI_FUNC_DEF"

#. type: pindex
#: zsh.texi:11664
#, no-wrap
msgid "MULTIFUNCDEF"
msgstr "MULTIFUNCDEF"

#. type: pindex
#: zsh.texi:11665
#, no-wrap
msgid "NOMULTIFUNCDEF"
msgstr "NOMULTIFUNCDEF"

#. type: item
#: zsh.texi:11666
#, no-wrap
msgid "@t{MULTI_FUNC_DEF} <Z>"
msgstr "@t{MULTI_FUNC_DEF} <Z>"

#. type: table
#: zsh.texi:11672
msgid ""
"Allow definitions of multiple functions at once in the form `@t{fn1 fn2}@var{...}@t{()}'; if the option is not set, this causes a parse error.  Definition of multiple functions with the @t{function} "
"keyword is always allowed.  Multiple function definitions are not often used and can cause obscure errors."
msgstr "允许以 `@t{fn1 fn2}@var{...}@t{()}' 的形式同时定义多个函数；如果未设置该选项，则会导致解析错误。 始终允许使用 @t{function} 关键字定义多个函数。 多重函数定义并不常用，可能会导致不明显的错误。"

#. type: pindex
#: zsh.texi:11673
#, no-wrap
msgid "MULTIOS"
msgstr "MULTIOS"

#. type: pindex
#: zsh.texi:11674
#, no-wrap
msgid "NO_MULTIOS"
msgstr "NO_MULTIOS"

#. type: pindex
#: zsh.texi:11675
#, no-wrap
msgid "NOMULTIOS"
msgstr "NOMULTIOS"

#. type: item
#: zsh.texi:11676
#, no-wrap
msgid "@t{MULTIOS} <Z>"
msgstr "@t{MULTIOS} <Z>"

#. type: table
#: zsh.texi:11679
msgid "Perform implicit @cite{tee}s or @cite{cat}s when multiple redirections are attempted (see @ref{Redirection})."
msgstr "当尝试多次重定向时，执行隐式 @cite{tee}s 或 @cite{cat}s （请参阅 @ref{重定向}）。"

#. type: pindex
#: zsh.texi:11680
#, no-wrap
msgid "OCTAL_ZEROES"
msgstr "OCTAL_ZEROES"

#. type: pindex
#: zsh.texi:11681
#, no-wrap
msgid "NO_OCTAL_ZEROES"
msgstr "NO_OCTAL_ZEROES"

#. type: pindex
#: zsh.texi:11682
#, no-wrap
msgid "OCTALZEROES"
msgstr "OCTALZEROES"

#. type: pindex
#: zsh.texi:11683
#, no-wrap
msgid "NOOCTALZEROES"
msgstr "NOOCTALZEROES"

#. type: cindex
#: zsh.texi:11684
#, no-wrap
msgid "octal, arithmetic expressions"
msgstr "八进制, 算术表达式"

#. type: item
#: zsh.texi:11685
#, no-wrap
msgid "@t{OCTAL_ZEROES} <S>"
msgstr "@t{OCTAL_ZEROES} <S>"

#. type: table
#: zsh.texi:11690
msgid ""
"Interpret any integer constant beginning with a 0 as octal, per IEEE Std 1003.2-1992 (ISO 9945-2:1993).  This is not enabled by default as it causes problems with parsing of, for example, date and time "
"strings with leading zeroes."
msgstr "根据 IEEE 标准 1003.2-1992（ISO 9945-2:1993），将以 0 开头的整数常量解释为八进制。 默认情况下不启用此功能，因为它会给日期和时间字符串等前导零字符串的解析带来问题。"

#. type: table
#: zsh.texi:11695
msgid "Sequences of digits indicating a numeric base such as the `@t{08}' component in `@t{08#77}' are always interpreted as decimal, regardless of leading zeroes."
msgstr "表示数值基数的数字序列，如 `@t{08#77}' 中的 `@t{08}'  分量，始终被解释为十进制，与前导零无关。"

#. type: t{#1}
#: zsh.texi:11696 zsh.texi:11703
#, no-wrap
msgid "PIPE_FAIL"
msgstr "PIPE_FAIL"

#. type: pindex
#: zsh.texi:11697
#, no-wrap
msgid "NO_PIPE_FAIL"
msgstr "NO_PIPE_FAIL"

#. type: pindex
#: zsh.texi:11698
#, no-wrap
msgid "PIPEFAIL"
msgstr "PIPEFAIL"

#. type: pindex
#: zsh.texi:11699
#, no-wrap
msgid "NOPIPEFAIL"
msgstr "NOPIPEFAIL"

#. type: cindex
#: zsh.texi:11700
#, no-wrap
msgid "exit status from pipeline"
msgstr "从管道中退出的状态"

#. type: cindex
#: zsh.texi:11701
#, no-wrap
msgid "status, on exit from pipeline"
msgstr "状态, 从管道退出的"

#. type: cindex
#: zsh.texi:11702
#, no-wrap
msgid "pipeline, exit status from"
msgstr "管道, 退出状态"

#. type: table
#: zsh.texi:11709
msgid ""
"By default, when a pipeline exits the exit status recorded by the shell and returned by the shell variable @t{$?} reflects that of the rightmost element of a pipeline.  If this option is set, the exit "
"status instead reflects the status of the rightmost element of the pipeline that was non-zero, or zero if all elements exited with zero status."
msgstr ""
"默认情况下，当管道退出时，shell 记录并由 shell 变量 @t{$?} 返回的退出状态，反映的是管道最右端元素的状态。 如果设置了该选项，退出状态将反映管道最右端元素的非零状态，如果所有元素都以零状态退出，则返回零状"
"态。"

#. type: t{#1}
#: zsh.texi:11710 zsh.texi:11714
#, no-wrap
msgid "SOURCE_TRACE"
msgstr "SOURCE_TRACE"

#. type: pindex
#: zsh.texi:11711
#, no-wrap
msgid "NO_SOURCE_TRACE"
msgstr "NO_SOURCE_TRACE"

#. type: pindex
#: zsh.texi:11712
#, no-wrap
msgid "SOURCETRACE"
msgstr "SOURCETRACE"

#. type: pindex
#: zsh.texi:11713
#, no-wrap
msgid "NOSOURCETRACE"
msgstr "NOSOURCETRACE"

#. type: table
#: zsh.texi:11721
msgid ""
"If set, zsh will print an informational message announcing the name of each file it loads.  The format of the output is similar to that for the @t{XTRACE} option, with the message @t{<sourcetrace>}.  A "
"file may be loaded by the shell itself when it starts up and shuts down (@t{Startup/Shutdown Files}) or by the use of the `@t{source}' and `@t{dot}' builtin commands."
msgstr ""
"如果设置了该选项，zsh 将打印一条信息消息，公布所加载的每个文件的名称。 输出格式与 @t{XTRACE} 选项类似，信息为 @t{<sourcetrace>}。 文件可以在 shell 启动和关闭时由 shell 本身加载（@t{启动/关闭文件}），也可以"
"通过使用 `@t{source}' 和 `@t{dot}' 内置命令加载。"

#. type: t{#1}
#: zsh.texi:11722 zsh.texi:11726
#, no-wrap
msgid "TYPESET_SILENT"
msgstr "TYPESET_SILENT"

#. type: pindex
#: zsh.texi:11723
#, no-wrap
msgid "NO_TYPESET_SILENT"
msgstr "NO_TYPESET_SILENT"

#. type: pindex
#: zsh.texi:11724
#, no-wrap
msgid "TYPESETSILENT"
msgstr "TYPESETSILENT"

#. type: pindex
#: zsh.texi:11725
#, no-wrap
msgid "NOTYPESETSILENT"
msgstr "NOTYPESETSILENT"

#. type: table
#: zsh.texi:11733
msgid ""
"If this is unset, executing any of the `@t{typeset}' family of commands with no options and a list of parameters that have no values to be assigned but already exist will display the value of the "
"parameter.  If the option is set, they will only be shown when parameters are selected with the `@t{-m}' option.  The option `@t{-p}' is available whether or not the option is set."
msgstr ""
"如果未设置该选项，在执行任何不带任何选项的 `@t{typeset}' 系列命令时，如果参数列表中已经存在的参数没有被赋值，则会显示该参数的值。 如果设置了该选项，则只有在使用 `@t{-m}'  选项选择参数时，才会显示这些参"
"数。 无论是否设置了该选项，都可以使用选项 `@t{-p}' 。"

#. type: pindex
#: zsh.texi:11734
#, no-wrap
msgid "TYPESET_TO_UNSET"
msgstr "TYPESET_TO_UNSET"

#. type: pindex
#: zsh.texi:11735
#, no-wrap
msgid "NO_TYPESET_TO_UNSET"
msgstr "NO_TYPESET_TO_UNSET"

#. type: pindex
#: zsh.texi:11736
#, no-wrap
msgid "TYPESETTOUNSET"
msgstr "TYPESETTOUNSET"

#. type: pindex
#: zsh.texi:11737
#, no-wrap
msgid "NOTYPESETTOUNSET"
msgstr "NOTYPESETTOUNSET"

#. type: item
#: zsh.texi:11738
#, no-wrap
msgid "@t{TYPESET_TO_UNSET} <K> <S>"
msgstr "@t{TYPESET_TO_UNSET} <K> <S>"

#. type: table
#: zsh.texi:11743
msgid ""
"When declaring a new parameter with any of the `@t{typeset}' family of related commands, the parameter remains unset unless and until a value is explicity assigned to it, either in the `@t{typeset}' "
"command itself or as a later assignment statement."
msgstr "当使用 `@t{typeset}' 系列相关命令声明一个新参数时，除非在 `@t{typeset}' 命令本身或稍后的赋值语句中明确为其赋值，否则该参数将保持未设置状态。"

#. type: table
#: zsh.texi:11744 zsh.texi:12645 zsh.texi:12690
#, no-wrap
msgid "VERBOSE"
msgstr "VERBOSE"

#. type: pindex
#: zsh.texi:11745
#, no-wrap
msgid "NO_VERBOSE"
msgstr "NO_VERBOSE"

#. type: pindex
#: zsh.texi:11746
#, no-wrap
msgid "NOVERBOSE"
msgstr "NOVERBOSE"

#. type: cindex
#: zsh.texi:11747
#, no-wrap
msgid "tracing, of input lines"
msgstr "跟踪, 输入行"

#. type: cindex
#: zsh.texi:11748
#, no-wrap
msgid "input, tracing"
msgstr "输入, 跟踪"

#. type: item
#: zsh.texi:11749
#, no-wrap
msgid "@t{VERBOSE} (@t{-v}, ksh: @t{-v})"
msgstr "@t{VERBOSE} (@t{-v}, ksh: @t{-v})"

#. type: table
#: zsh.texi:11751
msgid "Print shell input lines as they are read."
msgstr "在读取 shell 输入行时将其打印出来。"

#. type: table
#: zsh.texi:11752 zsh.texi:12649 zsh.texi:12692
#, no-wrap
msgid "XTRACE"
msgstr "XTRACE"

#. type: pindex
#: zsh.texi:11753
#, no-wrap
msgid "NO_XTRACE"
msgstr "NO_XTRACE"

#. type: pindex
#: zsh.texi:11754
#, no-wrap
msgid "NOXTRACE"
msgstr "NOXTRACE"

#. type: cindex
#: zsh.texi:11755
#, no-wrap
msgid "tracing, of commands"
msgstr "跟踪, 命令"

#. type: cindex
#: zsh.texi:11756
#, no-wrap
msgid "commands, tracing"
msgstr "命令, 跟踪"

#. type: item
#: zsh.texi:11757
#, no-wrap
msgid "@t{XTRACE} (@t{-x}, ksh: @t{-x})"
msgstr "@t{XTRACE} (@t{-x}, ksh: @t{-x})"

#. type: table
#: zsh.texi:11762
msgid "Print commands and their arguments as they are executed.  The output is preceded by the value of @t{$PS4}, formatted as described in @ref{Prompt Expansion}."
msgstr "在执行命令时打印命令及其参数。 输出结果的前面是 @t{$PS4} 的值，格式如 @ref{提示符扩展} 中所述。"

#. type: subsection
#: zsh.texi:11767
#, no-wrap
msgid "Shell Emulation"
msgstr "Shell 仿真"

#. type: pindex
#: zsh.texi:11770
#, no-wrap
msgid "APPEND_CREATE"
msgstr "APPEND_CREATE"

#. type: pindex
#: zsh.texi:11771
#, no-wrap
msgid "NO_APPEND_CREATE"
msgstr "NO_APPEND_CREATE"

#. type: pindex
#: zsh.texi:11772
#, no-wrap
msgid "APPENDCREATE"
msgstr "APPENDCREATE"

#. type: pindex
#: zsh.texi:11773
#, no-wrap
msgid "NOAPPENDCREATE"
msgstr "NOAPPENDCREATE"

#. type: cindex
#: zsh.texi:11774
#, no-wrap
msgid "clobbering, POSIX compatibility"
msgstr "覆盖(clobbering), POSIX 兼容性"

#. type: cindex
#: zsh.texi:11775
#, no-wrap
msgid "file clobbering, POSIX compatibility"
msgstr "文件覆盖(clobbering), POSIX 兼容性"

#. type: cindex
#: zsh.texi:11776
#, no-wrap
msgid "no clobber, POSIX compatible"
msgstr "不覆盖, POSIX 兼容性"

#. type: item
#: zsh.texi:11777
#, no-wrap
msgid "@t{APPEND_CREATE} <K> <S>"
msgstr "@t{APPEND_CREATE} <K> <S>"

#. type: table
#: zsh.texi:11779
msgid "This option only applies when @t{NO_CLOBBER} (-@t{C}) is in effect."
msgstr "该选项仅在 @t{NO_CLOBBER} （-@t{C}）有效时适用。"

#. type: table
#: zsh.texi:11785
msgid ""
"If this option is not set, the shell will report an error when a append redirection (@t{>>}) is used on a file that does not already exists (the traditional zsh behaviour of @t{NO_CLOBBER}).  If the "
"option is set, no error is reported (POSIX behaviour)."
msgstr "如果未设置该选项，当在一个不存在的文件上使用追加重定向（@t{>>}）时，shell 将报错（传统的 zsh 行为 @t{NO_CLOBBER}）。 如果设置了该选项，则不会报错（POSIX 行为）。"

#. type: t{#1}
#: zsh.texi:11786 zsh.texi:11792
#, no-wrap
msgid "BASH_REMATCH"
msgstr "BASH_REMATCH"

#. type: pindex
#: zsh.texi:11787
#, no-wrap
msgid "NO_BASH_REMATCH"
msgstr "NO_BASH_REMATCH"

#. type: pindex
#: zsh.texi:11788
#, no-wrap
msgid "BASHREMATCH"
msgstr "BASHREMATCH"

#. type: pindex
#: zsh.texi:11789
#, no-wrap
msgid "NOBASHREMATCH"
msgstr "NOBASHREMATCH"

#. type: cindex
#: zsh.texi:11790
#, no-wrap
msgid "bash, BASH_REMATCH variable"
msgstr "bash, BASH_REMATCH 变量"

#. type: cindex
#: zsh.texi:11791
#, no-wrap
msgid "regexp, bash BASH_REMATCH variable"
msgstr "regexp, bash BASH_REMATCH 变量"

#. type: table
#: zsh.texi:11802
msgid ""
"When set, matches performed with the @t{=~} operator will set the @t{BASH_REMATCH} array variable, instead of the default @t{MATCH} and @t{match} variables.  The first element of the @t{BASH_REMATCH} "
"array will contain the entire matched text and subsequent elements will contain extracted substrings.  This option makes more sense when @t{KSH_ARRAYS} is also set, so that the entire matched portion is "
"stored at index 0 and the first substring is at index 1.  Without this option, the @t{MATCH} variable contains the entire matched text and the @t{match} array variable contains substrings."
msgstr ""
"设置后，使用 @t{=~} 操作符执行的匹配将设置 @t{BASH_REMATCH} 数组变量，而不是默认的 @t{MATCH} 和 @t{match} 变量。 @t{BASH_REMATCH} 数组的第一个元素将包含整个匹配文本，随后的元素将包含提取的子串。 如果同时设"
"置了 @t{KSH_ARRAYS}，整个匹配部分将存储在索引 0 处，第一个子串存储在索引 1 处，那么该选项就更有意义了。 如果不使用该选项，@t{MATCH} 变量将包含整个匹配文本，而 @t{match} 数组变量将包含子串。"

#. type: pindex
#: zsh.texi:11803
#, no-wrap
msgid "BSD_ECHO"
msgstr "BSD_ECHO"

#. type: pindex
#: zsh.texi:11804
#, no-wrap
msgid "NO_BSD_ECHO"
msgstr "NO_BSD_ECHO"

#. type: pindex
#: zsh.texi:11805
#, no-wrap
msgid "BSDECHO"
msgstr "BSDECHO"

#. type: pindex
#: zsh.texi:11806
#, no-wrap
msgid "NOBSDECHO"
msgstr "NOBSDECHO"

#. type: cindex
#: zsh.texi:11807
#, no-wrap
msgid "echo, BSD compatible"
msgstr "echo, BSD 兼容"

#. type: item
#: zsh.texi:11808
#, no-wrap
msgid "@t{BSD_ECHO} <S>"
msgstr "@t{BSD_ECHO} <S>"

#. type: table
#: zsh.texi:11812
msgid "Make the @t{echo} builtin compatible with the BSD echo(1) command.  This disables backslashed escape sequences in echo strings unless the @t{-e} option is specified."
msgstr "Make the @t{echo} builtin compatible with the BSD echo(1) command.  This disables backslashed escape sequences in echo strings unless the @t{-e} option is specified."

#. type: t{#1}
#: zsh.texi:11813 zsh.texi:11818
#, no-wrap
msgid "CONTINUE_ON_ERROR"
msgstr "CONTINUE_ON_ERROR"

#. type: pindex
#: zsh.texi:11814
#, no-wrap
msgid "NO_CONTINUE_ON_ERROR"
msgstr "NO_CONTINUE_ON_ERROR"

#. type: pindex
#: zsh.texi:11815
#, no-wrap
msgid "CONTINUEONERROR"
msgstr "CONTINUEONERROR"

#. type: pindex
#: zsh.texi:11816
#, no-wrap
msgid "NOCONTINUEONERROR"
msgstr "NOCONTINUEONERROR"

#. type: cindex
#: zsh.texi:11817
#, no-wrap
msgid "error, option to continue script on"
msgstr "错误, 继续脚本的选项"

#. type: table
#: zsh.texi:11827
msgid ""
"If a fatal error is encountered (see @ref{Errors}), and the code is running in a script, the shell will resume execution at the next statement in the script at the top level, in other words outside all "
"functions or shell constructs such as loops and conditions.  This mimics the behaviour of interactive shells, where the shell returns to the line editor to read a new command; it was the normal behaviour "
"in versions of zsh before 5.0.1."
msgstr ""
"如果遇到致命错误（参见 @ref{错误}），并且代码是在脚本中运行，shell 将在脚本的下一条语句的顶层恢复执行，换句话说，是在所有函数或 shell 结构（如循环和条件）之外恢复执行。 这模仿了交互式 shell 的行为，即 "
"shell 返回行编辑器读取新命令；这是 5.0.1 之前的 zsh 版本的正常行为。"

#. type: pindex
#: zsh.texi:11828
#, no-wrap
msgid "CSH_JUNKIE_HISTORY"
msgstr "CSH_JUNKIE_HISTORY"

#. type: pindex
#: zsh.texi:11829
#, no-wrap
msgid "NO_CSH_JUNKIE_HISTORY"
msgstr "NO_CSH_JUNKIE_HISTORY"

#. type: pindex
#: zsh.texi:11830
#, no-wrap
msgid "CSHJUNKIEHISTORY"
msgstr "CSHJUNKIEHISTORY"

#. type: pindex
#: zsh.texi:11831
#, no-wrap
msgid "NOCSHJUNKIEHISTORY"
msgstr "NOCSHJUNKIEHISTORY"

#. type: cindex
#: zsh.texi:11832
#, no-wrap
msgid "csh, history style"
msgstr "csh, 历史风格"

#. type: cindex
#: zsh.texi:11833
#, no-wrap
msgid "history style, csh"
msgstr "历史风格, csh"

#. type: item
#: zsh.texi:11834
#, no-wrap
msgid "@t{CSH_JUNKIE_HISTORY} <C>"
msgstr "@t{CSH_JUNKIE_HISTORY} <C>"

#. type: table
#: zsh.texi:11839
msgid ""
"A history reference without an event specifier will always refer to the previous command.  Without this option, such a history reference refers to the same event as the previous history reference on the "
"current command line, defaulting to the previous command."
msgstr "不带事件指示符的历史引用，将始终指向上一条命令。 如果没有该选项，历史记录引用将与当前命令行中的前一个历史记录引用指向相同的事件，默认为前一个命令。"

#. type: pindex
#: zsh.texi:11840
#, no-wrap
msgid "CSH_JUNKIE_LOOPS"
msgstr "CSH_JUNKIE_LOOPS"

#. type: pindex
#: zsh.texi:11841
#, no-wrap
msgid "NO_CSH_JUNKIE_LOOPS"
msgstr "NO_CSH_JUNKIE_LOOPS"

#. type: pindex
#: zsh.texi:11842
#, no-wrap
msgid "CSHJUNKIELOOPS"
msgstr "CSHJUNKIELOOPS"

#. type: pindex
#: zsh.texi:11843
#, no-wrap
msgid "NOCSHJUNKIELOOPS"
msgstr "NOCSHJUNKIELOOPS"

#. type: cindex
#: zsh.texi:11844
#, no-wrap
msgid "csh, loop style"
msgstr "csh, 循环风格"

#. type: cindex
#: zsh.texi:11845
#, no-wrap
msgid "loop style, csh"
msgstr "循环风格, csh"

#. type: item
#: zsh.texi:11846
#, no-wrap
msgid "@t{CSH_JUNKIE_LOOPS} <C>"
msgstr "@t{CSH_JUNKIE_LOOPS} <C>"

#. type: table
#: zsh.texi:11849
msgid "Allow loop bodies to take the form `@var{list}@t{; end}' instead of `@t{do }@var{list}@t{; done}'."
msgstr "允许循环体采用 `@var{list}@t{; end}' 的形式，而不是`@t{do }@var{list}@t{; done}'。"

#. type: pindex
#: zsh.texi:11850
#, no-wrap
msgid "CSH_JUNKIE_QUOTES"
msgstr "CSH_JUNKIE_QUOTES"

#. type: pindex
#: zsh.texi:11851
#, no-wrap
msgid "NO_CSH_JUNKIE_QUOTES"
msgstr "NO_CSH_JUNKIE_QUOTES"

#. type: pindex
#: zsh.texi:11852
#, no-wrap
msgid "CSHJUNKIEQUOTES"
msgstr "CSHJUNKIEQUOTES"

#. type: pindex
#: zsh.texi:11853
#, no-wrap
msgid "NOCSHJUNKIEQUOTES"
msgstr "NOCSHJUNKIEQUOTES"

#. type: cindex
#: zsh.texi:11854
#, no-wrap
msgid "csh, quoting style"
msgstr "csh, 引号风格"

#. type: cindex
#: zsh.texi:11855
#, no-wrap
msgid "quoting style, csh"
msgstr "引号风格, csh"

#. type: item
#: zsh.texi:11856
#, no-wrap
msgid "@t{CSH_JUNKIE_QUOTES} <C>"
msgstr "@t{CSH_JUNKIE_QUOTES} <C>"

#. type: table
#: zsh.texi:11863
msgid ""
"Changes the rules for single- and double-quoted text to match that of @cite{csh}.  These require that embedded newlines be preceded by a backslash; unescaped newlines will cause an error message.  In "
"double-quoted strings, it is made impossible to escape `@t{$}', `@t{`}' or `@t{\"}' (and `@t{\\}' itself no longer needs escaping).  Command substitutions are only expanded once, and cannot be nested."
msgstr ""
"更改单引号和双引号文本的规则，使其与 @cite{csh} 的规则一致。 这些规则要求内嵌换行符前必须有反斜线；未转义的换行符将导致错误信息。 在双引号字符串中，无法转义`@t{$}', `@t{`}' 或 `@t{\"}'（ `@t{\\}' 本身也不"
"再需要转义）。 命令替换只扩展一次，不能嵌套。"

#. type: pindex
#: zsh.texi:11864
#, no-wrap
msgid "CSH_NULLCMD"
msgstr "CSH_NULLCMD"

#. type: pindex
#: zsh.texi:11865
#, no-wrap
msgid "NO_CSH_NULLCMD"
msgstr "NO_CSH_NULLCMD"

#. type: pindex
#: zsh.texi:11866
#, no-wrap
msgid "CSHNULLCMD"
msgstr "CSHNULLCMD"

#. type: pindex
#: zsh.texi:11867
#, no-wrap
msgid "NOCSHNULLCMD"
msgstr "NOCSHNULLCMD"

#. type: vindex
#: zsh.texi:11868 zsh.texi:12180
#, no-wrap
msgid "NULLCMD, ignoring"
msgstr "NULLCMD, 忽略"

#. type: vindex
#: zsh.texi:11869 zsh.texi:12181
#, no-wrap
msgid "READNULLCMD, ignoring"
msgstr "READNULLCMD, 忽略"

#. type: cindex
#: zsh.texi:11870
#, no-wrap
msgid "redirections with no command, csh"
msgstr "没有命令的重定向, csh"

#. type: cindex
#: zsh.texi:11871
#, no-wrap
msgid "csh, redirections with no command"
msgstr "csh, 没有命令的重定向"

#. type: item
#: zsh.texi:11872
#, no-wrap
msgid "@t{CSH_NULLCMD} <C>"
msgstr "@t{CSH_NULLCMD} <C>"

#. type: table
#: zsh.texi:11876
msgid "Do not use the values of @t{NULLCMD} and @t{READNULLCMD} when running redirections with no command.  This make such redirections fail (see @ref{Redirection})."
msgstr "在运行无命令重定向时，请勿使用 @t{NULLCMD} 和 @t{READNULLCMD} 的值。 这会导致重定向失败（参见 @ref{重定向}）。"

#. type: pindex
#: zsh.texi:11877
#, no-wrap
msgid "KSH_ARRAYS"
msgstr "KSH_ARRAYS"

#. type: pindex
#: zsh.texi:11878
#, no-wrap
msgid "NO_KSH_ARRAYS"
msgstr "NO_KSH_ARRAYS"

#. type: pindex
#: zsh.texi:11879
#, no-wrap
msgid "KSHARRAYS"
msgstr "KSHARRAYS"

#. type: pindex
#: zsh.texi:11880
#, no-wrap
msgid "NOKSHARRAYS"
msgstr "NOKSHARRAYS"

#. type: cindex
#: zsh.texi:11881
#, no-wrap
msgid "arrays, ksh style"
msgstr "数组, ksh 风格"

#. type: cindex
#: zsh.texi:11882
#, no-wrap
msgid "array style, ksh"
msgstr "数组风格, ksh"

#. type: cindex
#: zsh.texi:11883
#, no-wrap
msgid "ksh, array style"
msgstr "ksh, 数组风格"

#. type: item
#: zsh.texi:11884
#, no-wrap
msgid "@t{KSH_ARRAYS} <K> <S>"
msgstr "@t{KSH_ARRAYS} <K> <S>"

#. type: table
#: zsh.texi:11891
msgid ""
"Emulate @cite{ksh} array handling as closely as possible.  If this option is set, array elements are numbered from zero, an array parameter without subscript refers to the first element instead of the "
"whole array, and braces are required to delimit a subscript (`@t{$@{path[2]@}}' rather than just `@t{$path[2]}') or to apply modifiers to any parameter (`@t{$@{PWD:h@}}' rather than `@t{$PWD:h}')."
msgstr ""
"尽可能模拟 @cite{ksh} 数组处理。 如果设置了该选项，数组元素将从零开始编号，不带下标的数组参数将指向第一个元素，而不是整个数组，并且需要使用大括号来分隔下标（ `@t{$@{path[2]@}}' 而不只是 `@t{$path[2]}' ）或"
"对任何参数应用修饰符（`@t{$@{PWD:h@}}' 而不是 `@t{$PWD:h}'）。"

#. type: pindex
#: zsh.texi:11892
#, no-wrap
msgid "KSH_AUTOLOAD"
msgstr "KSH_AUTOLOAD"

#. type: pindex
#: zsh.texi:11893
#, no-wrap
msgid "NO_KSH_AUTOLOAD"
msgstr "NO_KSH_AUTOLOAD"

#. type: pindex
#: zsh.texi:11894
#, no-wrap
msgid "KSHAUTOLOAD"
msgstr "KSHAUTOLOAD"

#. type: pindex
#: zsh.texi:11895
#, no-wrap
msgid "NOKSHAUTOLOAD"
msgstr "NOKSHAUTOLOAD"

#. type: item
#: zsh.texi:11896
#, no-wrap
msgid "@t{KSH_AUTOLOAD} <K> <S>"
msgstr "@t{KSH_AUTOLOAD} <K> <S>"

#. type: table
#: zsh.texi:11903
msgid ""
"Emulate @cite{ksh} function autoloading.  This means that when a function is autoloaded, the corresponding file is merely executed, and must define the function itself.  (By default, the function is "
"defined to the contents of the file.  However, the most common @cite{ksh}-style case - of the file containing only a simple definition of the function - is always handled in the @cite{ksh}-compatible "
"manner.)"
msgstr ""
"模拟 @cite{ksh} 函数的自动加载。 这意味着当一个函数被自动加载时，相应的文件只是被执行，而且必须定义函数本身。 (默认情况下，函数是根据文件内容定义的。 不过，最常见的 @cite{ksh} 风格情况--文件仅包含函数的简"
"单定义--总是以 @cite{ksh} 兼容的方式处理）。"

#. type: pindex
#: zsh.texi:11904
#, no-wrap
msgid "KSH_OPTION_PRINT"
msgstr "KSH_OPTION_PRINT"

#. type: pindex
#: zsh.texi:11905
#, no-wrap
msgid "NO_KSH_OPTION_PRINT"
msgstr "NO_KSH_OPTION_PRINT"

#. type: pindex
#: zsh.texi:11906
#, no-wrap
msgid "KSHOPTIONPRINT"
msgstr "KSHOPTIONPRINT"

#. type: pindex
#: zsh.texi:11907
#, no-wrap
msgid "NOKSHOPTIONPRINT"
msgstr "NOKSHOPTIONPRINT"

#. type: cindex
#: zsh.texi:11908
#, no-wrap
msgid "option printing, ksh style"
msgstr "选项打印, ksh 风格"

#. type: cindex
#: zsh.texi:11909
#, no-wrap
msgid "option printing style, ksh"
msgstr "选项打印风格, ksh"

#. type: cindex
#: zsh.texi:11910
#, no-wrap
msgid "ksh, option printing style"
msgstr "ksh, 选项打印风格"

#. type: item
#: zsh.texi:11911
#, no-wrap
msgid "@t{KSH_OPTION_PRINT} <K>"
msgstr "@t{KSH_OPTION_PRINT} <K>"

#. type: table
#: zsh.texi:11915
msgid "Alters the way options settings are printed: instead of separate lists of set and unset options, all options are shown, marked `on' if they are in the non-default state, `off' otherwise."
msgstr "改变选项设置的打印方式：不再单独列出已设置和未设置的选项，而是显示所有选项，如果处于非默认状态，则标记为 \"on\"，否则标记为 \"off\"。"

#. type: t{#1}
#: zsh.texi:11916 zsh.texi:11922
#, no-wrap
msgid "KSH_TYPESET"
msgstr "KSH_TYPESET"

#. type: pindex
#: zsh.texi:11917
#, no-wrap
msgid "NO_KSH_TYPESET"
msgstr "NO_KSH_TYPESET"

#. type: pindex
#: zsh.texi:11918
#, no-wrap
msgid "KSHTYPESET"
msgstr "KSHTYPESET"

#. type: pindex
#: zsh.texi:11919
#, no-wrap
msgid "NOKSHTYPESET"
msgstr "NOKSHTYPESET"

#. type: cindex
#: zsh.texi:11920
#, no-wrap
msgid "argument splitting, in typeset etc."
msgstr "参数分割, 用typeset等。"

#. type: cindex
#: zsh.texi:11921
#, no-wrap
msgid "ksh, argument splitting in typeset"
msgstr "ksh, 用 typeset 分割参数"

#. type: table
#: zsh.texi:11928
msgid ""
"This option is now obsolete: a better appropximation to the behaviour of other shells is obtained with the reserved word interface to @t{declare}, @t{export}, @t{float}, @t{integer}, @t{local}, "
"@t{readonly} and @t{typeset}.  Note that the option is only applied when the reserved word interface is @emph{not} in use."
msgstr ""
"该选项现已过时：使用保留字接口 @t{declare}、@t{export}、@t{float}、@t{integer}、@t{local}、@t{readonly} 和 @t{typeset} 可以更好地适应其他 shell 的行为。 需要注意的是，只有在@emph{不} 使用保留字接口时，才会"
"应用该选项。"

#. type: table
#: zsh.texi:11935
msgid ""
"Alters the way arguments to the @t{typeset} family of commands, including @t{declare}, @t{export}, @t{float}, @t{integer}, @t{local} and @t{readonly}, are processed.  Without this option, zsh will perform "
"normal word splitting after command and parameter expansion in arguments of an assignment; with it, word splitting does not take place in those cases."
msgstr ""
"改变 @t{typeset}系列命令的参数处理方式，包括 @t{declare}、@t{export}、@t{float}、@t{integer}、@t{local} 和 @t{readonly}。 如果没有此选项，zsh 会在赋值参数中的命令和参数扩展后执行正常的分词；如果有此选项，"
"则不会执行分词。"

#. type: t{#1}
#: zsh.texi:11936 zsh.texi:11941
#, no-wrap
msgid "KSH_ZERO_SUBSCRIPT"
msgstr "KSH_ZERO_SUBSCRIPT"

#. type: pindex
#: zsh.texi:11937
#, no-wrap
msgid "NO_KSH_ZERO_SUBSCRIPT"
msgstr "NO_KSH_ZERO_SUBSCRIPT"

#. type: pindex
#: zsh.texi:11938
#, no-wrap
msgid "KSHZEROSUBSCRIPT"
msgstr "KSHZEROSUBSCRIPT"

#. type: pindex
#: zsh.texi:11939
#, no-wrap
msgid "NOKSHZEROSUBSCRIPT"
msgstr "NOKSHZEROSUBSCRIPT"

#. type: cindex
#: zsh.texi:11940
#, no-wrap
msgid "arrays, behaviour of index zero"
msgstr "数组, 0索引的行为"

#. type: table
#: zsh.texi:11945
msgid "Treat use of a subscript of value zero in array or string expressions as a reference to the first element, i.e. the element that usually has the subscript 1.  Ignored if @t{KSH_ARRAYS} is also set."
msgstr "将数组或字符串表达式中的零值下标视为对第一个元素的引用，即通常下标为 1 的元素。 如果同时设置了 @t{KSH_ARRAYS} 则忽略。"

#. type: table
#: zsh.texi:11953
msgid ""
"If neither this option nor @t{KSH_ARRAYS} is set, accesses to an element of an array or string with subscript zero return an empty element or string, while attempts to set element zero of an array or "
"string are treated as an error.  However, attempts to set an otherwise valid subscript range that includes zero will succeed.  For example, if @t{KSH_ZERO_SUBSCRIPT} is not set,"
msgstr ""
"如果既没有设置这个选项，也没有设置 @t{KSH_ARRAYS}，那么在访问数组或字符串时，如果下标为零，则会返回空元素或空字符串，而试图设置数组或字符串的零元素则会被视为错误。 但是，如果尝试设置包含零的有效下标范围，"
"则会成功。 例如，如果 @t{KSH_ZERO_SUBSCRIPT} 没有被设置，"

#. type: example
#: zsh.texi:11957
#, no-wrap
msgid "array[0]=(element)\n"
msgstr "array[0]=(element)\n"

#. type: table
#: zsh.texi:11961
msgid "is an error, while"
msgstr "是一个错误，而"

#. type: example
#: zsh.texi:11965
#, no-wrap
msgid "array[0,1]=(element)\n"
msgstr "array[0,1]=(element)\n"

#. type: table
#: zsh.texi:11969
msgid "is not and will replace the first element of the array."
msgstr "不是，并且会替换数组的第一个元素。"

#. type: table
#: zsh.texi:11973
msgid "This option is for compatibility with older versions of the shell and is not recommended in new code."
msgstr "该选项是为了与旧版 shell 兼容，不建议在新代码中使用。"

#. type: pindex
#: zsh.texi:11974
#, no-wrap
msgid "POSIX_ALIASES"
msgstr "POSIX_ALIASES"

#. type: pindex
#: zsh.texi:11975
#, no-wrap
msgid "NO_POSIX_ALIASES"
msgstr "NO_POSIX_ALIASES"

#. type: pindex
#: zsh.texi:11976
#, no-wrap
msgid "POSIXALIASES"
msgstr "POSIXALIASES"

#. type: pindex
#: zsh.texi:11977
#, no-wrap
msgid "NOPOSIXALIASES"
msgstr "NOPOSIXALIASES"

#. type: item
#: zsh.texi:11978
#, no-wrap
msgid "@t{POSIX_ALIASES} <K> <S>"
msgstr "@t{POSIX_ALIASES} <K> <S>"

#. type: table
#: zsh.texi:11983
msgid ""
"When this option is set, reserved words are not candidates for alias expansion: it is still possible to declare any of them as an alias, but the alias will never be expanded.  Reserved words are described "
"in @ref{Reserved Words}."
msgstr "设置该选项后，保留字将不作为别名扩展的候选字：仍可将其中任何一个声明为别名，但该别名将永远不会被扩展。 保留字在 @ref{保留字} 中有描述。"

#. type: table
#: zsh.texi:11994
msgid ""
"Alias expansion takes place while text is being read; hence when this option is set it does not take effect until the end of any function or other piece of shell code parsed as one unit.  Note this may "
"cause differences from other shells even when the option is in effect.  For example, when running a command with `@t{zsh -c}', or even `@t{zsh -o posixaliases -c}', the entire command argument is parsed "
"as one unit, so aliases defined within the argument are not available even in later lines.  If in doubt, avoid use of aliases in non-interactive code."
msgstr ""
"别名扩展是在读取文本时进行的；因此，当设置了该选项后，直到作为一个单元解析的函数或其他 shell 代码结束时才会生效。 请注意，即使该选项生效，也可能导致与其他 shell 的差异。 例如，当使用 `@t{zsh -c}'，甚至 "
"`@t{zsh -o posixaliases -c}' 运行命令时，整个命令参数会被解析为一个单元，因此在参数中定义的别名即使在后面的行中也无法使用。 如有疑问，请避免在非交互代码中使用别名。"

#. type: t{#1}
#: zsh.texi:11995 zsh.texi:12000
#, no-wrap
msgid "POSIX_ARGZERO"
msgstr "POSIX_ARGZERO"

#. type: pindex
#: zsh.texi:11996
#, no-wrap
msgid "NO_POSIX_ARGZERO"
msgstr "NO_POSIX_ARGZERO"

#. type: pindex
#: zsh.texi:11997
#, no-wrap
msgid "POSIXARGZERO"
msgstr "POSIXARGZERO"

#. type: pindex
#: zsh.texi:11998
#, no-wrap
msgid "NOPOSIXARGZERO"
msgstr "NOPOSIXARGZERO"

#. type: cindex
#: zsh.texi:11999
#, no-wrap
msgid "$0, using"
msgstr "$0, 使用"

#. type: table
#: zsh.texi:12009
msgid ""
"This option may be used to temporarily disable @t{FUNCTION_ARGZERO} and thereby restore the value of @t{$0} to the name used to invoke the shell (or as set by the @t{-c} command line option).  For "
"compatibility with previous versions of the shell, emulations use @t{NO_FUNCTION_ARGZERO} instead of @t{POSIX_ARGZERO}, which may result in unexpected scoping of @t{$0} if the emulation mode is changed "
"inside a function or script.  To avoid this, explicitly enable @t{POSIX_ARGZERO} in the @t{emulate} command:"
msgstr ""
"此选项可用于暂时禁用 @t{FUNCTION_ARGZERO}，从而将 @t{$0} 的值恢复为调用 shell 时使用的名称（或由 @t{-c} 命令行选项设置的名称）。 为了与以前版本的 shell 兼容，仿真会使用 @t{NO_FUNCTION_ARGZERO} 而不是 "
"@t{POSIX_ARGZERO}，如果在函数或脚本中改变仿真模式，可能会导致 @t{$0} 的范围超出预期。 为避免这种情况，请在 @t{emulate} 命令中明确启用 @t{POSIX_ARGZERO}："

#. type: example
#: zsh.texi:12013
#, no-wrap
msgid "emulate sh -o POSIX_ARGZERO\n"
msgstr "emulate sh -o POSIX_ARGZERO\n"

#. type: table
#: zsh.texi:12018
msgid "Note that @t{NO_POSIX_ARGZERO} has no effect unless @t{FUNCTION_ARGZERO} was already enabled upon entry to the function or script."
msgstr "请注意，除非 @t{FUNCTION_ARGZERO} 在进入函数或脚本时已经启用，否则 @t{NO_POSIX_ARGZERO} 不会产生任何影响。"

#. type: pindex
#: zsh.texi:12019
#, no-wrap
msgid "POSIX_BUILTINS"
msgstr "POSIX_BUILTINS"

#. type: pindex
#: zsh.texi:12020
#, no-wrap
msgid "NO_POSIX_BUILTINS"
msgstr "NO_POSIX_BUILTINS"

#. type: pindex
#: zsh.texi:12021
#, no-wrap
msgid "POSIXBUILTINS"
msgstr "POSIXBUILTINS"

#. type: pindex
#: zsh.texi:12022
#, no-wrap
msgid "NOPOSIXBUILTINS"
msgstr "NOPOSIXBUILTINS"

#. type: item
#: zsh.texi:12023
#, no-wrap
msgid "@t{POSIX_BUILTINS} <K> <S>"
msgstr "@t{POSIX_BUILTINS} <K> <S>"

#. type: table
#: zsh.texi:12047
msgid ""
"When this option is set the @t{command} builtin can be used to execute shell builtin commands.  Parameter assignments specified before shell functions and special builtins are kept after the command "
"completes unless the special builtin is prefixed with the @t{command} builtin.  Special builtins are @t{.}, @t{:}, @t{break}, @t{continue}, @t{declare}, @t{eval}, @t{exit}, @t{export}, @t{integer}, "
"@t{local}, @t{readonly}, @t{return}, @t{set}, @t{shift}, @t{source}, @t{times}, @t{trap} and @t{unset}."
msgstr ""
"设置该选项后，@t{command} 内置命令可用于执行 shell 内置命令。 在 shell 函数和特殊内置命令前指定的参数赋值会在命令补全后保留，除非特殊内置命令前缀为 @t{command} 内置命令。 特殊内置命令包括 @t{.}, @t{:}, "
"@t{break}, @t{continue}, @t{declare}, @t{eval}, @t{exit}, @t{export}, @t{integer}, @t{local}, @t{readonly}, @t{return}, @t{set}, @t{shift}, @t{source}, @t{times}, @t{trap} 和 @t{unset}。"

#. type: table
#: zsh.texi:12052
msgid "In addition, various error conditions associated with the above builtins or @t{exec} cause a non-interactive shell to exit and an interactive shell to return to its top-level processing."
msgstr "此外，与上述内置程序或 @t{exec} 相关的各种错误条件会导致非交互式 shell 退出和交互式 shell 返回顶层处理。"

#. type: table
#: zsh.texi:12057
msgid "Furthermore, functions and shell builtins are not executed after an @t{exec} prefix; the command to be executed must be an external command found in the path."
msgstr "此外，函数和 shell 内置命令不会在 @t{exec} 前缀后执行；要执行的命令必须是在路径中找到的外部命令。"

#. type: table
#: zsh.texi:12063
msgid ""
"Furthermore, the @t{getopts} builtin behaves in a POSIX-compatible fashion in that the associated variable @t{OPTIND} is not made local to functions, and its value is calculated differently to match other "
"shells."
msgstr "此外，@t{getopts} 内置命令的行为与 POSIX 兼容，相关变量 @t{OPTIND} 并非函数的本地变量，其值的计算方式也与其他 shell 不同。"

#. type: table
#: zsh.texi:12067
msgid "Moreover, the warning and special exit code from @t{[[ -o }@var{non_existent_option}@t{ ]]} are suppressed."
msgstr "此外， @t{[[ -o }@var{non_existent_option}@t{ ]]} 的警告和特殊退出代码也会被抑制。"

#. type: pindex
#: zsh.texi:12068
#, no-wrap
msgid "POSIX_IDENTIFIERS"
msgstr "POSIX_IDENTIFIERS"

#. type: pindex
#: zsh.texi:12069
#, no-wrap
msgid "NO_POSIX_IDENTIFIERS"
msgstr "NO_POSIX_IDENTIFIERS"

#. type: pindex
#: zsh.texi:12070
#, no-wrap
msgid "POSIXIDENTIFIERS"
msgstr "POSIXIDENTIFIERS"

#. type: pindex
#: zsh.texi:12071
#, no-wrap
msgid "NOPOSIXIDENTIFIERS"
msgstr "NOPOSIXIDENTIFIERS"

#. type: cindex
#: zsh.texi:12072
#, no-wrap
msgid "identifiers, non-portable characters in"
msgstr "标识符, 非可移植字符"

#. type: cindex
#: zsh.texi:12073
#, no-wrap
msgid "parameter names, non-portable characters in"
msgstr "参数名, 非可移植字符"

#. type: item
#: zsh.texi:12074
#, no-wrap
msgid "@t{POSIX_IDENTIFIERS} <K> <S>"
msgstr "@t{POSIX_IDENTIFIERS} <K> <S>"

#. type: table
#: zsh.texi:12078
msgid "When this option is set, only the ASCII characters @t{a} to @t{z}, @t{A} to @t{Z}, @t{0} to @t{9} and @t{_} may be used in identifiers (names of shell parameters and modules)."
msgstr "设置该选项后，标识符（shell 参数和模块的名称）中只能使用 ASCII 字符 @t{a} 至 @t{z}、@t{A} 至 @t{Z}、@t{0} 至 @t{9} 和 @t{_}。"

#. type: table
#: zsh.texi:12086
msgid ""
"In addition, setting this option limits the effect of parameter substitution with no braces, so that the expression @t{$#} is treated as the parameter @t{$#} even if followed by a valid parameter name.  "
"When it is unset, zsh allows expressions of the form @t{$#}@var{name} to refer to the length of @t{$}@var{name}, even for special variables, for example in expressions such as @t{$#-} and @t{$#*}."
msgstr ""
"此外，设置该选项会限制无括号参数替换的效果，因此表达式 @t{$#} 会被视为参数 @t{$#}，即使后面跟了一个有效的参数名。 未设置该选项时，zsh 允许 @t{$#}@var{name} 形式的表达式引用 @t{$}@var{name} 的长度，即使是特"
"殊变量，例如 @t{$#-} 和 @t{$#*} 这样的表达式。"

#. type: table
#: zsh.texi:12093
msgid ""
"Another difference is that with the option set assignment to an unset variable in arithmetic context causes the variable to be created as a scalar rather than a numeric type.  So after `@t{unset t; (( t = "
"3 ))}'. without @t{POSIX_IDENTIFIERS} set @t{t} has integer type, while with it set it has scalar type."
msgstr ""
"另一个区别是，在算术上下文中对未设置变量赋值时，选项设置会导致变量创建为标量而非数值类型。 因此，在 `@t{unset t; (( t = 3 ))}' 之后，如果没有设置 @t{POSIX_IDENTIFIERS} ，@t{t} 将是整数类型，而如果设置了 "
"@t{POSIX_IDENTIFIERS} ，@t{t} 将是标量类型。"

#. type: table
#: zsh.texi:12103
msgid ""
"When the option is unset and multibyte character support is enabled (i.e. it is compiled in and the option @t{MULTIBYTE} is set), then additionally any alphanumeric characters in the local character set "
"may be used in identifiers.  Note that scripts and functions written with this feature are not portable, and also that both options must be set before the script or function is parsed; setting them during "
"execution is not sufficient as the syntax @var{variable}@t{=}@var{value} has already been parsed as a command rather than an assignment."
msgstr ""
"如果未设置该选项，但启用了多字节字符支持（即编译了多字节字符支持并设置了 @t{MULTIBYTE} 选项），则可在标识符中使用本地字符集中的任何字母数字字符。 需要注意的是，使用此功能编写的脚本和函数不可移植，而且必须"
"在解析脚本或函数之前设置这两个选项；在执行过程中设置这两个选项是不够的，因为语法 @var{variable}@t{=}@var{value} 已被解析为命令而非赋值。"

#. type: table
#: zsh.texi:12108
msgid ""
"If multibyte character support is not compiled into the shell this option is ignored; all octets with the top bit set may be used in identifiers.  This is non-standard but is the traditional zsh behaviour."
msgstr "如果 shell 未编译多字节字符支持，该选项将被忽略；所有设置了最高位的八位字节都可用于标识符。 这是非标准的，但却是传统的 zsh 行为。"

#. type: pindex
#: zsh.texi:12109
#, no-wrap
msgid "POSIX_STRINGS"
msgstr "POSIX_STRINGS"

#. type: pindex
#: zsh.texi:12110
#, no-wrap
msgid "NO_POSIX_STRINGS"
msgstr "NO_POSIX_STRINGS"

#. type: pindex
#: zsh.texi:12111
#, no-wrap
msgid "POSIXSTRINGS"
msgstr "POSIXSTRINGS"

#. type: pindex
#: zsh.texi:12112
#, no-wrap
msgid "NOPOSIXSTRINGS"
msgstr "NOPOSIXSTRINGS"

#. type: cindex
#: zsh.texi:12113
#, no-wrap
msgid "discarding embedded nulls in $'...'"
msgstr "摒弃 $'...' 中嵌入的空值"

#. type: cindex
#: zsh.texi:12114
#, no-wrap
msgid "embedded nulls, in $'...'"
msgstr "嵌入的空值, $'...' 中"

#. type: cindex
#: zsh.texi:12115
#, no-wrap
msgid "nulls, embedded in $'...'"
msgstr "空值, 嵌入 $'...'"

#. type: item
#: zsh.texi:12116
#, no-wrap
msgid "@t{POSIX_STRINGS} <K> <S>"
msgstr "@t{POSIX_STRINGS} <K> <S>"

#. type: table
#: zsh.texi:12120
msgid "This option affects processing of quoted strings.  Currently it only affects the behaviour of null characters, i.e. character 0 in the portable character set corresponding to US ASCII."
msgstr "该选项会影响带引号字符串的处理。 目前，它只影响空字符的行为，即对应于 US ASCII 的可移植字符集中的字符 0。"

#. type: table
#: zsh.texi:12128
msgid ""
"When this option is not set, null characters embedded within strings of the form @t{$'}@var{...}@t{'} are treated as ordinary characters. The entire string is maintained within the shell and output to "
"files where necessary, although owing to restrictions of the library interface the string is truncated at the null character in file names, environment variables, or in arguments to external programs."
msgstr ""
"如果不设置该选项，嵌入  @t{$'}@var{...}@t{'} 格式字符串中的空字符将被视为普通字符。整个字符串将保留在 shell 中，并在必要时输出到文件中，但由于库接口的限制，字符串会在文件名、环境变量或外部程序参数中的空字"
"符处被截断。"

#. type: table
#: zsh.texi:12133
msgid "When this option is set, the @t{$'}@var{...}@t{'} expression is truncated at the null character.  Note that remaining parts of the same string beyond the termination of the quotes are not truncated."
msgstr "设置该选项后， @t{$'}@var{...}@t{'} 表达式将在空字符处截断。 请注意，同一字符串中引号结束后的其余部分不会被截断。"

#. type: table
#: zsh.texi:12138
msgid "For example, the command line argument @t{a$'b\\0c'd} is treated with the option off as the characters @t{a}, @t{b}, null, @t{c}, @t{d}, and with the option on as the characters @t{a}, @t{b}, @t{d}."
msgstr "例如，命令行参数  @t{a$'b\\0c'd}  在选项关闭的情况下被视为 @t{a}、@t{b}、null、@t{c}、@t{d} 字符，而在选项开启的情况下被视为 @t{a}、@t{b}、@t{d} 字符。"

#. type: pindex
#: zsh.texi:12139
#, no-wrap
msgid "POSIX_TRAPS"
msgstr "POSIX_TRAPS"

#. type: pindex
#: zsh.texi:12140
#, no-wrap
msgid "NO_POSIX_TRAPS"
msgstr "NO_POSIX_TRAPS"

#. type: pindex
#: zsh.texi:12141
#, no-wrap
msgid "POSIXTRAPS"
msgstr "POSIXTRAPS"

#. type: pindex
#: zsh.texi:12142
#, no-wrap
msgid "NOPOSIXTRAPS"
msgstr "NOPOSIXTRAPS"

#. type: cindex
#: zsh.texi:12143
#, no-wrap
msgid "traps, on function exit"
msgstr "陷井, 函数退出时"

#. type: cindex
#: zsh.texi:12144
#, no-wrap
msgid "traps, POSIX compatibility"
msgstr "陷井, POSIX 兼容性"

#. type: item
#: zsh.texi:12145
#, no-wrap
msgid "@t{POSIX_TRAPS} <K> <S>"
msgstr "@t{POSIX_TRAPS} <K> <S>"

#. type: table
#: zsh.texi:12151
msgid ""
"When this option is set, the usual zsh behaviour of executing traps for @t{EXIT} on exit from shell functions is suppressed.  In that case, manipulating @t{EXIT} traps always alters the global trap for "
"exiting the shell; the @t{LOCAL_TRAPS} option is ignored for the @t{EXIT} trap."
msgstr ""
"设置此选项后，zsh 通常在退出 shell 函数时执行 @t{EXIT} 陷阱的行为将被抑制。 在这种情况下，对 @t{EXIT} 陷阱的操作总是会改变用于退出 shell 的全局陷阱；对于 @t{EXIT} 陷阱，@t{LOCAL_TRAPS} 选项会被忽略。"

#. type: table
#: zsh.texi:12156
msgid "Also, a @t{return} statement executed in a trap with no argument passes back from the function the value from the surrounding context, not from code executed within the trap."
msgstr "此外，在没有参数的陷阱中执行 @t{return} 语句时，函数会传回周围上下文的值，而不是陷阱中执行的代码的值。"

#. type: table
#: zsh.texi:12161
msgid "Furthermore, if a trap is set to be ignored, this state persists when a subshell is entered.  Without the option, the trap would be reset to its default state at this point."
msgstr "此外，如果陷阱被设置为忽略，那么当进入子 shell 时，这种状态会持续存在。 如果没有该选项，陷阱此时会重置为默认状态。"

#. type: pindex
#: zsh.texi:12162
#, no-wrap
msgid "SH_FILE_EXPANSION"
msgstr "SH_FILE_EXPANSION"

#. type: pindex
#: zsh.texi:12163
#, no-wrap
msgid "NO_SH_FILE_EXPANSION"
msgstr "NO_SH_FILE_EXPANSION"

#. type: pindex
#: zsh.texi:12164
#, no-wrap
msgid "SHFILEEXPANSION"
msgstr "SHFILEEXPANSION"

#. type: pindex
#: zsh.texi:12165
#, no-wrap
msgid "NOSHFILEEXPANSION"
msgstr "NOSHFILEEXPANSION"

#. type: cindex
#: zsh.texi:12166
#, no-wrap
msgid "sh, expansion style"
msgstr "sh, 扩展风格"

#. type: cindex
#: zsh.texi:12167
#, no-wrap
msgid "expansion style, sh"
msgstr "扩展风格, sh"

#. type: item
#: zsh.texi:12168
#, no-wrap
msgid "@t{SH_FILE_EXPANSION} <K> <S>"
msgstr "@t{SH_FILE_EXPANSION} <K> <S>"

#. type: table
#: zsh.texi:12175
msgid ""
"Perform filename expansion (e.g., @t{~} expansion) @emph{before} parameter expansion, command substitution, arithmetic expansion and brace expansion.  If this option is unset, it is performed @emph{after} "
"brace expansion, so things like `@t{~$USERNAME}' and `@t{~@{pfalstad,rc@}}' will work."
msgstr ""
"在参数扩展、命令替换、算术扩展和括号扩展@emph{之前}，执行文件名扩展（例如 @t{~} 扩展） 。 如果未设置该选项，则在括号扩展 @emph{之后}执行，因此类似于 `@t{~$USERNAME}'  和`@t{~@{pfalstad,rc@}}' 将正常工作。"

#. type: pindex
#: zsh.texi:12176
#, no-wrap
msgid "SH_NULLCMD"
msgstr "SH_NULLCMD"

#. type: pindex
#: zsh.texi:12177
#, no-wrap
msgid "NO_SH_NULLCMD"
msgstr "NO_SH_NULLCMD"

#. type: pindex
#: zsh.texi:12178
#, no-wrap
msgid "SHNULLCMD"
msgstr "SHNULLCMD"

#. type: pindex
#: zsh.texi:12179
#, no-wrap
msgid "NOSHNULLCMD"
msgstr "NOSHNULLCMD"

#. type: cindex
#: zsh.texi:12182
#, no-wrap
msgid "sh, redirections with no command"
msgstr "sh, 没有命令的重定向"

#. type: cindex
#: zsh.texi:12183
#, no-wrap
msgid "ksh, redirections with no command"
msgstr "ksh, 没有命令的重定向"

#. type: cindex
#: zsh.texi:12184
#, no-wrap
msgid "redirections with no command, sh"
msgstr "没有命令的重定向, sh"

#. type: cindex
#: zsh.texi:12185
#, no-wrap
msgid "redirections with no command, ksh"
msgstr "没有命令的重定向, ksh"

#. type: item
#: zsh.texi:12186
#, no-wrap
msgid "@t{SH_NULLCMD} <K> <S>"
msgstr "@t{SH_NULLCMD} <K> <S>"

#. type: table
#: zsh.texi:12189
msgid "Do not use the values of @t{NULLCMD} and @t{READNULLCMD} when doing redirections, use `@t{:}' instead (see @ref{Redirection})."
msgstr "重定向时，请勿使用 @t{NULLCMD} 和 @t{READNULLCMD} 的值，而应使用 `@t{:}'（请参阅 @ref{重定向}）。"

#. type: pindex
#: zsh.texi:12190
#, no-wrap
msgid "SH_OPTION_LETTERS"
msgstr "SH_OPTION_LETTERS"

#. type: pindex
#: zsh.texi:12191
#, no-wrap
msgid "NO_SH_OPTION_LETTERS"
msgstr "NO_SH_OPTION_LETTERS"

#. type: pindex
#: zsh.texi:12192
#, no-wrap
msgid "SHOPTIONLETTERS"
msgstr "SHOPTIONLETTERS"

#. type: pindex
#: zsh.texi:12193
#, no-wrap
msgid "NOSHOPTIONLETTERS"
msgstr "NOSHOPTIONLETTERS"

#. type: cindex
#: zsh.texi:12194
#, no-wrap
msgid "sh, single letter options style"
msgstr "sh, 单字母选项风格"

#. type: cindex
#: zsh.texi:12195
#, no-wrap
msgid "ksh, single letter options style"
msgstr "ksh, 单字母选项风格"

#. type: cindex
#: zsh.texi:12196
#, no-wrap
msgid "single letter options, ksh style"
msgstr "单字母选项, ksh 风格"

#. type: cindex
#: zsh.texi:12197
#, no-wrap
msgid "options, single letter, ksh style"
msgstr "选项, 单字母, ksh 风格"

#. type: item
#: zsh.texi:12198
#, no-wrap
msgid "@t{SH_OPTION_LETTERS} <K> <S>"
msgstr "@t{SH_OPTION_LETTERS} <K> <S>"

#. type: table
#: zsh.texi:12202
msgid ""
"If this option is set the shell tries to interpret single letter options (which are used with @t{set} and @t{setopt}) like @cite{ksh} does.  This also affects the value of the @t{-} special parameter."
msgstr "如果设置了该选项，shell 会尝试像 @cite{ksh} 那样解释单字母选项（与 @t{set} 和 @t{setopt} 一起使用）。 这也会影响 @t{-} 特殊参数的值。"

#. type: table
#: zsh.texi:12203 zsh.texi:12651
#, no-wrap
msgid "SH_WORD_SPLIT"
msgstr "SH_WORD_SPLIT"

#. type: pindex
#: zsh.texi:12204
#, no-wrap
msgid "NO_SH_WORD_SPLIT"
msgstr "NO_SH_WORD_SPLIT"

#. type: pindex
#: zsh.texi:12205
#, no-wrap
msgid "SHWORDSPLIT"
msgstr "SHWORDSPLIT"

#. type: pindex
#: zsh.texi:12206
#, no-wrap
msgid "NOSHWORDSPLIT"
msgstr "NOSHWORDSPLIT"

#. type: cindex
#: zsh.texi:12207
#, no-wrap
msgid "field splitting, sh style"
msgstr "字段分割, sh 风格"

#. type: cindex
#: zsh.texi:12208
#, no-wrap
msgid "sh, field splitting style"
msgstr "sh, 字段分割风格"

#. type: item
#: zsh.texi:12209
#, no-wrap
msgid "@t{SH_WORD_SPLIT} (@t{-y}) <K> <S>"
msgstr "@t{SH_WORD_SPLIT} (@t{-y}) <K> <S>"

#. type: table
#: zsh.texi:12214
msgid "Causes field splitting to be performed on unquoted parameter expansions.  Note that this option has nothing to do with word splitting.  (See @ref{Parameter Expansion}.)"
msgstr "使字段分割在无引号的参数扩展上执行。 请注意，此选项与分词无关。 (参见 @ref{参数扩展}）。"

#. type: table
#: zsh.texi:12215 zsh.texi:12220 zsh.texi:12660
#, no-wrap
msgid "TRAPS_ASYNC"
msgstr "TRAPS_ASYNC"

#. type: pindex
#: zsh.texi:12216
#, no-wrap
msgid "NO_TRAPS_ASYNC"
msgstr "NO_TRAPS_ASYNC"

#. type: pindex
#: zsh.texi:12217
#, no-wrap
msgid "TRAPSASYNC"
msgstr "TRAPSASYNC"

#. type: pindex
#: zsh.texi:12218
#, no-wrap
msgid "NOTRAPSASYNC"
msgstr "NOTRAPSASYNC"

#. type: cindex
#: zsh.texi:12219
#, no-wrap
msgid "traps, asynchronous"
msgstr "陷井, 异步"

#. type: table
#: zsh.texi:12225
msgid ""
"While waiting for a program to exit, handle signals and run traps immediately.  Otherwise the trap is run after a child process has exited.  Note this does not affect the point at which traps are run for "
"any case other than when the shell is waiting for a child process."
msgstr "在等待程序退出时，应立即处理信号和运行陷阱。 否则，陷阱将在子进程退出后运行。 请注意，除了 shell 等待子进程外，这不会影响运行陷阱的时间点。"

#. type: subsection
#: zsh.texi:12230
#, no-wrap
msgid "Shell State"
msgstr "Shell 状态"

#. type: table
#: zsh.texi:12233 zsh.texi:12625 zsh.texi:12672
#, no-wrap
msgid "INTERACTIVE"
msgstr "INTERACTIVE"

#. type: pindex
#: zsh.texi:12234
#, no-wrap
msgid "NO_INTERACTIVE"
msgstr "NO_INTERACTIVE"

#. type: pindex
#: zsh.texi:12235
#, no-wrap
msgid "NOINTERACTIVE"
msgstr "NOINTERACTIVE"

#. type: item
#: zsh.texi:12236
#, no-wrap
msgid "@t{INTERACTIVE} (@t{-i}, ksh: @t{-i})"
msgstr "@t{INTERACTIVE} (@t{-i}, ksh: @t{-i})"

#. type: table
#: zsh.texi:12245
msgid ""
"This is an interactive shell.  This option is set upon initialisation if the standard input is a tty and commands are being read from standard input.  (See the discussion of @t{SHIN_STDIN}.)  This "
"heuristic may be overridden by specifying a state for this option on the command line.  The value of this option can only be changed via flags supplied at invocation of the shell.  It cannot be changed "
"once zsh is running."
msgstr ""
"这是一个交互式 shell。 如果标准输入是 tty 且命令是从标准输入读取的，则初始化时会设置该选项（参见 @t{SHIN_STDIN} 的讨论）。可以通过在命令行中指定该选项的状态来覆盖这一启发式方法。 该选项的值只能通过调用 "
"shell 时提供的标志来更改。 zsh 运行后就无法更改。"

#. type: table
#: zsh.texi:12246 zsh.texi:12629 zsh.texi:12674
#, no-wrap
msgid "LOGIN"
msgstr "LOGIN"

#. type: pindex
#: zsh.texi:12247
#, no-wrap
msgid "NO_LOGIN"
msgstr "NO_LOGIN"

#. type: pindex
#: zsh.texi:12248
#, no-wrap
msgid "NOLOGIN"
msgstr "NOLOGIN"

#. type: item
#: zsh.texi:12249
#, no-wrap
msgid "@t{LOGIN} (@t{-l}, ksh: @t{-l})"
msgstr "@t{LOGIN} (@t{-l}, ksh: @t{-l})"

#. type: table
#: zsh.texi:12253
msgid "This is a login shell.  If this option is not explicitly set, the shell becomes a login shell if the first character of the @t{argv[0]} passed to the shell is a `@t{-}'."
msgstr "这是一个登录 shell。 如果未明确设置此选项，则如果传给 shell 的 @t{argv[0]} 第一个字符是 `@t{-}'，则 shell 将成为登录 shell。"

#. type: table
#: zsh.texi:12254 zsh.texi:12635 zsh.texi:12680
#, no-wrap
msgid "PRIVILEGED"
msgstr "PRIVILEGED"

#. type: pindex
#: zsh.texi:12255
#, no-wrap
msgid "NO_PRIVILEGED"
msgstr "NO_PRIVILEGED"

#. type: pindex
#: zsh.texi:12256
#, no-wrap
msgid "NOPRIVILEGED"
msgstr "NOPRIVILEGED"

#. type: cindex
#: zsh.texi:12257
#, no-wrap
msgid "privileged mode"
msgstr "特权模式"

#. type: cindex
#: zsh.texi:12258
#, no-wrap
msgid "mode, privileged"
msgstr "模式, 特权"

#. type: item
#: zsh.texi:12259
#, no-wrap
msgid "@t{PRIVILEGED} (@t{-p}, ksh: @t{-p})"
msgstr "@t{PRIVILEGED} (@t{-p}, ksh: @t{-p})"

#. type: table
#: zsh.texi:12263
msgid ""
"Turn on privileged mode. Typically this is used when script is to be run with elevated privileges. This should be done as follows directly with the @t{-p} option to zsh so that it takes effect during "
"startup."
msgstr "开启特权模式。通常情况下，当脚本需要以提升的权限运行时会用到。具体操作如下：直接使用 zsh 的 @t{-p} 选项，使其在启动时生效。"

#. type: example
#: zsh.texi:12267
#, no-wrap
msgid "#!/bin/zsh -p\n"
msgstr "#!/bin/zsh -p\n"

#. type: table
#: zsh.texi:12276
msgid ""
"The option is enabled automatically on startup if the effective user (group) ID is not equal to the real user (group) ID. In this case, turning the option off causes the effective user and group IDs to be "
"set to the real user and group IDs. Be aware that if that fails the shell may be running with different IDs than was intended so a script should check for failure and act accordingly, for example:"
msgstr ""
"如果有效用户（组）ID 不等于真实用户（组）ID，则启动时会自动启用该选项。在这种情况下，关闭该选项会将有效用户和组 ID 设置为真实用户和组 ID。需要注意的是，如果该选项失效，shell 运行时的 ID 可能与预期不同，因"
"此脚本应检查是否失效并采取相应措施："

#. type: example
#: zsh.texi:12280
#, no-wrap
msgid "unsetopt privileged || exit\n"
msgstr "unsetopt privileged || exit\n"

#. type: table
#: zsh.texi:12291
msgid ""
"The @t{PRIVILEGED} option disables sourcing user startup files.  If zsh is invoked as `@t{sh}' or `@t{ksh}' with this option set, @t{/etc/suid_profile} is sourced (after @t{/etc/profile} on interactive "
"shells). Sourcing @t{~/.profile} is disabled and the contents of the @t{ENV} variable is ignored. This option cannot be changed using the @t{-m} option of @t{setopt} and @t{unsetopt}, and changing it "
"inside a function always changes it globally regardless of the @t{LOCAL_OPTIONS} option."
msgstr ""
"@t{PRIVILEGED} 选项禁止引入用户启动文件。 如果在设置了该选项后以 `@t{sh}' 或 `@t{ksh}' 的方式调用 zsh，则会引入 @t{/etc/suid_profile}（在交互式 shell 中位于 @t{/etc/profile} 之后）。@t{~/.profile} 将禁止引"
"入，并且 @t{ENV} 变量的内容将被忽略。使用 @t{setopt} 和 @t{unsetopt} 的 @t{-m} 选项无法更改该选项，在函数内部更改该选项时，无论是否使用 @t{LOCAL_OPTIONS} 选项，都会全局更改该选项。"

#. type: pindex
#: zsh.texi:12293
#, no-wrap
msgid "NO_RESTRICTED"
msgstr "NO_RESTRICTED"

#. type: pindex
#: zsh.texi:12294
#, no-wrap
msgid "NORESTRICTED"
msgstr "NORESTRICTED"

#. type: item
#: zsh.texi:12296
#, no-wrap
msgid "@t{RESTRICTED} (@t{-r})"
msgstr "@t{RESTRICTED} (@t{-r})"

#. type: table
#: zsh.texi:12301
msgid ""
"Enables restricted mode.  This option cannot be changed using @t{unsetopt}, and setting it inside a function always changes it globally regardless of the @t{LOCAL_OPTIONS} option.  See @ref{Restricted "
"Shell}."
msgstr "启用受限模式。 使用 @t{unsetopt} 无法更改此选项，在函数中设置此选项时，无论是否使用 @t{LOCAL_OPTIONS} 选项，都会全局更改此选项。 参见 @ref{受限的 Shell}。"

#. type: table
#: zsh.texi:12302 zsh.texi:12639 zsh.texi:12684
#, no-wrap
msgid "SHIN_STDIN"
msgstr "SHIN_STDIN"

#. type: pindex
#: zsh.texi:12303
#, no-wrap
msgid "NO_SHIN_STDIN"
msgstr "NO_SHIN_STDIN"

#. type: pindex
#: zsh.texi:12304
#, no-wrap
msgid "SHINSTDIN"
msgstr "SHINSTDIN"

#. type: pindex
#: zsh.texi:12305
#, no-wrap
msgid "NOSHINSTDIN"
msgstr "NOSHINSTDIN"

#. type: item
#: zsh.texi:12306
#, no-wrap
msgid "@t{SHIN_STDIN} (@t{-s}, ksh: @t{-s})"
msgstr "@t{SHIN_STDIN} (@t{-s}, ksh: @t{-s})"

#. type: table
#: zsh.texi:12321
msgid ""
"Commands are being read from the standard input.  Commands are read from standard input if no command is specified with @t{-c} and no file of commands is specified.  If @t{SHIN_STDIN} is set explicitly on "
"the command line, any argument that would otherwise have been taken as a file to run will instead be treated as a normal positional parameter.  Note that setting or unsetting this option on the command "
"line does not necessarily affect the state the option will have while the shell is running - that is purely an indicator of whether or not commands are @emph{actually} being read from standard input.  The "
"value of this option can only be changed via flags supplied at invocation of the shell.  It cannot be changed once zsh is running."
msgstr ""
"从标准输入端读取命令。 如果没有使用 @t{-c} 指定命令，也没有指定命令文件，则会从标准输入端读取命令。 如果在命令行中明确设置了 @t{SHIN_STDIN}，任何本应作为运行文件的参数都将被视为普通位置参数。 需要注意的"
"是，在命令行中设置或取消此选项，并不一定会影响 shell 运行时该选项的状态--这纯粹是一个指标，表明命令是否 @emph{真的} 从标准输入端读取。 该选项的值只能通过调用 shell 时提供的标志来更改。 zsh 运行后将无法更"
"改。"

#. type: table
#: zsh.texi:12322 zsh.texi:12641 zsh.texi:12686
#, no-wrap
msgid "SINGLE_COMMAND"
msgstr "SINGLE_COMMAND"

#. type: pindex
#: zsh.texi:12323
#, no-wrap
msgid "NO_SINGLE_COMMAND"
msgstr "NO_SINGLE_COMMAND"

#. type: pindex
#: zsh.texi:12324
#, no-wrap
msgid "SINGLECOMMAND"
msgstr "SINGLECOMMAND"

#. type: pindex
#: zsh.texi:12325
#, no-wrap
msgid "NOSINGLECOMMAND"
msgstr "NOSINGLECOMMAND"

#. type: cindex
#: zsh.texi:12326
#, no-wrap
msgid "single command"
msgstr "单一命令"

#. type: pindex
#: zsh.texi:12327
#, no-wrap
msgid "INTERACTIVE, use of"
msgstr "INTERACTIVE, use of"

#. type: item
#: zsh.texi:12328
#, no-wrap
msgid "@t{SINGLE_COMMAND} (@t{-t}, ksh: @t{-t})"
msgstr "@t{SINGLE_COMMAND} (@t{-t}, ksh: @t{-t})"

#. type: table
#: zsh.texi:12335
msgid ""
"If the shell is reading from standard input, it exits after a single command has been executed.  This also makes the shell non-interactive, unless the @t{INTERACTIVE} option is explicitly set on the "
"command line.  The value of this option can only be changed via flags supplied at invocation of the shell.  It cannot be changed once zsh is running."
msgstr ""
"如果 shell 从标准输入读取数据，则会在执行完一条命令后退出。 除非在命令行中明确设置 @t{INTERACTIVE} 选项，否则 shell 是非交互的。 该选项的值只能通过调用 shell 时提供的标志来更改。 zsh 运行后将无法更改。"

#. type: subsection
#: zsh.texi:12340
#, no-wrap
msgid "Zle"
msgstr "Zle"

#. type: pindex
#: zsh.texi:12343
#, no-wrap
msgid "BEEP"
msgstr "BEEP"

#. type: pindex
#: zsh.texi:12344
#, no-wrap
msgid "NO_BEEP"
msgstr "NO_BEEP"

#. type: pindex
#: zsh.texi:12345
#, no-wrap
msgid "NOBEEP"
msgstr "NOBEEP"

#. type: cindex
#: zsh.texi:12346
#, no-wrap
msgid "beep, enabling"
msgstr "蜂鸣器, 启用"

#. type: cindex
#: zsh.texi:12347
#, no-wrap
msgid "enabling the beep"
msgstr "启用蜂鸣器"

#. type: item
#: zsh.texi:12348
#, no-wrap
msgid "@t{BEEP} (@t{+B}) <D>"
msgstr "@t{BEEP} (@t{+B}) <D>"

#. type: table
#: zsh.texi:12350
msgid "Beep on error in ZLE."
msgstr "ZLE 出错时发出蜂鸣声。"

#. type: t{#1}
#: zsh.texi:12351 zsh.texi:12358
#, no-wrap
msgid "COMBINING_CHARS"
msgstr "COMBINING_CHARS"

#. type: pindex
#: zsh.texi:12352
#, no-wrap
msgid "NO_COMBINING_CHARS"
msgstr "NO_COMBINING_CHARS"

#. type: pindex
#: zsh.texi:12353
#, no-wrap
msgid "COMBININGCHARS"
msgstr "COMBININGCHARS"

#. type: pindex
#: zsh.texi:12354
#, no-wrap
msgid "NOCOMBININGCHARS"
msgstr "NOCOMBININGCHARS"

#. type: cindex
#: zsh.texi:12355
#, no-wrap
msgid "characters, (Unicode) combining"
msgstr "字符, (Unicode) 组合"

#. type: cindex
#: zsh.texi:12356
#, no-wrap
msgid "combining characters (Unicode)"
msgstr "组合字符(Unicode)"

#. type: cindex
#: zsh.texi:12357
#, no-wrap
msgid "Unicode combining characters"
msgstr "Unicode 组合字符"

#. type: table
#: zsh.texi:12366
msgid ""
"Assume that the terminal displays combining characters correctly.  Specifically, if a base alphanumeric character is followed by one or more zero-width punctuation characters, assume that the zero-width "
"characters will be displayed as modifications to the base character within the same width.  Not all terminals handle this.  If this option is not set, zero-width characters are displayed separately with "
"special mark-up."
msgstr ""
"假设终端能正确显示组合字符。 具体来说，如果一个基本字母数字字符后面有一个或多个零宽度标点符号字符，则假定零宽度字符将显示为在相同宽度内对基本字符的修改。 并非所有终端都会这样处理。 如果不设置此选项，零宽度"
"字符将以特殊标记单独显示。"

#. type: table
#: zsh.texi:12372
msgid ""
"If this option is set, the pattern test @t{[[:WORD:]]} matches a zero-width punctuation character on the assumption that it will be used as part of a word in combination with a word character.  Otherwise "
"the base shell does not handle combining characters specially."
msgstr "如果设置了该选项，则模式测试 @t{[[:WORD:]]}  将匹配零宽度标点符号，前提是该字符将作为单词的一部分与单词字符结合使用。 否则，基本 shell 不会特别处理组合字符。"

#. type: t{#1}
#: zsh.texi:12373 zsh.texi:12376
#, no-wrap
msgid "EMACS"
msgstr "EMACS"

#. type: pindex
#: zsh.texi:12374
#, no-wrap
msgid "NO_EMACS"
msgstr "NO_EMACS"

#. type: pindex
#: zsh.texi:12375
#, no-wrap
msgid "NOEMACS"
msgstr "NOEMACS"

#. type: table
#: zsh.texi:12382
msgid ""
"If ZLE is loaded, turning on this option has the equivalent effect of `@t{bindkey -e}'.  In addition, the VI option is unset.  Turning it off has no effect.  The option setting is not guaranteed to "
"reflect the current keymap.  This option is provided for compatibility; @t{bindkey} is the recommended interface."
msgstr "如果已加载 ZLE，则打开该选项的效果等同于 `@t{bindkey -e}'。 此外，VI 选项是未设置的。 关闭该选项没有任何效果。 该选项的设置不能保证反映当前的键映射。 提供该选项是为了兼容；@t{bindkey} 是推荐的接口。"

#. type: t{#1}
#: zsh.texi:12383 zsh.texi:12388
#, no-wrap
msgid "OVERSTRIKE"
msgstr "OVERSTRIKE"

#. type: pindex
#: zsh.texi:12384
#, no-wrap
msgid "NO_OVERSTRIKE"
msgstr "NO_OVERSTRIKE"

#. type: pindex
#: zsh.texi:12385
#, no-wrap
msgid "NOOVERSTRIKE"
msgstr "NOOVERSTRIKE"

#. type: cindex
#: zsh.texi:12386
#, no-wrap
msgid "editor, overstrike mode"
msgstr "编辑器, 叠加模式"

#. type: cindex
#: zsh.texi:12387
#, no-wrap
msgid "overstrike mode, of editor"
msgstr "叠加模式, 编辑器的"

#. type: table
#: zsh.texi:12390
msgid "Start up the line editor in overstrike mode."
msgstr "以叠加模式启动行编辑器。"

#. type: table
#: zsh.texi:12391 zsh.texi:12587
#, no-wrap
msgid "SINGLE_LINE_ZLE"
msgstr "SINGLE_LINE_ZLE"

#. type: pindex
#: zsh.texi:12392
#, no-wrap
msgid "NO_SINGLE_LINE_ZLE"
msgstr "NO_SINGLE_LINE_ZLE"

#. type: pindex
#: zsh.texi:12393
#, no-wrap
msgid "SINGLELINEZLE"
msgstr "SINGLELINEZLE"

#. type: pindex
#: zsh.texi:12394
#, no-wrap
msgid "NOSINGLELINEZLE"
msgstr "NOSINGLELINEZLE"

#. type: cindex
#: zsh.texi:12395
#, no-wrap
msgid "editor, single line mode"
msgstr "编辑器, 单行模式"

#. type: item
#: zsh.texi:12396
#, no-wrap
msgid "@t{SINGLE_LINE_ZLE} (@t{-M}) <K>"
msgstr "@t{SINGLE_LINE_ZLE} (@t{-M}) <K>"

#. type: table
#: zsh.texi:12398
msgid "Use single-line command line editing instead of multi-line."
msgstr "使用单行命令行编辑，而不是多行编辑。"

#. type: table
#: zsh.texi:12405
msgid ""
"Note that although this is on by default in ksh emulation it only provides superficial compatibility with the ksh line editor and reduces the effectiveness of the zsh line editor.  As it has no effect on "
"shell syntax, many users may wish to disable this option when using ksh emulation interactively."
msgstr "请注意，尽管在 ksh 模拟中该选项是默认开启的，但它仅提供了与 ksh 行编辑器的表面兼容性，并降低了 zsh 行编辑器的有效性。 由于它对 shell 语法没有影响，许多用户可能希望在交互式使用 ksh 模拟时禁用该选项。"

#. type: t{#1}
#: zsh.texi:12406 zsh.texi:12409
#, no-wrap
msgid "VI"
msgstr "VI"

#. type: pindex
#: zsh.texi:12407
#, no-wrap
msgid "NO_VI"
msgstr "NO_VI"

#. type: pindex
#: zsh.texi:12408
#, no-wrap
msgid "NOVI"
msgstr "NOVI"

#. type: table
#: zsh.texi:12415
msgid ""
"If ZLE is loaded, turning on this option has the equivalent effect of `@t{bindkey -v}'.  In addition, the EMACS option is unset.  Turning it off has no effect.  The option setting is not guaranteed to "
"reflect the current keymap.  This option is provided for compatibility; @t{bindkey} is the recommended interface."
msgstr "如果已加载 ZLE，则打开该选项的效果等同于 `@t{bindkey -v}'。 此外，EMACS 选项未设置。 关闭该选项没有任何效果。 选项设置并不能保证反映当前的键映射。 提供此选项是为了兼容；@t{bindkey} 是推荐的接口。"

#. type: cindex
#: zsh.texi:12416 zsh.texi:12613 zsh.texi:16085
#, no-wrap
msgid "ZLE"
msgstr "ZLE"

#. type: pindex
#: zsh.texi:12417
#, no-wrap
msgid "NO_ZLE"
msgstr "NO_ZLE"

#. type: pindex
#: zsh.texi:12418
#, no-wrap
msgid "NOZLE"
msgstr "NOZLE"

#. type: cindex
#: zsh.texi:12419
#, no-wrap
msgid "editor, enabling"
msgstr "编辑器, 启用"

#. type: cindex
#: zsh.texi:12420
#, no-wrap
msgid "enabling the editor"
msgstr "启用编辑器"

#. type: item
#: zsh.texi:12421
#, no-wrap
msgid "@t{ZLE} (@t{-Z})"
msgstr "@t{ZLE} (@t{-Z})"

#. type: table
#: zsh.texi:12424
msgid "Use the zsh line editor.  Set by default in interactive shells connected to a terminal."
msgstr "使用 zsh 行编辑器。 在连接到终端的交互式 shell 中默认设置。"

#. type: cindex
#: zsh.texi:12432
#, no-wrap
msgid "options, aliases"
msgstr "选项, 别名"

#. type: Plain text
#: zsh.texi:12436
msgid "Some options have alternative names.  These aliases are never used for output, but can be used just like normal option names when specifying options to the shell."
msgstr "有些选项有别名。 这些别名从不用于输出，但在向 shell 指定选项时，可以像普通选项名一样使用。"

#. type: t{#1}
#: zsh.texi:12439 zsh.texi:12443
#, no-wrap
msgid "BRACE_EXPAND"
msgstr "BRACE_EXPAND"

#. type: pindex
#: zsh.texi:12440
#, no-wrap
msgid "NO_BRACE_EXPAND"
msgstr "NO_BRACE_EXPAND"

#. type: pindex
#: zsh.texi:12441
#, no-wrap
msgid "BRACEEXPAND"
msgstr "BRACEEXPAND"

#. type: pindex
#: zsh.texi:12442
#, no-wrap
msgid "NOBRACEEXPAND"
msgstr "NOBRACEEXPAND"

#. type: table
#: zsh.texi:12446
msgid "@emph{NO_}@t{IGNORE_BRACES} (ksh and bash compatibility)"
msgstr "@emph{NO_}@t{IGNORE_BRACES} (ksh 和 bash 兼容性)"

#. type: t{#1}
#: zsh.texi:12447 zsh.texi:12451
#, no-wrap
msgid "DOT_GLOB"
msgstr "DOT_GLOB"

#. type: pindex
#: zsh.texi:12448
#, no-wrap
msgid "NO_DOT_GLOB"
msgstr "NO_DOT_GLOB"

#. type: pindex
#: zsh.texi:12449
#, no-wrap
msgid "DOTGLOB"
msgstr "DOTGLOB"

#. type: pindex
#: zsh.texi:12450
#, no-wrap
msgid "NODOTGLOB"
msgstr "NODOTGLOB"

#. type: table
#: zsh.texi:12454
msgid "@t{GLOB_DOTS} (bash compatibility)"
msgstr "@t{GLOB_DOTS} (bash 兼容性)"

#. type: t{#1}
#: zsh.texi:12455 zsh.texi:12459
#, no-wrap
msgid "HASH_ALL"
msgstr "HASH_ALL"

#. type: pindex
#: zsh.texi:12456
#, no-wrap
msgid "NO_HASH_ALL"
msgstr "NO_HASH_ALL"

#. type: pindex
#: zsh.texi:12457
#, no-wrap
msgid "HASHALL"
msgstr "HASHALL"

#. type: pindex
#: zsh.texi:12458
#, no-wrap
msgid "NOHASHALL"
msgstr "NOHASHALL"

#. type: table
#: zsh.texi:12462
msgid "@t{HASH_CMDS} (bash compatibility)"
msgstr "@t{HASH_CMDS} (bash 兼容性)"

#. type: t{#1}
#: zsh.texi:12463 zsh.texi:12467
#, no-wrap
msgid "HIST_APPEND"
msgstr "HIST_APPEND"

#. type: pindex
#: zsh.texi:12464
#, no-wrap
msgid "NO_HIST_APPEND"
msgstr "NO_HIST_APPEND"

#. type: pindex
#: zsh.texi:12465
#, no-wrap
msgid "HISTAPPEND"
msgstr "HISTAPPEND"

#. type: pindex
#: zsh.texi:12466
#, no-wrap
msgid "NOHISTAPPEND"
msgstr "NOHISTAPPEND"

#. type: table
#: zsh.texi:12470
msgid "@t{APPEND_HISTORY} (bash compatibility)"
msgstr "@t{APPEND_HISTORY} (bash 兼容性)"

#. type: t{#1}
#: zsh.texi:12471 zsh.texi:12475
#, no-wrap
msgid "HIST_EXPAND"
msgstr "HIST_EXPAND"

#. type: pindex
#: zsh.texi:12472
#, no-wrap
msgid "NO_HIST_EXPAND"
msgstr "NO_HIST_EXPAND"

#. type: pindex
#: zsh.texi:12473
#, no-wrap
msgid "HISTEXPAND"
msgstr "HISTEXPAND"

#. type: pindex
#: zsh.texi:12474
#, no-wrap
msgid "NOHISTEXPAND"
msgstr "NOHISTEXPAND"

#. type: table
#: zsh.texi:12478
msgid "@t{BANG_HIST} (bash compatibility)"
msgstr "@t{BANG_HIST} (bash 兼容性)"

#. type: t{#1}
#: zsh.texi:12479 zsh.texi:12482
#, no-wrap
msgid "LOG"
msgstr "LOG"

#. type: pindex
#: zsh.texi:12480
#, no-wrap
msgid "NO_LOG"
msgstr "NO_LOG"

#. type: pindex
#: zsh.texi:12481
#, no-wrap
msgid "NOLOG"
msgstr "NOLOG"

#. type: table
#: zsh.texi:12485
msgid "@emph{NO_}@t{HIST_NO_FUNCTIONS} (ksh compatibility)"
msgstr "@emph{NO_}@t{HIST_NO_FUNCTIONS} (ksh 兼容性)"

#. type: t{#1}
#: zsh.texi:12486 zsh.texi:12490
#, no-wrap
msgid "MAIL_WARN"
msgstr "MAIL_WARN"

#. type: pindex
#: zsh.texi:12487
#, no-wrap
msgid "NO_MAIL_WARN"
msgstr "NO_MAIL_WARN"

#. type: pindex
#: zsh.texi:12488
#, no-wrap
msgid "MAILWARN"
msgstr "MAILWARN"

#. type: pindex
#: zsh.texi:12489
#, no-wrap
msgid "NOMAILWARN"
msgstr "NOMAILWARN"

#. type: table
#: zsh.texi:12493
msgid "@t{MAIL_WARNING} (bash compatibility)"
msgstr "@t{MAIL_WARNING} (bash 兼容性)"

#. type: t{#1}
#: zsh.texi:12494 zsh.texi:12498
#, no-wrap
msgid "ONE_CMD"
msgstr "ONE_CMD"

#. type: pindex
#: zsh.texi:12495
#, no-wrap
msgid "NO_ONE_CMD"
msgstr "NO_ONE_CMD"

#. type: pindex
#: zsh.texi:12496
#, no-wrap
msgid "ONECMD"
msgstr "ONECMD"

#. type: pindex
#: zsh.texi:12497
#, no-wrap
msgid "NOONECMD"
msgstr "NOONECMD"

#. type: table
#: zsh.texi:12501
msgid "@t{SINGLE_COMMAND} (bash compatibility)"
msgstr "@t{SINGLE_COMMAND} (bash 兼容性)"

#. type: t{#1}
#: zsh.texi:12502 zsh.texi:12505
#, no-wrap
msgid "PHYSICAL"
msgstr "PHYSICAL"

#. type: pindex
#: zsh.texi:12503
#, no-wrap
msgid "NO_PHYSICAL"
msgstr "NO_PHYSICAL"

#. type: pindex
#: zsh.texi:12504
#, no-wrap
msgid "NOPHYSICAL"
msgstr "NOPHYSICAL"

#. type: table
#: zsh.texi:12508
msgid "@t{CHASE_LINKS} (ksh and bash compatibility)"
msgstr "@t{CHASE_LINKS} (ksh 和 bash 兼容性)"

#. type: t{#1}
#: zsh.texi:12509 zsh.texi:12513
#, no-wrap
msgid "PROMPT_VARS"
msgstr "PROMPT_VARS"

#. type: pindex
#: zsh.texi:12510
#, no-wrap
msgid "NO_PROMPT_VARS"
msgstr "NO_PROMPT_VARS"

#. type: pindex
#: zsh.texi:12511
#, no-wrap
msgid "PROMPTVARS"
msgstr "PROMPTVARS"

#. type: pindex
#: zsh.texi:12512
#, no-wrap
msgid "NOPROMPTVARS"
msgstr "NOPROMPTVARS"

#. type: table
#: zsh.texi:12516
msgid "@t{PROMPT_SUBST} (bash compatibility)"
msgstr "@t{PROMPT_SUBST} (bash 兼容性)"

#. type: t{#1}
#: zsh.texi:12517 zsh.texi:12520
#, no-wrap
msgid "STDIN"
msgstr "STDIN"

#. type: pindex
#: zsh.texi:12518
#, no-wrap
msgid "NO_STDIN"
msgstr "NO_STDIN"

#. type: pindex
#: zsh.texi:12519
#, no-wrap
msgid "NOSTDIN"
msgstr "NOSTDIN"

#. type: table
#: zsh.texi:12523
msgid "@t{SHIN_STDIN} (ksh compatibility)"
msgstr "@t{SHIN_STDIN} (ksh 兼容性)"

#. type: t{#1}
#: zsh.texi:12524 zsh.texi:12528
#, no-wrap
msgid "TRACK_ALL"
msgstr "TRACK_ALL"

#. type: pindex
#: zsh.texi:12525
#, no-wrap
msgid "NO_TRACK_ALL"
msgstr "NO_TRACK_ALL"

#. type: pindex
#: zsh.texi:12526
#, no-wrap
msgid "TRACKALL"
msgstr "TRACKALL"

#. type: pindex
#: zsh.texi:12527
#, no-wrap
msgid "NOTRACKALL"
msgstr "NOTRACKALL"

#. type: table
#: zsh.texi:12531
msgid "@t{HASH_CMDS} (ksh compatibility)"
msgstr "@t{HASH_CMDS} (ksh 兼容性)"

#. type: cindex
#: zsh.texi:12537
#, no-wrap
msgid "options, single letter"
msgstr "选项, 单字母"

#. type: cindex
#: zsh.texi:12538
#, no-wrap
msgid "single letter options"
msgstr "单字母选项"

#. type: subsection
#: zsh.texi:12540
#, no-wrap
msgid "Default set"
msgstr "默认集(set)"

#. type: t{#1}
#: zsh.texi:12543 zsh.texi:24794
#, no-wrap
msgid "-0"
msgstr "-0"

#. type: t{#1}
#: zsh.texi:12545 zsh.texi:19840 zsh.texi:27402 zsh.texi:38911
#, no-wrap
msgid "-1"
msgstr "-1"

#. type: t{#1}
#: zsh.texi:12547 zsh.texi:19846 zsh.texi:27407
#, no-wrap
msgid "-2"
msgstr "-2"

#. type: table
#: zsh.texi:12549
msgid "@emph{NO_}BAD_PATTERN"
msgstr "@emph{NO_}BAD_PATTERN"

#. type: t{#1}
#: zsh.texi:12549 zsh.texi:38917
#, no-wrap
msgid "-3"
msgstr "-3"

#. type: table
#: zsh.texi:12551
msgid "@emph{NO_}NOMATCH"
msgstr "@emph{NO_}NOMATCH"

#. type: t{#1}
#: zsh.texi:12551
#, no-wrap
msgid "-4"
msgstr "-4"

#. type: t{#1}
#: zsh.texi:12553
#, no-wrap
msgid "-5"
msgstr "-5"

#. type: t{#1}
#: zsh.texi:12555
#, no-wrap
msgid "-6"
msgstr "-6"

#. type: t{#1}
#: zsh.texi:12557
#, no-wrap
msgid "-7"
msgstr "-7"

#. type: t{#1}
#: zsh.texi:12559
#, no-wrap
msgid "-8"
msgstr "-8"

#. type: t{#1}
#: zsh.texi:12561
#, no-wrap
msgid "-9"
msgstr "-9"

#. type: t{#1}
#: zsh.texi:12563 zsh.texi:27030
#, no-wrap
msgid "-B"
msgstr "-B"

#. type: table
#: zsh.texi:12565
msgid "@emph{NO_}BEEP"
msgstr "@emph{NO_}BEEP"

#. type: t{#1}
#: zsh.texi:12565 zsh.texi:12656 zsh.texi:19990 zsh.texi:24751 zsh.texi:26908 zsh.texi:38390 zsh.texi:41158
#, no-wrap
msgid "-C"
msgstr "-C"

#. type: table
#: zsh.texi:12567 zsh.texi:12658
msgid "@emph{NO_}CLOBBER"
msgstr "@emph{NO_}CLOBBER"

#. type: t{#1}
#: zsh.texi:12567 zsh.texi:13622 zsh.texi:14216 zsh.texi:26914 zsh.texi:32496 zsh.texi:33093
#, no-wrap
msgid "-D"
msgstr "-D"

#. type: t{#1}
#: zsh.texi:12569 zsh.texi:13609 zsh.texi:14466 zsh.texi:27085 zsh.texi:32503
#, no-wrap
msgid "-E"
msgstr "-E"

#. type: t{#1}
#: zsh.texi:12571 zsh.texi:27027 zsh.texi:32512
#, no-wrap
msgid "-F"
msgstr "-F"

#. type: table
#: zsh.texi:12573 zsh.texi:12670
msgid "@emph{NO_}GLOB"
msgstr "@emph{NO_}GLOB"

#. type: t{#1}
#: zsh.texi:12573 zsh.texi:27045
#, no-wrap
msgid "-G"
msgstr "-G"

#. type: t{#1}
#: zsh.texi:12575 zsh.texi:15235
#, no-wrap
msgid "-H"
msgstr "-H"

#. type: t{#1}
#: zsh.texi:12577 zsh.texi:13567 zsh.texi:16813 zsh.texi:27073
#, no-wrap
msgid "-I"
msgstr "-I"

#. type: t{#1}
#: zsh.texi:12579
#, no-wrap
msgid "-J"
msgstr "-J"

#. type: t{#1}
#: zsh.texi:12581 zsh.texi:32524
#, no-wrap
msgid "-K"
msgstr "-K"

#. type: table
#: zsh.texi:12583
msgid "@emph{NO_}BANG_HIST"
msgstr "@emph{NO_}BANG_HIST"

#. type: t{#1}
#: zsh.texi:12583 zsh.texi:13569 zsh.texi:26941 zsh.texi:30481 zsh.texi:41159
#, no-wrap
msgid "-L"
msgstr "-L"

#. type: t{#1}
#: zsh.texi:12585 zsh.texi:15712 zsh.texi:32532 zsh.texi:38915 zsh.texi:41160
#, no-wrap
msgid "-M"
msgstr "-M"

#. type: t{#1}
#: zsh.texi:12587 zsh.texi:14238 zsh.texi:26026 zsh.texi:27067 zsh.texi:30494 zsh.texi:38913
#, no-wrap
msgid "-N"
msgstr "-N"

#. type: t{#1}
#: zsh.texi:12589 zsh.texi:14246 zsh.texi:27076
#, no-wrap
msgid "-O"
msgstr "-O"

#. type: t{#1}
#: zsh.texi:12591 zsh.texi:14252 zsh.texi:25980
#, no-wrap
msgid "-P"
msgstr "-P"

#. type: t{#1}
#: zsh.texi:12593 zsh.texi:19944 zsh.texi:27202 zsh.texi:41145
#, no-wrap
msgid "-Q"
msgstr "-Q"

#. type: t{#1}
#: zsh.texi:12595 zsh.texi:14262 zsh.texi:15701 zsh.texi:24755 zsh.texi:27042
#, no-wrap
msgid "-R"
msgstr "-R"

#. type: t{#1}
#: zsh.texi:12597 zsh.texi:14273 zsh.texi:15578 zsh.texi:24759 zsh.texi:25728
#, no-wrap
msgid "-S"
msgstr "-S"

#. type: t{#1}
#: zsh.texi:12601 zsh.texi:15174 zsh.texi:15698 zsh.texi:19960 zsh.texi:27288
#, no-wrap
msgid "-U"
msgstr "-U"

#. type: t{#1}
#: zsh.texi:12603
#, no-wrap
msgid "-V"
msgstr "-V"

#. type: table
#: zsh.texi:12605
msgid "@emph{NO_}PROMPT_CR"
msgstr "@emph{NO_}PROMPT_CR"

#. type: t{#1}
#: zsh.texi:12605 zsh.texi:24744 zsh.texi:41155
#, no-wrap
msgid "-W"
msgstr "-W"

#. type: t{#1}
#: zsh.texi:12607 zsh.texi:12660
#, no-wrap
msgid "-X"
msgstr "-X"

#. type: t{#1}
#: zsh.texi:12609
#, no-wrap
msgid "-Y"
msgstr "-Y"

#. type: t{#1}
#: zsh.texi:12611 zsh.texi:27082
#, no-wrap
msgid "-Z"
msgstr "-Z"

#. type: t{#1}
#: zsh.texi:12613 zsh.texi:12662 zsh.texi:14199 zsh.texi:15194 zsh.texi:15341 zsh.texi:15565 zsh.texi:16318 zsh.texi:19774 zsh.texi:27039 zsh.texi:33071 zsh.texi:33629 zsh.texi:38895
#, no-wrap
msgid "-a"
msgstr "-a"

#. type: t{#1}
#: zsh.texi:12615 zsh.texi:12666 zsh.texi:14465 zsh.texi:16308 zsh.texi:19922 zsh.texi:27053 zsh.texi:36043
#, no-wrap
msgid "-e"
msgstr "-e"

#. type: t{#1}
#: zsh.texi:12617 zsh.texi:12668 zsh.texi:13606 zsh.texi:15201 zsh.texi:15349 zsh.texi:15556 zsh.texi:19914 zsh.texi:26029 zsh.texi:26121 zsh.texi:27017 zsh.texi:41132
#, no-wrap
msgid "-f"
msgstr "-f"

#. type: table
#: zsh.texi:12619
msgid "@emph{NO_}RCS"
msgstr "@emph{NO_}RCS"

#. type: t{#1}
#: zsh.texi:12619 zsh.texi:15050 zsh.texi:30472
#, no-wrap
msgid "-g"
msgstr "-g"

#. type: t{#1}
#: zsh.texi:12621 zsh.texi:15219 zsh.texi:37976
#, no-wrap
msgid "-h"
msgstr "-h"

#. type: t{#1}
#: zsh.texi:12625 zsh.texi:15353 zsh.texi:15719 zsh.texi:19780
#, no-wrap
msgid "-k"
msgstr "-k"

#. type: t{#1}
#: zsh.texi:12627 zsh.texi:12672 zsh.texi:13127 zsh.texi:14224 zsh.texi:14475 zsh.texi:15262 zsh.texi:15355 zsh.texi:16334 zsh.texi:19798 zsh.texi:30476 zsh.texi:36032 zsh.texi:37971
#, no-wrap
msgid "-l"
msgstr "-l"

#. type: t{#1}
#: zsh.texi:12629 zsh.texi:12674 zsh.texi:12703 zsh.texi:13573 zsh.texi:14230 zsh.texi:15059 zsh.texi:15357 zsh.texi:15570 zsh.texi:16389 zsh.texi:27033 zsh.texi:33640
#, no-wrap
msgid "-m"
msgstr "-m"

#. type: t{#1}
#: zsh.texi:12631 zsh.texi:12676 zsh.texi:14235 zsh.texi:14483 zsh.texi:15359 zsh.texi:19956 zsh.texi:24711 zsh.texi:27088 zsh.texi:28836 zsh.texi:30489 zsh.texi:41140
#, no-wrap
msgid "-n"
msgstr "-n"

#. type: table
#: zsh.texi:12633 zsh.texi:12678
msgid "@emph{NO_}EXEC"
msgstr "@emph{NO_}EXEC"

#. type: t{#1}
#: zsh.texi:12633 zsh.texi:12678 zsh.texi:13130 zsh.texi:14249 zsh.texi:14493 zsh.texi:15361 zsh.texi:15561 zsh.texi:25567 zsh.texi:27079 zsh.texi:37973
#, no-wrap
msgid "-p"
msgstr "-p"

#. type: t{#1}
#: zsh.texi:12635 zsh.texi:12680 zsh.texi:14259 zsh.texi:14431 zsh.texi:15266 zsh.texi:15365 zsh.texi:27098 zsh.texi:28843 zsh.texi:30504 zsh.texi:33100 zsh.texi:33644 zsh.texi:36039 zsh.texi:38392
#, no-wrap
msgid "-r"
msgstr "-r"

#. type: t{#1}
#: zsh.texi:12639 zsh.texi:12684 zsh.texi:15289 zsh.texi:15373 zsh.texi:30514 zsh.texi:33663
#, no-wrap
msgid "-t"
msgstr "-t"

#. type: t{#1}
#: zsh.texi:12641 zsh.texi:12686 zsh.texi:15293 zsh.texi:15375 zsh.texi:27104
#, no-wrap
msgid "-u"
msgstr "-u"

#. type: table
#: zsh.texi:12643 zsh.texi:12688
msgid "@emph{NO_}UNSET"
msgstr "@emph{NO_}UNSET"

#. type: t{#1}
#: zsh.texi:12643 zsh.texi:12688 zsh.texi:13133 zsh.texi:15377 zsh.texi:15540 zsh.texi:16313 zsh.texi:27064 zsh.texi:33197 zsh.texi:41150
#, no-wrap
msgid "-v"
msgstr "-v"

#. type: t{#1}
#: zsh.texi:12645 zsh.texi:15380 zsh.texi:15547 zsh.texi:24734 zsh.texi:27036 zsh.texi:38384 zsh.texi:41152
#, no-wrap
msgid "-w"
msgstr "-w"

#. type: t{#1}
#: zsh.texi:12647 zsh.texi:12690 zsh.texi:15298 zsh.texi:15382
#, no-wrap
msgid "-x"
msgstr "-x"

#. type: t{#1}
#: zsh.texi:12649
#, no-wrap
msgid "-y"
msgstr "-y"

#. type: subsection
#: zsh.texi:12653
#, no-wrap
msgid "sh/ksh emulation set"
msgstr "sh/ksh 模拟集"

#. type: t{#1}
#: zsh.texi:12664 zsh.texi:12699 zsh.texi:14203 zsh.texi:15343 zsh.texi:27091 zsh.texi:33075
#, no-wrap
msgid "-b"
msgstr "-b"

#. type: subsection
#: zsh.texi:12694
#, no-wrap
msgid "Also note"
msgstr "另请注意"

#. type: t{#1}
#: zsh.texi:12697 zsh.texi:14470 zsh.texi:15140 zsh.texi:27070 zsh.texi:33633
#, no-wrap
msgid "-A"
msgstr "-A"

#. type: table
#: zsh.texi:12699
msgid "Used by @t{set} for setting arrays"
msgstr "由 @t{set} 使用，用于设置数组"

#. type: table
#: zsh.texi:12701
msgid "Used on the command line to specify end of option processing"
msgstr "在命令行中使用，用于指定选项处理的结束"

#. type: table
#: zsh.texi:12703
msgid "Used on the command line to specify a single command"
msgstr "在命令行中使用，用于指定单一命令"

#. type: table
#: zsh.texi:12705
msgid "Used by @t{setopt} for pattern-matching option setting"
msgstr "由 @t{setopt} 使用，用于模式匹配选项设置"

#. type: t{#1}
#: zsh.texi:12705 zsh.texi:14243 zsh.texi:27060 zsh.texi:30497 zsh.texi:38905
#, no-wrap
msgid "-o"
msgstr "-o"

#. type: table
#: zsh.texi:12707
msgid "Used in all places to allow use of long option names"
msgstr "在所有地方使用，允许使用长选项名"

#. type: table
#: zsh.texi:12709
msgid "Used by @t{set} to sort positional parameters"
msgstr "被 @t{set} 用来对位置参数排序"

#. type: cindex
#: zsh.texi:12717
#, no-wrap
msgid "builtin commands"
msgstr "内置命令"

#. type: cindex
#: zsh.texi:12718
#, no-wrap
msgid "commands, builtin"
msgstr "命令, 内置"

#. type: Plain text
#: zsh.texi:12725
msgid ""
"Some shell builtin commands take options as described in individual entries; these are often referred to in the list below as `@t{flags}' to avoid confusion with shell options, which may also have an "
"effect on the behaviour of builtin commands.  In this introductory section, `@t{option}' always has the meaning of an option to a command that should be familiar to most command line users."
msgstr ""
"某些 shell 内置命令会使用个别条目中描述的选项；这些选项在下面的列表中通常被称为 `@t{标志}'，以避免与 shell 选项混淆，后者也可能对内置命令的行为产生影响。 在本介绍性章节中，`@t{选项}' 总是指大多数命令行用户"
"熟悉的命令选项。"

#. type: Plain text
#: zsh.texi:12735
msgid ""
"Typically, options are single letters preceded by a hyphen (@t{-}).  Options that take an argument accept it either immediately following the option letter or after white space, for example `@t{print -C3 "
"@{1..9@}}' or `@t{print -C 3 @{1..9@}}' are equivalent.  Arguments to options are not the same as arguments to the command; the documentation indicates which is which.  Options that do not take an "
"argument may be combined in a single word, for example `@t{print -rca -- *}' and `@t{print -r -c -a -- *}' are equivalent."
msgstr ""
"通常情况下，选项为单个字母，前面有一个连字符（@t{-}）。 带参数的选项要么紧跟在选项字母之后，要么在空白处之后接受参数，例如， `@t{print -C3 @{1..9@}}' 和 `@t{print -C 3 @{1..9@}}' 是等价的。 选项的参数与命"
"令的参数不同；文档中会说明哪个是哪个。 不带参数的选项可以合并为一个单词，例如， `@t{print -rca -- *}' 和 `@t{print -r -c -a -- *}' 是等价的。"

#. type: Plain text
#: zsh.texi:12740
msgid "Some shell builtin commands also take options that begin with `@t{+}' instead of `@t{-}'.  The list below makes clear which commands these are."
msgstr "某些 shell 内置命令的选项也是以 `@t{+}' 开头，而不是以 `@t{-}' 开头。 下面的列表清楚地列出了这些命令。"

#. type: Plain text
#: zsh.texi:12745
msgid "Options (together with their individual arguments, if any) must appear in a group before any non-option arguments; once the first non-option argument has been found, option processing is terminated."
msgstr "选项（及其单个参数（如果有））必须先于非选项参数出现在一组中；一旦找到第一个非选项参数，选项处理就会终止。"

#. type: Plain text
#: zsh.texi:12755
msgid ""
"All builtin commands other than `@t{echo}' and precommand modifiers, even those that have no options, can be given the argument `@t{-}@t{-}' to terminate option processing.  This indicates that the "
"following words are non-option arguments, but is otherwise ignored.  This is useful in cases where arguments to the command may begin with `@t{-}'.  For historical reasons, most builtin commands "
"(including `@t{echo}') also recognize a single `@t{-}' in a separate word for this purpose; note that this is less standard and use of `@t{-}@t{-}' is recommended."
msgstr ""
"除 `@t{echo}' 和前置命令修饰符之外的所有内置命令，甚至那些没有选项的命令，都可以使用参数 `@t{-}@t{-}' 来终止选项处理。 这表明后面的词是非选项参数，但在其他情况下会被忽略。 这在命令参数可能以 `@t{-}' 开头的"
"情况下非常有用。 由于历史原因，大多数内置命令（包括 `@t{echo}'）也会为此目的在单独的单词中识别单个 `@t{-}'；请注意，这不是标准的做法，建议使用 `@t{-}@t{-}'。"

#. type: item
#: zsh.texi:12758
#, no-wrap
msgid "@t{-} @var{simple command}"
msgstr "@t{-} @var{simple command}"

#. type: table
#: zsh.texi:12760 zsh.texi:14163
msgid "See @ref{Precommand Modifiers}."
msgstr "请参阅 @ref{前置命令修饰符}"

#. type: item
#: zsh.texi:12762
#, no-wrap
msgid "@t{.} @var{file} [ @var{arg} ... ]"
msgstr "@t{.} @var{file} [ @var{arg} ... ]"

#. type: table
#: zsh.texi:12765
msgid "Read commands from @var{file} and execute them in the current shell environment."
msgstr "从 @var{file} 中读取命令，并在当前 shell 环境中执行。"

#. type: table
#: zsh.texi:12774
msgid ""
"If @var{file} does not contain a slash, or if @t{PATH_DIRS} is set, the shell looks in the components of @t{$path} to find the directory containing @var{file}.  Files in the current directory are not read "
"unless `@t{.}' appears somewhere in @t{$path}.  If a file named `@var{file}@t{.zwc}' is found, is newer than @var{file}, and is the compiled form (created with the @t{zcompile} builtin) of @var{file}, "
"then commands are read from that file instead of @var{file}."
msgstr ""
"如果 @var{file} 不包含斜线，或者 @t{PATH_DIRS} 已被设置，shell 会在 @t{$path} 的组件中查找包含 @var{file} 的目录。 除非 @t{$path} 中出现了`@t{.}' ，否则不会读取当前目录下的文件。 如果找到名为 `@var{file}"
"@t{.zwc}' 的文件，该文件比 @var{file} 新，并且是 @var{file} 的编译形式（使用 @t{zcompile} 内置程序创建），则将从该文件而不是 @var{file} 读取命令。"

#. type: table
#: zsh.texi:12782
msgid ""
"If any arguments @var{arg} are given, they become the positional parameters; the old positional parameters are restored when the @var{file} is done executing.  However, if no arguments are given, the "
"positional parameters remain those of the calling context, and no restoring is done."
msgstr "如果给定了任何参数 @var{arg}，它们就会成为位置参数；当 @var{file} 执行完毕后，旧的位置参数会被还原。 但是，如果没有给出参数，位置参数仍然是调用上下文中的参数，不会被还原。"

#. type: table
#: zsh.texi:12787
msgid ""
"If @var{file} was not found the return status is 127; if @var{file} was found but contained a syntax error the return status is 126; else the return status is the exit status of the last command executed."
msgstr "如果 @var{file} 未找到，则返回状态为 127；如果 @var{file} 找到了，但包含语法错误，则返回状态为 126；否则返回状态为最后执行命令的退出状态。"

#. type: t{#1}
#: zsh.texi:12788 zsh.texi:38790
#, no-wrap
msgid ":"
msgstr ":"

#. type: cindex
#: zsh.texi:12789
#, no-wrap
msgid "expanding parameters"
msgstr "扩展参数"

#. type: cindex
#: zsh.texi:12790
#, no-wrap
msgid "parameters, expanding"
msgstr "参数, 扩展"

#. type: cindex
#: zsh.texi:12791
#, no-wrap
msgid "doing nothing"
msgstr "什么也不做"

#. type: item
#: zsh.texi:12792
#, no-wrap
msgid "@t{:} [ @var{arg} ... ]"
msgstr "@t{:} [ @var{arg} ... ]"

#. type: table
#: zsh.texi:12795
msgid "This command does nothing, although normal argument expansions is performed which may have effects on shell parameters.  A zero exit status is returned."
msgstr "该命令不执行任何操作，但会执行正常的参数扩展，这可能会对 shell 参数产生影响。 返回的退出状态为零。"

#. type: findex
#: zsh.texi:12796
#, no-wrap
msgid "alias"
msgstr "alias"

#. type: cindex
#: zsh.texi:12797
#, no-wrap
msgid "aliases, defining"
msgstr "别名, 定义"

#. type: cindex
#: zsh.texi:12798
#, no-wrap
msgid "aliases, listing"
msgstr "别名, 列出"

#. type: item
#: zsh.texi:12799
#, no-wrap
msgid "@t{alias} [ @{@t{+}|@t{-}@}@t{gmrsL} ] [ @var{name}[@t{=}@var{value}] ... ]"
msgstr "@t{alias} [ @{@t{+}|@t{-}@}@t{gmrsL} ] [ @var{name}[@t{=}@var{value}] ... ]"

#. type: table
#: zsh.texi:12805
msgid ""
"For each @var{name} with a corresponding @var{value}, define an alias with that value.  A trailing space in @var{value} causes the next word to be checked for alias expansion.  If the @t{-g} flag is "
"present, define a global alias; global aliases are expanded even if they do not occur in command position:"
msgstr ""
"对于每个带有相应 @var{value} 的 @var{name}，定义一个带有该值的别名。 如果 @var{value} 的尾部有空格，则会检查下一个单词的别名扩展情况。 如果存在 @t{-g} 标志，则定义全局别名；全局别名即使不出现在命令位置，也"
"会被扩展："

#. type: example
#: zsh.texi:12813
#, no-wrap
msgid ""
"% perldoc --help 2>&1 | grep 'built-in functions'\n"
"    -f   Search Perl built-in functions\n"
"% alias -g HG='--help 2>&1 | grep'\n"
"% perldoc HG 'built-in functions'\n"
"    -f   Search Perl built-in functions\n"
msgstr ""
"% perldoc --help 2>&1 | grep 'built-in functions'\n"
"    -f   Search Perl built-in functions\n"
"% alias -g HG='--help 2>&1 | grep'\n"
"% perldoc HG 'built-in functions'\n"
"    -f   Search Perl built-in functions\n"

#. type: table
#: zsh.texi:12822
msgid ""
"If the @t{-s} flag is present, define a suffix alias: if the command word on a command line is in the form `@var{text}@t{.}@var{name}', where @var{text} is any non-empty string, it is replaced by the text "
"`@var{value} @var{text}@t{.}@var{name}'.  Note that @var{name} is treated as a literal string, not a pattern.  A trailing space in @var{value} is not special in this case.  For example,"
msgstr ""
"如果存在 @t{-s} 标志，则定义后缀别名：如果命令行中的命令字格式为 `@var{text}@t{.}@var{name}'，其中 @var{text} 为任何非空字符串，则该命令字将被文本 `@var{value} @var{text}@t{.}@var{name}' 替换。 请注意，"
"@var{name} 被视为字面字符串，而不是模式。 在这种情况下，@var{value} 中的尾部空格并不特殊。 例如"

#. type: example
#: zsh.texi:12826
#, no-wrap
msgid "alias -s ps='gv --'\n"
msgstr "alias -s ps='gv --'\n"

#. type: table
#: zsh.texi:12835
msgid ""
"will cause the command `@t{*.ps}' to be expanded to `@t{gv -- *.ps}'.  As alias expansion is carried out earlier than globbing, the `@t{*.ps}' will then be expanded.  Suffix aliases constitute a different "
"name space from other aliases (so in the above example it is still possible to create an alias for the command @t{ps}) and the two sets are never listed together."
msgstr ""
"将导致命令  `@t{*.ps}'  扩展为  `@t{gv -- *.ps}'。 由于别名扩展比 globbing 进行得更早，`@t{*.ps}' 随后也将被扩展。 后缀别名与其他别名构成不同的名称空间（因此在上述示例中，仍然可以为命令 @t{ps} 创建一个别"
"名），这两组别名永远不会列在一起。"

#. type: table
#: zsh.texi:12848
msgid ""
"For each @var{name} with no @var{value}, print the value of @var{name}, if any.  With no arguments, print all currently defined aliases other than suffix aliases.  If the @t{-m} flag is given the "
"arguments are taken as patterns (they should be quoted to preserve them from being interpreted as glob patterns), and the aliases matching these patterns are printed.  When printing aliases and one of the "
"@t{-g}, @t{-r} or @t{-s} flags is present, restrict the printing to global, regular or suffix aliases, respectively; a regular alias is one which is neither a global nor a suffix alias.  Using `@t{+}' "
"instead of `@t{-}', or ending the option list with a single `@t{+}', prevents the values of the aliases from being printed."
msgstr ""
"对于没有 @var{value} 的 @var{name}，打印 @var{name} 的值。 如果没有参数，则打印当前定义的所有别名（后缀别名除外）。 如果给定了 @t{-m} 标志，参数将作为模式（应加引号以防止被解释为 glob 模式），并打印与这些"
"模式匹配的别名。 在打印别名时，如果有 @t{-g}、@t{-r} 或 @t{-s} 标志，则分别限制为打印全局别名、常规别名或后缀别名；常规别名既不是全局别名，也不是后缀别名。 使用 `@t{+}' 而不是 `@t{-}' ，或以单个`@t{+}' 结"
"束选项列表，可以防止打印别名的值。"

#. type: table
#: zsh.texi:12854
msgid ""
"If the @t{-L} flag is present, then print each alias in a manner suitable for putting in a startup script.  The exit status is nonzero if a @var{name} (with no @var{value}) is given for which no alias has "
"been defined."
msgstr "如果存在 @t{-L} 标志，则以适合放入启动脚本的方式打印每个别名。 如果给出的 @var{name}（没有 @var{value}）没有定义别名，则退出状态为非零。"

#. type: table
#: zsh.texi:12858
msgid "For more on aliases, include common problems, see @ref{Aliasing}."
msgstr "有关别名的更多信息，包括常见问题，请参阅 @ref{别名}。"

#. type: findex
#: zsh.texi:12859
#, no-wrap
msgid "autoload"
msgstr "autoload"

#. type: item
#: zsh.texi:12862
#, no-wrap
msgid "@t{autoload} [ @{@t{+}|@t{-}@}@t{RTUXdkmrtWz} ] [ @t{-w} ] [ @var{name} ... ]"
msgstr "@t{autoload} [ @{@t{+}|@t{-}@}@t{RTUXdkmrtWz} ] [ @t{-w} ] [ @var{name} ... ]"

#. type: vindex
#: zsh.texi:12863
#, no-wrap
msgid "fpath, searching"
msgstr "fpath, 搜索"

#. type: table
#: zsh.texi:12867
msgid "See the section `Autoloading Functions' in @ref{Functions} for full details.  The @t{fpath} parameter will be searched to find the function definition when the function is first referenced."
msgstr "详情请参阅 @ref{函数} 中的 `自动加载函数' 部分。 首次引用函数时，将搜索 @t{fpath} 参数以查找函数定义。"

#. type: table
#: zsh.texi:12878
msgid ""
"If @var{name} consists of an absolute path, the function is defined to load from the file given (searching as usual for dump files in the given location).  The name of the function is the basename (non-"
"directory part) of the file.  It is normally an error if the function is not found in the given location; however, if the option @t{-d} is given, searching for the function defaults to @t{$fpath}.  If a "
"function is loaded by absolute path, any functions loaded from it that are marked for @t{autoload} without an absolute path have the load path of the parent function temporarily prepended to @t{$fpath}."
msgstr ""
"如果 @var{name} 包含一个绝对路径，函数将被定义为从给定文件加载（像往常一样搜索给定位置的转储文件）。 函数名称是文件的基名（非目录部分）。 如果在给定位置找不到函数，通常会出错；但如果给出选项 @t{-d}，则搜索"
"函数时默认使用 @t{$fpath}。 如果函数是通过绝对路径加载的，那么从该函数加载的任何标记为 @t{autoload} 但没有绝对路径的函数，都会将父函数的加载路径暂时预置为 @t{$fpath}。"

#. type: table
#: zsh.texi:12888
msgid ""
"If the option @t{-r} or @t{-R} is given, the function is searched for immediately and the location is recorded internally for use when the function is executed; a relative path is expanded using the value "
"of @t{$PWD}.  This protects against a change to @t{$fpath} after the call to @t{autoload}.  With @t{-r}, if the function is not found, it is silently left unresolved until execution; with @t{-R}, an error "
"message is printed and command processing aborted immediately the search fails, i.e. at the @t{autoload} command rather than at function execution.."
msgstr ""
"如果给出选项 @t{-r} 或 @t{-R}，则会立即搜索函数，并在内部记录位置，供执行函数时使用；相对路径会使用 @t{$PWD} 的值展开。 这样可以防止 @t{$fpath} 在调用 @t{autoload} 后发生变化。 使用 @t{-r} 时，如果函数未找"
"到，则会静默地将其搁置，直到执行为止；如果使用 @t{-R}，则会打印错误信息，并在搜索失败后立即终止命令处理，即在 @t{autoload} 命令执行时终止，而不是在函数执行时终止。"

#. type: table
#: zsh.texi:12900
msgid ""
"The flag @t{-X} may be used only inside a shell function.  It causes the calling function to be marked for autoloading and then immediately loaded and executed, with the current array of positional "
"parameters as arguments.  This replaces the previous definition of the function.  If no function definition is found, an error is printed and the function remains undefined and marked for autoloading.  If "
"an argument is given, it is used as a directory (i.e. it does not include the name of the function) in which the function is to be found; this may be combined with the @t{-d} option to allow the function "
"search to default to @t{$fpath} if it is not in the given location."
msgstr ""
"标志 @t{-X} 只能在 shell 函数内部使用。 它会将调用的函数标记为自动加载，然后立即加载并执行，并将当前的位置参数数组作为参数。 这将替换之前的函数定义。 如果没有找到函数定义，则会打印错误信息，函数将保持未定"
"义状态并标记为自动加载。 如果给定了一个参数，则该参数将被用作查找函数的目录（即不包含函数名称）；如果函数不在给定的位置，则可以结合 @t{-d} 选项，将函数搜索默认为 @t{$fpath}。"

#. type: table
#: zsh.texi:12915
msgid ""
"The flag @t{+X} attempts to load each @var{name} as an autoloaded function, but does @emph{not} execute it.  The exit status is zero (success) if the function was not previously defined @emph{and} a "
"definition for it was found.  This does @emph{not} replace any existing definition of the function.  The exit status is nonzero (failure) if the function was already defined or when no definition was "
"found.  In the latter case the function remains undefined and marked for autoloading.  If ksh-style autoloading is enabled, the function created will contain the contents of the file plus a call to the "
"function itself appended to it, thus giving normal ksh autoloading behaviour on the first call to the function.  If the @t{-m} flag is also given each @var{name} is treated as a pattern and all functions "
"already marked for autoload that match the pattern are loaded."
msgstr ""
"标志 @t{+X} 会尝试将 @var{name} 作为自动加载函数加载，但 @emph{不会} 执行该函数。 如果函数之前未定义过 @emph{并且} 找到了函数的定义，则退出状态为零（成功）。 这不会 @emph{不会} 替换函数的任何现有定义。 如"
"果函数已被定义或未找到定义，则退出状态为非零（失败）。 在后一种情况下，函数将保持未定义状态，并标记为自动加载。 如果启用了 ksh 样式的自动加载，创建的函数将包含文件内容以及附加到函数本身的调用，从而在首次调"
"用函数时提供正常的 ksh 自动加载行为。 如果同时给出 @t{-m} 标志，则每个 @var{name} 都会被视为一个模式，所有已经标记为自动加载的、与该模式匹配的函数都会被加载。"

#. type: table
#: zsh.texi:12920
msgid ""
"With the @t{-t} flag, turn on execution tracing; with @t{-T}, turn on execution tracing only for the current function, turning it off on entry to any called functions that do not also have tracing enabled."
msgstr "使用 @t{-t} 标志，开启执行跟踪；使用 @t{-T}，仅对当前函数开启执行跟踪，在进入任何未开启跟踪的被调用函数时关闭跟踪。"

#. type: table
#: zsh.texi:12924
msgid "With the @t{-U} flag, alias expansion is suppressed when the function is loaded."
msgstr "使用 @t{-U} 标志时，在加载函数时会抑制别名扩展。"

#. type: table
#: zsh.texi:12929
msgid "With the @t{-w} flag, the @var{name}s are taken as names of files compiled with the @t{zcompile} builtin, and all functions defined in them are marked for autoloading."
msgstr "使用 @t{-w} 标志时，@var{name}s 将被视为使用 @t{zcompile} 内置程序编译的文件名，其中定义的所有函数都会被标记为自动加载。"

#. type: table
#: zsh.texi:12935
msgid ""
"The flags @t{-z} and @t{-k} mark the function to be autoloaded using the zsh or ksh style, as if the option @t{KSH_AUTOLOAD} were unset or were set, respectively.  The flags override the setting of the "
"option at the time the function is loaded."
msgstr "标志 @t{-z} 和 @t{-k} 分别标记函数将使用 zsh 或 ksh 样式自动加载，如同选项 @t{KSH_AUTOLOAD} 未设置或已设置。 这些标志会覆盖加载函数时的选项设置。"

#. type: table
#: zsh.texi:12940
msgid ""
"Note that the @t{autoload} command makes no attempt to ensure the shell options set during the loading or execution of the file have any particular value.  For this, the @t{emulate} command can be used:"
msgstr "请注意，@t{autoload} 命令并不试图确保在加载或执行文件时设置的 shell 选项具有任何特定值。 为此，可以使用 @t{emulate} 命令："

#. type: example
#: zsh.texi:12944
#, no-wrap
msgid "emulate zsh -c 'autoload -Uz @var{func}'\n"
msgstr "emulate zsh -c 'autoload -Uz @var{func}'\n"

#. type: table
#: zsh.texi:12949
msgid "arranges that when @var{func} is loaded the shell is in native @t{zsh} emulation, and this emulation is also applied when @var{func} is run."
msgstr "安排在加载 @var{func} 时使用原生 @t{zsh} 模拟 shell，在运行 @var{func} 时也使用这种模拟。"

#. type: table
#: zsh.texi:12954
msgid "Some of the functions of @t{autoload} are also provided by @t{functions -u} or @t{functions -U}, but @t{autoload} is a more comprehensive interface."
msgstr "@t{autoload} 的某些功能也由 @t{functions -u} 或 @t{functions -U} 提供，但 @t{autoload} 是一个更全面的接口。"

#. type: t{#1}
#: zsh.texi:12955 zsh.texi:40735
#, no-wrap
msgid "bg"
msgstr "bg"

#. type: cindex
#: zsh.texi:12956
#, no-wrap
msgid "jobs, backgrounding"
msgstr "作业, 后台"

#. type: item
#: zsh.texi:12957
#, no-wrap
msgid "@t{bg} [ @var{job} ... ]"
msgstr "@t{bg} [ @var{job} ... ]"

#. type: itemx
#: zsh.texi:12958
#, no-wrap
msgid "@var{job} ... @t{&}"
msgstr "@var{job} ... @t{&}"

#. type: table
#: zsh.texi:12961
msgid "Put each specified @var{job} in the background, or the current job if none is specified."
msgstr "将每个指定的 @var{job} 置于后台，如果没有指定，则将当前工作置于后台。"

#. type: findex
#: zsh.texi:12962 zsh.texi:16286
#, no-wrap
msgid "bindkey"
msgstr "bindkey"

#. type: table
#: zsh.texi:12964 zsh.texi:15489 zsh.texi:15754
msgid "See @ref{Zle Builtins}."
msgstr "参见 @ref{Zle 内置命令}。"

#. type: findex
#: zsh.texi:12965
#, no-wrap
msgid "break"
msgstr "break"

#. type: cindex
#: zsh.texi:12966
#, no-wrap
msgid "exiting loops"
msgstr "退出循环"

#. type: cindex
#: zsh.texi:12967
#, no-wrap
msgid "loops, exiting"
msgstr "循环, 退出"

#. type: item
#: zsh.texi:12968
#, no-wrap
msgid "@t{break} [ @var{n} ]"
msgstr "@t{break} [ @var{n} ]"

#. type: table
#: zsh.texi:12972
msgid "Exit from an enclosing @t{for}, @t{while}, @t{until}, @t{select} or @t{repeat} loop. If an arithmetic expression @var{n} is specified, then break @var{n} levels instead of just one."
msgstr "从闭合的 @t{for}、@t{while}、@t{until}、@t{select} 或 @t{repeat} 循环中退出。如果指定了算术表达式 @var{n}，则会中断 @var{n} 层，而不是只中断一层。"

#. type: item
#: zsh.texi:12974
#, no-wrap
msgid "@t{builtin} @var{name} [ @var{args} ... ]"
msgstr "@t{builtin} @var{name} [ @var{args} ... ]"

#. type: table
#: zsh.texi:12976
msgid "Executes the builtin @var{name}, with the given @var{args}."
msgstr "使用给定的 @var{args} 执行 @var{name} 内置命令。"

#. type: t{#1}
#: zsh.texi:12977 zsh.texi:12978
#, no-wrap
msgid "bye"
msgstr "bye"

#. type: table
#: zsh.texi:12980
msgid "Same as @t{exit}."
msgstr "与 @t{exit} 相同。"

#. type: findex
#: zsh.texi:12981 zsh.texi:27840
#, no-wrap
msgid "cap"
msgstr "cap"

#. type: table
#: zsh.texi:12983 zsh.texi:13841 zsh.texi:14652
msgid "See @ref{The zsh/cap Module}."
msgstr "参见 @ref{zsh/cap 模块}."

#. type: findex
#: zsh.texi:12984
#, no-wrap
msgid "cd"
msgstr "cd"

#. type: cindex
#: zsh.texi:12985
#, no-wrap
msgid "directories, changing"
msgstr "目录, 改变"

#. type: item
#: zsh.texi:12986
#, no-wrap
msgid "@t{cd} [ @t{-qsLP} ] [ @var{arg} ]"
msgstr "@t{cd} [ @t{-qsLP} ] [ @var{arg} ]"

#. type: itemx
#: zsh.texi:12987
#, no-wrap
msgid "@t{cd} [ @t{-qsLP} ] @var{old} @var{new}"
msgstr "@t{cd} [ @t{-qsLP} ] @var{old} @var{new}"

#. type: itemx
#: zsh.texi:12988
#, no-wrap
msgid "@t{cd} [ @t{-qsLP} ] @{@t{+}|@t{-}@}@var{n}"
msgstr "@t{cd} [ @t{-qsLP} ] @{@t{+}|@t{-}@}@var{n}"

#. type: table
#: zsh.texi:12993
msgid ""
"Change the current directory.  In the first form, change the current directory to @var{arg}, or to the value of @t{$HOME} if @var{arg} is not specified.  If @var{arg} is `@t{-}', change to the previous "
"directory."
msgstr "更改当前目录。 在第一种形式中，将当前目录更改为 @var{arg}，如果未指定 @var{arg}，则更改为 @t{$HOME} 的值。 如果 @var{arg} 是 `@t{-}'，则会更改为前一个目录。"

#. type: table
#: zsh.texi:12997
msgid "Otherwise, if @var{arg} begins with a slash, attempt to change to the directory given by @var{arg}."
msgstr "否则，如果 @var{arg} 以斜线开头，则尝试切换到 @var{arg} 指定的目录。"

#. type: table
#: zsh.texi:13007
msgid ""
"If @var{arg} does not begin with a slash, the behaviour depends on whether the current directory `@t{.}' occurs in the list of directories contained in the shell parameter @t{cdpath}.  If it does not, "
"first attempt to change to the directory @var{arg} under the current directory, and if that fails but @t{cdpath} is set and contains at least one element attempt to change to the directory @var{arg} under "
"each component of @t{cdpath} in turn until successful.  If `@t{.}' occurs in @t{cdpath}, then @t{cdpath} is searched strictly in order so that `@t{.}' is only tried at the appropriate point."
msgstr ""
"如果 @var{arg} 并非以斜线开头，其行为取决于当前目录 `@t{.}'是否出现在 shell 参数 @t{cdpath} 包含的目录列表中。 如果没有，则首先尝试更改为当前目录下的 @var{arg} 目录，如果失败，但 @t{cdpath} 已设置且包含至"
"少一个元素，则尝试依次更改为 @t{cdpath} 的每个组件下的 @var{arg} 目录，直至成功。 如果 `@t{.}' 出现在 @t{cdpath} 中，那么 @t{cdpath} 将严格按照顺序进行搜索，这样 `@t{.}' 只会在适当的位置被尝试。"

#. type: table
#: zsh.texi:13011
msgid "The order of testing @t{cdpath} is modified if the option @t{POSIX_CD} is set, as described in the documentation for the option."
msgstr "如果设置了 @t{POSIX_CD} 选项，则会修改 @t{cdpath} 的测试顺序，具体请参见该选项的文档。"

#. type: table
#: zsh.texi:13017
msgid ""
"If no directory is found, the option @t{CDABLE_VARS} is set, and a parameter named @var{arg} exists whose value begins with a slash, treat its value as the directory.  In that case, the parameter is added "
"to the named directory hash table."
msgstr "如果未找到目录，但选项 @t{CDABLE_VARS} 已设置，且存在以斜线开头的名为 @var{arg} 的参数，则将其值视为目录。 在这种情况下，该参数会被添加到已命名的目录哈希表中。"

#. type: table
#: zsh.texi:13022
msgid "The second form of @t{cd} substitutes the string @var{new} for the string @var{old} in the name of the current directory, and tries to change to this new directory."
msgstr "@t{cd} 的第二种形式是用 @var{new} 字符串替换当前目录名称中的 @var{old} 字符串，并尝试更改为这个新目录。"

#. type: table
#: zsh.texi:13033
msgid ""
"The third form of @t{cd} extracts an entry from the directory stack, and changes to that directory.  An argument of the form `@t{+}@var{n}' identifies a stack entry by counting from the left of the list "
"shown by the @t{dirs} command, starting with zero.  An argument of the form `@t{-}@var{n}' counts from the right.  If the @t{PUSHD_MINUS} option is set, the meanings of `@t{+}' and `@t{-}' in this context "
"are swapped.  If the @t{POSIX_CD} option is set, this form of @t{cd} is not recognised and will be interpreted as the first form."
msgstr ""
"@t{cd} 的第三种形式是从目录堆栈中提取一个条目，并更改为该目录。 形式为 `@t{+}@var{n}' 的参数从 @t{dirs} 命令显示的列表左侧开始计数(从 0 开始)，以此来识别堆栈条目。 形式为 `@t{-}@var{n}' 的参数从右边开始计"
"数。 如果设置了 @t{PUSHD_MINUS} 选项， `@t{+}' 和 `@t{-}' 在此处的含义将互换。 如果设置了 @t{POSIX_CD} 选项，@t{cd} 的这种形式将不被识别，并被解释为第一种形式。"

#. type: table
#: zsh.texi:13039
msgid ""
"If the @t{-q} (quiet) option is specified, the hook function @t{chpwd} and the functions in the array @t{chpwd_functions} are not called.  This is useful for calls to @t{cd} that do not change the "
"environment seen by an interactive user."
msgstr "如果指定了 @t{-q}（quiet）选项，则不会调用钩子函数 @t{chpwd} 和数组 @t{chpwd_functions} 中的函数。 这对于调用 @t{cd} 且不会改变交互式用户所看到的环境非常有用。"

#. type: table
#: zsh.texi:13047
msgid ""
"If the @t{-s} option is specified, @t{cd} refuses to change the current directory if the given pathname contains symlinks.  If the @t{-P} option is given or the @t{CHASE_LINKS} option is set, symbolic "
"links are resolved to their true values.  If the @t{-L} option is given symbolic links are retained in the directory (and not resolved) regardless of the state of the @t{CHASE_LINKS} option."
msgstr ""
"如果指定了 @t{-s} 选项，@t{cd} 会在给定路径名包含符号链接的情况下拒绝更改当前目录。 如果指定了 @t{-P} 选项或设置了 @t{CHASE_LINKS} 选项，符号链接将被解析为其真实值。 如果给定了 @t{-L} 选项，无论 "
"@t{CHASE_LINKS} 选项的状态如何，符号链接都会保留在目录中（而不会被解析）。"

#. type: t{#1}
#: zsh.texi:13048 zsh.texi:13049
#, no-wrap
msgid "chdir"
msgstr "chdir"

#. type: table
#: zsh.texi:13051
msgid "Same as @t{cd}."
msgstr "与 @t{cd} 一样。"

#. type: findex
#: zsh.texi:13052 zsh.texi:27871
#, no-wrap
msgid "clone"
msgstr "clone"

#. type: table
#: zsh.texi:13054
msgid "See @ref{The zsh/clone Module}."
msgstr "参见 @ref{zsh/clone 模块}."

#. type: item
#: zsh.texi:13056
#, no-wrap
msgid "@t{command} [ @t{-pvV} ] @var{simple command}"
msgstr "@t{command} [ @t{-pvV} ] @var{simple command}"

#. type: table
#: zsh.texi:13064
msgid ""
"The simple command argument is taken as an external command instead of a function or builtin and is executed. If the @t{POSIX_BUILTINS} option is set, builtins will also be executed but certain special "
"properties of them are suppressed. The @t{-p} flag causes a default path to be searched instead of that in @t{$path}. With the @t{-v} flag, @t{command} is similar to @t{whence} and with @t{-V}, it is "
"equivalent to @t{whence -v}."
msgstr ""
"简单命令参数将作为外部命令而非函数或内置命令执行。如果设置了 @t{POSIX_BUILTINS} 选项，内置命令也会被执行，但它们的某些特殊属性会被抑制。@t{-p} 标志会导致搜索默认路径，而不是 @t{$path} 中的路径。使用 @t{-"
"v} 标志时，@t{command} 类似于 @t{whence}，而使用 @t{-V} 时，则等同于 @t{whence -v}。"

#. type: table
#: zsh.texi:13067
msgid "See also @ref{Precommand Modifiers}."
msgstr "另请参阅 @ref{前置命令修饰符}。"

#. type: t{#1}
#: zsh.texi:13068 zsh.texi:28418 zsh.texi:28419
#, no-wrap
msgid "comparguments"
msgstr "comparguments"

#. type: table
#: zsh.texi:13070 zsh.texi:13079 zsh.texi:13082 zsh.texi:13085 zsh.texi:13088 zsh.texi:13091 zsh.texi:13094 zsh.texi:13097
msgid "See @ref{The zsh/computil Module}."
msgstr "参见 @ref{zsh/computil 模块}."

#. type: t{#1}
#: zsh.texi:13071
#, no-wrap
msgid "compcall"
msgstr "compcall"

#. type: table
#: zsh.texi:13073 zsh.texi:13076
msgid "See @ref{The zsh/compctl Module}."
msgstr "参见 @ref{zsh/compctl 模块}."

#. type: findex
#: zsh.texi:13074 zsh.texi:26839
#, no-wrap
msgid "compctl"
msgstr "compctl"

#. type: t{#1}
#: zsh.texi:13077 zsh.texi:28425 zsh.texi:28426
#, no-wrap
msgid "compdescribe"
msgstr "compdescribe"

#. type: t{#1}
#: zsh.texi:13080 zsh.texi:28446 zsh.texi:28447
#, no-wrap
msgid "compfiles"
msgstr "compfiles"

#. type: t{#1}
#: zsh.texi:13083 zsh.texi:28458 zsh.texi:28459
#, no-wrap
msgid "compgroups"
msgstr "compgroups"

#. type: findex
#: zsh.texi:13086 zsh.texi:28466
#, no-wrap
msgid "compquote"
msgstr "compquote"

#. type: t{#1}
#: zsh.texi:13089 zsh.texi:28482 zsh.texi:28484
#, no-wrap
msgid "comptags"
msgstr "comptags"

#. type: t{#1}
#: zsh.texi:13092 zsh.texi:28483 zsh.texi:28485
#, no-wrap
msgid "comptry"
msgstr "comptry"

#. type: t{#1}
#: zsh.texi:13095 zsh.texi:28488 zsh.texi:28489
#, no-wrap
msgid "compvalues"
msgstr "compvalues"

#. type: findex
#: zsh.texi:13098
#, no-wrap
msgid "continue"
msgstr "continue"

#. type: cindex
#: zsh.texi:13099
#, no-wrap
msgid "loops, continuing"
msgstr "循环, 继续"

#. type: cindex
#: zsh.texi:13100
#, no-wrap
msgid "continuing loops"
msgstr "继续循环"

#. type: item
#: zsh.texi:13101
#, no-wrap
msgid "@t{continue} [ @var{n} ]"
msgstr "@t{continue} [ @var{n} ]"

#. type: table
#: zsh.texi:13106
msgid ""
"Resume the next iteration of the enclosing @t{for}, @t{while}, @t{until}, @t{select} or @t{repeat} loop. If an arithmetic expression @var{n} is specified, break out of @var{n}-1 loops and resume at the "
"@var{n}th enclosing loop."
msgstr "继续 @t{for}、@t{while}、@t{until}、@t{select} 或 @t{repeat} 循环的下一次迭代。如果指定了算术表达式 @var{n}，则跳出 @var{n}-1 循环，继续第 @var{n}  个封闭循环。"

#. type: t{#1}
#: zsh.texi:13107 zsh.texi:13108
#, no-wrap
msgid "declare"
msgstr "declare"

#. type: table
#: zsh.texi:13110
msgid "Same as @t{typeset}."
msgstr "与 @t{typeset} 相同。"

#. type: findex
#: zsh.texi:13111
#, no-wrap
msgid "dirs"
msgstr "dirs"

#. type: cindex
#: zsh.texi:13112
#, no-wrap
msgid "directory stack, printing"
msgstr "目录栈, 打印"

#. type: item
#: zsh.texi:13113
#, no-wrap
msgid "@t{dirs} [ @t{-c} ] [ @var{arg} ... ]"
msgstr "@t{dirs} [ @t{-c} ] [ @var{arg} ... ]"

#. type: itemx
#: zsh.texi:13114
#, no-wrap
msgid "@t{dirs} [ @t{-lpv} ]"
msgstr "@t{dirs} [ @t{-lpv} ]"

#. type: table
#: zsh.texi:13121
msgid ""
"With no arguments, print the contents of the directory stack.  Directories are added to this stack with the @t{pushd} command, and removed with the @t{cd} or @t{popd} commands.  If arguments are "
"specified, load them onto the directory stack, replacing anything that was there, and push the current directory onto the stack."
msgstr ""
"在没有参数的情况下，打印目录栈的内容。 使用 @t{pushd} 命令可将目录添加到目录栈，使用 @t{cd} 或 @t{popd} 命令可将目录移除。 如果指定了参数，则会将参数加载到目录栈，替换原有的参数，并将当前目录推入目录栈。"

#. type: table
#: zsh.texi:13126
msgid "clear the directory stack."
msgstr "清空目录栈。"

#. type: table
#: zsh.texi:13129
msgid "print directory names in full instead of using of using @t{~} expressions (@ref{Filename Expansion})."
msgstr "打印完整目录名，而不是使用 @t{~} 表达式（@ref{文件名扩展}）。"

#. type: table
#: zsh.texi:13132
msgid "print directory entries one per line."
msgstr "每行打印一个目录条目。"

#. type: table
#: zsh.texi:13135
msgid "number the directories in the stack when printing."
msgstr "打印时对堆栈中的目录编号。"

#. type: t{#1}
#: zsh.texi:13140 zsh.texi:36791 zsh.texi:36792 zsh.texi:37008
#, no-wrap
msgid "disable"
msgstr "disable"

#. type: cindex
#: zsh.texi:13141
#, no-wrap
msgid "disabling commands"
msgstr "禁用命令"

#. type: cindex
#: zsh.texi:13142
#, no-wrap
msgid "commands, disabling"
msgstr "命令, 禁用"

#. type: item
#: zsh.texi:13143
#, no-wrap
msgid "@t{disable} [ @t{-afmprs} ] @var{name} ..."
msgstr "@t{disable} [ @t{-afmprs} ] @var{name} ..."

#. type: table
#: zsh.texi:13157
msgid ""
"Temporarily disable the @var{name}d hash table elements or patterns.  The default is to disable builtin commands.  This allows you to use an external command with the same name as a builtin command.  The "
"@t{-a} option causes @t{disable} to act on regular or global aliases.  The @t{-s} option causes @t{disable} to act on suffix aliases.  The @t{-f} option causes @t{disable} to act on shell functions.  The "
"@t{-r} options causes @t{disable} to act on reserved words.  Without arguments all disabled hash table elements from the corresponding hash table are printed.  With the @t{-m} flag the arguments are taken "
"as patterns (which should be quoted to prevent them from undergoing filename expansion), and all hash table elements from the corresponding hash table matching these patterns are disabled.  Disabled "
"objects can be enabled with the @t{enable} command."
msgstr ""
"暂时禁用名为 @var{name} 的哈希表元素或模式。 默认情况下禁用内置命令。 这样就可以使用与内置命令同名的外部命令。 @t{-a} 选项会使 @t{disable} 作用于常规或全局别名。 @t{-s} 选项会使 @t{disable} 作用于后缀别"
"名。 通过 @t{-f} 选项，@t{disable} 将作用于 shell 函数。 通过 @t{-r} 选项，@t{disable} 将作用于保留字。 在不带参数的情况下，会打印相应哈希表中所有禁用的哈希表元素。 使用 @t{-m} 标志时，参数将被视为模式（应"
"加引号以防止其进行文件名扩展），相应哈希表中与这些模式匹配的所有哈希表元素都会被禁用。 禁用对象可以使用 @t{enable} 命令启用。"

#. type: table
#: zsh.texi:13162
msgid "With the option @t{-p}, @var{name} ... refer to elements of the shell's pattern syntax as described in @ref{Filename Generation}.  Certain elements can be disabled separately, as given below."
msgstr "用选项 @t{-p}，@var{name} ... 指的是 @ref{文件名生成} 中描述的 shell 模式语法元素。 某些元素可以单独禁用，如下所示。"

#. type: table
#: zsh.texi:13174
msgid ""
"Note that patterns not allowed by the current settings for the options @t{EXTENDED_GLOB}, @t{KSH_GLOB} and @t{SH_GLOB} are never enabled, regardless of the setting here.  For example, if @t{EXTENDED_GLOB} "
"is not active, the pattern @t{^} is ineffective even if `@t{disable -p \"^\"}' has not been issued.  The list below indicates any option settings that restrict the use of the pattern.  It should be noted "
"that setting @t{SH_GLOB} has a wider effect than merely disabling patterns as certain expressions, in particular those involving parentheses, are parsed differently."
msgstr ""
"请注意，选项 @t{EXTENDED_GLOB}、@t{KSH_GLOB} 和 @t{SH_GLOB} 的当前设置不允许的模式将永远无法启用，与此处的设置无关。 例如，如果 @t{EXTENDED_GLOB} 未激活，即使未发出`@t{disable -p \"^\"}'，模式 @t{^} 也不会"
"生效。 下面列出了限制使用该模式的选项设置。 需要注意的是，设置 @t{SH_GLOB} 不仅仅会禁用模式，还会产生更广泛的影响，因为某些表达式，特别是涉及括号的表达式，会以不同的方式进行解析。"

#. type: table
#: zsh.texi:13180
msgid ""
"The following patterns may be disabled; all the strings need quoting on the command line to prevent them from being interpreted immediately as patterns and the patterns are shown below in single quotes as "
"a reminder."
msgstr "可以禁用以下模式；所有字符串都需要在命令行中加注引号，以防止被立即解释为模式，下面显示的这些模式用单引号括起来，以示提醒。"

#. type: t{#1}
#: zsh.texi:13183
#, no-wrap
msgid "'?'"
msgstr "'?'"

#. type: table
#: zsh.texi:13186
msgid "The pattern character @t{?} wherever it occurs, including when preceding a parenthesis with @t{KSH_GLOB}."
msgstr "无论出现在何处，包括在使用 @t{KSH_GLOB} 选项时紧跟在括号之前的模式字符 @t{?}。"

#. type: t{#1}
#: zsh.texi:13187
#, no-wrap
msgid "'*'"
msgstr "'*'"

#. type: table
#: zsh.texi:13190
msgid "The pattern character @t{*} wherever it occurs, including recursive globbing and when preceding a parenthesis with @t{KSH_GLOB}."
msgstr "模式字符 @t{*} 出现的任何地方，包括递归 globbing 以及在括号前使用 （用 @t{KSH_GLOB}） 时。"

#. type: t{#1}
#: zsh.texi:13191
#, no-wrap
msgid "'['"
msgstr "'['"

#. type: table
#: zsh.texi:13193
msgid "Character classes."
msgstr "字符类。"

#. type: item
#: zsh.texi:13194
#, no-wrap
msgid "@t{'<'} (@t{NO_SH_GLOB})"
msgstr "@t{'<'} (@t{NO_SH_GLOB})"

#. type: table
#: zsh.texi:13196
msgid "Numeric ranges."
msgstr "数值范围。"

#. type: item
#: zsh.texi:13197
#, no-wrap
msgid "@t{'|'} (@t{NO_SH_GLOB})"
msgstr "@t{'|'} (@t{NO_SH_GLOB})"

#. type: table
#: zsh.texi:13200
msgid "Alternation in grouped patterns, case statements, or KSH_GLOB parenthesised expressions."
msgstr "分组模式、case 语句或 KSH_GLOB 括弧表达式中的变换（Alternation）。"

#. type: item
#: zsh.texi:13201
#, no-wrap
msgid "@t{'('} (@t{NO_SH_GLOB})"
msgstr "@t{'('} (@t{NO_SH_GLOB})"

#. type: table
#: zsh.texi:13207
msgid ""
"Grouping using single parentheses.  Disabling this does not disable the use of parentheses for @t{KSH_GLOB} where they are introduced by a special character, nor for glob qualifiers (use `@t{setopt "
"NO_BARE_GLOB_QUAL}' to disable glob qualifiers that use parentheses only)."
msgstr "使用单一括号分组。 在 @t{KSH_GLOB} 中，如果括号是由特殊字符引入的，禁用此功能并不会禁用括号，也不会禁用 glob 修饰符（使用  `@t{setopt NO_BARE_GLOB_QUAL}' 禁用仅使用括号的 glob 修饰符）。"

#. type: item
#: zsh.texi:13208
#, no-wrap
msgid "@t{'~'} (@t{EXTENDED_GLOB})"
msgstr "@t{'~'} (@t{EXTENDED_GLOB})"

#. type: table
#: zsh.texi:13210
msgid "Exclusion in the form @var{A}@t{~}@var{B}."
msgstr "以 @var{A}@t{~}@var{B} 的形式排除。"

#. type: item
#: zsh.texi:13211
#, no-wrap
msgid "@t{'^'} (@t{EXTENDED_GLOB})"
msgstr "@t{'^'} (@t{EXTENDED_GLOB})"

#. type: table
#: zsh.texi:13213
msgid "Exclusion in the form @var{A}@t{^}@var{B}."
msgstr "以 @var{A}@t{^}@var{B} 的形式排除。"

#. type: item
#: zsh.texi:13214
#, no-wrap
msgid "@t{'#'} (@t{EXTENDED_GLOB})"
msgstr "@t{'#'} (@t{EXTENDED_GLOB})"

#. type: table
#: zsh.texi:13217
msgid "The pattern character @t{#} wherever it occurs, both for repetition of a previous pattern and for indicating globbing flags."
msgstr "模式字符 @t{#} 出现的地方，既表示重复前一个模式，也表示 globbing 标志。"

#. type: item
#: zsh.texi:13218
#, no-wrap
msgid "@t{'?('} (@t{KSH_GLOB})"
msgstr "@t{'?('} (@t{KSH_GLOB})"

#. type: table
#: zsh.texi:13221
msgid "The grouping form @t{?(}@var{...}@t{)}.  Note this is also disabled if @t{'?'} is disabled."
msgstr "分组形式  @t{?(}@var{...}@t{)}。 请注意，如果禁用了 @t{'?'}，该功能也会被禁用。"

#. type: item
#: zsh.texi:13222
#, no-wrap
msgid "@t{'*('} (@t{KSH_GLOB})"
msgstr "@t{'*('} (@t{KSH_GLOB})"

#. type: table
#: zsh.texi:13225
msgid "The grouping form @t{*(}@var{...}@t{)}.  Note this is also disabled if @t{'*'} is disabled."
msgstr "分组形式 @t{*(}@var{...}@t{)}。 请注意，如果 @t{'*'} 被禁用，该功能也被禁用。"

#. type: item
#: zsh.texi:13226
#, no-wrap
msgid "@t{'+('} (@t{KSH_GLOB})"
msgstr "@t{'+('} (@t{KSH_GLOB})"

#. type: table
#: zsh.texi:13228
msgid "The grouping form @t{+(}@var{...}@t{)}."
msgstr "分组形式 @t{+(}@var{...}@t{)}."

#. type: item
#: zsh.texi:13229
#, no-wrap
msgid "@t{'!('} (@t{KSH_GLOB})"
msgstr "@t{'!('} (@t{KSH_GLOB})"

#. type: table
#: zsh.texi:13231
msgid "The grouping form @t{!(}@var{...}@t{)}."
msgstr "分组形式 @t{!(}@var{...}@t{)}。"

#. type: item
#: zsh.texi:13232
#, no-wrap
msgid "@t{'@@('} (@t{KSH_GLOB})"
msgstr "@t{'@@('} (@t{KSH_GLOB})"

#. type: table
#: zsh.texi:13234
msgid "The grouping form @t{@@(}@var{...}@t{)}."
msgstr "分组形式 @t{@@(}@var{...}@t{)}。"

#. type: t{#1}
#: zsh.texi:13237 zsh.texi:40008
#, no-wrap
msgid "disown"
msgstr "disown"

#. type: item
#: zsh.texi:13239
#, no-wrap
msgid "@t{disown} [ @var{job} ... ]"
msgstr "@t{disown} [ @var{job} ... ]"

#. type: itemx
#: zsh.texi:13240
#, no-wrap
msgid "@var{job} ... @t{&|}"
msgstr "@var{job} ... @t{&|}"

#. type: itemx
#: zsh.texi:13241
#, no-wrap
msgid "@var{job} ... @t{&!}"
msgstr "@var{job} ... @t{&!}"

#. type: table
#: zsh.texi:13246
msgid ""
"Remove the specified @var{job}s from the job table; the shell will no longer report their status, and will not complain if you try to exit an interactive shell with them running or stopped.  If no "
"@var{job} is specified, disown the current job."
msgstr "从作业表中删除指定的 @var{job}；shell 将不再报告这些作业的状态，如果在这些作业运行或停止的情况下尝试退出交互式 shell，shell 也不会抱怨。 如果未指定 @var{job}，则删除当前作业。"

#. type: table
#: zsh.texi:13253
msgid ""
"If the @var{job}s are currently stopped and the @t{AUTO_CONTINUE} option is not set, a warning is printed containing information about how to make them running after they have been disowned.  If one of "
"the latter two forms is used, the @var{job}s will automatically be made running, independent of the setting of the @t{AUTO_CONTINUE} option."
msgstr ""
"如果 @var{job}s 当前已停止运行，且 @t{AUTO_CONTINUE} 选项未设置，系统将打印一条警告信息，说明如何在 @var{job} 被取消所有权后使其继续运行。 如果使用了后两种形式之一，@var{job}s 将自动运行，与 "
"@t{AUTO_CONTINUE} 选项的设置无关。"

#. type: findex
#: zsh.texi:13254
#, no-wrap
msgid "echo"
msgstr "echo"

#. type: item
#: zsh.texi:13255
#, no-wrap
msgid "@t{echo} [ @t{-neE} ] [ @var{arg} ... ]"
msgstr "@t{echo} [ @t{-neE} ] [ @var{arg} ... ]"

#. type: table
#: zsh.texi:13260
msgid "Write each @var{arg} on the standard output, with a space separating each one.  If the @t{-n} flag is not present, print a newline at the end.  @t{echo} recognizes the following escape sequences:"
msgstr "将每个 @var{arg} 写入标准输出，每个参数之间用空格隔开。 如果没有 @t{-n} 标志，则在末尾打印换行。 @t{echo} 可以识别以下转义序列："

#. type: t{#1}
#: zsh.texi:13263 zsh.texi:16461
#, no-wrap
msgid "\\a"
msgstr "\\a"

#. type: table
#: zsh.texi:13265 zsh.texi:16463
msgid "bell character"
msgstr "响铃字符"

#. type: t{#1}
#: zsh.texi:13265 zsh.texi:16463
#, no-wrap
msgid "\\b"
msgstr "\\b"

#. type: table
#: zsh.texi:13267 zsh.texi:16465
msgid "backspace"
msgstr "退格键"

#. type: t{#1}
#: zsh.texi:13267
#, no-wrap
msgid "\\c"
msgstr "\\c"

#. type: table
#: zsh.texi:13269
msgid "suppress subsequent characters and final newline"
msgstr "抑制后续字符和最后的换行符"

#. type: t{#1}
#: zsh.texi:13269
#, no-wrap
msgid "\\e"
msgstr "\\e"

#. type: table
#: zsh.texi:13271 zsh.texi:16467
msgid "escape"
msgstr "转义"

#. type: t{#1}
#: zsh.texi:13271 zsh.texi:16467
#, no-wrap
msgid "\\f"
msgstr "\\f"

#. type: table
#: zsh.texi:13273 zsh.texi:16469
msgid "form feed"
msgstr "分页符（form feed）"

#. type: t{#1}
#: zsh.texi:13273 zsh.texi:16469
#, no-wrap
msgid "\\n"
msgstr "\\n"

#. type: table
#: zsh.texi:13275 zsh.texi:16471
msgid "linefeed (newline)"
msgstr "换行符"

#. type: t{#1}
#: zsh.texi:13275 zsh.texi:16471
#, no-wrap
msgid "\\r"
msgstr "\\r"

#. type: table
#: zsh.texi:13277 zsh.texi:16473
msgid "carriage return"
msgstr "回车"

#. type: t{#1}
#: zsh.texi:13277 zsh.texi:16473
#, no-wrap
msgid "\\t"
msgstr "\\t"

#. type: table
#: zsh.texi:13279 zsh.texi:16475
msgid "horizontal tab"
msgstr "水平制表符"

#. type: t{#1}
#: zsh.texi:13279 zsh.texi:16475
#, no-wrap
msgid "\\v"
msgstr "\\v"

#. type: table
#: zsh.texi:13281 zsh.texi:16477
msgid "vertical tab"
msgstr "垂直制表符"

#. type: t{#1}
#: zsh.texi:13281
#, no-wrap
msgid "\\\\"
msgstr "\\\\"

#. type: table
#: zsh.texi:13283
msgid "backslash"
msgstr "反斜杠"

#. type: item
#: zsh.texi:13283
#, no-wrap
msgid "@t{\\0}@var{NNN}"
msgstr "@t{\\0}@var{NNN}"

#. type: table
#: zsh.texi:13285 zsh.texi:16479
msgid "character code in octal"
msgstr "八进制字符代码"

#. type: item
#: zsh.texi:13285 zsh.texi:16479
#, no-wrap
msgid "@t{\\x}@var{NN}"
msgstr "@t{\\x}@var{NN}"

#. type: table
#: zsh.texi:13287 zsh.texi:16481
msgid "character code in hexadecimal"
msgstr "十六进制字符代码"

#. type: item
#: zsh.texi:13287 zsh.texi:16481
#, no-wrap
msgid "@t{\\u}@var{NNNN}"
msgstr "@t{\\u}@var{NNNN}"

#. type: table
#: zsh.texi:13289 zsh.texi:13291 zsh.texi:16483 zsh.texi:16485
msgid "unicode character code in hexadecimal"
msgstr "十六进制 unicode 字符代码"

#. type: item
#: zsh.texi:13289 zsh.texi:16483
#, no-wrap
msgid "@t{\\U}@var{NNNNNNNN}"
msgstr "@t{\\U}@var{NNNNNNNN}"

#. type: pindex
#: zsh.texi:13294
#, no-wrap
msgid "BSD_ECHO, use of"
msgstr "BSD_ECHO, use of"

#. type: table
#: zsh.texi:13298
msgid "The @t{-E} flag, or the @t{BSD_ECHO} option, can be used to disable these escape sequences.  In the latter case, @t{-e} flag can be used to enable them."
msgstr "@t{-E} 标志或 @t{BSD_ECHO} 选项可用于禁用这些转义序列。 在后一种情况下，可以使用 @t{-e} 标志来启用它们。"

#. type: table
#: zsh.texi:13308
msgid ""
"Note that for standards compliance a double dash does not terminate option processing; instead, it is printed directly.  However, a single dash does terminate option processing, so the first dash, "
"possibly following options, is not printed, but everything following it is printed as an argument.  The single dash behaviour is different from other shells.  For a more portable way of printing text, see "
"@t{printf}, and for a more controllable way of printing text within zsh, see @t{print}."
msgstr ""
"请注意，为了符合标准，双破折号不会终止选项处理，而是直接打印出来。 然而，单破折号会终止选项处理，因此第一个破折号（可能是选项后面的破折号）不会打印，但后面的所有内容都会作为参数打印。 单破折号行为与其他 "
"shell 不同。 如需更加可移植的文本打印方式，请参阅 @t{printf}；如需在 zsh 中更可控的文本打印方式，请参阅 @t{print}。"

#. type: findex
#: zsh.texi:13309 zsh.texi:31078
#, no-wrap
msgid "echotc"
msgstr "echotc"

#. type: table
#: zsh.texi:13311
msgid "See @ref{The zsh/termcap Module}."
msgstr "参见 @ref{zsh/termcap 模块}。"

#. type: findex
#: zsh.texi:13312 zsh.texi:31108
#, no-wrap
msgid "echoti"
msgstr "echoti"

#. type: table
#: zsh.texi:13314
msgid "See @ref{The zsh/terminfo Module}."
msgstr "参见 @ref{zsh/terminfo 模块}。"

#. type: findex
#: zsh.texi:13315
#, no-wrap
msgid "emulate"
msgstr "emulate"

#. type: cindex
#: zsh.texi:13316
#, no-wrap
msgid "compatibility, sh"
msgstr "兼容性, sh"

#. type: cindex
#: zsh.texi:13317
#, no-wrap
msgid "compatibility, ksh"
msgstr "兼容性, ksh"

#. type: cindex
#: zsh.texi:13318
#, no-wrap
msgid "compatibility, csh"
msgstr "兼容性, csh"

#. type: cindex
#: zsh.texi:13319
#, no-wrap
msgid "sh, compatibility"
msgstr "sh, 兼容性"

#. type: cindex
#: zsh.texi:13320
#, no-wrap
msgid "ksh, compatibility"
msgstr "ksh, 兼容性"

#. type: cindex
#: zsh.texi:13321
#, no-wrap
msgid "csh, compatibility"
msgstr "csh, 兼容性"

#. type: item
#: zsh.texi:13322
#, no-wrap
msgid "@t{emulate} [ @t{-lLR} ] [ @{@t{zsh}|@t{sh}|@t{ksh}|@t{csh}@} [ @var{flags} ... ] ]"
msgstr "@t{emulate} [ @t{-lLR} ] [ @{@t{zsh}|@t{sh}|@t{ksh}|@t{csh}@} [ @var{flags} ... ] ]"

#. type: table
#: zsh.texi:13324
msgid "Without any argument print current emulation mode."
msgstr "不带任何参数打印当前模拟模式。"

#. type: table
#: zsh.texi:13337
msgid ""
"With single argument set up zsh options to emulate the specified shell as much as possible.  @cite{csh} will never be fully emulated.  If the argument is not one of the shells listed above, @t{zsh} will "
"be used as a default; more precisely, the tests performed on the argument are the same as those used to determine the emulation at startup based on the shell name, see @ref{Compatibility} .  In addition "
"to setting shell options, the command also restores the pristine state of pattern enables, as if all patterns had been enabled using @t{enable -p}."
msgstr ""
"使用单参数设置 zsh 选项，以尽可能模拟指定的 shell。 @cite{csh} 将不会被完全模拟。 如果参数不是上面列出的 shell，@t{zsh} 将作为默认值使用；更确切地说，对参数进行的测试与启动时根据 shell 名称确定模拟的测试相"
"同，参见 @ref{兼容性} 。 除了设置 shell 选项，该命令还能恢复模式启用的原始状态，就像使用 @t{enable -p} 启用所有模式一样。"

#. type: table
#: zsh.texi:13345
msgid ""
"If the @t{emulate} command occurs inside a function that has been marked for execution tracing with @t{functions -t} then the @t{xtrace} option will be turned on regardless of emulation mode or other "
"options.  Note that code executed inside the function by the @t{.}, @t{source}, or @t{eval} commands is not considered to be running directly from the function, hence does not provoke this behaviour."
msgstr ""
"如果 @t{emulate} 命令出现在使用 @t{functions -t} 标记为执行跟踪的函数内部，那么无论仿真模式或其他选项如何，@t{xtrace} 选项都将开启。 请注意，通过 @t{.}、@t{source} 或 @t{eval} 命令在函数内部执行的代码不被"
"视为直接从函数运行，因此不会引发此行为。"

#. type: table
#: zsh.texi:13360
msgid ""
"If the @t{-R} switch is given, all settable options are reset to their default value corresponding to the specified emulation mode, except for certain options describing the interactive environment; "
"otherwise, only those options likely to cause portability problems in scripts and functions are altered.  If the @t{-L} switch is given, the options @t{LOCAL_OPTIONS}, @t{LOCAL_PATTERNS} and "
"@t{LOCAL_TRAPS} will be set as well, causing the effects of the @t{emulate} command and any @t{setopt}, @t{disable -p} or @t{enable -p}, and @t{trap} commands to be local to the immediately surrounding "
"shell function, if any; normally these options are turned off in all emulation modes except @t{ksh}. The @t{-L} switch is mutually exclusive with the use of @t{-c} in @var{flags}."
msgstr ""
"如果使用 @t{-R} 开关，除了某些描述交互式环境的选项外，所有可设置的选项都将重置为与指定仿真模式相对应的默认值；否则，只有那些可能导致脚本和函数的可移植性问题的选项才会被修改。 如果给定了 @t{-L}开关，选项 "
"@t{LOCAL_OPTIONS}、@t{LOCAL_PATTERNS} 和 @t{LOCAL_TRAPS} 也将被设置，从而导致 @t{emulate} 命令和任何 @t{setopt}、@t{disable -p} 或 @t{enable -p} 以及 @t{trap} 命令的效果与紧随其后的 shell 函数（如果有的"
"话）本地相关； 通常，除了 @t{ksh} 之外，这些选项在所有模拟模式下都是关闭的。@t{-L} 开关与 @var{flags} 中的 @t{-c} 相互排斥。"

#. type: table
#: zsh.texi:13369
msgid ""
"If there is a single argument and the @t{-l} switch is given, the options that would be set or unset (the latter indicated with the prefix `@t{no}') are listed.  @t{-l} can be combined with @t{-L} or @t{-"
"R} and the list will be modified in the appropriate way.  Note the list does not depend on the current setting of options, i.e. it includes all options that may in principle change, not just those that "
"would actually change."
msgstr ""
"如果只有一个参数，且给出了 @t{-l} 开关，则会列出需要设置或取消设置的选项（后者用前缀 `@t{no}' 表示）。 @t{-l} 可以与 @t{-L} 或 @t{-R} 结合使用，列表会以适当方式修改。 请注意，该列表并不取决于当前的选项设"
"置，也就是说，它包括所有原则上可能发生变化的选项，而不仅仅是那些实际会发生变化的选项。"

#. type: table
#: zsh.texi:13375
msgid ""
"The @var{flags} may be any of the invocation-time flags described in @ref{Invocation}, except that `@t{-o EMACS}' and `@t{-o VI}' may not be used.  Flags such as `@t{+r}'/`@t{+o RESTRICTED}' may be "
"prohibited in some circumstances."
msgstr "@var{flags} 可以是 @ref{调用} 中描述的任何调用时标志，但不能使用 `@t{-o EMACS}' 和 `@t{-o VI}' 。 在某些情况下， `@t{+r}'/`@t{+o RESTRICTED}' 等标志可能被禁止使用。"

#. type: table
#: zsh.texi:13383
msgid ""
"If @t{-c} @var{arg} appears in @var{flags}, @var{arg} is evaluated while the requested emulation is temporarily in effect.  In this case the emulation mode and all options are restored to their previous "
"values before @t{emulate} returns.  The @t{-R} switch may precede the name of the shell to emulate; note this has a meaning distinct from including @t{-R} in @var{flags}."
msgstr ""
"如果 @t{-c} @var{arg} 出现在 @var{flags} 中，则 @var{arg} 将在所请求的仿真暂时生效时进行求值。 在这种情况下，在 @t{emulate} 返回之前，仿真模式和所有选项都会恢复到之前的值。 @t{-R} 开关可以放在要模拟的 "
"shell 名称之前；注意这与 @var{flags} 中的 @t{-R} 意义不同。"

#. type: table
#: zsh.texi:13399
msgid ""
"Use of @t{-c} enables `sticky' emulation mode for functions defined within the evaluated expression: the emulation mode is associated thereafter with the function so that whenever the function is executed "
"the emulation (respecting the @t{-R} switch, if present) and all options are set (and pattern disables cleared)  before entry to the function, and the state is restored after exit.  If the function is "
"called when the sticky emulation is already in effect, either within an `@t{emulate} @var{shell} @t{-c}' expression or within another function with the same sticky emulation, entry and exit from the "
"function do not cause options to be altered (except due to standard processing such as the @t{LOCAL_OPTIONS} option).  This also applies to functions marked for autoload within the sticky emulation; the "
"appropriate set of options will be applied at the point the function is loaded as well as when it is run."
msgstr ""
"使用 @t{-c} 可以为在求值表达式中定义的函数启用  `sticky' 仿真模式：仿真模式会随之与函数关联，因此在执行函数时，仿真模式（如果存在 @t{-R} 开关，则尊重 @t{-R} 开关）和所有选项都会在进入函数前设置（并清除模式"
"禁用），并在退出后恢复状态。 如果调用该函数时粘性（ sticky）仿真已经生效（可以在 `@t{emulate} @var{shell} @t{-c}' 中调用，也可以在其他具有相同粘性模拟的函数中调用），则函数的进入和退出不会导致选项发生变化"
"（标准处理（如 @t{LOCAL_OPTIONS} 选项）除外）。 这同样适用于在粘性仿真中标记为自动加载的函数；在加载函数和运行函数时，都会应用相应的选项集。"

#. type: table
#: zsh.texi:13402 zsh.texi:22858 zsh.texi:23540 zsh.texi:24602 zsh.texi:25305 zsh.texi:26380 zsh.texi:32363
msgid "For example:"
msgstr "例如："

#. type: example
#: zsh.texi:13408
#, no-wrap
msgid ""
"emulate sh -c 'fni() @{ setopt cshnullglob; @}\n"
"fno() @{ fni; @}'\n"
"fno\n"
msgstr ""
"emulate sh -c 'fni() @{ setopt cshnullglob; @}\n"
"fno() @{ fni; @}'\n"
"fno\n"

#. type: table
#: zsh.texi:13420
msgid ""
"The two functions @t{fni} and @t{fno} are defined with sticky @t{sh} emulation.  @t{fno} is then executed, causing options associated with emulations to be set to their values in @t{sh}.  @t{fno} then "
"calls @t{fni}; because @t{fni} is also marked for sticky @t{sh} emulation, no option changes take place on entry to or exit from it.  Hence the option @t{cshnullglob}, turned off by @t{sh} emulation, will "
"be turned on within @t{fni} and remain on return to @t{fno}.  On exit from @t{fno}, the emulation mode and all options will be restored to the state they were in before entry to the temporary emulation."
msgstr ""
"@t{fni} 和 @t{fno} 这两个函数是用粘性 @t{sh} 仿真定义的。 执行 @t{fno}后，与仿真相关的选项将被设置为 @t{sh} 中的值。 @t{fno} 然后调用 @t{fni}；由于 @t{fni} 也被标记为粘性 @t{sh} 仿真，因此在进入或退出 "
"@t{fno} 时，选项不会发生变化。 因此，被 @t{sh} 模拟关闭的 @t{cshnullglob} 选项将在 @t{fni} 中开启，并在返回 @t{fno} 时保持不变。 从 @t{fno} 退出后，仿真模式和所有选项将恢复到进入临时仿真前的状态。"

#. type: table
#: zsh.texi:13425
msgid "The documentation above is typically sufficient for the intended purpose of executing code designed for other shells in a suitable environment.  More detailed rules follow."
msgstr "对于在合适的环境中执行为其他 shell 设计的代码这一预期目的来说，上述文件通常已经足够。 更详细的规则在后面。"

#. type: table
#: zsh.texi:13433
msgid ""
"The sticky emulation environment provided by `@t{emulate} @var{shell} @t{-c}' is identical to that provided by entry to a function marked for sticky emulation as a consequence of being defined in such an "
"environment.  Hence, for example, the sticky emulation is inherited by subfunctions defined within functions with sticky emulation."
msgstr "由 `@t{emulate} @var{shell} @t{-c}'  提供的粘性仿真环境与被标记为粘性仿真的函数的入口所提供的环境完全相同。 因此，举例来说，在具有粘性仿真的函数中定义的子函数将继承粘性仿真。"

#. type: table
#: zsh.texi:13438
msgid ""
"No change of options takes place on entry to or exit from functions that are not marked for sticky emulation, other than those that would normally take place, even if those functions are called within "
"sticky emulation."
msgstr "在进入或退出未标记为粘性仿真的函数时，除了正常情况下会发生的变化外，选项不会发生任何变化，即使这些函数是在粘性仿真中调用的。"

#. type: table
#: zsh.texi:13442
msgid "No special handling is provided for functions marked for @t{autoload} nor for functions present in wordcode created by the @t{zcompile} command."
msgstr "对于标记为 @t{autoload} 的函数或 @t{zcompile} 命令创建的字码中的函数，不提供特殊处理。"

#. type: table
#: zsh.texi:13447
msgid ""
"The presence or absence of the @t{-R} switch to @t{emulate} corresponds to different sticky emulation modes, so for example `@t{emulate sh -c}', `@t{emulate -R sh -c}' and `@t{emulate csh -c}' are treated "
"as three distinct sticky emulations."
msgstr "@t{emulate} 的 @t{-R} 开关的存在与否对应不同的粘性仿真模式，因此，例如，`@t{emulate sh -c}'、`@t{emulate -R sh -c}' 和 `@t{emulate csh -c}' 被视为三种不同的粘性仿真。"

#. type: item
#: zsh.texi:13447 zsh.texi:31722
#, no-wrap
msgid "5."
msgstr "5."

#. type: table
#: zsh.texi:13452
msgid ""
"Difference in shell options supplied in addition to the basic emulation also mean the sticky emulations are different, so for example `@t{emulate zsh -c}' and `@t{emulate zsh -o cbases -c}' are treated as "
"distinct sticky emulations."
msgstr "除了基本仿真外，提供的 shell 选项不同也意味着粘性仿真不同，例如，`@t{emulate zsh -c}' 和 `@t{emulate zsh -o cbases -c}' 被视为不同的粘性仿真。"

#. type: t{#1}
#: zsh.texi:13454 zsh.texi:36783 zsh.texi:36784 zsh.texi:37006
#, no-wrap
msgid "enable"
msgstr "enable"

#. type: cindex
#: zsh.texi:13455
#, no-wrap
msgid "enabling commands"
msgstr "启用命令"

#. type: cindex
#: zsh.texi:13456
#, no-wrap
msgid "commands, enabling"
msgstr "命令, 启用"

#. type: item
#: zsh.texi:13457
#, no-wrap
msgid "@t{enable} [ @t{-afmprs} ] @var{name} ..."
msgstr "@t{enable} [ @t{-afmprs} ] @var{name} ..."

#. type: table
#: zsh.texi:13469
msgid ""
"Enable the @var{name}d hash table elements, presumably disabled earlier with @t{disable}.  The default is to enable builtin commands.  The @t{-a} option causes @t{enable} to act on regular or global "
"aliases.  The @t{-s} option causes @t{enable} to act on suffix aliases.  The @t{-f} option causes @t{enable} to act on shell functions.  The @t{-r} option causes @t{enable} to act on reserved words.  "
"Without arguments all enabled hash table elements from the corresponding hash table are printed.  With the @t{-m} flag the arguments are taken as patterns (should be quoted) and all hash table elements "
"from the corresponding hash table matching these patterns are enabled.  Enabled objects can be disabled with the @t{disable} builtin command."
msgstr ""
"启用 @var{name}d 哈希表元素，可能是之前使用 @t{disable} 禁用了该元素。 默认情况下启用内置命令。 @t{-a} 选项会使 @t{enable} 作用于常规或全局别名。 @t{-s} 选项会使 @t{enable} 作用于后缀别名。 通过 @t{-f} 选"
"项，@t{enable} 可以使用 shell 函数。 通过 @t{-r} 选项，@t{enable} 可以使用保留字。 在不带参数的情况下，会打印相应哈希表中所有已启用的哈希表元素。 使用 @t{-m} 标志时，参数被视为模式（应加引号），相应哈希表"
"中与这些模式匹配的所有哈希表元素都会被启用。 可以使用 @t{disable} 内置命令禁用已启用的对象。"

#. type: table
#: zsh.texi:13477
msgid ""
"@t{enable -p} reenables patterns disabled with @t{disable -p}.  Note that it does not override globbing options; for example, `@t{enable -p \"~\"}' does not cause the pattern character @t{~} to be active "
"unless the @t{EXTENDED_GLOB} option is also set.  To enable all possible patterns (so that they may be individually disabled with @t{disable -p}), use `@t{setopt EXTENDED_GLOB KSH_GLOB NO_SH_GLOB}'."
msgstr ""
"@t{enable -p} 可以重新启用 @t{disable -p} 禁用的模式。 请注意，它不会覆盖 globbing 选项；例如，除非同时设置了 @t{EXTENDED_GLOB} 选项，否则 `@t{enable -p \"~\"}' 不会使 @t{~} 模式字符生效。 要启用所有可能的"
"模式（以便使用 @t{disable -p} 单独禁用它们），请使用  `@t{setopt EXTENDED_GLOB KSH_GLOB NO_SH_GLOB}'。"

#. type: cindex
#: zsh.texi:13479
#, no-wrap
msgid "evaluating arguments as commands"
msgstr "把参数当命令执行"

#. type: item
#: zsh.texi:13480
#, no-wrap
msgid "@t{eval} [ @var{arg} ... ]"
msgstr "@t{eval} [ @var{arg} ... ]"

#. type: table
#: zsh.texi:13486
msgid ""
"Read the arguments as input to the shell and execute the resulting command(s) in the current shell process.  The return status is the same as if the commands had been executed directly by the shell; if "
"there are no @var{args} or they contain no commands (i.e. are an empty string or whitespace) the return status is zero."
msgstr "将参数作为输入读入 shell，并在当前 shell 进程中执行产生的命令。 返回状态与 shell 直接执行命令的状态相同；如果没有 @var{args} 或不包含命令（即空字符串或空白），则返回状态为零。"

#. type: item
#: zsh.texi:13487
#, no-wrap
msgid "@t{exec} [ @t{-cl} ] [ @t{-a} @var{argv0} ] [ @var{command} [ @var{arg} ... ] ]"
msgstr "@t{exec} [ @t{-cl} ] [ @t{-a} @var{argv0} ] [ @var{command} [ @var{arg} ... ] ]"

#. type: table
#: zsh.texi:13491
msgid "Replace the current shell with @var{command} rather than forking.  If @var{command} is a shell builtin command or a shell function, the shell executes it, and exits when the command is complete."
msgstr "用 @var{command} 替换当前 shell，而不是分叉。 如果 @var{command} 是 shell 内置命令或 shell 函数，则 shell 会执行该命令，并在命令完成后退出。"

#. type: table
#: zsh.texi:13498
msgid ""
"With @t{-c} clear the environment; with @t{-l} prepend @t{-} to the @t{argv[0]} string of the command executed (to simulate a login shell); with @t{-a} @var{argv0} set the @t{argv[0]} string of the "
"command executed.  See @ref{Precommand Modifiers}."
msgstr "使用 @t{-c} 清除环境；使用 @t{-l} 在执行命令的 @t{argv[0]} 字符串前加上 @t{-}（模拟登录 shell）；使用 @t{-a} @var{argv0} 设置所执行命令的 @t{argv[0]} 字符串。 参见 @ref{前置命令修饰符}。"

#. type: table
#: zsh.texi:13505
msgid ""
"If the option @t{POSIX_BUILTINS} is set, @var{command} is never interpreted as a shell builtin command or shell function.  This means further precommand modifiers such as @t{builtin} and @t{noglob} are "
"also not interpreted within the shell.  Hence @var{command} is always found by searching the command path."
msgstr ""
"如果设置了 @t{POSIX_BUILTINS} 选项，@var{command} 将永远不会被解释为 shell 内置命令或 shell 函数。 这意味着其他命令前修饰符，如 @t{builtin} 和 @t{noglob} 也不会在 shell 中被解释。 因此 @var{command} 总是通"
"过搜索命令路径找到。"

#. type: cindex
#: zsh.texi:13507
#, no-wrap
msgid "redirection, current shell's I/O"
msgstr "重定向, 当前 shell 的 I/O"

#. type: table
#: zsh.texi:13510
msgid "If @var{command} is omitted but any redirections are specified, then the redirections will take effect in the current shell."
msgstr "如果省略了 @var{command}，但指定了重定向，那么重定向将在当前 shell 中生效。"

#. type: findex
#: zsh.texi:13511
#, no-wrap
msgid "exit"
msgstr "exit"

#. type: item
#: zsh.texi:13512
#, no-wrap
msgid "@t{exit} [ @var{n} ]"
msgstr "@t{exit} [ @var{n} ]"

#. type: table
#: zsh.texi:13516
msgid "Exit the shell with the exit status specified by an arithmetic expression @var{n}; if none is specified, use the exit status from the last command executed."
msgstr "使用算术表达式 @var{n} 指定的退出状态退出 shell；如果未指定退出状态，则使用最后执行的命令的退出状态。"

#. type: pindex
#: zsh.texi:13516
#, no-wrap
msgid "IGNORE_EOF, use of"
msgstr "IGNORE_EOF, use of"

#. type: table
#: zsh.texi:13519
msgid "An EOF condition will also cause the shell to exit, unless the @t{IGNORE_EOF} option is set."
msgstr "除非设置了 @t{IGNORE_EOF} 选项，否则 EOF 条件也会导致 shell 退出。"

#. type: table
#: zsh.texi:13524
msgid "See notes at the end of @ref{Jobs & Signals} for some possibly unexpected interactions of the @t{exit} command with jobs."
msgstr "请参阅 @ref{作业和信号} 末尾的注释，了解 @t{exit} 命令与作业之间可能存在的意外交互。"

#. type: item
#: zsh.texi:13526
#, no-wrap
msgid "@t{export} [ @var{name}[@t{=}@var{value}] ... ]"
msgstr "@t{export} [ @var{name}[@t{=}@var{value}] ... ]"

#. type: table
#: zsh.texi:13532
msgid ""
"The specified @var{name}s are marked for automatic export to the environment of subsequently executed commands.  Equivalent to @t{typeset -gx}.  If a parameter specified does not already exist, it is "
"created in the global scope."
msgstr "指定的 @var{name}s 将被标记为自动导出到后续执行命令的环境中。 等同于 @t{typeset -gx}。 如果指定的参数不存在，则会在全局范围内创建它。"

#. type: table
#: zsh.texi:13533 zsh.texi:37014 zsh.texi:37016 zsh.texi:37024 zsh.texi:37026 zsh.texi:37028 zsh.texi:37032 zsh.texi:37036 zsh.texi:37040 zsh.texi:37042 zsh.texi:37052
#, no-wrap
msgid "false"
msgstr "false"

#. type: cindex
#: zsh.texi:13534
#, no-wrap
msgid "doing nothing, unsuccessfully"
msgstr "不做任何事, 不成功"

#. type: item
#: zsh.texi:13535
#, no-wrap
msgid "@t{false} [ @var{arg} ... ]"
msgstr "@t{false} [ @var{arg} ... ]"

#. type: table
#: zsh.texi:13537
msgid "Do nothing and return an exit status of 1."
msgstr "不做任何事并返回退出状态1 。"

#. type: cindex
#: zsh.texi:13539
#, no-wrap
msgid "history, editing"
msgstr "历史, 编辑"

#. type: cindex
#: zsh.texi:13540
#, no-wrap
msgid "editing history"
msgstr "编辑历史"

#. type: item
#: zsh.texi:13542
#, no-wrap
msgid "@t{fc} [ @t{-e} @var{ename} ] [ @t{-s} ] [ @t{-LI} ] [ @t{-m} @var{match} ] [ @var{old}@t{=}@var{new} ... ] [ @var{first} [ @var{last} ] ]"
msgstr "@t{fc} [ @t{-e} @var{ename} ] [ @t{-s} ] [ @t{-LI} ] [ @t{-m} @var{match} ] [ @var{old}@t{=}@var{new} ... ] [ @var{first} [ @var{last} ] ]"

#. type: itemx
#: zsh.texi:13543
#, no-wrap
msgid "@t{fc -l }[ @t{-LI} ] [ @t{-nrdfEiD} ] [ @t{-t} @var{timefmt} ] [ @t{-m} @var{match} ]"
msgstr "@t{fc -l }[ @t{-LI} ] [ @t{-nrdfEiD} ] [ @t{-t} @var{timefmt} ] [ @t{-m} @var{match} ]"

#. type: itemx
#: zsh.texi:13544
#, no-wrap
msgid "@t{@ @ @ @ @ @ }[ @var{old}@t{=}@var{new} ... ] [ @var{first} [ @var{last} ] ]"
msgstr "@t{@ @ @ @ @ @ }[ @var{old}@t{=}@var{new} ... ] [ @var{first} [ @var{last} ] ]"

#. type: itemx
#: zsh.texi:13545
#, no-wrap
msgid "@t{fc -p }[ @t{-a} ] [ @var{filename} [ @var{histsize} [ @var{savehistsize} ] ] ]"
msgstr "@t{fc -p }[ @t{-a} ] [ @var{filename} [ @var{histsize} [ @var{savehistsize} ] ] ]"

#. type: itemx
#: zsh.texi:13546
#, no-wrap
msgid "@t{fc} @t{-P}"
msgstr "@t{fc} @t{-P}"

#. type: itemx
#: zsh.texi:13547
#, no-wrap
msgid "@t{fc} @t{-ARWI} [ @var{filename} ]"
msgstr "@t{fc} @t{-ARWI} [ @var{filename} ]"

#. type: table
#: zsh.texi:13553
msgid ""
"The @t{fc} command controls the interactive history mechanism.  Note that reading and writing of history options is only performed if the shell is interactive.  Usually this is detected automatically, but "
"it can be forced by setting the @t{interactive} option when starting the shell."
msgstr "@t{fc} 命令控制交互式历史机制。 请注意，只有在 shell 是交互式的情况下，才会读写历史选项。 这通常是自动检测到的，但也可以通过在启动 shell 时设置 @t{interactive} 选项来强制执行。"

#. type: table
#: zsh.texi:13562
msgid ""
"The first two forms of this command select a range of events from @var{first} to @var{last} from the history list.  The arguments @var{first} and @var{last} may be specified as a number or as a string.  A "
"negative number is used as an offset to the current history event number.  A string specifies the most recent event beginning with the given string.  All substitutions @var{old}@t{=}@var{new}, if any, are "
"then performed on the text of the events."
msgstr ""
"该命令的前两种形式是从历史记录列表中选择 @var{first} 至 @var{last} 的一系列事件。 参数 @var{first} 和 @var{last} 可以指定为数字或字符串。 负数将用作当前历史事件编号的偏移量。 字符串则指定从给定字符串开始的"
"最新事件。 所有替换 @var{old}@t{=}@var{new} 都将作用在事件文本中（如果有的话）。"

#. type: table
#: zsh.texi:13566
msgid "The range of events selected by numbers can be narrowed further by the following flags."
msgstr "可以通过以下标志进一步缩小用数字选择的事件范围。"

#. type: table
#: zsh.texi:13569
msgid "restricts to only internal events (not from @t{$HISTFILE})"
msgstr "仅限于内部事件（非来自 @t{$HISTFILE} 的事件）"

#. type: table
#: zsh.texi:13573
msgid "restricts to only local events (not from other shells, see @t{SHARE_HISTORY} in @ref{Description of Options} -- note that @t{$HISTFILE} is considered local when read at startup)"
msgstr "只限制本地事件（不包括来自其他 shell 的事件，参见 @ref{选项说明} 中的 @t{SHARE_HISTORY} -- 注意 @t{$HISTFILE} 在启动时读取，会被视为本地事件）"

#. type: table
#: zsh.texi:13576
msgid "takes the first argument as a pattern (which should be quoted) and only the history events matching this pattern are considered"
msgstr "将第一个参数作为模式（应加引号），只有符合该模式的历史事件才会被考虑"

#. type: table
#: zsh.texi:13586
msgid ""
"If @var{first} is not specified, it will be set to -1 (the most recent event), or to -16 if the @t{-l} flag is given.  If @var{last} is not specified, it will be set to @var{first}, or to -1 if the @t{-l} "
"flag is given.  However, if the current event has added entries to the history with `@t{print -s}' or `@t{fc -R}', then the default @var{last} for @t{-l} includes all new history entries since the current "
"event began."
msgstr ""
"如果未指定 @var{first}，则将设置为-1（最新事件），如果给定了 @t{-l} 标志，则将设置为-16。 如果未指定 @var{last}，则会将其设置为 @var{first}，如果给定了 @t{-l} 标志，则会将其设置为-1。 不过，如果当前事件已"
"使用`@t{print -s}' 或 `@t{fc -R}' 向历史记录添加了条目，那么 @t{-l} 的默认 @var{last} 将包含当前事件开始后所有新的历史记录条目。"

#. type: table
#: zsh.texi:13595
msgid ""
"When the @t{-l} flag is given, the resulting events are listed on standard output.  Otherwise the editor program specified by @t{-e} @var{ename} is invoked on a file containing these history events.  If "
"@t{-e} is not given, the value of the parameter @t{FCEDIT} is used; if that is not set the value of the parameter @t{EDITOR} is used; if that is not set a builtin default, usually `@t{vi}' is used.  If "
"@var{ename} is `@t{-}', no editor is invoked.  When editing is complete, the edited command is executed."
msgstr ""
"如果给出 @t{-l} 标志，则会在标准输出中列出生成的事件。 否则，将在包含这些历史事件的文件上调用 @t{-e} @var{ename} 所指定的编辑程序。 如果未给出 @t{-e}，则使用参数 @t{FCEDIT} 的值；如果未设置该参数，则使用参"
"数 @t{EDITOR} 的值；如果未设置该参数，则使用内置缺省值，通常是 `@t{vi}'。 如果 @var{ename} 为 `@t{-}'，则不调用编辑器。 编辑完成后，将执行已编辑的命令。"

#. type: table
#: zsh.texi:13600
msgid "The flag `@t{-s}' is equivalent to `@t{-e -}'.  The flag @t{-r} reverses the order of the events and the flag @t{-n} suppresses event numbers when listing."
msgstr "标志 `@t{-s}' 等同于 `@t{-e -}'。 标志 @t{-r} 会颠倒事件的顺序，而标志 @t{-n} 则会在列出时抑制事件编号。"

#. type: table
#: zsh.texi:13603
msgid "Also when listing,"
msgstr "列出时也是，"

#. type: t{#1}
#: zsh.texi:13604 zsh.texi:15347 zsh.texi:16347 zsh.texi:27048 zsh.texi:33087 zsh.texi:33637
#, no-wrap
msgid "-d"
msgstr "-d"

#. type: table
#: zsh.texi:13606
msgid "prints timestamps for each event"
msgstr "打印每个事件的时间戳"

#. type: table
#: zsh.texi:13609
msgid "prints full time-date stamps in the US `@var{MM}@t{/}@var{DD}@t{/}@var{YY} @var{hh}@t{:}@var{mm}' format"
msgstr "以美国格式 `@var{MM}@t{/}@var{DD}@t{/}@var{YY} @var{hh}@t{:}@var{mm}' ，打印完整的时间日期戳"

#. type: table
#: zsh.texi:13612
msgid "prints full time-date stamps in the European `@var{dd}@t{.}@var{mm}@t{.}@var{yyyy} @var{hh}@t{:}@var{mm}' format"
msgstr "以欧洲格式 `@var{dd}@t{.}@var{mm}@t{.}@var{yyyy} @var{hh}@t{:}@var{mm}' ，打印完整的时间日期戳"

#. type: table
#: zsh.texi:13615
msgid "prints full time-date stamps in ISO8601 `@var{yyyy}@t{-}@var{mm}@t{-}@var{dd} @var{hh}@t{:}@var{mm}' format"
msgstr "以 ISO8601 格式 `@var{yyyy}@t{-}@var{mm}@t{-}@var{dd} @var{hh}@t{:}@var{mm}' 打印完整的时间日期戳"

#. type: item
#: zsh.texi:13615
#, no-wrap
msgid "@t{-t} @var{fmt}"
msgstr "@t{-t} @var{fmt}"

#. type: table
#: zsh.texi:13621
msgid ""
"prints time and date stamps in the given format; @var{fmt} is formatted with the strftime function with the zsh extensions described for the @t{%D@{}@var{string}@t{@}} prompt format in @ref{Prompt "
"Expansion}.  The resulting formatted string must be no more than 256 characters or will not be printed"
msgstr ""
"打印指定格式的时间和日期戳；@var{fmt} 使用 strftime 函数格式化，并使用 @ref{提示符扩展} 中针对 @t{%D@{}@var{string}@t{@}} 提示符格式描述的 zsh 扩展。 生成的格式化字符串不得超过 256 个字符，否则将无法打印"

#. type: table
#: zsh.texi:13625
msgid "prints elapsed times; may be combined with one of the options above"
msgstr "打印经过时间；可与上述选项之一结合使用"

#. type: cindex
#: zsh.texi:13628
#, no-wrap
msgid "history, stack"
msgstr "历史, 栈"

#. type: cindex
#: zsh.texi:13629
#, no-wrap
msgid "stack, history"
msgstr "栈, 历史"

#. type: table
#: zsh.texi:13644
msgid ""
"`@t{fc -p}' pushes the current history list onto a stack and switches to a new history list.  If the @t{-a} option is also specified, this history list will be automatically popped when the current "
"function scope is exited, which is a much better solution than creating a trap function to call `@t{fc -P}' manually.  If no arguments are specified, the history list is left empty, @t{$HISTFILE} is "
"unset, and @t{$HISTSIZE} & @t{$SAVEHIST} are set to their default values.  If one argument is given, @t{$HISTFILE} is set to that filename, @t{$HISTSIZE} & @t{$SAVEHIST} are left unchanged, and the "
"history file is read in (if it exists) to initialize the new list.  If a second argument is specified, @t{$HISTSIZE} & @t{$SAVEHIST} are instead set to the single specified numeric value.  Finally, if a "
"third argument is specified, @t{$SAVEHIST} is set to a separate value from @t{$HISTSIZE}.  You are free to change these environment values for the new history list however you desire in order to "
"manipulate the new history list."
msgstr ""
"`@t{fc -p}' 会将当前历史列表推入栈，并切换到新的历史列表。 如果同时指定了 @t{-a} 选项，当退出当前函数作用域时，历史列表将自动弹出，这比创建一个陷阱函数来手动调用 `@t{fc -P}' 要好得多。 如果未指定参数，则历"
"史列表为空，@t{$HISTFILE} 取消设置，@t{$HISTSIZE} 和 @t{$SAVEHIST} 设置为它们的默认值。 如果指定了一个参数，@t{$HISTFILE} 将设置为那个文件名，@t{$HISTSIZE} 和 @t{$SAVEHIST} 保持不变，并读入历史文件（如果存"
"在）以初始化新列表。 如果指定了第二个参数，@t{$HISTSIZE} 和 @t{$SAVEHIST}将被设置为指定的数值。 最后，如果指定了第三个参数，@t{$SAVEHIST} 将被设置为与 @t{$HISTSIZE} 不同的值。 您可以随意更改新历史记录列表"
"的这些环境值，以便对新历史记录列表进行操作。"

#. type: table
#: zsh.texi:13658
msgid ""
"`@t{fc -P}' pops the history list back to an older list saved by `@t{fc -p}'.  The current list is saved to its @t{$HISTFILE} before it is destroyed (assuming that @t{$HISTFILE} and @t{$SAVEHIST} are set "
"appropriately, of course).  The values of @t{$HISTFILE}, @t{$HISTSIZE}, and @t{$SAVEHIST} are restored to the values they had when `@t{fc -p}' was called.  Note that this restoration can conflict with "
"making these variables \"local\", so your best bet is to avoid local declarations for these variables in functions that use `@t{fc -p}'.  The one other guaranteed-safe combination is declaring these "
"variables to be local at the top of your function and using the automatic option (@t{-a}) with `@t{fc -p}'.  Finally, note that it is legal to manually pop a push marked for automatic popping if you need "
"to do so before the function exits."
msgstr ""
"`@t{fc -P}' 会将历史列表弹回到 `@t{fc -p}' 保存的旧列表。 当前列表会在销毁前保存到 @t{$HISTFILE} 中（当然，前提是 @t{$HISTFILE} 和 @t{$SAVEHIST} 设置得当）。 @t{$HISTFILE}、@t{$HISTSIZE} 和 @t{$SAVEHIST}的"
"值会恢复到调用 `@t{fc -p}' 时的值。 需要注意的是，这种恢复可能与将这些变量设置为 \"本地 \"变量相冲突，因此最好避免在使用 `@t{fc -p}' 的函数中对这些变量进行本地声明。 另一个有保障的安全组合是在函数顶层声明"
"这些变量为局部变量，并与 `@t{fc -p}' 一起使用自动选项 (@t{-a})。 最后需要注意的是，如果需要在函数退出前手动弹出标记为自动弹出的推送，也是合法的。"

#. type: cindex
#: zsh.texi:13660
#, no-wrap
msgid "history, file"
msgstr "历史, 文件"

#. type: cindex
#: zsh.texi:13661
#, no-wrap
msgid "file, history"
msgstr "文件, 历史"

#. type: table
#: zsh.texi:13673
msgid ""
"`@t{fc -R}' reads the history from the given file, `@t{fc -W}' writes the history out to the given file, and `@t{fc -A}' appends the history out to the given file.  If no filename is specified, the "
"@t{$HISTFILE} is assumed.  If the @t{-I} option is added to @t{-R}, only those events that are not already contained within the internal history list are added.  If the @t{-I} option is added to @t{-A} or "
"@t{-W}, only those events that are new since last incremental append/write to the history file are appended/written.  In any case, the created file will have no more than @t{$SAVEHIST} entries."
msgstr ""
"`@t{fc -R}' 从指定文件读取历史记录，`@t{fc -W}' 将历史记录写入指定文件，`@t{fc -A}' 将历史记录追加到指定文件。 如果没有指定文件名，则假定使用 @t{$HISTFILE}。 如果在 @t{-R} 中添加 @t{-I} 选项，则只会添加内"
"部历史列表中尚未包含的事件。 如果 @t{-I} 选项被添加到 @t{-A} 或 @t{-W} 中，则只会添加/写入上次增量添加/写入历史文件后新增的事件。 在任何情况下，创建的文件条目都不会超过 @t{$SAVEHIST} 。"

#. type: t{#1}
#: zsh.texi:13674 zsh.texi:40728
#, no-wrap
msgid "fg"
msgstr "fg"

#. type: cindex
#: zsh.texi:13675
#, no-wrap
msgid "jobs, foregrounding"
msgstr "作业, 前台"

#. type: cindex
#: zsh.texi:13676
#, no-wrap
msgid "jobs, resuming"
msgstr "作业, 恢复"

#. type: item
#: zsh.texi:13677
#, no-wrap
msgid "@t{fg} [ @var{job} ... ]"
msgstr "@t{fg} [ @var{job} ... ]"

#. type: itemx
#: zsh.texi:13678
#, no-wrap
msgid "@var{job} ..."
msgstr "@var{job} ..."

#. type: table
#: zsh.texi:13681
msgid "Bring each specified @var{job} in turn to the foreground.  If no @var{job} is specified, resume the current job."
msgstr "依次将指定的 @var{job} 置于前台。 如果未指定 @var{job}，则恢复当前作业。"

#. type: findex
#: zsh.texi:13682
#, no-wrap
msgid "float"
msgstr "float"

#. type: item
#: zsh.texi:13683
#, no-wrap
msgid "@t{float} [ @{@t{+}|@t{-}@}@t{Hghlprtux} ] [ @{@t{+}|@t{-}@}@t{EFLRZ} [ @var{n} ] ] [ @var{name}[@t{=}@var{value}] ... ]"
msgstr "@t{float} [ @{@t{+}|@t{-}@}@t{Hghlprtux} ] [ @{@t{+}|@t{-}@}@t{EFLRZ} [ @var{n} ] ] [ @var{name}[@t{=}@var{value}] ... ]"

#. type: table
#: zsh.texi:13686
msgid "Equivalent to @t{typeset -E}, except that options irrelevant to floating point numbers are not permitted."
msgstr "等同于 @t{typeset -E}，但不允许使用与浮点数无关的选项。"

#. type: item
#: zsh.texi:13688
#, no-wrap
msgid "@t{functions} [ @{@t{+}|@t{-}@}@t{UkmtTuWz} ] [ @t{-x} @var{num} ] [ @var{name} ... ]"
msgstr "@t{functions} [ @{@t{+}|@t{-}@}@t{UkmtTuWz} ] [ @t{-x} @var{num} ] [ @var{name} ... ]"

#. type: itemx
#: zsh.texi:13689
#, no-wrap
msgid "@t{functions -c} @var{oldfn} @var{newfn}"
msgstr "@t{functions -c} @var{oldfn} @var{newfn}"

#. type: itemx
#: zsh.texi:13690
#, no-wrap
msgid "@t{functions -M} [@t{-s}] @var{mathfn} [ @var{min} [ @var{max} [ @var{shellfn} ] ] ]"
msgstr "@t{functions -M} [@t{-s}] @var{mathfn} [ @var{min} [ @var{max} [ @var{shellfn} ] ] ]"

#. type: itemx
#: zsh.texi:13691
#, no-wrap
msgid "@t{functions -M} [ @t{-m} @var{pattern} ... ]"
msgstr "@t{functions -M} [ @t{-m} @var{pattern} ... ]"

#. type: itemx
#: zsh.texi:13692
#, no-wrap
msgid "@t{functions +M} [ @t{-m} ] @var{mathfn} ..."
msgstr "@t{functions +M} [ @t{-m} ] @var{mathfn} ..."

#. type: table
#: zsh.texi:13697
msgid ""
"Equivalent to @t{typeset -f}, with the exception of the @t{-c}, @t{-x}, @t{-M} and @t{-W} options.  For @t{functions -u} and @t{functions -U}, see @t{autoload}, which provides additional options.  For "
"@t{functions -t} and @t{functions -T}, see @t{typeset -f}."
msgstr ""
"等同于 @t{typeset -f}，但 @t{-c}、@t{-x}、@t{-M} 和 @t{-W} 选项除外。 关于 @t{functions -u} 和 @t{functions -U}，请参见 @t{autoload}，它提供了额外的选项。 关于 @t{functions -t} 和 @t{functions -T}，请参见 "
"@t{typeset -f}。"

#. type: table
#: zsh.texi:13703
msgid ""
"The @t{-x} option indicates that any functions output will have each leading tab for indentation, added by the shell to show syntactic structure, expanded to the given number @var{num} of spaces.  "
"@var{num} can also be 0 to suppress all indentation."
msgstr "@t{-x} 选项表示任何函数的输出都将以开头的制表符作为缩进，这些缩进由 shell 添加，用于显示语法结构，并扩展为指定数量 @var{num} 个空格。@var{num} 也可以为 0，以抑制所有缩进。"

#. type: table
#: zsh.texi:13709
msgid ""
"The @t{-W} option turns on the option @t{WARN_NESTED_VAR} for the named function or functions only.  The option is turned off at the start of nested functions (apart from anonoymous functions) unless the "
"called function also has the @t{-W} attribute."
msgstr "@t{-W} 选项仅为指名的函数开启 @t{WARN_NESTED_VAR} 选项。 除非被调用函数也具有 @t{-W} 属性，否则该选项会在嵌套函数（无名函数除外）的起始位置关闭。"

#. type: table
#: zsh.texi:13718
msgid ""
"The @t{-c} option causes @var{oldfn} to be copied to @var{newfn}.  The copy is efficiently handled internally by reference counting.  If @var{oldfn} was marked for autoload it is first loaded and if this "
"fails the copy fails.  Either function may subsequently be redefined without affecting the other.  A typical idiom is that @var{oldfn} is the name of a library shell function which is then redefined to "
"call @t{newfn}, thereby installing a modified version of the function."
msgstr ""
"@t{-c} 选项会将 @var{oldfn} 复制到 @var{newfn} 中。 内部通过引用计数有效地处理复制。 如果 @var{oldfn} 被标记为自动加载，则会首先加载，如果加载失败，则复制失败。 随后可以重新定义其中一个函数，而不影响另一个"
"函数。 一个典型的惯用手法是 @var{oldfn} 是一个库 shell 函数的名称，重新定义后调用 @t{newfn}，从而安装了该函数的修改版本。"

#. type: table
#: zsh.texi:13721
msgid "@emph{The }@t{-M}@emph{ and }@t{+M}@emph{ flags}"
msgstr "@emph{The }@t{-M}@emph{ and }@t{+M}@emph{ flags}"

#. type: cindex
#: zsh.texi:13721
#, no-wrap
msgid "defining mathematical functions"
msgstr "定义数学函数"

#. type: cindex
#: zsh.texi:13722
#, no-wrap
msgid "functions, defining mathematical"
msgstr "函数, 定义数学的"

#. type: table
#: zsh.texi:13727
msgid "Use of the @t{-M} option may not be combined with any of the options handled by @t{typeset -f}."
msgstr "@t{-M} 选项不得与 @t{typeset -f} 处理的任何选项结合使用。"

#. type: table
#: zsh.texi:13737
msgid ""
"@t{functions -M} @var{mathfn} defines @var{mathfn} as the name of a mathematical function recognised in all forms of arithmetical expressions; see @ref{Arithmetic Evaluation}.  By default @var{mathfn} may "
"take any number of comma-separated arguments.  If @var{min} is given, it must have exactly @var{min} args; if @var{min} and @var{max} are both given, it must have at least @var{min} and at most @var{max} "
"args.  @var{max} may be -1 to indicate that there is no upper limit."
msgstr ""
"@t{functions -M} @var{mathfn} 将 @var{mathfn} 定义为一个数学函数的名称，该函数可用于所有形式的算术表达式；参见 @ref{算术求值}。 默认情况下，@var{mathfn} 可以接受任意多个逗号分隔的参数。 如果给出 "
"@var{min}，则必须有 @var{min} 个参数；如果同时给出 @var{min} 和 @var{max}，则必须至少有 @var{min} 个参数，最多有 @var{max} 个参数。 @var{max} 可以为 -1 表示没有上限。"

#. type: table
#: zsh.texi:13746
msgid ""
"By default the function is implemented by a shell function of the same name; if @var{shellfn} is specified it gives the name of the corresponding shell function while @var{mathfn} remains the name used in "
"arithmetical expressions.  The name of the function in @t{$0} is @var{mathfn} (not @var{shellfn} as would usually be the case), provided the option @t{FUNCTION_ARGZERO} is in effect.  The positional "
"parameters in the shell function correspond to the arguments of the mathematical function call."
msgstr ""
"默认情况下，函数由同名的 shell 函数实现；如果指定了 @var{shellfn}，则会给出相应 shell 函数的名称，而 @var{mathfn} 仍然是算术表达式中使用的名称。 如果选项 @t{FUNCTION_ARGZERO} 有效，则 @t{$0} 中的函数名称"
"为 @var{mathfn}（而不是通常的 @var{shellfn}）。 shell 函数中的位置参数与数学函数调用的参数相对应。"

#. type: table
#: zsh.texi:13761
msgid ""
"The result of the last arithmetical expression evaluated inside the shell function gives the result of the mathematical function.  This is not limited to arithmetic substitutions of the form @t{$((}"
"@var{...}@t{))}, but also includes arithmetical expressions evaluated in any other way, including by the @t{let} builtin, by @t{((}@var{...}@t{))} statements, and even by the @t{return} builtin and by "
"array subscripts.  Therefore, care must be taken not to use syntactical constructs that perform arithmetic evaluation after evaluating what is to be the result of the function.  For example:"
msgstr ""
"shell 函数内部最后一个算术表达式的求值结果给出了数学函数的结果。这不仅限于形式为  @t{$((}@var{...}@t{))} 的算术替换，还包括以任何其他方式计算的算术表达式，包括通过 @t{let} 内置命令，通过 @t{((}@var{...}"
"@t{))} 语句，甚至通过 @t{return} 内置命令和数组下标来进行计算。因此，在计算函数结果之后执行算术计算的语法结构必须小心使用。例如"

#. type: findex
#: zsh.texi:13763
#, no-wrap
msgid "zmath_cube"
msgstr "zmath_cube"

#. type: findex
#: zsh.texi:13764
#, no-wrap
msgid "cube"
msgstr "cube"

#. type: example
#: zsh.texi:13773
#, no-wrap
msgid ""
"# WRONG\n"
"zmath_cube() @{\n"
"  (( $1 * $1 * $1 ))\n"
"  return 0\n"
"@}\n"
"functions -M cube 1 1 zmath_cube\n"
"print $(( cube(3) ))\n"
msgstr ""
"# WRONG\n"
"zmath_cube() @{\n"
"  (( $1 * $1 * $1 ))\n"
"  return 0\n"
"@}\n"
"functions -M cube 1 1 zmath_cube\n"
"print $(( cube(3) ))\n"

#. type: table
#: zsh.texi:13777
msgid "This will print `@t{0}' because of the @t{return}."
msgstr "由于使用了 @t{return}，因此将打印 `@t{0}'。"

#. type: table
#: zsh.texi:13784
msgid ""
"Commenting the @t{return} out would lead to a different problem: the @t{((}@var{...}@t{))} statement would become the last statement in the function, so the @emph{return status} (@t{$?}) of the function "
"would be non-zero (indicating failure) whenever the @emph{arithmetic result} of the function would happen to be zero (numerically):"
msgstr ""
"注释掉 @t{return} 会导致另一个问题： @t{((}@var{...}@t{))}  语句将成为函数的最后一条语句，因此只要函数的 @emph{arithmetic result}  恰好为零（数值上），函数的  @emph{return status} (@t{$?})  就会为非零（表"
"示失败）："

#. type: example
#: zsh.texi:13793
#, no-wrap
msgid ""
"# WRONG\n"
"zmath_cube() @{\n"
"  (( $1 * $1 * $1 ))\n"
"@}\n"
"functions -M cube 1 1 zmath_cube\n"
"print $(( cube(0) ))\n"
msgstr ""
"# WRONG\n"
"zmath_cube() @{\n"
"  (( $1 * $1 * $1 ))\n"
"@}\n"
"functions -M cube 1 1 zmath_cube\n"
"print $(( cube(0) ))\n"

#. type: table
#: zsh.texi:13797
msgid "Instead, the @t{true} builtin can be used:"
msgstr "相反，可以使用 @t{true} 内置函数："

#. type: example
#: zsh.texi:13807
#, no-wrap
msgid ""
"# RIGHT\n"
"zmath_cube() @{\n"
"  (( $1 * $1 * $1 ))\n"
"  true\n"
"@}\n"
"functions -M cube 1 1 zmath_cube\n"
"print $(( cube(3) ))\n"
msgstr ""
"# RIGHT\n"
"zmath_cube() @{\n"
"  (( $1 * $1 * $1 ))\n"
"  true\n"
"@}\n"
"functions -M cube 1 1 zmath_cube\n"
"print $(( cube(3) ))\n"

#. type: table
#: zsh.texi:13818
msgid ""
"If the additional option @t{-s} is given to @t{functions -M}, the argument to the function is a single string: anything between the opening and matching closing parenthesis is passed to the function as a "
"single argument, even if it includes commas or white space.  The minimum and maximum argument specifiers must therefore be 1 if given.  An empty argument list is passed as a zero-length string.  Thus, the "
"following string function takes a single argument, including the commas, and prints 11:"
msgstr ""
"如果在 @t{functions -M} 的基础上给定了附加选项 @t{-s}，那么函数的参数就是一个单独的字符串：开头括号和匹配的结尾括号之间的任何内容都将作为一个单独的参数传递给函数，即使其中包含逗号或空白。 因此，如果给定了"
"最小参数和最大参数，则这两个参数必须为 1。 空参数列表将作为零长度字符串传递。 因此，下面的字符串函数接收单个参数（包括逗号）并打印 11："

#. type: example
#: zsh.texi:13824
#, no-wrap
msgid ""
"stringfn() @{ (( $#1 )); true @}\n"
"functions -Ms stringfn\n"
"print $(( stringfn(foo,bar,rod) ))\n"
msgstr ""
"stringfn() @{ (( $#1 )); true @}\n"
"functions -Ms stringfn\n"
"print $(( stringfn(foo,bar,rod) ))\n"

#. type: table
#: zsh.texi:13831
msgid ""
"@t{functions -M} with no arguments lists all such user-defined functions in the same form as a definition.  With the additional option @t{-m} and a list of arguments, all functions whose @var{mathfn} "
"matches one of the pattern arguments are listed."
msgstr "不带参数的 @t{functions -M} 会以与定义相同的形式列出所有此类用户自定义函数。 如果使用附加选项 @t{-m} 和参数列表，则会列出 @var{mathfn} 与模式参数之一匹配的所有函数。"

#. type: table
#: zsh.texi:13838
msgid ""
"@t{function +M} removes the list of mathematical functions; with the additional option @t{-m} the arguments are treated as patterns and all functions whose @var{mathfn} matches the pattern are removed.  "
"Note that the shell function implementing the behaviour is not removed (regardless of whether its name coincides with @var{mathfn})."
msgstr ""
"@t{function +M} 会移除数学函数列表；如果使用附加选项 @t{-m}，参数会被视为模式，所有 @var{mathfn} 与模式匹配的函数都会被移除。 需要注意的是，实现该行为的 shell 函数不会被移除（无论其名称是否与 @var{mathfn} "
"相同）。"

#. type: findex
#: zsh.texi:13839 zsh.texi:27846
#, no-wrap
msgid "getcap"
msgstr "getcap"

#. type: findex
#: zsh.texi:13842
#, no-wrap
msgid "getln"
msgstr "getln"

#. type: cindex
#: zsh.texi:13843
#, no-wrap
msgid "line, reading"
msgstr "行, 读取"

#. type: cindex
#: zsh.texi:13844
#, no-wrap
msgid "reading a line"
msgstr "读取一行"

#. type: item
#: zsh.texi:13845
#, no-wrap
msgid "@t{getln} [ @t{-AclneE} ] @var{name} ..."
msgstr "@t{getln} [ @t{-AclneE} ] @var{name} ..."

#. type: table
#: zsh.texi:13849
msgid "Read the top value from the buffer stack and put it in the shell parameter @var{name}.  Equivalent to @t{read -zr}."
msgstr "从缓冲堆栈读取顶部值，并将其放入 shell 参数 @var{name}。 等同于 @t{read -zr}。"

#. type: findex
#: zsh.texi:13850
#, no-wrap
msgid "getopts"
msgstr "getopts"

#. type: cindex
#: zsh.texi:13851
#, no-wrap
msgid "options, processing"
msgstr "选项, 处理"

#. type: item
#: zsh.texi:13852
#, no-wrap
msgid "@t{getopts} @var{optstring} @var{name} [ @var{arg} ... ]"
msgstr "@t{getopts} @var{optstring} @var{name} [ @var{arg} ... ]"

#. type: table
#: zsh.texi:13862
msgid ""
"Checks the @var{arg}s for legal options.  If the @var{arg}s are omitted, use the positional parameters.  A valid option argument begins with a `@t{+}' or a `@t{-}'.  An argument not beginning with a "
"`@t{+}' or a `@t{-}', or the argument `@t{-}@t{-}', ends the options.  Note that a single `@t{-}' is not considered a valid option argument.  @var{optstring} contains the letters that @t{getopts} "
"recognizes.  If a letter is followed by a `@t{:}', that option requires an argument.  The options can be separated from the argument by blanks."
msgstr ""
"检查 @var{arg}s 是否为合法选项。 如果省略了 @var{arg}，则使用位置参数。 有效的选项参数以 `@t{+}' 或 `@t{-}' 开头。 如果参数不是以 `@t{+}' 或 `@t{-}' 开头，或者参数 `@t{-}@t{-}'，则选项结束。 注意，单个 "
"`@t{-}' 不被视为有效的选项参数。 @var{optstring} 包含 @t{getopts} 可以识别的字母。 如果一个字母后面有 `@t{:}'，则该选项需要一个参数。 选项与参数之间可以用空格分隔。"

#. type: table
#: zsh.texi:13869
msgid ""
"Each time it is invoked, @t{getopts} places the option letter it finds in the shell parameter @var{name}, prepended with a `@t{+}' when @var{arg} begins with a `@t{+}'.  The index of the next @var{arg} is "
"stored in @t{OPTIND}.  The option argument, if any, is stored in @t{OPTARG}."
msgstr ""
"每次调用时，@t{getopts} 都会将找到的选项字母放入 shell 参数 @var{name}，当 @var{arg} 以 `@t{+}' 开头时，则以 `@t{+}' 作为前缀。 下一个 @var{arg} 的索引存储在 @t{OPTIND} 中。 选项参数（如果有）存储在 "
"@t{OPTARG} 中。"

#. type: vindex
#: zsh.texi:13869
#, no-wrap
msgid "OPTIND, use of"
msgstr "OPTIND, use of"

#. type: vindex
#: zsh.texi:13870
#, no-wrap
msgid "OPTARG, use of"
msgstr "OPTARG, use of"

#. type: table
#: zsh.texi:13882
msgid ""
"The first option to be examined may be changed by explicitly assigning to @t{OPTIND}.  @t{OPTIND} has an initial value of @t{1}, and is normally set to @t{1} upon entry to a shell function and restored "
"upon exit.  (The @t{POSIX_BUILTINS} option disables this, and also changes the way the value is calculated to match other shells.)  @t{OPTARG} is not reset and retains its value from the most recent call "
"to @t{getopts}.  If either of @t{OPTIND} or @t{OPTARG} is explicitly unset, it remains unset, and the index or option argument is not stored.  The option itself is still stored in @var{name} in this case."
msgstr ""
"可以通过显式赋值 @t{OPTIND} 来改变第一个要检查的选项。 @t{OPTIND} 的初始值为 @t{1}，通常在进入 shell 函数时设置为 @t{1}，并在退出时恢复。 (@t{POSIX_BUILTINS} 选项禁用了这一功能，同时也改变了计算值的方式，"
"以便与其他 shell 匹配）。 @t{OPTARG} 不会重置，并保留最近一次调用 @t{getopts} 时的值。 如果 @t{OPTIND} 或 @t{OPTARG} 中的任何一个被明确取消设置，它将保持未设置状态，索引或选项参数也不会被保存。 在这种情况"
"下，选项本身仍存储在 @var{name} 中。"

#. type: table
#: zsh.texi:13890
msgid ""
"A leading `@t{:}' in @var{optstring} causes @t{getopts} to store the letter of any invalid option in @t{OPTARG}, and to set @var{name} to `@t{?}' for an unknown option and to `@t{:}' when a required "
"argument is missing.  Otherwise, @t{getopts} sets @var{name} to `@t{?}' and prints an error message when an option is invalid.  The exit status is nonzero when there are no more options."
msgstr ""
"@var{optstring} 中的前导字母 `@t{:}' 会导致 @t{getopts} 将无效选项的字母保存在 @t{OPTARG} 中，并在出现未知选项时将 @var{name} 设置为`@t{?}' ，在缺少必填参数时将 @var{name} 设置为 `@t{:}' 。 否则，"
"@t{getopts} 会将 @var{name} 设置为 `@t{?}'，并在选项无效时打印错误信息。 当没有更多选项时，退出状态为非零。"

#. type: item
#: zsh.texi:13892
#, no-wrap
msgid "@t{hash} [ @t{-Ldfmrv} ] [ @var{name}[@t{=}@var{value}] ] ..."
msgstr "@t{hash} [ @t{-Ldfmrv} ] [ @var{name}[@t{=}@var{value}] ] ..."

#. type: table
#: zsh.texi:13901
msgid ""
"@t{hash} can be used to directly modify the contents of the command hash table, and the named directory hash table.  Normally one would modify these tables by modifying one's @t{PATH} (for the command "
"hash table) or by creating appropriate shell parameters (for the named directory hash table).  The choice of hash table to work on is determined by the @t{-d} option; without the option the command hash "
"table is used, and with the option the named directory hash table is used."
msgstr ""
"@t{hash} 可用于直接修改命令哈希表和命名目录哈希表的内容。 通常，我们会通过修改 @t{PATH}（命令哈希表）或创建适当的 shell 参数（命名目录哈希表）来修改这些表。 使用哪个哈希表由 @t{-d} 选项决定；不使用该选项时"
"使用命令哈希表，使用该选项时使用命名目录哈希表。"

#. type: table
#: zsh.texi:13906
msgid "A command @var{name} starting with a @t{/} is never hashed, whether by explicit use of the @t{hash} command or otherwise.  Such a command is always found by direct look up in the file system."
msgstr "无论是否明确使用 @t{hash} 命令，以 @t{/} 开头的命令 @var{name} 永远不会散列。 这样的命令总是可以在文件系统中直接查找到。"

#. type: table
#: zsh.texi:13910
msgid "Given no arguments, and neither the @t{-r} or @t{-f} options, the selected hash table will be listed in full."
msgstr "如果没有参数，也没有 @t{-r} 或 @t{-f} 选项，所选的哈希表将全部列出。"

#. type: table
#: zsh.texi:13919
msgid ""
"The @t{-r} option causes the selected hash table to be emptied.  It will be subsequently rebuilt in the normal fashion.  The @t{-f} option causes the selected hash table to be fully rebuilt immediately.  "
"For the command hash table this hashes all the absolute directories in the @t{PATH}, and for the named directory hash table this adds all users' home directories.  These two options cannot be used with "
"any arguments."
msgstr ""
"@t{-r} 选项会清空所选的哈希表。 随后将以正常方式重建。 @t{-f} 选项会立即完全重建所选的哈希表。 对于命令哈希表，这将对 @t{PATH} 中的所有绝对目录进行散列；对于命名目录哈希表，这将添加所有用户的主目录。 这两"
"个选项不能与任何参数一起使用。"

#. type: table
#: zsh.texi:13925
msgid ""
"The @t{-m} option causes the arguments to be taken as patterns (which should be quoted) and the elements of the hash table matching those patterns are printed.  This is the only way to display a limited "
"selection of hash table elements."
msgstr "@t{-m} 选项会将参数视为模式（应加引号），并打印出与这些模式匹配的哈希表元素。 这是显示有限选择的哈希表元素的唯一方法。"

#. type: table
#: zsh.texi:13934
msgid ""
"For each @var{name} with a corresponding @var{value}, put `@var{name}' in the selected hash table, associating it with the pathname `@var{value}'.  In the command hash table, this means that whenever "
"`@var{name}' is used as a command argument, the shell will try to execute the file given by `@var{value}'.  In the named directory hash table, this means that `@var{value}' may be referred to as `@t{~}"
"@var{name}'."
msgstr ""
"对于每个带有相应 @var{value} 的 @var{name}，将 `@var{name}'  放入选定的哈希表，并将其与路径名 `@var{value}' 关联。 在命令哈希表中，这意味着只要将 `@var{name}'  作为命令参数，shell 就会尝试执行 "
"`@var{value}' 给出的文件。 在命名目录哈希表中，这意味着 `@var{value}' 可以被引用为 `@t{~}@var{name}'。"

#. type: table
#: zsh.texi:13941
msgid ""
"For each @var{name} with no corresponding @var{value}, attempt to add @var{name} to the hash table, checking what the appropriate @t{value} is in the normal manner for that hash table.  If an appropriate "
"@t{value} can't be found, then the hash table will be unchanged."
msgstr "对于每个没有对应 @var{value} 的 @var{name} ，都会尝试将 @var{name} 添加到哈希表中，并以该哈希表的正常方式检查相应的 @t{value} 是什么。 如果找不到合适的 @t{value}，哈希表将保持不变。"

#. type: table
#: zsh.texi:13945
msgid "The @t{-v} option causes hash table entries to be listed as they are added by explicit specification.  If has no effect if used with @t{-f}."
msgstr "如果使用 @t{-v} 选项，哈希表条目会以显式指定的方式添加到哈希表中。 如果与 @t{-f} 一起使用，则不会产生任何影响。"

#. type: table
#: zsh.texi:13949
msgid "If the @t{-L} flag is present, then each hash table entry is printed in the form of a call to hash."
msgstr "如果存在 @t{-L} 标志，那么每个哈希表条目都会以调用哈希的形式打印出来。"

#. type: table
#: zsh.texi:13953
msgid "Same as @t{fc -l}."
msgstr "与 @t{fc -l} 相同。"

#. type: findex
#: zsh.texi:13954
#, no-wrap
msgid "integer"
msgstr "integer"

#. type: item
#: zsh.texi:13955
#, no-wrap
msgid "@t{integer} [ @{@t{+}|@t{-}@}@t{Hghlprtux} ] [ @{@t{+}|@t{-}@}@t{LRZi} [ @var{n} ] ] [ @var{name}[@t{=}@var{value}] ... ]"
msgstr "@t{integer} [ @{@t{+}|@t{-}@}@t{Hghlprtux} ] [ @{@t{+}|@t{-}@}@t{LRZi} [ @var{n} ] ] [ @var{name}[@t{=}@var{value}] ... ]"

#. type: table
#: zsh.texi:13958
msgid "Equivalent to @t{typeset -i}, except that options irrelevant to integers are not permitted."
msgstr "等同于 @t{typeset -i}，但不允许使用与整数无关的选项。"

#. type: item
#: zsh.texi:13960
#, no-wrap
msgid "@t{jobs} [ @t{-dlprs} ] [ @var{job} ... ]"
msgstr "@t{jobs} [ @t{-dlprs} ] [ @var{job} ... ]"

#. type: itemx
#: zsh.texi:13961
#, no-wrap
msgid "@t{jobs -Z} @var{string}"
msgstr "@t{jobs -Z} @var{string}"

#. type: table
#: zsh.texi:13970
msgid ""
"Lists information about each given job, or all jobs if @var{job} is omitted.  The @t{-l} flag lists process IDs, and the @t{-p} flag lists process groups.  If the @t{-r} flag is specified only running "
"jobs will be listed and if the @t{-s} flag is given only stopped jobs are shown.  If the @t{-d} flag is given, the directory from which the job was started (which may not be the current directory of the "
"job) will also be shown."
msgstr ""
"列出每个给定作业的信息，如果省略 @var{job}，则列出所有作业的信息。 @t{-l} 标志列出进程 ID，@t{-p} 标志列出进程组。 如果指定了 @t{-r} 标志，则只会列出正在运行的作业；如果指定了 @t{-s} 标志，则只会显示已停止"
"的作业。 如果给出 @t{-d} 标志，还将显示作业的启动目录（可能不是作业的当前目录）。"

#. type: table
#: zsh.texi:13976
msgid ""
"The @t{-Z} option replaces the shell's argument and environment space with the given string, truncated if necessary to fit.  This will normally be visible in @t{ps} (ps(1)) listings.  This feature is "
"typically used by daemons, to indicate their state."
msgstr "@t{-Z} 选项会用给定的字符串替换 shell 的参数和环境空间，必要时会截断。 这通常在  @t{ps} (ps(1)) 列表中可见。 守护进程通常会使用这一功能来显示其状态。"

#. type: table
#: zsh.texi:13986
msgid ""
"Full job control is only available in the top-level interactive shell, not in commands run in the left hand side of pipelines or within the @t{(}@var{...}@t{)} construct.  However, a snapshot of the job "
"state at that point is taken, so it is still possible to use the @t{jobs} builtin, or any parameter providing job information.  This gives information about the state of jobs at the point the subshell was "
"created.  If background processes are created within the subshell, then instead information about those processes is provided."
msgstr ""
"只有在顶层交互 shell 中才能对作业进行全面控制，而在管道左侧或 @t{(}@var{...}@t{)}  结构中运行的命令则无法对作业进行全面控制。 不过，此时作业状态的快照会被提取出来，因此仍然可以使用 @t{jobs} 内置命令或任何"
"提供作业信息的参数。 这将提供子 shell 创建时的作业状态信息。 如果子 shell 中创建了后台进程，则会提供这些进程的相关信息。"

#. type: example
#: zsh.texi:13998
#, no-wrap
msgid ""
"sleep 10 &    # Job in background\n"
"(             # Shell forks\n"
"jobs          # Shows information about \"sleep 10 &\"\n"
"sleep 5 &     # Process in background (no job control)\n"
"jobs          # Shows information about \"sleep 5 &\"\n"
")\n"
msgstr ""
"sleep 10 &    # Job in background\n"
"(             # Shell forks\n"
"jobs          # Shows information about \"sleep 10 &\"\n"
"sleep 5 &     # Process in background (no job control)\n"
"jobs          # Shows information about \"sleep 5 &\"\n"
")\n"

#. type: findex
#: zsh.texi:14000
#, no-wrap
msgid "kill"
msgstr "kill"

#. type: cindex
#: zsh.texi:14001
#, no-wrap
msgid "killing jobs"
msgstr "杀死作业"

#. type: cindex
#: zsh.texi:14002
#, no-wrap
msgid "jobs, killing"
msgstr "作业, 杀死"

#. type: item
#: zsh.texi:14003
#, no-wrap
msgid "@t{kill} [ @t{-s} @var{signal_name} | @t{-n} @var{signal_number} | @t{-}@var{sig} ] @var{job} ..."
msgstr "@t{kill} [ @t{-s} @var{signal_name} | @t{-n} @var{signal_number} | @t{-}@var{sig} ] @var{job} ..."

#. type: itemx
#: zsh.texi:14004
#, no-wrap
msgid "@t{kill} @t{-l} [ @var{sig} ... ]"
msgstr "@t{kill} @t{-l} [ @var{sig} ... ]"

#. type: table
#: zsh.texi:14019
msgid ""
"Sends either @t{SIGTERM} or the specified signal to the given jobs or processes.  Signals are given by number or by names, with or without the `@t{SIG}' prefix.  If the signal being sent is not `@t{KILL}' "
"or `@t{CONT}', then the job will be sent a `@t{CONT}' signal if it is stopped.  The argument @var{job} can be the process ID of a job not in the job list.  In the second form, @t{kill -l}, if @var{sig} is "
"not specified the signal names are listed.  Otherwise, for each @var{sig} that is a name, the corresponding signal number is listed.  For each @var{sig} that is a signal number or a number representing "
"the exit status of a process which was terminated or stopped by a signal the name of the signal is printed."
msgstr ""
"向指定作业或进程发送 @t{SIGTERM} 或指定信号。 信号可以用数字或名称表示，带或不带前缀 `@t{SIG}' 。 如果发送的信号不是`@t{KILL}' 或`@t{CONT}'，那么作业被停止时将发送`@t{CONT}' 信号。 参数 @var{job} 可以是作"
"业列表中没有的作业的进程 ID。 在第二种形式 @t{kill -l} 中，如果未指定 @var{sig}，则会列出信号名称。 否则，将列出每个 @var{sig} 名称对应的信号编号。 每个 @var{sig} 如果是信号编号或代表被信号终止或停止的进程"
"的退出状态的编号，则打印该信号的名称。"

#. type: table
#: zsh.texi:14028
msgid ""
"On some systems, alternative signal names are allowed for a few signals.  Typical examples are @t{SIGCHLD} and @t{SIGCLD} or @t{SIGPOLL} and @t{SIGIO}, assuming they correspond to the same signal number.  "
"@t{kill -l} will only list the preferred form, however @t{kill -l} @var{alt} will show if the alternative form corresponds to a signal number.  For example, under Linux @t{kill -l IO} and @t{kill -l POLL} "
"both output 29, hence @t{kill -IO} and @t{kill -POLL} have the same effect."
msgstr ""
"在某些系统中，少数信号可以使用其他信号名称。 典型的例子是 @t{SIGCHLD} 和 @t{SIGCLD} 或 @t{SIGPOLL} 和 @t{SIGIO}，假设它们对应的信号编号相同。 @t{kill -l} 只列出首选形式，但 @t{kill -l} @var{alt} 则会显示替"
"代形式是否与信号编号对应。 例如，在 Linux 下 @t{kill -l IO} 和 @t{kill -l POLL} 都会输出 29，因此 @t{kill -IO} 和 @t{kill -POLL} 的效果相同。"

#. type: table
#: zsh.texi:14032
msgid "Many systems will allow process IDs to be negative to kill a process group or zero to kill the current process group."
msgstr "许多系统允许进程 ID 为负数时杀死一个进程组，或为零时杀死当前进程组。"

#. type: findex
#: zsh.texi:14033
#, no-wrap
msgid "let"
msgstr "let"

#. type: item
#: zsh.texi:14034
#, no-wrap
msgid "@t{let} @var{arg} ..."
msgstr "@t{let} @var{arg} ..."

#. type: table
#: zsh.texi:14041
msgid ""
"Evaluate each @var{arg} as an arithmetic expression.  See @ref{Arithmetic Evaluation} for a description of arithmetic expressions.  The exit status is 0 if the value of the last expression is nonzero, 1 "
"if it is zero, and 2 if an error occurred."
msgstr "将每个 @var{arg} 作为算术表达式进行求值。 有关算术表达式的说明，请参阅 @ref{算术求值}。 如果最后一个表达式的值不为零，则退出状态为 0；如果为零，则退出状态为 1；如果出现错误，则退出状态为 2。"

#. type: findex
#: zsh.texi:14042
#, no-wrap
msgid "limit"
msgstr "limit"

#. type: cindex
#: zsh.texi:14043 zsh.texi:15308 zsh.texi:15438
#, no-wrap
msgid "resource limits"
msgstr "资源限制"

#. type: cindex
#: zsh.texi:14044 zsh.texi:15309 zsh.texi:15439
#, no-wrap
msgid "limits, resource"
msgstr "限制, 资源"

#. type: item
#: zsh.texi:14045
#, no-wrap
msgid "@t{limit} [ @t{-hs} ] [ @var{resource} [ @var{limit} ] ] ..."
msgstr "@t{limit} [ @t{-hs} ] [ @var{resource} [ @var{limit} ] ] ..."

#. type: table
#: zsh.texi:14050
msgid ""
"Set or display resource limits.  Unless the @t{-s} flag is given, the limit applies only the children of the shell.  If @t{-s} is given without other arguments, the resource limits of the current shell is "
"set to the previously set resource limits of the children."
msgstr "设置或显示资源限制。 除非给出 @t{-s} 标志，否则限制仅适用于 shell 的子代。 如果给定 @t{-s} 而未给定其他参数，则当前 shell 的资源限制将设置为先前设置的子 shell 的资源限制。"

#. type: table
#: zsh.texi:14057
msgid ""
"If @var{limit} is not specified, print the current limit placed on @var{resource}, otherwise set the limit to the specified value.  If the @t{-h} flag is given, use hard limits instead of soft limits.  If "
"no @var{resource} is given, print all limits."
msgstr "如果未指定 @var{limit}，则打印 @var{resource} 的当前限制值，否则将限制值设置为指定值。 如果给出 @t{-h} 标志，则使用硬限制而不是软限制。 如果没有指定 @var{resource}，则打印所有限制。"

#. type: table
#: zsh.texi:14062 zsh.texi:15334
msgid ""
"When looping over multiple resources, the shell will abort immediately if it detects a badly formed argument.  However, if it fails to set a limit for some other reason it will continue trying to set the "
"remaining limits."
msgstr "在对多个资源进行循环时，如果 shell 检测到一个错误的参数，它会立即终止。 但是，如果由于其他原因无法设置限制，它将继续尝试设置剩余的限制。"

#. type: table
#: zsh.texi:14065
msgid "@var{resource} can be one of:"
msgstr "@var{resource} 可以是下面之一:"

#. type: t{#1}
#: zsh.texi:14068
#, no-wrap
msgid "addressspace"
msgstr "addressspace"

#. type: table
#: zsh.texi:14070
msgid "Maximum amount of address space used."
msgstr "已使用的最大地址空间。"

#. type: t{#1}
#: zsh.texi:14070
#, no-wrap
msgid "aiomemorylocked"
msgstr "aiomemorylocked"

#. type: table
#: zsh.texi:14072
msgid "Maximum amount of memory locked in RAM for AIO operations."
msgstr "RAM 中为 AIO 操作锁定的最大内存量。"

#. type: t{#1}
#: zsh.texi:14072
#, no-wrap
msgid "aiooperations"
msgstr "aiooperations"

#. type: table
#: zsh.texi:14074
msgid "Maximum number of AIO operations."
msgstr "AIO 操作的最大次数。"

#. type: t{#1}
#: zsh.texi:14074
#, no-wrap
msgid "cachedthreads"
msgstr "cachedthreads"

#. type: table
#: zsh.texi:14076
msgid "Maximum number of cached threads."
msgstr "缓存线程的最大数量。"

#. type: t{#1}
#: zsh.texi:14076
#, no-wrap
msgid "coredumpsize"
msgstr "coredumpsize"

#. type: table
#: zsh.texi:14078
msgid "Maximum size of a core dump."
msgstr "核心转储的最大容量。"

#. type: t{#1}
#: zsh.texi:14078
#, no-wrap
msgid "cputime"
msgstr "cputime"

#. type: table
#: zsh.texi:14080
msgid "Maximum CPU seconds per process."
msgstr "每个进程的最长 CPU 秒数。"

#. type: t{#1}
#: zsh.texi:14080
#, no-wrap
msgid "datasize"
msgstr "datasize"

#. type: table
#: zsh.texi:14082
msgid "Maximum data size (including stack) for each process."
msgstr "每个进程的最大数据量（包括堆栈）。"

#. type: t{#1}
#: zsh.texi:14082
#, no-wrap
msgid "descriptors"
msgstr "descriptors"

#. type: table
#: zsh.texi:14084
msgid "Maximum value for a file descriptor."
msgstr "文件描述符的最大值。"

#. type: t{#1}
#: zsh.texi:14084
#, no-wrap
msgid "filesize"
msgstr "filesize"

#. type: table
#: zsh.texi:14086
msgid "Largest single file allowed."
msgstr "允许的最大单个文件。"

#. type: t{#1}
#: zsh.texi:14086
#, no-wrap
msgid "kqueues"
msgstr "kqueues"

#. type: table
#: zsh.texi:14088
msgid "Maximum number of kqueues allocated."
msgstr "已分配 kqueues 的最大数量。"

#. type: t{#1}
#: zsh.texi:14088
#, no-wrap
msgid "maxproc"
msgstr "maxproc"

#. type: table
#: zsh.texi:14090
msgid "Maximum number of processes."
msgstr "进程的最大数量。"

#. type: t{#1}
#: zsh.texi:14090
#, no-wrap
msgid "maxpthreads"
msgstr "maxpthreads"

#. type: table
#: zsh.texi:14092
msgid "Maximum number of threads per process."
msgstr "每个进程的最大线程数。"

#. type: t{#1}
#: zsh.texi:14092
#, no-wrap
msgid "memorylocked"
msgstr "memorylocked"

#. type: table
#: zsh.texi:14094
msgid "Maximum amount of memory locked in RAM."
msgstr "内存中锁定的最大内存量。"

#. type: t{#1}
#: zsh.texi:14094
#, no-wrap
msgid "memoryuse"
msgstr "memoryuse"

#. type: table
#: zsh.texi:14096 zsh.texi:14104
msgid "Maximum resident set size."
msgstr "最大驻留集大小。"

#. type: t{#1}
#: zsh.texi:14096
#, no-wrap
msgid "msgqueue"
msgstr "msgqueue"

#. type: table
#: zsh.texi:14098
msgid "Maximum number of bytes in POSIX message queues."
msgstr "POSIX 报文队列的最大字节数。"

#. type: t{#1}
#: zsh.texi:14098
#, no-wrap
msgid "posixlocks"
msgstr "posixlocks"

#. type: table
#: zsh.texi:14100
msgid "Maximum number of POSIX locks per user."
msgstr "每个用户的最大 POSIX 锁数。"

#. type: t{#1}
#: zsh.texi:14100
#, no-wrap
msgid "pseudoterminals"
msgstr "pseudoterminals"

#. type: table
#: zsh.texi:14102
msgid "Maximum number of pseudo-terminals."
msgstr "伪终端的最大数量。"

#. type: t{#1}
#: zsh.texi:14102
#, no-wrap
msgid "resident"
msgstr "resident"

#. type: t{#1}
#: zsh.texi:14104
#, no-wrap
msgid "sigpending"
msgstr "sigpending"

#. type: table
#: zsh.texi:14106
msgid "Maximum number of pending signals."
msgstr "待处理信号的最大数量。"

#. type: t{#1}
#: zsh.texi:14106
#, no-wrap
msgid "sockbufsize"
msgstr "sockbufsize"

#. type: table
#: zsh.texi:14108
msgid "Maximum size of all socket buffers."
msgstr "所有套接字缓冲区的最大容量。"

#. type: t{#1}
#: zsh.texi:14108
#, no-wrap
msgid "stacksize"
msgstr "stacksize"

#. type: table
#: zsh.texi:14110
msgid "Maximum stack size for each process."
msgstr "每个进程的最大堆栈大小。"

#. type: t{#1}
#: zsh.texi:14110
#, no-wrap
msgid "swapsize"
msgstr "swapsize"

#. type: table
#: zsh.texi:14112
msgid "Maximum amount of swap used."
msgstr "使用的最大交换区量。"

#. type: t{#1}
#: zsh.texi:14112
#, no-wrap
msgid "vmemorysize"
msgstr "vmemorysize"

#. type: table
#: zsh.texi:14114
msgid "Maximum amount of virtual memory."
msgstr "虚拟内存的最大容量。"

#. type: table
#: zsh.texi:14121
msgid ""
"Which of these resource limits are available depends on the system.  @var{resource} can be abbreviated to any unambiguous prefix.  It can also be an integer, which corresponds to the integer defined for "
"the resource by the operating system."
msgstr "哪些资源限制可用取决于系统。 @var{resource} 可以缩写为任何明确的前缀。 它也可以是一个整数，对应于操作系统为资源定义的整数。"

#. type: table
#: zsh.texi:14128
msgid ""
"If argument corresponds to a number which is out of the range of the resources configured into the shell, the shell will try to read or write the limit anyway, and will report an error if this fails.  As "
"the shell does not store such resources internally, an attempt to set the limit will fail unless the @t{-s} option is present."
msgstr "如果参数对应的数字超出了 shell 配置的资源范围，shell 会尝试读取或写入限制值，如果失败则会报错。 由于 shell 内部不存储此类资源，因此除非有 @t{-s} 选项，否则设置限制的尝试将失败。"

#. type: table
#: zsh.texi:14131
msgid "@var{limit} is a number, with an optional scaling factor, as follows:"
msgstr "@var{limit} 是一个数字，可选的缩放因子如下："

#. type: item
#: zsh.texi:14134
#, no-wrap
msgid "@var{n}@t{h}"
msgstr "@var{n}@t{h}"

#. type: table
#: zsh.texi:14136
msgid "hours"
msgstr "小时"

#. type: item
#: zsh.texi:14136
#, no-wrap
msgid "@var{n}@t{k}"
msgstr "@var{n}@t{k}"

#. type: table
#: zsh.texi:14138
msgid "kilobytes (default)"
msgstr "千字节 (默认)"

#. type: item
#: zsh.texi:14138
#, no-wrap
msgid "@var{n}@t{m}"
msgstr "@var{n}@t{m}"

#. type: table
#: zsh.texi:14140
msgid "megabytes or minutes"
msgstr "兆字节或分钟"

#. type: item
#: zsh.texi:14140
#, no-wrap
msgid "@var{n}@t{g}"
msgstr "@var{n}@t{g}"

#. type: table
#: zsh.texi:14142
msgid "gigabytes"
msgstr "千兆字节"

#. type: item
#: zsh.texi:14142
#, no-wrap
msgid "[@var{mm}@t{:}]@var{ss}"
msgstr "[@var{mm}@t{:}]@var{ss}"

#. type: table
#: zsh.texi:14144
msgid "minutes and seconds"
msgstr "分和秒"

#. type: table
#: zsh.texi:14150
msgid "The @t{limit} command is not made available by default when the shell starts in a mode emulating another shell.  It can be made available with the command `@t{zmodload -F zsh/rlimits b:limit}'."
msgstr "当 shell 以模拟其他 shell 的模式启动时，@t{limit} 命令默认不可用。 可以使用 `@t{zmodload -F zsh/rlimits b:limit}' 命令来使用它。"

#. type: item
#: zsh.texi:14152
#, no-wrap
msgid "@t{local} [ @{@t{+}|@t{-}@}@t{AHUahlprtux} ] [ @{@t{+}|@t{-}@}@t{EFLRZi} [ @var{n} ] ] [ @var{name}[@t{=}@var{value}] ... ]"
msgstr "@t{local} [ @{@t{+}|@t{-}@}@t{AHUahlprtux} ] [ @{@t{+}|@t{-}@}@t{EFLRZi} [ @var{n} ] ] [ @var{name}[@t{=}@var{value}] ... ]"

#. type: table
#: zsh.texi:14156
msgid ""
"Same as @t{typeset}, except that the options @t{-g}, and @t{-f} are not permitted.  In this case the @t{-x} option does not force the use of @t{-g}, i.e. exported variables will be local to functions."
msgstr "与 @t{typeset} 相同，但不允许使用 @t{-g} 和 @t{-f}。 在这种情况下，@t{-x} 选项并不强制使用 @t{-g}，即导出变量将是函数的局部变量。"

#. type: findex
#: zsh.texi:14157
#, no-wrap
msgid "logout"
msgstr "logout"

#. type: item
#: zsh.texi:14158
#, no-wrap
msgid "@t{logout} [ @var{n} ]"
msgstr "@t{logout} [ @var{n} ]"

#. type: table
#: zsh.texi:14160
msgid "Same as @t{exit}, except that it only works in a login shell."
msgstr "与 @t{exit}相同，但它只在登录 shell 中起作用。"

#. type: item
#: zsh.texi:14161
#, no-wrap
msgid "@t{noglob} @var{simple command}"
msgstr "@t{noglob} @var{simple command}"

#. type: findex
#: zsh.texi:14164
#, no-wrap
msgid "popd"
msgstr "popd"

#. type: item
#: zsh.texi:14165
#, no-wrap
msgid "@t{popd} [ @t{-q} ] [ @{@t{+}|@t{-}@}@var{n} ]"
msgstr "@t{popd} [ @t{-q} ] [ @{@t{+}|@t{-}@}@var{n} ]"

#. type: table
#: zsh.texi:14171
msgid ""
"Remove an entry from the directory stack, and perform a @t{cd} to the new top directory.  With no argument, the current top entry is removed.  An argument of the form `@t{+}@var{n}' identifies a stack "
"entry by counting from the left of the list shown by the @t{dirs} command, starting with zero.  An argument of the form @t{-}@var{n} counts from the right."
msgstr ""
"从目录栈中移除一个条目，并执行 @t{cd} 到新的顶部目录。 如果没有参数，则删除当前的顶部目录。 形式为 `@t{+}@var{n}' 的参数从 @t{dirs} 命令显示的列表左侧开始计数，从 0 开始识别堆栈条目。 形式为 @t{-}@var{n} "
"的参数从右边开始计数。"

#. type: table
#: zsh.texi:14174
msgid "If the @t{PUSHD_MINUS} option is set, the meanings of `@t{+}' and `@t{-}' in this context are swapped."
msgstr "如果设置了 @t{PUSHD_MINUS} 选项， `@t{+}' 和 `@t{-}' 在此处的含义将互换。"

#. type: table
#: zsh.texi:14180
msgid ""
"If the @t{-q} (quiet) option is specified, the hook function @t{chpwd} and the functions in the array @t{$chpwd_functions} are not called, and the new directory stack is not printed.  This is useful for "
"calls to @t{popd} that do not change the environment seen by an interactive user."
msgstr "如果指定了 @t{-q}（quiet）选项，则不会调用钩子函数 @t{chpwd} 和数组 @t{$chpwd_functions} 中的函数，也不会打印新的目录栈。 这对于调用 @t{popd} 不会改变交互式用户所看到的环境非常有用。"

#. type: findex
#: zsh.texi:14181
#, no-wrap
msgid "print"
msgstr "print"

#. type: item
#: zsh.texi:14182
#, no-wrap
msgid "@t{print }[ @t{-abcDilmnNoOpPrsSz} ] [ @t{-u} @var{n} ] [ @t{-f} @var{format} ] [ @t{-C} @var{cols} ]"
msgstr "@t{print }[ @t{-abcDilmnNoOpPrsSz} ] [ @t{-u} @var{n} ] [ @t{-f} @var{format} ] [ @t{-C} @var{cols} ]"

#. type: itemx
#: zsh.texi:14183
#, no-wrap
msgid "@t{@ @ @ @ @ @ }[ @t{-v} @var{name} ] [ @t{-xX} @var{tabstop} ] [ @t{-R} [ @t{-en} ]] [ @var{arg} ... ]"
msgstr "@t{@ @ @ @ @ @ }[ @t{-v} @var{name} ] [ @t{-xX} @var{tabstop} ] [ @t{-R} [ @t{-en} ]] [ @var{arg} ... ]"

#. type: table
#: zsh.texi:14196
msgid ""
"With the `@t{-f}' option the arguments are printed as described by @t{printf}.  With no flags or with the flag `@t{-}', the arguments are printed on the standard output as described by @t{echo}, with the "
"following differences: the escape sequence `@t{\\M-}@var{x}' (or `@t{\\M}@var{x}') metafies the character @var{x} (sets the highest bit), `@t{\\C-}@var{x}' (or `@t{\\C}@var{x}') produces a control "
"character (`@t{\\C-@@}' and `@t{\\C-?}' give the characters NULL and delete), a character code in octal is represented by `@t{\\}@var{NNN}' (instead of `@t{\\0}@var{NNN}'), and `@t{\\E}' is a synonym for "
"`@t{\\e}'.  Finally, if not in an escape sequence, `@t{\\}' escapes the following character and is not printed."
msgstr ""
"如果使用 `@t{-f}' 选项，参数将按照 @t{printf} 的方式打印。 如果没有使用标志或使用标志 `@t{-}'，参数将按照 @t{echo} 的方式打印在标准输出上，但有以下不同： 转义序列 `@t{\\M-}@var{x}' （或`@t{\\M}@var{x}'）会"
"元化字符 @var{x}（设置最高位），`@t{\\C-}@var{x}'（或 `@t{\\C}@var{x}'）会产生一个控制字符（`@t{\\C-@@}' 和 `@t{\\C-?}' 表示 NULL 和 delete 字符），八进制的字符代码用 `@t{\\}@var{NNN}' 表示（而不是 "
"`@t{\\0}@var{NNN}'），而 `@t{\\E}' 是 `@t{\\e}' 的同义词。 最后，如果不在转义序列中，`@t{\\}' 会转义后面的字符，并不会被打印出来。"

#. type: table
#: zsh.texi:14202
msgid "Print arguments with the column incrementing first.  Only useful with the @t{-c} and @t{-C} options."
msgstr "打印参数，列先递增（with the column incrementing first）。 仅在使用 @t{-c} 和 @t{-C} 选项时有用。"

#. type: table
#: zsh.texi:14207
msgid "Recognize all the escape sequences defined for the @t{bindkey} command, see @ref{Zle Builtins}."
msgstr "识别为 @t{bindkey} 命令定义的所有转义序列，参见 @ref{Zle 内置命令}。"

#. type: table
#: zsh.texi:14211
msgid "Print the arguments in columns.  Unless @t{-a} is also given, arguments are printed with the row incrementing first."
msgstr "按列打印参数。 除非同时给出 @t{-a}，否则参数将按行先递增的方式打印。"

#. type: item
#: zsh.texi:14212
#, no-wrap
msgid "@t{-C} @var{cols}"
msgstr "@t{-C} @var{cols}"

#. type: table
#: zsh.texi:14215
msgid "Print the arguments in @var{cols} columns.  Unless @t{-a} is also given, arguments are printed with the row incrementing first."
msgstr "打印 @var{cols} 列中的参数。 除非同时给出 @t{-a}，否则参数将按行先递增的方式打印。"

#. type: table
#: zsh.texi:14219
msgid "Treat the arguments as paths, replacing directory prefixes with @t{~} expressions corresponding to directory names, as appropriate."
msgstr "将参数视为路径，酌情用与目录名相对应的 @t{~} 表达式替换目录前缀。"

#. type: table
#: zsh.texi:14223
msgid "If given together with @t{-o} or @t{-O}, sorting is performed case-independently."
msgstr "如果同时给出 @t{-o} 或 @t{-O}，则排序与大小写无关。"

#. type: table
#: zsh.texi:14229
msgid ""
"Print the arguments separated by newlines instead of spaces.  Note: if the list of arguments is empty, @t{print -l} will still output one empty line. To print a possibly-empty list of arguments one per "
"line, use @t{print -C1}, as in `@t{print -rC1 -- \"$list[@@]\"}'."
msgstr "打印参数，以换行符而不是空格分隔。 注意：如果参数列表为空，@t{print -l}仍会输出一行空行。若要每行打印一个可能为空的参数列表，请使用 @t{print -C1}，如 `@t{print -rC1 -- \"$list[@@]\"}'。"

#. type: table
#: zsh.texi:14234
msgid "Take the first argument as a pattern (should be quoted), and remove it from the argument list together with subsequent arguments that do not match this pattern."
msgstr "将第一个参数作为一个模式（应加引号），并将其从参数列表中移除，同时移除与该模式不匹配的后续参数。"

#. type: table
#: zsh.texi:14237
msgid "Do not add a newline to the output."
msgstr "输出时不要加换行符。"

#. type: table
#: zsh.texi:14242
msgid "Print the arguments separated and terminated by nulls. Again, @t{print -rNC1 -- \"$list[@@]\"} is a canonical way to print an arbitrary list as null-delimited records."
msgstr "打印参数，以空字符分隔和结束。同样，@t{print -rNC1 -- \"$list[@@]\"}  是将任意列表打印为空字符分隔的记录的典型方法。"

#. type: table
#: zsh.texi:14245
msgid "Print the arguments sorted in ascending order."
msgstr "按升序打印参数。"

#. type: table
#: zsh.texi:14248
msgid "Print the arguments sorted in descending order."
msgstr "按降序打印参数。"

#. type: table
#: zsh.texi:14251
msgid "Print the arguments to the input of the coprocess."
msgstr "将参数打印到协进程的输入端。"

#. type: table
#: zsh.texi:14258
msgid "Perform prompt expansion (see @ref{Prompt Expansion}).  In combination with `@t{-f}', prompt escape sequences are parsed only within interpolated arguments, not within the format string."
msgstr "执行提示符扩展（参见 @ref{提示符扩展}）。 与 `@t{-f}' 结合使用时，提示符转义序列只在插值参数中解析，而不在格式字符串中解析。"

#. type: table
#: zsh.texi:14261
msgid "Ignore the escape conventions of @t{echo}."
msgstr "忽略 @t{echo} 的转义规则。"

#. type: table
#: zsh.texi:14267
msgid ""
"Emulate the BSD @t{echo} command, which does not process escape sequences unless the @t{-e} flag is given.  The @t{-n} flag suppresses the trailing newline.  Only the @t{-e} and @t{-n} flags are "
"recognized after @t{-R}; all other arguments and options are printed."
msgstr "模拟 BSD @t{echo} 命令，除非给出 @t{-e} 标志，否则该命令不处理转义序列。 @t{-n} 标志会抑制尾部换行。 只有 @t{-e} 和 @t{-n} 标志会在 @t{-R} 之后被识别；所有其他参数和选项都会被打印。"

#. type: table
#: zsh.texi:14272
msgid "Place the results in the history list instead of on the standard output.  Each argument to the @t{print} command is treated as a single word in the history, regardless of its content."
msgstr "将结果放在历史记录列表中，而不是标准输出中。 在历史记录中，@t{print} 命令的每个参数都被视为一个单词，无论其内容如何。"

#. type: table
#: zsh.texi:14279
msgid ""
"Place the results in the history list instead of on the standard output.  In this case only a single argument is allowed; it will be split into words as if it were a full shell command line.  The effect "
"is similar to reading the line from a history file with the @t{HIST_LEX_WORDS} option active."
msgstr "将结果放在历史记录列表中，而不是标准输出中。 在这种情况下，只允许使用单个参数；参数将被分割成单词，就像完整的 shell 命令行一样。 其效果与使用启用 @t{HIST_LEX_WORDS} 选项时从历史文件读取行类似。"

#. type: item
#: zsh.texi:14280 zsh.texi:14490
#, no-wrap
msgid "@t{-u} @var{n}"
msgstr "@t{-u} @var{n}"

#. type: table
#: zsh.texi:14282
msgid "Print the arguments to file descriptor @var{n}."
msgstr "打印文件描述符 @var{n} 的参数。"

#. type: item
#: zsh.texi:14283
#, no-wrap
msgid "@t{-v} @var{name}"
msgstr "@t{-v} @var{name}"

#. type: table
#: zsh.texi:14285
msgid "Store the printed arguments as the value of the parameter @var{name}."
msgstr "将打印的参数存储为参数 @var{name} 的值。"

#. type: item
#: zsh.texi:14286
#, no-wrap
msgid "@t{-x} @var{tab-stop}"
msgstr "@t{-x} @var{tab-stop}"

#. type: table
#: zsh.texi:14294
msgid ""
"Expand leading tabs on each line of output in the printed string assuming a tab stop every @var{tab-stop} characters.  This is appropriate for formatting code that may be indented with tabs.  Note that "
"leading tabs of any argument to print, not just the first, are expanded, even if @t{print} is using spaces to separate arguments (the column count is maintained across arguments but may be incorrect on "
"output owing to previous unexpanded tabs)."
msgstr ""
"在打印字符串的每一行输出中展开前导制表符，假设每 @var{tab-stop} 个字符有一个制表符停止符。 这适用于格式化可能使用制表符缩进的代码。 请注意，即使 @t{print} 使用空格分隔参数，也会展开要打印的任何参数的前导制"
"表符，而不仅仅是第一个参数的前导制表符（列数在各参数间保持不变，但由于之前的制表符未展开，输出时可能会不正确）。"

#. type: table
#: zsh.texi:14302
msgid ""
"The start of the output of each print command is assumed to be aligned with a tab stop.  Widths of multibyte characters are handled if the option @t{MULTIBYTE} is in effect.  This option is ignored if "
"other formatting options are in effect, namely column alignment or @t{printf} style, or if output is to a special location such as shell history or the command line editor."
msgstr ""
"每条打印命令的输出起始位置假定与制表符停止位置对齐。 如果选项 @t{MULTIBYTE} 有效，多字节字符的宽度将被处理。 如果使用了其他格式化选项，即列对齐或 @t{printf} 样式，或者输出到 shell 历史记录或命令行编辑器等"
"特殊位置，则该选项将被忽略。"

#. type: item
#: zsh.texi:14303
#, no-wrap
msgid "@t{-X} @var{tab-stop}"
msgstr "@t{-X} @var{tab-stop}"

#. type: table
#: zsh.texi:14307
msgid "This is similar to @t{-x}, except that all tabs in the printed string are expanded.  This is appropriate if tabs in the arguments are being used to produce a table format."
msgstr "这与 @t{-x} 类似，但打印字符串中的所有制表符都会展开。 如果参数中的制表符被用于生成表格格式，则可以使用这种方法。"

#. type: t{#1}
#: zsh.texi:14308 zsh.texi:14459 zsh.texi:15720 zsh.texi:27101
#, no-wrap
msgid "-z"
msgstr "-z"

#. type: table
#: zsh.texi:14310
msgid "Push the arguments onto the editing buffer stack, separated by spaces."
msgstr "将参数推入编辑缓冲堆栈，中间用空格隔开。"

#. type: table
#: zsh.texi:14317
msgid "If any of `@t{-m}', `@t{-o}' or `@t{-O}' are used in combination with `@t{-f}' and there are no arguments (after the removal process in the case of `@t{-m}') then nothing is printed."
msgstr "如果`@t{-m}', `@t{-o}' 或 `@t{-O}' 中的任何一个与 `@t{-f}' 结合使用，且没有参数（ `@t{-m}' 的情况下是在删除参数后），则不会打印任何内容。"

#. type: findex
#: zsh.texi:14318
#, no-wrap
msgid "printf"
msgstr "printf"

#. type: item
#: zsh.texi:14319
#, no-wrap
msgid "@t{printf} [ @t{-v} @var{name} ] @var{format} [ @var{arg} ... ]"
msgstr "@t{printf} [ @t{-v} @var{name} ] @var{format} [ @var{arg} ... ]"

#. type: table
#: zsh.texi:14334
msgid ""
"Print the arguments according to the format specification. Formatting rules are the same as used in C. The same escape sequences as for @t{echo} are recognised in the format. All C conversion "
"specifications ending in one of @t{csdiouxXeEfgGn} are handled. In addition to this, `@t{%b}' can be used instead of `@t{%s}' to cause escape sequences in the argument to be recognised and `@t{%q}' can be "
"used to quote the argument in such a way that allows it to be reused as shell input. With the numeric format specifiers, if the corresponding argument starts with a quote character, the numeric value of "
"the following character is used as the number to print; otherwise the argument is evaluated as an arithmetic expression. See @ref{Arithmetic Evaluation} for a description of arithmetic expressions. With "
"`@t{%n}', the corresponding argument is taken as an identifier which is created as an integer parameter."
msgstr ""
"根据格式规范打印参数。格式规则与 C 语言中的相同。格式中可识别与 @t{echo} 相同的转义序列。所有以 @t{csdiouxeEfgGn} 结尾的 C 转换规范都会被处理。除此之外，还可以使用 `@t{%b}' 代替 `@t{%s}'，以识别参数中的转"
"义序列，并使用 `@t{%q}'  引用参数，使其可以作为 shell 输入重复使用。对于数字格式指定符，如果相应参数以引号字符开头，则使用后面字符的数值作为要打印的数字；否则参数将作为算术表达式求值。有关算术表达式的说"
"明，请参阅 @ref{算术求值}。使用 `@t{%n}' 时，相应参数将作为标识符，并作为整数参数创建。"

#. type: table
#: zsh.texi:14342
msgid ""
"Normally, conversion specifications are applied to each argument in order but they can explicitly specify the @var{n}th argument is to be used by replacing `@t{%}' by `@t{%}@var{n}@t{$}' and `@t{*}' by "
"`@t{*}@var{n}@t{$}'.  It is recommended that you do not mix references of this explicit style with the normal style and the handling of such mixed styles may be subject to future change."
msgstr ""
"通常，转换规范会按顺序应用于每个参数，但也可以通过将 `@t{%}' 替换为 `@t{%}@var{n}@t{$}' ，将 `@t{*}' 替换为 `@t{*}@var{n}@t{$}'，从而明确指定使用第 @var{n} 个参数。 建议不要将这种明确样式的引用与正常样式的"
"引用混用，而且对这种混用样式的处理可能会在将来发生变化。"

#. type: table
#: zsh.texi:14349
msgid ""
"If arguments remain unused after formatting, the format string is reused until all arguments have been consumed. With the @t{print} builtin, this can be suppressed by using the @t{-r} option. If more "
"arguments are required by the format than have been specified, the behaviour is as if zero or an empty string had been specified as the argument."
msgstr ""
"如果参数在格式化后仍未使用，格式化字符串会被重复使用，直到所有参数都被用完。使用 @t{print} 内置命令时，可以通过 @t{-r} 选项来抑制这种情况。如果格式化所需的参数多于指定的参数，则行为与指定零参数或空字符串相"
"同。"

#. type: table
#: zsh.texi:14355
msgid ""
"The @t{-v} option causes the output to be stored as the value of the parameter @var{name}, instead of printed. If @var{name} is an array and the format string is reused when consuming arguments then one "
"array element will be used for each use of the format string."
msgstr "@t{-v} 选项会将输出存储为参数 @var{name} 的值，而不是打印出来。如果 @var{name} 是一个数组，且格式字符串在使用参数时被重复使用，那么每次使用格式字符串时都会使用一个数组元素。"

#. type: findex
#: zsh.texi:14356
#, no-wrap
msgid "pushd"
msgstr "pushd"

#. type: pindex
#: zsh.texi:14357
#, no-wrap
msgid "PUSHD_TO_HOME, use of"
msgstr "PUSHD_TO_HOME, use of"

#. type: pindex
#: zsh.texi:14359
#, no-wrap
msgid "CDABLE_VARS, use of"
msgstr "CDABLE_VARS, use of"

#. type: pindex
#: zsh.texi:14360
#, no-wrap
msgid "PUSHD_SILENT, use of"
msgstr "PUSHD_SILENT, use of"

#. type: item
#: zsh.texi:14361
#, no-wrap
msgid "@t{pushd} [ @t{-qsLP} ] [ @var{arg} ]"
msgstr "@t{pushd} [ @t{-qsLP} ] [ @var{arg} ]"

#. type: itemx
#: zsh.texi:14362
#, no-wrap
msgid "@t{pushd} [ @t{-qsLP} ] @var{old} @var{new}"
msgstr "@t{pushd} [ @t{-qsLP} ] @var{old} @var{new}"

#. type: itemx
#: zsh.texi:14363
#, no-wrap
msgid "@t{pushd} [ @t{-qsLP} ] @{@t{+}|@t{-}@}@var{n}"
msgstr "@t{pushd} [ @t{-qsLP} ] @{@t{+}|@t{-}@}@var{n}"

#. type: table
#: zsh.texi:14374
msgid ""
"Change the current directory, and push the old current directory onto the directory stack.  In the first form, change the current directory to @var{arg}.  If @var{arg} is not specified, change to the "
"second directory on the stack (that is, exchange the top two entries), or change to @t{$HOME} if the @t{PUSHD_TO_HOME} option is set or if there is only one entry on the stack.  Otherwise, @var{arg} is "
"interpreted as it would be by @t{cd}.  The meaning of @var{old} and @var{new} in the second form is also the same as for @t{cd}."
msgstr ""
"更改当前目录，并将旧的当前目录推入目录栈。 在第一种形式中，将当前目录更改为 @var{arg}。 如果未指定 @var{arg}，则将当前目录更改为目录栈中的第二个目录（即交换前两个条目）；如果设置了 @t{PUSHD_TO_HOME}选项，"
"或者目录栈中只有一个条目，则将当前目录更改为 @t{$HOME}。 否则，@var{arg} 将按照 @t{cd} 的方式解释。 第二种形式中 @var{old} 和 @var{new} 的含义也与 @t{cd} 相同。"

#. type: table
#: zsh.texi:14382
msgid ""
"The third form of @t{pushd} changes directory by rotating the directory list.  An argument of the form `@t{+}@var{n}' identifies a stack entry by counting from the left of the list shown by the @t{dirs} "
"command, starting with zero.  An argument of the form `@t{-}@var{n}' counts from the right.  If the @t{PUSHD_MINUS} option is set, the meanings of `@t{+}' and `@t{-}' in this context are swapped."
msgstr ""
"@t{pushd} 的第三种形式是通过旋转目录列表来更改目录。 形式为 `@t{+}@var{n}' 的参数从 @t{dirs} 命令显示的目录列表的左边开始计数，从 0 开始，以此确定堆栈条目。 形式为 `@t{-}@var{n}'的参数从右边开始计数。 如果"
"设置了 @t{PUSHD_MINUS} 选项， `@t{+}' 和 `@t{-}' 在此处的含义将互换。"

#. type: table
#: zsh.texi:14388
msgid ""
"If the @t{-q} (quiet) option is specified, the hook function @t{chpwd} and the functions in the array @t{$chpwd_functions} are not called, and the new directory stack is not printed.  This is useful for "
"calls to @t{pushd} that do not change the environment seen by an interactive user."
msgstr "如果指定了 @t{-q}（quiet）选项，则不会调用钩子函数 @t{chpwd} 和数组 @t{$chpwd_functions} 中的函数，也不会打印新的目录栈。 这对于调用 @t{pushd} 不会改变交互式用户所看到的环境非常有用。"

#. type: table
#: zsh.texi:14393
msgid "If the option @t{-q} is not specified and the shell option @t{PUSHD_SILENT} is not set, the directory stack will be printed after a @t{pushd} is performed."
msgstr "如果未指定选项 @t{-q}，也未设置 shell 选项 @t{PUSHD_SILENT}，则将在执行 @t{pushd} 之后打印目录堆栈。"

#. type: table
#: zsh.texi:14397
msgid "The options @t{-s}, @t{-L} and @t{-P} have the same meanings as for the @t{cd} builtin."
msgstr "选项 @t{-s}、@t{-L} 和 @t{-P} 的含义与 @t{cd} 内置命令相同。"

#. type: findex
#: zsh.texi:14398
#, no-wrap
msgid "pushln"
msgstr "pushln"

#. type: item
#: zsh.texi:14399
#, no-wrap
msgid "@t{pushln} [ @var{arg} ... ]"
msgstr "@t{pushln} [ @var{arg} ... ]"

#. type: table
#: zsh.texi:14401
msgid "Equivalent to @t{print -nz}."
msgstr "等价于 @t{print -nz}。"

#. type: t{#1}
#: zsh.texi:14402 zsh.texi:22562
#, no-wrap
msgid "pwd"
msgstr "pwd"

#. type: pindex
#: zsh.texi:14403
#, no-wrap
msgid "CHASE_LINKS, use of"
msgstr "CHASE_LINKS, use of"

#. type: item
#: zsh.texi:14404
#, no-wrap
msgid "@t{pwd} [ @t{-rLP} ]"
msgstr "@t{pwd} [ @t{-rLP} ]"

#. type: table
#: zsh.texi:14409
msgid ""
"Print the absolute pathname of the current working directory.  If the @t{-r} or the @t{-P} flag is specified, or the @t{CHASE_LINKS} option is set and the @t{-L} flag is not given, the printed path will "
"not contain symbolic links."
msgstr "打印当前工作目录的绝对路径名。 如果指定了 @t{-r} 或 @t{-P} 标志，或设置了 @t{CHASE_LINKS} 选项且未给出 @t{-L} 标志，则打印的路径将不包含符号链接。"

#. type: table
#: zsh.texi:14413
msgid "Same as @t{fc -e -}."
msgstr "与 @t{fc -e -} 一样。"

#. type: findex
#: zsh.texi:14414
#, no-wrap
msgid "read"
msgstr "read"

#. type: item
#: zsh.texi:14417
#, no-wrap
msgid "@t{read }[ @t{-rszpqAclneE} ] [ @t{-t} [ @var{num} ] ] [ @t{-k} [ @var{num} ] ] [ @t{-d} @var{delim} ]"
msgstr "@t{read }[ @t{-rszpqAclneE} ] [ @t{-t} [ @var{num} ] ] [ @t{-k} [ @var{num} ] ] [ @t{-d} @var{delim} ]"

#. type: itemx
#: zsh.texi:14418
#, no-wrap
msgid "@t{@ @ @ @ @ }[ @t{-u} @var{n} ] [ [@var{name}][@t{?}@var{prompt}] ] [ @var{name} ...  ]"
msgstr "@t{@ @ @ @ @ }[ @t{-u} @var{n} ] [ [@var{name}][@t{?}@var{prompt}] ] [ @var{name} ...  ]"

#. type: table
#: zsh.texi:14428
msgid ""
"Read one line and break it into fields using the characters in @t{$IFS} as separators, except as noted below.  The first field is assigned to the first @var{name}, the second field to the second "
"@var{name}, etc., with leftover fields assigned to the last @var{name}.  If @var{name} is omitted then @t{REPLY} is used for scalars and @t{reply} for arrays."
msgstr ""
"读取一行，并使用 @t{$IFS} 中的字符作为分隔符将其分成多个字段,下文所述情况除外。 第一个字段分配给第一个 @var{name}，第二个字段分配给第二个 @var{name}，以此类推，剩余字段分配给最后一个 @var{name}。 如果省略 "
"@var{name}， @t{REPLY} 用于标量， @t{reply}用于数组。"

#. type: table
#: zsh.texi:14435
msgid "Raw mode: a `@t{\\}' at the end of a line does not signify line continuation and backslashes in the line don't quote the following character and are not removed."
msgstr "原始模式：行末的 `@t{\\}' 不表示续行，行中的反斜线不会引述后面的字符，也不会被删除。"

#. type: table
#: zsh.texi:14438
msgid "Don't echo back characters if reading from the terminal."
msgstr "如果从终端读取，则不回显字符。"

#. type: t{#1}
#: zsh.texi:14439 zsh.texi:15363 zsh.texi:19881 zsh.texi:20101 zsh.texi:27249 zsh.texi:28839 zsh.texi:41142
#, no-wrap
msgid "-q"
msgstr "-q"

#. type: table
#: zsh.texi:14447
msgid ""
"Read only one character from the terminal and set @var{name} to `@t{y}' if this character was `@t{y}' or `@t{Y}' and to `@t{n}' otherwise.  With this flag set the return status is zero only if the "
"character was `@t{y}' or `@t{Y}'.  This option may be used with a timeout (see @t{-t}); if the read times out, or encounters end of file, status 2 is returned.  Input is read from the terminal unless one "
"of @t{-u} or @t{-p} is present.  This option may also be used within zle widgets."
msgstr ""
"只从终端读取一个字符，如果该字符为 `@t{y}'  或 `@t{Y}' ，则将 @var{name} 设置为 `@t{y}'，否则设置为 `@t{n}'。 设置该标志后，只有当字符为 `@t{y}' 或 `@t{Y}' 时，返回状态才为零。 该选项可与超时（参见 @t{-"
"t}）一起使用；如果读取超时或遇到文件结束，则返回状态 2。 除非有 @t{-u} 或 @t{-p}，否则将从终端读取输入。 该选项也可在 zle 小部件中使用。"

#. type: item
#: zsh.texi:14448
#, no-wrap
msgid "@t{-k} [ @var{num} ]"
msgstr "@t{-k} [ @var{num} ]"

#. type: table
#: zsh.texi:14453
msgid ""
"Read only one (or @var{num}) characters.  All are assigned to the first @var{name}, without word splitting.  This flag is ignored when @t{-q} is present.  Input is read from the terminal unless one of @t{-"
"u} or @t{-p} is present.  This option may also be used within zle widgets."
msgstr "只读取一个（或 @var{num} 个）字符。 所有字符都分配给第一个 @var{name}，不分词。 当 @t{-q} 存在时，该标志将被忽略。 除非有 @t{-u} 或 @t{-p}，否则将从终端读取输入。 该选项也可在 zle 小部件中使用。"

#. type: table
#: zsh.texi:14458
msgid "Note that despite the mnemonic `key' this option does read full characters, which may consist of multiple bytes if the option @t{MULTIBYTE} is set."
msgstr "请注意，尽管使用了 `key' 这个助记符，但该选项确实读取全字符，如果设置了 @t{MULTIBYTE} 选项，全字符可能由多个字节组成。"

#. type: table
#: zsh.texi:14464
msgid ""
"Read one entry from the editor buffer stack and assign it to the first @var{name}, without word splitting.  Text is pushed onto the stack with `@t{print -z}' or with @t{push-line} from the line editor "
"(see @ref{Zsh Line Editor}).  This flag is ignored when the @t{-k} or @t{-q} flags are present."
msgstr ""
"从编辑器缓冲堆栈中读取一个条目并将其赋值给第一个 @var{name}，不进行分词。 文本将通过 `@t{print -z}' 或行编辑器（参见 @ref{Zsh 行编辑器}）中的 @t{push-line} 推入堆栈。 当 @t{-k} 或 @t{-q} 标志存在时，该标志"
"将被忽略。"

#. type: table
#: zsh.texi:14469
msgid "The input read is printed (echoed) to the standard output.  If the @t{-e} flag is used, no input is assigned to the parameters."
msgstr "读取的输入将打印（回显）到标准输出。 如果使用 @t{-e} 标志，则不会将输入分配给参数。"

#. type: table
#: zsh.texi:14473
msgid "The first @var{name} is taken as the name of an array and all words are assigned to it."
msgstr "第一个 @var{name} 将作为数组的名称，所有单词都将赋值给它。"

#. type: table
#: zsh.texi:14482
msgid ""
"These flags are allowed only if called inside a function used for completion (specified with the @t{-K} flag to @t{compctl}).  If the @t{-c} flag is given, the words of the current command are read. If "
"the @t{-l} flag is given, the whole line is assigned as a scalar.  If both flags are present, @t{-l} is used and @t{-c} is ignored."
msgstr ""
"只有在用于补全的函数（使用 @t{compctl} 的 @t{-K} 标志指定 ）中调用时，才允许使用这些标志。 如果给出 @t{-c} 标志，将读取当前命令的字词。如果给出 @t{-l} 标志，则将整行作为标量分配。 如果两个标志都存在，则使"
"用 @t{-l}，忽略 @t{-c}。"

#. type: table
#: zsh.texi:14489
msgid ""
"Together with @t{-c}, the number of the word the cursor is on is read.  With @t{-l}, the index of the character the cursor is on is read.  Note that the command name is word number 1, not word 0, and that "
"when the cursor is at the end of the line, its character index is the length of the line plus one."
msgstr "与 @t{-c} 一起使用时，将读取光标所在单词的编号。 使用 @t{-l}，将读取光标所在字符的索引。 请注意，命令名称是字 1，而不是字 0，当光标位于行尾时，其字符索引是行长加 1。"

#. type: table
#: zsh.texi:14492
msgid "Input is read from file descriptor @var{n}."
msgstr "输入内容从文件描述符 @var{n} 读取。"

#. type: table
#: zsh.texi:14495
msgid "Input is read from the coprocess."
msgstr "从协进程读取输入。"

#. type: item
#: zsh.texi:14496
#, no-wrap
msgid "@t{-d} @var{delim}"
msgstr "@t{-d} @var{delim}"

#. type: table
#: zsh.texi:14499
msgid "Input is terminated by the first character of @var{delim} instead of by newline."
msgstr "输入以 @var{delim} 的第一个字符结束，而不是换行。"

#. type: item
#: zsh.texi:14500
#, no-wrap
msgid "@t{-t} [ @var{num} ]"
msgstr "@t{-t} [ @var{num} ]"

#. type: table
#: zsh.texi:14508
msgid ""
"Test if input is available before attempting to read.  If @var{num} is present, it must begin with a digit and will be evaluated to give a number of seconds, which may be a floating point number; in this "
"case the read times out if input is not available within this time.  If @var{num} is not present, it is taken to be zero, so that @t{read} returns immediately if no input is available.  If no input is "
"available, return status 1 and do not set any variables."
msgstr ""
"在尝试读取数据前测试输入是否可用。 如果存在 @var{num}，它必须以数字开头，并将被计算为一个秒数（可以是浮点数）；在这种情况下，如果在这段时间内输入不可用，读取将超时。 如果 @var{num} 不存在，它将被视为零，因"
"此 @t{read} 会在没有输入时立即返回。 如果没有输入，则返回状态 1，不设置任何变量。"

#. type: table
#: zsh.texi:14513
msgid ""
"This option is not available when reading from the editor buffer with @t{-z}, when called from within completion with @t{-c} or @t{-l}, with @t{-q} which clears the input queue before reading, or within "
"zle where other mechanisms should be used to test for input."
msgstr "当使用 @t{-z} 从编辑器缓冲区读取数据时，当使用 @t{-c} 或 @t{-l} 从补全中调用时，当使用 @t{-q} 在读取数据前清空输入队列时，或者在使用其他机制测试输入的 zle 中，该选项不可用。"

#. type: table
#: zsh.texi:14522
msgid ""
"Note that read does not attempt to alter the input processing mode.  The default mode is canonical input, in which an entire line is read at a time, so usually `@t{read -t}' will not read anything until "
"an entire line has been typed.  However, when reading from the terminal with @t{-k} input is processed one key at a time; in this case, only availability of the first character is tested, so that e.g. "
"`@t{read -t -k 2}' can still block on the second character.  Use two instances of `@t{read -t -k}' if this is not what is wanted."
msgstr ""
"请注意，read 并不试图改变输入处理模式。 默认模式是规范输入，即一次读取整行内容，因此通常在输入整行内容之前， `@t{read -t}' 不会读取任何内容。 不过，当使用 @t{-k} 从终端读取时，输入是一次处理一个键的；在这"
"种情况下，只测试第一个字符是否可用，因此，例如`@t{read -t -k 2}' 仍然可以阻塞第二个字符。 如果不希望这样，请使用两个 `@t{read -t -k}' 实例。"

#. type: table
#: zsh.texi:14529
msgid "If the first argument contains a `@t{?}', the remainder of this word is used as a @var{prompt} on standard error when the shell is interactive."
msgstr "如果第一个参数包含 `@t{?}'，则在 shell 处于交互状态时，该单词的剩余部分将作为 @var{prompt} 出现在标准错误中。"

#. type: table
#: zsh.texi:14535
msgid ""
"The value (exit status) of @t{read} is 1 when an end-of-file is encountered, or when @t{-c} or @t{-l} is present and the command is not called from a @t{compctl} function, or as described for @t{-q}.  "
"Otherwise the value is 0."
msgstr "当遇到文件结束、出现 @t{-c} 或 @t{-l} 且命令不是由 @t{compctl} 函数调用时，或如 @t{-q} 所述，@t{read}的值（退出状态）为 1。 否则，值为 0。"

#. type: table
#: zsh.texi:14541
msgid ""
"The behavior of some combinations of the @t{-k}, @t{-p}, @t{-q}, @t{-u} and @t{-z} flags is undefined.  Presently @t{-q} cancels all the others, @t{-p} cancels @t{-u}, @t{-k} cancels @t{-z}, and otherwise "
"@t{-z} cancels both @t{-p} and @t{-u}."
msgstr "@t{-k}、@t{-p}、@t{-q}、@t{-u} 和 @t{-z} 标志的某些组合，其行为未定义。 目前 @t{-q} 取消了所有其他标志，@t{-p} 取消了 @t{-u}，@t{-k} 取消了 @t{-z}，而 @t{-z} 则同时取消了 @t{-p} 和 @t{-u}。"

#. type: table
#: zsh.texi:14544
msgid "The @t{-c} or @t{-l} flags cancel any and all of @t{-kpquz}."
msgstr "@t{-c} 或 @t{-l} 标志会取消所有 @t{-kpquz} 标志。"

#. type: cindex
#: zsh.texi:14545
#, no-wrap
msgid "parameters, marking readonly"
msgstr "参数, 只读标记"

#. type: table
#: zsh.texi:14549
msgid "Same as @t{typeset -r}.  With the @t{POSIX_BUILTINS} option set, same as @t{typeset -gr}."
msgstr "与 @t{typeset -r} 相同。 设置 @t{POSIX_BUILTINS} 选项后，与 @t{typeset -gr} 相同。"

#. type: t{#1}
#: zsh.texi:14550 zsh.texi:14551 zsh.texi:23349
#, no-wrap
msgid "rehash"
msgstr "rehash"

#. type: table
#: zsh.texi:14553
msgid "Same as @t{hash -r}."
msgstr "与 @t{hash -r} 一样。"

#. type: findex
#: zsh.texi:14554
#, no-wrap
msgid "return"
msgstr "return"

#. type: cindex
#: zsh.texi:14555
#, no-wrap
msgid "functions, returning from"
msgstr "函数, 返回"

#. type: item
#: zsh.texi:14556
#, no-wrap
msgid "@t{return} [ @var{n} ]"
msgstr "@t{return} [ @var{n} ]"

#. type: table
#: zsh.texi:14561
msgid "Causes a shell function or `@t{.}' script to return to the invoking script with the return status specified by an arithmetic expression @var{n}.  For example, the following prints `@t{42}':"
msgstr "使 shell 函数或 `@t{.}' 脚本以算术表达式 @var{n} 指定的返回状态返回调用脚本。 例如，下面的代码会打印  `@t{42}'："

#. type: example
#: zsh.texi:14566
#, no-wrap
msgid ""
"() @{ integer foo=40; return \"foo + 2\" @}\n"
"echo $?\n"
msgstr ""
"() @{ integer foo=40; return \"foo + 2\" @}\n"
"echo $?\n"

#. type: table
#: zsh.texi:14572
msgid "If @var{n} is omitted, the return status is that of the last command executed."
msgstr "如果省略 @var{n}，则返回最后执行命令的状态。"

#. type: table
#: zsh.texi:14583
msgid ""
"If @t{return} was executed from a trap in a @t{TRAP}@var{NAL} function, the effect is different for zero and non-zero return status.  With zero status (or after an implicit return at the end of the trap), "
"the shell will return to whatever it was previously processing; with a non-zero status, the shell will behave as interrupted except that the return status of the trap is retained.  Note that the numeric "
"value of the signal which caused the trap is passed as the first argument, so the statement `@t{return \"128+$1\"}' will return the same status as if the signal had not been trapped."
msgstr ""
"如果 @t{return} 是通过 @t{TRAP}@var{NAL} 函数中的陷阱执行的，那么返回状态为零和非零的效果是不同的。 状态为零（或陷阱结束后隐式返回）时，shell 将返回到之前正在处理的内容；状态为非零时，除了保留陷阱的返回状"
"态外，shell 的行为与中断时一样。 需要注意的是，引起陷阱的信号的数值会作为第一个参数传递，因此语句 `@t{return \"128+$1\"}' 返回的状态与信号未被捕获时的状态相同。"

#. type: findex
#: zsh.texi:14587
#, no-wrap
msgid "set"
msgstr "set"

#. type: cindex
#: zsh.texi:14588
#, no-wrap
msgid "parameters, listing"
msgstr "参数, 列出"

#. type: cindex
#: zsh.texi:14589 zsh.texi:14686
#, no-wrap
msgid "parameters, positional"
msgstr "参数, 位置的"

#. type: cindex
#: zsh.texi:14590
#, no-wrap
msgid "parameters, setting array"
msgstr "参数, 设置数组"

#. type: cindex
#: zsh.texi:14591
#, no-wrap
msgid "array parameters, setting"
msgstr "数组参数, 设置"

#. type: item
#: zsh.texi:14594
#, no-wrap
msgid "@t{set }[ @{@t{+}|@t{-}@}@var{options} | @{@t{+}|@t{-}@}@t{o} [ @var{option_name} ] ] ... [ @{@t{+}|@t{-}@}@t{A} [ @var{name} ] ]"
msgstr "@t{set }[ @{@t{+}|@t{-}@}@var{options} | @{@t{+}|@t{-}@}@t{o} [ @var{option_name} ] ] ... [ @{@t{+}|@t{-}@}@t{A} [ @var{name} ] ]"

#. type: itemx
#: zsh.texi:14595
#, no-wrap
msgid "@t{@ @ @ @ }[ @var{arg} ... ]"
msgstr "@t{@ @ @ @ }[ @var{arg} ... ]"

#. type: table
#: zsh.texi:14606
msgid ""
"Set the options for the shell and/or set the positional parameters, or declare and set an array.  If the @t{-s} option is given, it causes the specified arguments to be sorted before assigning them to the "
"positional parameters (or to the array @var{name} if @t{-A} is used).  With @t{+s} sort arguments in descending order.  For the meaning of the other flags, see @ref{Options}.  Flags may be specified by "
"name using the @t{-o} option. If no option name is supplied with @t{-o}, the current option states are printed: see the description of @t{setopt} below for more information on the format.  With @t{+o} "
"they are printed in a form that can be used as input to the shell."
msgstr ""
"设置 shell 的选项和/或设置位置参数，或声明和设置数组。 如果给定 @t{-s} 选项，则会在将指定参数赋值给位置参数（如果使用 @t{-A}，则赋值给数组 @var{name}）之前对其进行排序。 使用 @t{+s} 会按降序对参数排序。 其"
"他标志的含义请参见 @ref{选项}。 可以使用 @t{-o} 选项指定标志的名称。如果没有用 @t{-o} 提供选项名称，则会打印当前的选项状态：有关格式的更多信息，请参阅下文对 @t{setopt} 的描述。 如果使用 @t{+o}，则以可作为 "
"shell 输入的形式打印。"

#. type: table
#: zsh.texi:14611
msgid "If the @t{-A} flag is specified, @var{name} is set to an array containing the given @var{arg}s; if no @var{name} is specified, all arrays are printed together with their values."
msgstr "如果指定了 @t{-A} 标志，@var{name} 将被设置为包含给定 @var{arg} 的数组；如果没有指定 @var{name}，所有数组将连同其值一起打印。"

#. type: table
#: zsh.texi:14616
msgid "If @t{+A} is used and @var{name} is an array, the given arguments will replace the initial elements of that array; if no @var{name} is specified, all arrays are printed without their values."
msgstr "如果使用 @t{+A}，且 @var{name} 是数组，则给定参数将替换该数组的初始元素；如果未指定 @var{name}，则打印所有数组，但不包含其值。"

#. type: table
#: zsh.texi:14624
msgid ""
"The behaviour of arguments after @t{-A} @var{name} or @t{+A} @var{name} depends on whether the option @t{KSH_ARRAYS} is set.  If it is not set, all arguments following @var{name} are treated as values for "
"the array, regardless of their form.  If the option is set, normal option processing continues at that point; only regular arguments are treated as values for the array.  This means that"
msgstr ""
"@t{-A} @var{name} 或  @t{+A} @var{name} 之后的参数的行为取决于是否设置了 @t{KSH_ARRAYS} 选项。 如果未设置，则 @var{name} 后面的所有参数都会被视为数组的值，无论其形式如何。 如果设置了该选项，则会继续进行正"
"常的选项处理；只有常规参数才会被视为数组的值。 这意味着"

#. type: example
#: zsh.texi:14628
#, no-wrap
msgid "set -A array -x -- foo\n"
msgstr "set -A array -x -- foo\n"

#. type: table
#: zsh.texi:14633
msgid "sets @t{array} to `@t{-x -}@t{- foo}' if @t{KSH_ARRAYS} is not set, but sets the array to @t{foo} and turns on the option `@t{-x}' if it is set."
msgstr "如果 @t{KSH_ARRAYS} 未设置，则会将 @t{array} 设置为 `@t{-x -}@t{- foo}' ；如果设置了@t{KSH_ARRAYS},则会将数组设置为 @t{foo}，并开启 `@t{-x}' 选项。"

#. type: table
#: zsh.texi:14639
msgid ""
"If the @t{-A} flag is not present, but there are arguments beyond the options, the positional parameters are set.  If the option list (if any)  is terminated by `@t{-}@t{-}', and there are no further "
"arguments, the positional parameters will be unset."
msgstr "如果没有 @t{-A} 标志，但在选项之外还有参数，则会设置位置参数。 如果选项列表（如果有）以 `@t{-}@t{-}' 结束，且没有其他参数，位置参数将被取消设置。"

#. type: table
#: zsh.texi:14644
msgid ""
"If no arguments and no `@t{-}@t{-}' are given, then the names and values of all parameters are printed on the standard output.  If the only argument is `@t{+}', the names of all parameters are printed."
msgstr "如果没有参数，也没有给出 `@t{-}@t{-}' ，那么所有参数的名称和值都会打印在标准输出上。 如果唯一的参数是 `@t{+}'，则会打印所有参数的名称。"

#. type: table
#: zsh.texi:14649
msgid "For historical reasons, `@t{set -}' is treated as `@t{set +xv}' and `@t{set -} @var{args}' as `@t{set +xv --} @var{args}' when in any other emulation mode than zsh's native mode."
msgstr "由于历史原因，在任何其他模拟模式下，而非 zsh 的原生模式下，`@t{set -}' 被视为 `@t{set +xv}' ，而 `@t{set -} @var{args}' 被视为 `@t{set +xv --} @var{args}'  。"

#. type: findex
#: zsh.texi:14650 zsh.texi:27852
#, no-wrap
msgid "setcap"
msgstr "setcap"

#. type: findex
#: zsh.texi:14653
#, no-wrap
msgid "setopt"
msgstr "setopt"

#. type: cindex
#: zsh.texi:14654
#, no-wrap
msgid "options, setting"
msgstr "选项, 设置"

#. type: item
#: zsh.texi:14655
#, no-wrap
msgid "@t{setopt} [ @{@t{+}|@t{-}@}@var{options} | @{@t{+}|@t{-}@}@t{o} @var{option_name} ] [ @t{-m} ] [ @var{name} ... ]"
msgstr "@t{setopt} [ @{@t{+}|@t{-}@}@var{options} | @{@t{+}|@t{-}@}@t{o} @var{option_name} ] [ @t{-m} ] [ @var{name} ... ]"

#. type: table
#: zsh.texi:14658
msgid "Set the options for the shell.  All options specified either with flags or by name are set."
msgstr "设置 shell 的选项。 所有用标志或名称指定的选项都会被设置。"

#. type: table
#: zsh.texi:14673
msgid ""
"If no arguments are supplied, the names of all options currently set are printed.  The form is chosen so as to minimize the differences from the default options for the current emulation (the default "
"emulation being native @t{zsh}, shown as @t{<Z>} in @ref{Description of Options}).  Options that are on by default for the emulation are shown with the prefix @t{no} only if they are off, while other "
"options are shown without the prefix @t{no} and only if they are on.  In addition to options changed from the default state by the user, any options activated automatically by the shell (for example, "
"@t{SHIN_STDIN} or @t{INTERACTIVE})  will be shown in the list.  The format is further modified by the option @t{KSH_OPTION_PRINT}, however the rationale for choosing options with or without the @t{no} "
"prefix remains the same in this case."
msgstr ""
"如果没有提供参数，则会打印当前设置的所有选项名称。 选择这种形式是为了尽量减少与当前模拟器（emulation）的默认选项之间的差异（默认模拟器为原生 @t{zsh}，在 @ref{选项说明} 中显示为 @t{<Z>}）。 只有在关闭时，才"
"会以 @t{no} 为前缀显示默认开启的模拟选项，而只有在开启时，才会以不带 @t{no} 前缀的方式显示其他选项。 除了用户从默认状态修改的选项外，任何由 shell 自动激活的选项（例如 @t{SHIN_STDIN} 或 @t{INTERACTIVE}）都"
"会显示在列表中。 选项 @t{KSH_OPTION_PRINT} 会进一步修改格式，但在这种情况下，选择带或不带 @t{no} 前缀的选项的原理是一样的。"

#. type: table
#: zsh.texi:14678
msgid "If the @t{-m} flag is given the arguments are taken as patterns (which should be quoted to protect them from filename expansion), and all options with names matching these patterns are set."
msgstr "如果给定 @t{-m} 标志，参数将作为模式（应加引号以防止文件名扩展），所有名称与这些模式匹配的选项都将被设置。"

#. type: table
#: zsh.texi:14684
msgid ""
"Note that a bad option name does not cause execution of subsequent shell code to be aborted; this is behaviour is different from that of `@t{set -o}'.  This is because @t{set} is regarded as a special "
"builtin by the POSIX standard, but @t{setopt} is not."
msgstr "需要注意的是，错误的选项名称不会导致后续 shell 代码的中止执行；这一行为与 `@t{set -o}' 不同。 这是因为 POSIX 标准将 @t{set} 视为特殊的内置命令，而 @t{setopt} 并非如此。"

#. type: findex
#: zsh.texi:14685
#, no-wrap
msgid "shift"
msgstr "shift"

#. type: item
#: zsh.texi:14687
#, no-wrap
msgid "@t{shift} [ @t{-p} ] [ @var{n} ] [ @var{name} ... ]"
msgstr "@t{shift} [ @t{-p} ] [ @var{n} ] [ @var{name} ... ]"

#. type: table
#: zsh.texi:14693
msgid ""
"The positional parameters @t{$@{}@var{n}+1@t{@}} ... are renamed to @t{$1} ..., where @var{n} is an arithmetic expression that defaults to 1.  If any @var{name}s are given then the arrays with these names "
"are shifted instead of the positional parameters."
msgstr "位置参数 @t{$@{}@var{n}+1@t{@}} ... 更名为 @t{$1} ...，其中 @var{n} 是默认为 1 的算术表达式。如果指定了 @var{name}，则会移位具有这些名称的数组，而不是位置参数。"

#. type: table
#: zsh.texi:14697
msgid "If the option @t{-p} is given arguments are instead removed (popped)  from the end rather than the start of the array."
msgstr "如果给定了选项 @t{-p}，参数将从数组的末尾而不是起始位置移除（弹出）。"

#. type: findex
#: zsh.texi:14698
#, no-wrap
msgid "source"
msgstr "source"

#. type: item
#: zsh.texi:14699
#, no-wrap
msgid "@t{source} @var{file} [ @var{arg} ... ]"
msgstr "@t{source} @var{file} [ @var{arg} ... ]"

#. type: table
#: zsh.texi:14702
msgid "Same as `@t{.}', except that the current directory is always searched and is always searched first, before directories in @t{$path}."
msgstr "与 `@t{.}' 相同，不同之处在于总是先搜索当前目录，然后再搜索 @t{$path} 中的目录。"

#. type: findex
#: zsh.texi:14703 zsh.texi:30354
#, no-wrap
msgid "stat"
msgstr "stat"

#. type: table
#: zsh.texi:14705
msgid "See @ref{The zsh/stat Module}."
msgstr "参见 @ref{zsh/stat 模块}。"

#. type: findex
#: zsh.texi:14706
#, no-wrap
msgid "suspend"
msgstr "suspend"

#. type: cindex
#: zsh.texi:14707
#, no-wrap
msgid "shell, suspending"
msgstr "shell, 挂起"

#. type: cindex
#: zsh.texi:14708
#, no-wrap
msgid "suspending the shell"
msgstr "挂起 shell"

#. type: item
#: zsh.texi:14709
#, no-wrap
msgid "@t{suspend} [ @t{-f} ]"
msgstr "@t{suspend} [ @t{-f} ]"

#. type: table
#: zsh.texi:14713
msgid "Suspend the execution of the shell (send it a @t{SIGTSTP})  until it receives a @t{SIGCONT}.  Unless the @t{-f} option is given, this will refuse to suspend a login shell."
msgstr "暂停 shell 的执行（向其发送 @t{SIGTSTP}），直到收到 @t{SIGCONT}。 除非给出 @t{-f} 选项，否则将拒绝暂停登录 shell。"

#. type: t{#1}
#: zsh.texi:14714 zsh.texi:31415
#, no-wrap
msgid "test"
msgstr "test"

#. type: item
#: zsh.texi:14715
#, no-wrap
msgid "@t{test} [ @var{arg} ... ]"
msgstr "@t{test} [ @var{arg} ... ]"

#. type: itemx
#: zsh.texi:14716
#, no-wrap
msgid "@t{[} [ @var{arg} ... ] @t{]}"
msgstr "@t{[} [ @var{arg} ... ] @t{]}"

#. type: table
#: zsh.texi:14725
msgid ""
"Like the system version of @t{test}.  Added for compatibility; use conditional expressions instead (see @ref{Conditional Expressions}).  The main differences between the conditional expression syntax and "
"the @t{test} and @t{[} builtins are: these commands are not handled syntactically, so for example an empty variable expansion may cause an argument to be omitted; syntax errors cause status 2 to be "
"returned instead of a shell error; and arithmetic operators expect integer arguments rather than arithmetic expressions."
msgstr ""
"类似于 @t{test} 的系统版本。 为兼容而添加；请使用条件表达式代替（参见 @ref{条件表达式}）。 条件表达式语法与 @t{test} 和 @t{[} 内置命令的主要区别在于：这些命令不按语法处理，因此如空变量扩展可能会导致省略参"
"数；语法错误会导致返回状态 2，而不是 shell 错误；算术运算符希望使用整数参数，而不是算术表达式。"

#. type: table
#: zsh.texi:14734
msgid ""
"The command attempts to implement POSIX and its extensions where these are specified.  Unfortunately there are intrinsic ambiguities in the syntax; in particular there is no distinction between test "
"operators and strings that resemble them.  The standard attempts to resolve these for small numbers of arguments (up to four); for five or more arguments compatibility cannot be relied on.  Users are "
"urged wherever possible to use the `@t{[[}' test syntax which does not have these ambiguities."
msgstr ""
"该命令试图实现 POSIX 及其扩展（在指定的地方）。 遗憾的是，语法本身存在歧义，特别是测试运算符和类似运算符的字符串之间没有区别。 对于少量参数（最多四个），该标准试图解决这些问题；对于五个或更多参数，则无法保"
"证兼容性。 建议用户尽可能使用没有这些歧义的 `@t{[[}' 测试语法。"

#. type: t{#1}
#: zsh.texi:14735 zsh.texi:14738
#, no-wrap
msgid "times"
msgstr "times"

#. type: cindex
#: zsh.texi:14736
#, no-wrap
msgid "shell, timing"
msgstr "shell, 计时"

#. type: cindex
#: zsh.texi:14737
#, no-wrap
msgid "timing the shell"
msgstr "对 shell 进行计时"

#. type: table
#: zsh.texi:14741
msgid "Print the accumulated user and system times for the shell and for processes run from the shell."
msgstr "打印 shell 和从 shell 运行的进程的累计用户和系统时间。"

#. type: item
#: zsh.texi:14745
#, no-wrap
msgid "@t{trap} [ @var{arg} ] [ @var{sig} ... ]"
msgstr "@t{trap} [ @var{arg} ] [ @var{sig} ... ]"

#. type: table
#: zsh.texi:14752
msgid ""
"@var{arg} is a series of commands (usually quoted to protect it from immediate evaluation by the shell) to be read and executed when the shell receives any of the signals specified by one or more "
"@var{sig} args.  Each @var{sig} can be given as a number, or as the name of a signal either with or without the string @t{SIG} in front (e.g. 1, HUP, and SIGHUP are all the same signal)."
msgstr ""
"@var{arg} 是一系列命令（通常加引号以防止 shell 立即执行），当 shell 接收到一个或多个 @var{sig} 参数指定的信号时，将读取并执行这些命令。 每个 @var{sig} 都可以是一个数字，也可以是一个信号的名称，可以在前面加"
"上或不加上 @t{SIG} 字符串（例如，1、HUP 和 SIGHUP 都是同一个信号）。"

#. type: table
#: zsh.texi:14756
msgid "If @var{arg} is `@t{-}', then the specified signals are reset to their defaults, or, if no @var{sig} args are present, all traps are reset."
msgstr "如果 @var{arg} 为 `@t{-}' ，则重置指定的信号为默认值；如果没有 @var{sig} 参数，则重置所有陷阱。"

#. type: table
#: zsh.texi:14760
msgid "If @var{arg} is an empty string, then the specified signals are ignored by the shell (and by the commands it invokes)."
msgstr "如果 @var{arg} 为空字符串，则 shell（及其调用的命令）将忽略指定的信号。"

#. type: table
#: zsh.texi:14765
msgid "If @var{arg} is omitted but one or more @var{sig} args are provided (i.e.  the first argument is a valid signal number or name), the effect is the same as if @var{arg} had been specified as `@t{-}'."
msgstr "如果省略了 @var{arg}，但提供了一个或多个 @var{sig} 参数（即第一个参数是有效的信号编号或名称），其效果与 @var{arg} 被指定为  `@t{-}' 相同。"

#. type: table
#: zsh.texi:14769
msgid "The @t{trap} command with no arguments prints a list of commands associated with each signal."
msgstr "无参数的 @t{trap} 命令将打印与每个信号相关的命令列表。"

#. type: table
#: zsh.texi:14775
msgid ""
"If @var{sig} is @t{ZERR} then @var{arg} will be executed after each command with a nonzero exit status.  @t{ERR} is an alias for @t{ZERR} on systems that have no @t{SIGERR} signal (this is the usual case)."
msgstr "如果 @var{sig} 是 @t{ZERR}，那么 @var{arg} 将在每条退出状态为非零的命令后执行。 在没有 @t{SIGERR} 信号的系统中，@t{ERR} 是 @t{ZERR} 的别名（通常是这种情况）。"

#. type: table
#: zsh.texi:14790
msgid ""
"If @var{sig} is @t{DEBUG} then @var{arg} will be executed before each command if the option @t{DEBUG_BEFORE_CMD} is set (as it is by default), else after each command.  Here, a `command' is what is "
"described as a `sublist' in the shell grammar, see @ref{Simple Commands & Pipelines}.  If @t{DEBUG_BEFORE_CMD} is set various additional features are available.  First, it is possible to skip the next "
"command by setting the option @t{ERR_EXIT}; see the description of the @t{ERR_EXIT} option in @ref{Description of Options}.  Also, the shell parameter @t{ZSH_DEBUG_CMD} is set to the string corresponding "
"to the command to be executed following the trap.  Note that this string is reconstructed from the internal format and may not be formatted the same way as the original text.  The parameter is unset after "
"the trap is executed."
msgstr ""
"如果 @var{sig} 是 @t{DEBUG}，那么如果设置了 @t{DEBUG_BEFORE_CMD}（默认情况），@var{arg} 将在每条命令之前执行，否则将在每条命令之后执行。 这里的 `命令' 就是 shell 语法中的 `子列表(sublist)'，参见 @ref{简单"
"命令和管道}。 如果设置了 @t{DEBUG_BEFORE_CMD}，就可以使用多种附加功能。 首先，通过设置选项 @t{ERR_EXIT}，可以跳过下一条命令；请参阅 @ref{选项说明} 中关于 @t{ERR_EXIT} 选项的描述。 此外，shell 参数 "
"@t{ZSH_DEBUG_CMD} 也会被设置为与陷阱后要执行的命令相对应的字符串。 请注意，该字符串是根据内部格式重建的，格式可能与原文不同。 陷阱执行后，该参数将被取消。"

#. type: table
#: zsh.texi:14801
msgid ""
"If @var{sig} is @t{0} or @t{EXIT} and the @t{trap} statement is executed inside the body of a function, then the command @var{arg} is executed after the function completes.  The value of @t{$?} at the "
"start of execution is the exit status of the shell or the return status of the function exiting.  If @var{sig} is @t{0} or @t{EXIT} and the @t{trap} statement is not executed inside the body of a "
"function, then the command @var{arg} is executed when the shell terminates; the trap runs before any @t{zshexit} hook functions."
msgstr ""
"如果 @var{sig} 为 @t{0} 或 @t{EXIT}，且 @t{trap} 语句在函数体内部执行，则在函数完成后执行命令 @var{arg}。 开始执行时 @t{$?} 的值是 shell 的退出状态或函数退出时的返回状态。 如果 @var{sig} 为 @t{0} 或 "
"@t{EXIT}，且 @t{trap} 语句未在函数体内部执行，则在 shell 终止时执行命令 @var{arg}；陷阱在任何 @t{zshexit} 挂钩函数之前运行。"

#. type: table
#: zsh.texi:14806
msgid "@t{ZERR}, @t{DEBUG}, and @t{EXIT} traps are not executed inside other traps.  @t{ZERR} and @t{DEBUG} traps are kept within subshells, while other traps are reset."
msgstr "@t{ZERR}、@t{DEBUG} 和 @t{EXIT} 陷阱不会在其他陷阱内执行。 @t{ZERR} 和 @t{DEBUG} 陷阱会保留在子 shell 内，而其他陷阱会被重置。"

#. type: table
#: zsh.texi:14813
msgid ""
"Note that traps defined with the @t{trap} builtin are slightly different from those defined as `@t{TRAP}@var{NAL} () @{ ... @}', as the latter have their own function environment (line numbers, local "
"variables, etc.) while the former use the environment of the command in which they were called.  For example,"
msgstr "请注意，使用 @t{trap} 内置命令定义的陷阱与 `@t{TRAP}@var{NAL} () @{ ... @}' 定义的陷阱略有不同，因为后者有自己的函数环境（行号、局部变量等），而前者使用的是调用陷阱的命令环境。 例如"

#. type: example
#: zsh.texi:14817
#, no-wrap
msgid "trap 'print $LINENO' DEBUG\n"
msgstr "trap 'print $LINENO' DEBUG\n"

#. type: table
#: zsh.texi:14821
msgid "will print the line number of a command executed after it has run, while"
msgstr "会在命令运行后打印该命令的行号，而"

#. type: example
#: zsh.texi:14825
#, no-wrap
msgid "TRAPDEBUG() @{ print $LINENO; @}\n"
msgstr "TRAPDEBUG() @{ print $LINENO; @}\n"

#. type: table
#: zsh.texi:14829
msgid "will always print the number zero."
msgstr "将始终打印数字 0。"

#. type: table
#: zsh.texi:14835
msgid ""
"Alternative signal names are allowed as described under @t{kill} above.  Defining a trap under either name causes any trap under an alternative name to be removed.  However, it is recommended that for "
"consistency users stick exclusively to one name or another."
msgstr "如上文 @t{kill} 所述，允许使用可替换信号名称。 使用其中任何一个名称定义陷阱，都会导致使用其他可替换名称的陷阱被删除。 不过，为了保持一致性，我们建议用户只使用一种名称。"

#. type: table
#: zsh.texi:14836 zsh.texi:37030 zsh.texi:37034
#, no-wrap
msgid "true"
msgstr "true"

#. type: cindex
#: zsh.texi:14837
#, no-wrap
msgid "doing nothing, successfully"
msgstr "不做任何事, 总是成功"

#. type: item
#: zsh.texi:14838
#, no-wrap
msgid "@t{true} [ @var{arg} ... ]"
msgstr "@t{true} [ @var{arg} ... ]"

#. type: table
#: zsh.texi:14840
msgid "Do nothing and return an exit status of 0."
msgstr "不做任何事并返回 0 退出状态。"

#. type: findex
#: zsh.texi:14841
#, no-wrap
msgid "ttyctl"
msgstr "ttyctl"

#. type: cindex
#: zsh.texi:14842
#, no-wrap
msgid "tty, freezing"
msgstr "tty, 冻结"

#. type: item
#: zsh.texi:14843
#, no-wrap
msgid "@t{ttyctl} [ @t{-fu} ]"
msgstr "@t{ttyctl} [ @t{-fu} ]"

#. type: table
#: zsh.texi:14854
msgid ""
"The @t{-f} option freezes the tty (i.e. terminal or terminal emulator), and @t{-u} unfreezes it.  When the tty is frozen, no changes made to the tty settings by external programs will be honored by the "
"shell, except for changes in the size of the screen; the shell will simply reset the settings to their previous values as soon as each command exits or is suspended.  Thus, @t{stty} and similar programs "
"have no effect when the tty is frozen.  Freezing the tty does not cause the current state to be remembered: instead, it causes future changes to the state to be blocked."
msgstr ""
"@t{-f} 选项会冻结 tty（即终端或终端模拟器），而 @t{-u} 则会解除冻结。 当 tty 被冻结时，除了屏幕大小的改变外，shell 不会执行外部程序对 tty 设置所做的任何更改；每当命令退出或暂停时，shell 会简单地将设置重置"
"为之前的值。 因此，当 tty 被冻结时，@t{stty} 和类似程序将不起作用。 冻结 tty 并不会导致当前状态被记忆：相反，它会导致状态的未来更改被阻止。"

#. type: table
#: zsh.texi:14857
msgid "Without options it reports whether the terminal is frozen or not."
msgstr "在没有选项的情况下，它会报告终端是否被冻结。"

#. type: table
#: zsh.texi:14867
msgid ""
"Note that, regardless of whether the tty is frozen or not, the shell needs to change the settings when the line editor starts, so unfreezing the tty does not guarantee settings made on the command line "
"are preserved.  Strings of commands run between editing the command line will see a consistent tty state.  See also the shell variable @t{STTY} for a means of initialising the tty before running external "
"commands and/or freezing the tty around a single command."
msgstr ""
"需要注意的是，无论 tty 是否冻结，shell 都需要在行编辑器启动时更改设置，因此解冻 tty 并不能保证命令行上的设置得到保留。 在编辑命令行之间运行的命令字符串将保持一致的 tty 状态。 另请参阅 shell 变量 @t{STTY}，"
"了解在运行外部命令前初始化 tty 和/或在单个命令周围冻结 tty 的方法。"

#. type: findex
#: zsh.texi:14868
#, no-wrap
msgid "type"
msgstr "type"

#. type: item
#: zsh.texi:14869
#, no-wrap
msgid "@t{type} [ @t{-wfpamsS} ] @var{name} ..."
msgstr "@t{type} [ @t{-wfpamsS} ] @var{name} ..."

#. type: table
#: zsh.texi:14871
msgid "Equivalent to @t{whence -v}."
msgstr "等价于 @t{whence -v}。"

#. type: findex
#: zsh.texi:14872
#, no-wrap
msgid "typeset"
msgstr "typeset"

#. type: cindex
#: zsh.texi:14873
#, no-wrap
msgid "parameters, setting"
msgstr "参数, 设置"

#. type: cindex
#: zsh.texi:14874
#, no-wrap
msgid "parameters, declaring"
msgstr "参数, 声名"

#. type: item
#: zsh.texi:14876
#, no-wrap
msgid "@t{typeset }[ @{@t{+}|@t{-}@}@t{AHUaghlmrtux} ] [ @{@t{+}|@t{-}@}@t{EFLRZip} [ @var{n} ] ]"
msgstr "@t{typeset }[ @{@t{+}|@t{-}@}@t{AHUaghlmrtux} ] [ @{@t{+}|@t{-}@}@t{EFLRZip} [ @var{n} ] ]"

#. type: itemx
#: zsh.texi:14877
#, no-wrap
msgid "@t{@ @ @ @ @ @ @ @ }[ @t{+} ] [ @var{name}[@t{=}@var{value}] ... ]"
msgstr "@t{@ @ @ @ @ @ @ @ }[ @t{+} ] [ @var{name}[@t{=}@var{value}] ... ]"

#. type: itemx
#: zsh.texi:14878
#, no-wrap
msgid "@t{typeset }@t{-T} [ @{@t{+}|@t{-}@}@t{Uglrux} ] [ @{@t{+}|@t{-}@}@t{LRZp} [ @var{n} ] ]"
msgstr "@t{typeset }@t{-T} [ @{@t{+}|@t{-}@}@t{Uglrux} ] [ @{@t{+}|@t{-}@}@t{LRZp} [ @var{n} ] ]"

#. type: itemx
#: zsh.texi:14879
#, no-wrap
msgid "@t{@ @ @ @ @ @ @ @ }[ @t{+} | @var{SCALAR}[@t{=}@var{value}] @var{array}[@t{=(}@var{value} ...@t{)}] [ @var{sep} ] ]"
msgstr "@t{@ @ @ @ @ @ @ @ }[ @t{+} | @var{SCALAR}[@t{=}@var{value}] @var{array}[@t{=(}@var{value} ...@t{)}] [ @var{sep} ] ]"

#. type: itemx
#: zsh.texi:14880
#, no-wrap
msgid "@t{typeset} @t{-f} [ @{@t{+}|@t{-}@}@t{TUkmtuz} ] [ @t{+} ] [ @var{name} ... ]"
msgstr "@t{typeset} @t{-f} [ @{@t{+}|@t{-}@}@t{TUkmtuz} ] [ @t{+} ] [ @var{name} ... ]"

#. type: table
#: zsh.texi:14882
msgid "Set or display attributes and values for shell parameters."
msgstr "设置或显示 shell 参数的属性和数值。"

#. type: table
#: zsh.texi:14891
msgid ""
"Except as noted below for control flags that change the behavior, a parameter is created for each @var{name} that does not already refer to one.  When inside a function, a new parameter is created for "
"every @var{name} (even those that already exist), and is unset again when the function completes.  See @ref{Local Parameters}.  The same rules apply to special shell parameters, which retain their special "
"attributes when made local."
msgstr ""
"除了下面提到的会改变行为的控制标志外，每一个 @var{name} 都会创建一个参数，但前提是该参数尚未被引用。 在函数内部时，会为每个 @var{name}（即使是已经存在的参数）创建一个新参数，并在函数完成后取消设置。 请参"
"阅 @ref{局部参数}。 同样的规则也适用于特殊 shell 参数，这些参数在局部化后仍保留其特殊属性。"

#. type: table
#: zsh.texi:14899
msgid ""
"For each @var{name}@t{=}@var{value} assignment, the parameter @var{name} is set to @var{value}.  If the assignment is omitted and @var{name} does @emph{not} refer to an existing parameter, a new parameter "
"is intialized to empty string, zero, or empty array (as appropriate), @emph{unless} the shell option @t{TYPESET_TO_UNSET} is set.  When that option is set, the parameter attributes are recorded but the "
"parameter remains unset."
msgstr ""
"对于每个  @var{name}@t{=}@var{value}  赋值，参数 @var{name} 将被设置为 @var{value}。 如果省略了赋值，并且 @var{name} @emph{没有} 指向了一个现有参数，那么一个新参数将初始化为空字符串、零或空数组（视情况而"
"定），@emph{除非} shell 选项 @t{TYPESET_TO_UNSET} 已被设置。 设置该选项后，参数属性将被记录，但参数仍保持未设置状态。"

#. type: table
#: zsh.texi:14907
msgid ""
"If the shell option @t{TYPESET_SILENT} is not set, for each remaining @var{name} that refers to a parameter that is already set, the name and value of the parameter are printed in the form of an "
"assignment.  Nothing is printed for newly-created parameters, or when any attribute flags listed below are given along with the @var{name}.  Using `@t{+}' instead of minus to introduce an attribute turns "
"it off."
msgstr ""
"如果未设置 shell 选项 @t{TYPESET_SILENT}，那么对于每一个指向已设置参数的剩余 @var{name}，都会以赋值的形式打印参数的名称和值。 对于新创建的参数，或 @var{name} 同时给出以下属性标志时，将不打印任何内容。 使"
"用 `@t{+}' 而不是减号来引入属性时，将关闭该属性。"

#. type: table
#: zsh.texi:14914
msgid ""
"If no @var{name} is present, the names and values of all parameters are printed.  In this case the attribute flags restrict the display to only those parameters that have the specified attributes, and "
"using `@t{+}' rather than `@t{-}' to introduce the flag suppresses printing of the values of parameters when there is no parameter name."
msgstr "如果没有 @var{name}，则打印所有参数的名称和值。 在这种情况下，属性标志限制为只显示具有指定属性的参数，使用 `@t{+}' 而不是 `@t{-}' 引入标志可以在没有参数名时抑制参数值的打印。"

#. type: table
#: zsh.texi:14924
msgid ""
"All forms of the command handle scalar assignment.  Array assignment is possible if any of the reserved words @t{declare}, @t{export}, @t{float}, @t{integer}, @t{local}, @t{readonly} or @t{typeset} is "
"matched when the line is parsed (N.B. not when it is executed).  In this case the arguments are parsed as assignments, except that the `@t{+=}' syntax and the @t{GLOB_ASSIGN} option are not supported, and "
"scalar values after @t{=} are @emph{not} split further into words, even if expanded (regardless of the setting of the @t{KSH_TYPESET} option; this option is obsolete)."
msgstr ""
"该命令的所有形式都能处理标量赋值。 如果在解析命令行时（注意：不是在执行时）匹配了保留字 @t{declare}、@t{export}、@t{float}、@t{integer}、@t{local}、@t{readonly} 或 @t{typeset}，则可以进行数组赋值。 在这种"
"情况下，参数将作为赋值进行解析，但不支持 `@t{+=}' 语法和 @t{GLOB_ASSIGN} 选项，并且 @t{=} 之后的标量值@emph{不会}被分割为单词，即使已展开（与 @t{KSH_TYPESET} 选项的设置无关；该选项已过时）。"

#. type: table
#: zsh.texi:14927
msgid "Examples of the differences between command and reserved word parsing:"
msgstr "命令和保留字解析差异示例："

#. type: example
#: zsh.texi:14932
#, no-wrap
msgid ""
"# Reserved word parsing\n"
"typeset svar=$(echo one word) avar=(several words)\n"
msgstr ""
"# Reserved word parsing\n"
"typeset svar=$(echo one word) avar=(several words)\n"

#. type: table
#: zsh.texi:14937
msgid "The above creates a scalar parameter @t{svar} and an array parameter @t{avar} as if the assignments had been"
msgstr "上面的代码创建了一个标量参数 @t{svar} 和一个数组参数 @t{avar}，就好像赋值是"

#. type: example
#: zsh.texi:14942
#, no-wrap
msgid ""
"svar=\"one word\"\n"
"avar=(several words)\n"
msgstr ""
"svar=\"one word\"\n"
"avar=(several words)\n"

#. type: table
#: zsh.texi:14946
msgid "On the other hand:"
msgstr "另一方面："

#. type: example
#: zsh.texi:14951
#, no-wrap
msgid ""
"# Normal builtin interface\n"
"builtin typeset svar=$(echo two words)\n"
msgstr ""
"# Normal builtin interface\n"
"builtin typeset svar=$(echo two words)\n"

#. type: table
#: zsh.texi:14960
msgid ""
"The @t{builtin} keyword causes the above to use the standard builtin interface to @t{typeset} in which argument parsing is performed in the same way as for other commands.  This example creates a scalar "
"@t{svar} containing the value @t{two} and another scalar parameter @t{words} with no value.  An array value in this case would either cause an error or be treated as an obscure set of glob qualifiers."
msgstr ""
"使用 @t{builtin} 关键字后，上述命令将使用 @t{typeset} 的标准内置接口，其中参数解析的方式与其他命令相同。 本示例创建了一个包含值 @t{two} 的标量 @t{svar}，以及另一个无值的标量参数 @t{words}。 在这种情况下，"
"数组值要么会导致错误，要么会被视为一组模糊的 glob 限定符。"

#. type: table
#: zsh.texi:14965
msgid "Arbitrary arguments are allowed if they take the form of assignments after command line expansion; however, these only perform scalar assignment:"
msgstr "如果在命令行扩展后采用赋值形式，则允许使用任意参数；不过，这些参数只能执行标量赋值："

#. type: example
#: zsh.texi:14970
#, no-wrap
msgid ""
"var='svar=val'\n"
"typeset $var\n"
msgstr ""
"var='svar=val'\n"
"typeset $var\n"

#. type: table
#: zsh.texi:14978
msgid ""
"The above sets the scalar parameter @t{svar} to the value @t{val}.  Parentheses around the value within @t{var} would not cause array assignment as they will be treated as ordinary characters when "
"@t{$var} is substituted.  Any non-trivial expansion in the name part of the assignment causes the argument to be treated in this fashion:"
msgstr ""
"上述代码将标量参数 @t{svar} 设置为值 @t{val}。 在 @t{var} 中的值周围使用括号不会导致数组赋值，因为在替换 @t{$var} 时，括号将被视为普通字符。 赋值中名称部分的任何非平凡（non-trivial) 式扩展都会导致以这种方"
"式处理参数："

#. type: example
#: zsh.texi:14982
#, no-wrap
msgid "typeset @{var1,var2,var3@}=name\n"
msgstr "typeset @{var1,var2,var3@}=name\n"

#. type: table
#: zsh.texi:14990
msgid ""
"The above syntax is valid, and has the expected effect of setting the three parameters to the same value, but the command line is parsed as a set of three normal command line arguments to @t{typeset} "
"after expansion.  Hence it is not possible to assign to multiple arrays by this means."
msgstr "上述语法是有效的，并具有将三个参数设置为相同值的预期效果，但扩展后的命令行会被解析为 @t{typeset} 的三个普通命令行参数的集合。 因此，无法通过这种方法为多个数组赋值。"

#. type: table
#: zsh.texi:14999
msgid ""
"Note that each interface to any of the commands may be disabled separately.  For example, `@t{disable -r typeset}' disables the reserved word interface to @t{typeset}, exposing the builtin interface, "
"while `@t{disable typeset}' disables the builtin.  Note that disabling the reserved word interface for @t{typeset} may cause problems with the output of `@t{typeset -p}', which assumes the reserved word "
"interface is available in order to restore array and associative array values."
msgstr ""
"请注意，任何命令的每个接口都可以单独禁用。 例如，`@t{disable -r typeset}' 禁用 @t{typeset} 的保留字接口，暴露内置接口，而 `@t{disable typeset}' 则禁用内置接口。 需要注意的是，禁用 @t{typeset} 的保留字接口"
"可能会导致 `@t{typeset -p}' 的输出出现问题，因为 `@t{typeset -p}' 假定保留字接口可用，以便还原数组和关联数组的值。"

#. type: table
#: zsh.texi:15006
msgid ""
"Unlike parameter assignment statements, @t{typeset}'s exit status on an assignment that involves a command substitution does not reflect the exit status of the command substitution.  Therefore, to test "
"for an error in a command substitution, separate the declaration of the parameter from its initialization:"
msgstr "与参数赋值语句不同，@t{typeset} 在涉及命令替换的赋值中的退出状态并不反映命令替换的退出状态。 因此，要测试命令替换中的错误，应将参数的声明与其初始化分开："

#. type: example
#: zsh.texi:15011
#, no-wrap
msgid ""
"# WRONG\n"
"typeset var1=$(exit 1) || echo \"Trouble with var1\"\n"
"\n"
msgstr ""
"# WRONG\n"
"typeset var1=$(exit 1) || echo \"Trouble with var1\"\n"
"\n"

#. type: example
#: zsh.texi:15014
#, no-wrap
msgid ""
"# RIGHT\n"
"typeset var1 && var1=$(exit 1) || echo \"Trouble with var1\"\n"
"\n"
msgstr ""
"# RIGHT\n"
"typeset var1 && var1=$(exit 1) || echo \"Trouble with var1\"\n"
"\n"

#. type: table
#: zsh.texi:15021
msgid "To initialize a parameter @var{param} to a command output and mark it readonly, use @t{typeset -r }@var{param} or @t{readonly }@var{param} after the parameter assignment statement."
msgstr "要将参数 @var{param} 初始化为命令输出并标记为只读，请在参数赋值语句后使用 @t{typeset -r }@var{param}  或 @t{readonly }@var{param} 。"

#. type: table
#: zsh.texi:15031
msgid ""
"If no attribute flags are given, and either no @var{name} arguments are present or the flag @t{+m} is used, then each parameter name printed is preceded by a list of the attributes of that parameter "
"(@t{array}, @t{association}, @t{exported}, @t{float}, @t{integer}, @t{readonly}, or @t{undefined} for autoloaded parameters not yet loaded).  If @t{+m} is used with attribute flags, and all those flags "
"are introduced with @t{+}, the matching parameter names are printed but their values are not."
msgstr ""
"如果没有给出属性标志，也没有 @var{name} 参数或使用了 @t{+m} 标志，则在打印的每个参数名称前都会列出该参数的属性（@t{array}、@t{association}、@t{exported}、@t{float}、@t{integer}、@t{readonly} 或 "
"@t{undefined} (用于尚未加载的自动加载参数) ）。 如果 @t{+m} 与属性标志一起使用，且所有这些标志都用 @t{+} 引入，则会打印匹配的参数名，但不会打印其值。"

#. type: table
#: zsh.texi:15034
msgid "The following control flags change the behavior of @t{typeset}:"
msgstr "以下控制标志会改变 @t{typeset} 的行为："

#. type: t{#1}
#: zsh.texi:15037
#, no-wrap
msgid "+"
msgstr "+"

#. type: table
#: zsh.texi:15049
msgid ""
"If `@t{+}' appears by itself in a separate word as the last option, then the names of all parameters (functions with @t{-f}) are printed, but the values (function bodies) are not.  No @var{name} arguments "
"may appear, and it is an error for any other options to follow `@t{+}'.  The effect of `@t{+}' is as if all attribute flags which precede it were given with a `@t{+}' prefix.  For example, `@t{typeset -U "
"+}' is equivalent to `@t{typeset +U}' and displays the names of all arrays having the uniqueness attribute, whereas `@t{typeset -f -U +}' displays the names of all autoloadable functions.  If @t{+} is the "
"only option, then type information (array, readonly, etc.) is also printed for each parameter, in the same manner as `@t{typeset +m \"*\"}'."
msgstr ""
"如果 `@t{+}' 作为最后一个选项单独出现，那么将打印所有参数（带 @t{-f} 的函数）的名称，但不打印参数值（函数体）。 不允许出现 @var{name} 参数，而且在 `@t{+}' 之后出现其他选项都是错误的。`@t{+}' 的作用就好像在"
"它前面的所有属性标志都加上了 `@t{+}' 前缀。 例如，`@t{typeset -U +}' 等同于 `@t{typeset +U}' ，显示所有具有唯一性属性的数组的名称，而  `@t{typeset -f -U +}' 则显示所有可自动加载函数的名称。 如果 @t{+} 是唯"
"一的选项，那么每个参数的类型信息（数组、只读等）也会被打印出来，打印方式与  `@t{typeset +m \"*\"}' 相同。"

#. type: table
#: zsh.texi:15058
msgid ""
"The @t{-g} (global) means that any resulting parameter will not be restricted to local scope.  Note that this does not necessarily mean that the parameter will be global, as the flag will apply to any "
"existing parameter (even if unset) from an enclosing function.  This flag does not affect the parameter after creation, hence it has no effect when listing existing parameters, nor does the flag @t{+g} "
"have any effect except in combination with @t{-m} (see below)."
msgstr ""
"@t{-g}（全局）表示产生的参数将不限于本地作用域。 请注意，这并不一定意味着参数将是全局的，因为该标志将适用于来自封闭函数的任何现有参数（即使未设置）。 该标志不会影响创建后的参数，因此在列出现有参数时没有任"
"何作用，除了与 @t{-m} 结合使用外，标志 @t{+g} 也没有任何作用（见下文）。"

#. type: table
#: zsh.texi:15065
msgid ""
"If the @t{-m} flag is given the @var{name} arguments are taken as patterns (use quoting to prevent these from being interpreted as file patterns).  With no attribute flags, all parameters (or functions "
"with the @t{-f} flag) with matching names are printed (the shell option @t{TYPESET_SILENT} is not used in this case)."
msgstr ""
"如果给出 @t{-m} 标志，@var{name} 参数将被视为模式（使用引号防止这些参数被解释为文件模式）。 在没有属性标志的情况下，所有名称匹配的参数（或带有 @t{-f} 标志的函数）都会被打印（此时不使用 shell 选项 "
"@t{TYPESET_SILENT}）。"

#. type: table
#: zsh.texi:15070
msgid ""
"If the @t{+g} flag is combined with @t{-m}, a new local parameter is created for every matching parameter that is not already local.  Otherwise @t{-m} applies all other flags or assignments to the "
"existing parameters."
msgstr "如果 @t{+g} 标志与 @t{-m} 结合使用，则会为每一个尚未本地化的匹配参数创建一个新的本地参数。 否则，@t{-m} 会将所有其他标志或赋值应用于现有参数。"

#. type: table
#: zsh.texi:15077
msgid ""
"Except when assignments are made with @var{name}@t{=}@var{value}, using @t{+m} forces the matching parameters and their attributes to be printed, even inside a function.  Note that @t{-m} is ignored if no "
"patterns are given, so `@t{typeset -m}' displays attributes but `@t{typeset -a +m}' does not."
msgstr ""
"除了使用 @var{name}@t{=}@var{value} 进行赋值外，使用 @t{+m} 会强制打印匹配的参数及其属性，即使在函数内部也是如此。 请注意，如果没有给出模式，@t{-m} 将被忽略，因此 `@t{typeset -m}' 会显示属性，但 "
"`@t{typeset -a +m}' 不会。"

#. type: item
#: zsh.texi:15078
#, no-wrap
msgid "@t{-p} [ @var{n} ]"
msgstr "@t{-p} [ @var{n} ]"

#. type: table
#: zsh.texi:15083
msgid ""
"If the @t{-p} option is given, parameters and values are printed in the form of a typeset command with an assignment, regardless of other flags and options.  Note that the @t{-H} flag on parameters is "
"respected; no value will be shown for these parameters."
msgstr "如果给出 @t{-p} 选项，参数和值将以带赋值的排版命令形式打印，与其他标志和选项无关。 需要注意的是，会尊守参数上的 @t{-H} 标志；这些参数不会显示任何值。"

#. type: table
#: zsh.texi:15089
msgid ""
"@t{-p} may be followed by an optional integer argument.  Currently only the value @t{1} is supported.  In this case arrays and associative arrays are printed with newlines between indented elements for "
"readability."
msgstr "@t{-p} 后面可以跟一个可选的整数参数。 目前只支持 @t{1} 值。 在这种情况下，为了便于阅读，数组和关联数组会在缩进元素之间使用换行符打印。"

#. type: item
#: zsh.texi:15090
#, no-wrap
msgid "@t{-T} [ @var{scalar}[@t{=}@var{value}] @var{array}[@t{=(}@var{value} ...@t{)}] [ @var{sep} ] ]"
msgstr "@t{-T} [ @var{scalar}[@t{=}@var{value}] @var{array}[@t{=(}@var{value} ...@t{)}] [ @var{sep} ] ]"

#. type: table
#: zsh.texi:15102
msgid ""
"This flag has a different meaning when used with @t{-f}; see below.  Otherwise the @t{-T} option requires zero, two, or three arguments to be present.  With no arguments, the list of parameters created in "
"this fashion is shown.  With two or three arguments, the first two are the name of a scalar and of an array parameter (in that order) that will be tied together in the manner of @t{$PATH} and @t{$path}.  "
"The optional third argument is a single-character separator which will be used to join the elements of the array to form the scalar; if absent, a colon is used, as with @t{$PATH}.  Only the first "
"character of the separator is significant; any remaining characters are ignored.  Multibyte characters are not yet supported."
msgstr ""
"当与 @t{-f} 搭配使用时，该标志的含义有所不同；见下文。 在其他情况下，@t{-T} 选项需要 0、2 或 3 个参数。 如果没有参数，将显示以这种方式创建的参数列表。 如果有两个或三个参数，前两个参数是一个标量和一个数组参"
"数的名称（按此顺序），这两个参数将以 @t{$PATH} 和 @t{$path} 的方式绑定在一起。 第三个可选参数是一个单字符分隔符，用于连接数组元素以形成标量；如果没有分隔符，则使用冒号，与 @t{$PATH} 一样。 只有分隔符的第一"
"个字符才有意义，其余字符将被忽略。 目前还不支持多字节字符。"

#. type: table
#: zsh.texi:15106
msgid "Only one of the scalar and array parameters may be assigned an initial value (the restrictions on assignment forms described above also apply)."
msgstr "标量参数和数组参数中只有一个可以赋初值（上述赋值形式上的限制也适用）。"

#. type: table
#: zsh.texi:15114
msgid ""
"Both the scalar and the array may be manipulated as normal.  If one is unset, the other will automatically be unset too.  There is no way of untying the variables without unsetting them, nor of converting "
"the type of one of them with another @t{typeset} command; @t{+T} does not work, assigning an array to @var{scalar} is an error, and assigning a scalar to @var{array} sets it to be a single-element array."
msgstr ""
"标量和数组都可以正常操作。 如果其中一个被取消设置，另一个也会自动取消设置。 我们无法在不取消设置的情况下解除变量的绑定，也无法使用 @t{typeset} 命令转换其中一个变量的类型；@t{+T}不起作用，将数组赋值给 "
"@var{scalar} 会出错，将标量赋值给 @var{array} 会将其设置为单元素数组。"

#. type: table
#: zsh.texi:15122
msgid ""
"Note that both `@t{typeset -xT ...}' and `@t{export -T ...}' work, but only the scalar will be marked for export.  Setting the value using the scalar version causes a split on all separators (which cannot "
"be quoted).  It is possible to apply @t{-T} to two previously tied variables but with a different separator character, in which case the variables remain joined as before but the separator is changed."
msgstr ""
"请注意， `@t{typeset -xT ...}' 和 `@t{export -T ...}' 都有效，但只有标量会被标记为导出。 使用标量版本设置值会导致在所有分隔符位置被拆分（不能使用引号）。 可以将 @t{-T} 应用于两个先前绑定但使用不同分隔符的"
"变量，在这种情况下，变量仍像以前一样连接，但分隔符会改变。"

#. type: table
#: zsh.texi:15126
msgid "When an existing scalar is tied to a new array, the value of the scalar is preserved but no attribute other than export will be preserved."
msgstr "当现有标量与新数组绑定时，标量的值将被保留，但除导出之外的其他属性将不会被保留。"

#. type: table
#: zsh.texi:15134
msgid ""
"Attribute flags that transform the final value (@t{-L}, @t{-R}, @t{-Z}, @t{-l}, @t{-u}) are only applied to the expanded value at the point of a parameter expansion expression using `@t{$}'.  They are not "
"applied when a parameter is retrieved internally by the shell for any purpose."
msgstr "改变最终值的属性标志（@t{-L}、@t{-R}、@t{-Z}、@t{-L}、@t{-u}）仅在使用 `@t{$}' 的参数扩展表达式时应用于扩展值。 当 shell 为任何目的在内部检索参数时，它们都不会被使用。"

#. type: table
#: zsh.texi:15137
msgid "The following attribute flags may be specified:"
msgstr "可指定以下属性标志："

#. type: table
#: zsh.texi:15143
msgid "The names refer to associative array parameters; see @ref{Array Parameters}."
msgstr "这些名称指的是关联数组参数；请参阅 @ref{数组参数}。"

#. type: item
#: zsh.texi:15144
#, no-wrap
msgid "@t{-L} [ @var{n} ]"
msgstr "@t{-L} [ @var{n} ]"

#. type: table
#: zsh.texi:15152
msgid ""
"Left justify and remove leading blanks from the value when the parameter is expanded.  If @var{n} is nonzero, it defines the width of the field.  If @var{n} is zero, the width is determined by the width "
"of the value of the first assignment.  In the case of numeric parameters, the length of the complete value assigned to the parameter is used to determine the width, not the value that would be output."
msgstr ""
"当参数展开时，左对齐并删除值的前导空白。 如果 @var{n} 非零，则定义字段的宽度。 如果 @var{n} 为零，则宽度由第一次赋值的宽度决定。 如果是数值参数，则使用赋给参数的完整值的长度来确定宽度，而不是将输出的值。"

#. type: table
#: zsh.texi:15161
msgid ""
"The width is the count of characters, which may be multibyte characters if the @t{MULTIBYTE} option is in effect.  Note that the screen width of the character is not taken into account; if this is "
"required, use padding with parameter expansion flags @t{$@{(ml}@var{...}@t{)}@var{...}@t{@}} as described in `Parameter Expansion Flags' in @ref{Parameter Expansion}."
msgstr ""
"宽度是字符数，如果使用 @t{MULTIBYTE} 选项，则可能是多字节字符。 需要注意的是，字符的屏幕宽度不会考虑在内；如果需要，请使用参数扩展标志 @t{$@{(ml}@var{...}@t{)}@var{...}@t{@}} 填充，如 @ref{参数扩展} 中的 `"
"参数扩展标志' 所述。"

#. type: table
#: zsh.texi:15167
msgid ""
"When the parameter is expanded, it is filled on the right with blanks or truncated if necessary to fit the field.  Note truncation can lead to unexpected results with numeric parameters.  Leading zeros "
"are removed if the @t{-Z} flag is also set."
msgstr "当参数展开时，会在右侧填充空白，或根据需要截断以适应字段。 请注意，截断会导致数字参数出现意外结果。 如果同时设置了 @t{-Z} 标志，前导零将被删除。"

#. type: item
#: zsh.texi:15168
#, no-wrap
msgid "@t{-R} [ @var{n} ]"
msgstr "@t{-R} [ @var{n} ]"

#. type: table
#: zsh.texi:15173
msgid "Similar to @t{-L}, except that right justification is used; when the parameter is expanded, the field is left filled with blanks or truncated from the end.  May not be combined with the @t{-Z} flag."
msgstr "与 @t{-L} 类似，但使用右对齐方式；当参数展开时，字段左侧填充空白或从末尾截断。 不得与 @t{-Z} 标志结合使用。"

#. type: table
#: zsh.texi:15182
msgid ""
"For arrays (but not for associative arrays), keep only the first occurrence of each duplicated value.  This may also be set for tied parameters (see @t{-T}) or colon-separated special parameters like "
"@t{PATH} or @t{FIGNORE}, etc.  Note the flag takes effect on assignment, and the type of the variable being assigned to is determinative; for variables with shared values it is therefore recommended to "
"set the flag for all interfaces, e.g. `@t{typeset -U PATH path}'."
msgstr ""
"对于数组（但不包括关联数组），只保留每个重复值的第一次出现。 对于绑定参数（参见 @t{-T}）或以冒号分隔的特殊参数，如 @t{PATH} 或 @t{FIGNORE} 等，也可以设置此标志。 需要注意的是，该标志在赋值时生效，被赋值变"
"量的类型起决定作用；因此，对于具有共享值的变量，建议为所有接口设置该标志，例如 `@t{typeset -U PATH path}' 。"

#. type: table
#: zsh.texi:15185
msgid "This flag has a different meaning when used with @t{-f}; see below."
msgstr "当与 @t{-f} 搭配使用时，该标志的含义有所不同；见下文。"

#. type: item
#: zsh.texi:15186
#, no-wrap
msgid "@t{-Z} [ @var{n} ]"
msgstr "@t{-Z} [ @var{n} ]"

#. type: table
#: zsh.texi:15193
msgid ""
"Specially handled if set along with the @t{-L} flag.  Otherwise, similar to @t{-R}, except that leading zeros are used for padding instead of blanks if the first non-blank character is a digit.  Numeric "
"parameters are specially handled: they are always eligible for padding with zeroes, and the zeroes are inserted at an appropriate place in the output."
msgstr ""
"如果与 @t{-L} 标志一起设置，则进行特殊处理。否则，类似于 @t{-R}，只是如果第一个非空字符是数字，则使用前导零进行填充，而不是空格。 数字参数受到特殊处理：它们始终符合使用零进行填充的条件，并且零被插入到输出"
"中的适当位置。"

#. type: table
#: zsh.texi:15200
msgid ""
"The names refer to array parameters.  An array parameter may be created this way, but it may be assigned to in the @t{typeset} statement only if the reserved word form of @t{typeset} is enabled (as it is "
"by default).  When displaying, both normal and associative arrays are shown."
msgstr "这些名称指的是数组参数。 数组参数可以通过这种方式创建，但只有启用 @t{typeset} 的保留字形式（默认情况下是这样）后，才能在 @t{typeset} 语句中对其进行赋值。 显示时，普通数组和关联数组都会显示。"

#. type: table
#: zsh.texi:15212
msgid ""
"The names refer to functions rather than parameters.  No assignments can be made, and the only other valid flags are @t{-t}, @t{-T}, @t{-k}, @t{-u}, @t{-U} and @t{-z}.  The flag @t{-t} turns on execution "
"tracing for this function; the flag @t{-T} does the same, but turns off tracing for any named (not anonymous) function called from the present one, unless that function also has the @t{-t} or @t{-T} "
"flag.  The @t{-u} and @t{-U} flags cause the function to be marked for autoloading; @t{-U} also causes alias expansion to be suppressed when the function is loaded.  See the description of the "
"`@t{autoload}' builtin for details."
msgstr ""
"这些名称指的是函数而不是参数。 不能进行赋值，唯一有效的标志是 @t{-t}、@t{-T}、@t{-k}、@t{-u}、@t{-U} 和 @t{-z}。 标志 @t{-t} 开启了该函数的执行跟踪；标志 @t{-T} 的作用与此相同，但会关闭从当前函数调用的任何"
"命名函数（非匿名函数）的跟踪，除非该函数也具有 @t{-t} 或 @t{-T} 标志。 @t{-u} 和 @t{-U} 标志会将函数标记为自动加载；@t{-U} 还会在加载函数时抑制别名扩展。 详情请参见内置命令 `@t{autoload}' 的描述。"

#. type: table
#: zsh.texi:15218
msgid ""
"Note that the builtin @t{functions} provides the same basic capabilities as @t{typeset -f} but gives access to a few extra options; @t{autoload} gives further additional options for the case @t{typeset -"
"fu} and @t{typeset -fU}."
msgstr "请注意，内置的 @t{functions} 提供了与 @t{typeset -f} 相同的基本功能，但提供了一些额外的选项；@t{autoload} 为 @t{typeset -fu} 和 @t{typeset -fU} 的情况提供了更多的额外选项。"

#. type: table
#: zsh.texi:15234
msgid ""
"Hide: only useful for special parameters (those marked `<S>' in the table in @ref{Parameters Set By The Shell}), and for local parameters with the same name as a special parameter, though harmless for "
"others.  A special parameter with this attribute will not retain its special effect when made local.  Thus after `@t{typeset -h PATH}', a function containing `@t{typeset PATH}' will create an ordinary "
"local parameter without the usual behaviour of @t{PATH}.  Alternatively, the local parameter may itself be given this attribute; hence inside a function `@t{typeset -h PATH}' creates an ordinary local "
"parameter and the special @t{PATH} parameter is not altered in any way.  It is also possible to create a local parameter using `@t{typeset +h }@var{special}', where the local copy of @var{special} will "
"retain its special properties regardless of having the @t{-h} attribute.  Global special parameters loaded from shell modules (currently those in @t{zsh/mapfile} and @t{zsh/parameter}) are automatically "
"given the @t{-h} attribute to avoid name clashes."
msgstr ""
"隐藏：仅对特殊参数（在 @ref{由 Shell 设置的参数} 中的表格中标记为 `<S>' 的参数）和与特殊参数同名的本地参数有用，但对其他参数无害。 带有此属性的特殊参数在本地化后将不会保留其特殊效果。 因此，在 `@t{typeset "
"-h PATH}' 之后，包含 `@t{typeset PATH}' 的函数将创建一个普通的本地参数，而不具有 @t{PATH} 的通常行为。 或者，本地参数本身也可以被赋予此属性；因此，在函数 `@t{typeset -h PATH}' 中，将创建一个普通的本地参"
"数，而特殊的 @t{PATH} 参数不会以任何方式改变。 也可以使用 `@t{typeset +h }@var{special}' 创建一个本地参数，此时 @var{special} 的本地副本将保留其特殊属性，而与 @t{-h} 属性无关。 为避免名称冲突，从 shell 模"
"块加载的全局特殊参数（目前为 @t{zsh/mapfile} 和 @t{zsh/parameter} 中的参数）会自动获得 @t{-h} 属性。"

#. type: table
#: zsh.texi:15244
msgid ""
"Hide value: specifies that @t{typeset} will not display the value of the parameter when listing parameters; the display for such parameters is always as if the `@t{+}' flag had been given.  Use of the "
"parameter is in other respects normal, and the option does not apply if the parameter is specified by name, or by pattern with the @t{-m} option.  This is on by default for the parameters in the @t{zsh/"
"parameter} and @t{zsh/mapfile} modules.  Note, however, that unlike the @t{-h} flag this is also useful for non-special parameters."
msgstr ""
"隐藏值：指定 @t{typeset} 在列出参数时不显示参数的值；对此类参数的显示总是如同给定了 `@t{+}' 标志。 在其他方面，参数的使用是正常的，如果参数是通过名称或 @t{-m} 选项的模式指定的，则该选项不适用。 对于 "
"@t{zsh/parameter} 和 @t{zsh/mapfile} 模块中的参数，该选项默认为开启。 但需要注意的是，与 @t{-h} 标志不同，该标志也适用于非特殊参数。"

#. type: item
#: zsh.texi:15245
#, no-wrap
msgid "@t{-i} [ @var{n} ]"
msgstr "@t{-i} [ @var{n} ]"

#. type: table
#: zsh.texi:15249
msgid "Use an internal integer representation.  If @var{n} is nonzero it defines the output arithmetic base, otherwise it is determined by the first assignment.  Bases from 2 to 36 inclusive are allowed."
msgstr "使用内部整数表示。 如果 @var{n} 非零，则定义输出的算术基数，否则由第一个赋值决定。 允许的基数范围为 2 至 36（含 36）。"

#. type: item
#: zsh.texi:15250
#, no-wrap
msgid "@t{-E} [ @var{n} ]"
msgstr "@t{-E} [ @var{n} ]"

#. type: table
#: zsh.texi:15255
msgid ""
"Use an internal double-precision floating point representation.  On output the variable will be converted to scientific notation.  If @var{n} is nonzero it defines the number of significant figures to "
"display; the default is ten."
msgstr "使用内部双精度浮点表示法。 输出时，变量将转换为科学计数法。 如果 @var{n} 非零，则定义要显示的有效数字个数；默认为 10。"

#. type: item
#: zsh.texi:15256
#, no-wrap
msgid "@t{-F} [ @var{n} ]"
msgstr "@t{-F} [ @var{n} ]"

#. type: table
#: zsh.texi:15261
msgid ""
"Use an internal double-precision floating point representation.  On output the variable will be converted to fixed-point decimal notation.  If @var{n} is nonzero it defines the number of digits to display "
"after the decimal point; the default is ten."
msgstr "使用内部双精度浮点表示法。 输出时，变量将转换为定点小数。 如果 @var{n} 非零，则定义小数点后显示的位数；默认为十位。"

#. type: table
#: zsh.texi:15265
msgid "Convert the result to lower case whenever the parameter is expanded.  The value is @emph{not} converted when assigned."
msgstr "当参数展开时，将结果转换为小写。 赋值时将 @emph{不} 进行转换。"

#. type: table
#: zsh.texi:15270
msgid "The given @var{name}s are marked readonly.  Note that if @var{name} is a special parameter, the readonly attribute can be turned on, but cannot then be turned off."
msgstr "给定的 @var{name}s 将被标记为只读。 需要注意的是，如果 @var{name} 是一个特殊参数，那么只读属性可以打开，但之后不能关闭。"

#. type: table
#: zsh.texi:15276
msgid ""
"If the @t{POSIX_BUILTINS} option is set, the readonly attribute is more restrictive: unset variables can be marked readonly and cannot then be set; furthermore, the readonly attribute cannot be removed "
"from any variable."
msgstr "如果设置了 @t{POSIX_BUILTINS} 选项，只读属性的限制性会更强：未设置的变量可以标记为 readonly，但之后不能设置；此外，只读属性不能从任何变量中移除。"

#. type: table
#: zsh.texi:15281
msgid ""
"It is still possible to change other attributes of the variable though, some of which like @t{-U} or @t{-Z} would affect the value. More generally, the readonly attribute should not be relied on as a "
"security mechanism."
msgstr "但仍有可能更改变量的其他属性，其中一些属性（如 @t{-U} 或 @t{-Z} ）会影响变量值。一般来说，不应将只读属性作为一种安全机制。"

#. type: table
#: zsh.texi:15288
msgid ""
"Note that in zsh (like in pdksh but unlike most other shells) it is still possible to create a local variable of the same name as this is considered a different variable (though this variable, too, can be "
"marked readonly). Special variables that have been made readonly retain their value and readonly attribute when made local."
msgstr ""
"请注意，在 zsh 中（与 pdksh 类似，但与大多数其他 shell 不同），仍然可以创建一个同名的局部变量，因为这被视为一个不同的变量（尽管这个变量也可以标记为只读）。已设置为只读的特殊变量在设置为本地变量后，其值和只"
"读属性仍会保留。"

#. type: table
#: zsh.texi:15292
msgid "Tags the named parameters.  Tags have no special meaning to the shell.  This flag has a different meaning when used with @t{-f}; see above."
msgstr "为已命名的参数打标签。 标签对 shell 没有特殊意义。 当与 @t{-f} 一起使用时，该标志具有不同的含义；参见上文。"

#. type: table
#: zsh.texi:15297
msgid "Convert the result to upper case whenever the parameter is expanded.  The value is @emph{not} converted when assigned.  This flag has a different meaning when used with @t{-f}; see above."
msgstr "当参数展开时，将结果转换为大写。 赋值时@emph{不}会进行转换。 当与 @t{-f} 一起使用时，该标志具有不同的含义；参见上文。"

#. type: table
#: zsh.texi:15304
msgid ""
"Mark for automatic export to the environment of subsequently executed commands.  If the option @t{GLOBAL_EXPORT} is set, this implies the option @t{-g}, unless @t{+g} is also explicitly given; in other "
"words the parameter is not made local to the enclosing function.  This is for compatibility with previous versions of zsh."
msgstr "标记，用于将随后执行的命令自动导出到环境中。 如果设置了选项 @t{GLOBAL_EXPORT}，这意味着选项 @t{-g}，除非同时明确给出 @t{+g}；换句话说，参数不会被本地化到闭合函数中。 这是为了与以前版本的 zsh 兼容。"

#. type: findex
#: zsh.texi:15307
#, no-wrap
msgid "ulimit"
msgstr "ulimit"

#. type: item
#: zsh.texi:15310
#, no-wrap
msgid "@t{ulimit} [ @t{-HSa} ] [ @{ @t{-bcdfiklmnpqrsTtvwx} | @t{-N} @var{resource} @} [ @var{limit} ] ... ]"
msgstr "@t{ulimit} [ @t{-HSa} ] [ @{ @t{-bcdfiklmnpqrsTtvwx} | @t{-N} @var{resource} @} [ @var{limit} ] ... ]"

#. type: table
#: zsh.texi:15316
msgid ""
"Set or display resource limits of the shell and the processes started by the shell.  The value of @var{limit} can be a number in the unit specified below or one of the values `@t{unlimited}', which "
"removes the limit on the resource, or `@t{hard}', which uses the current value of the hard limit on the resource."
msgstr "设置或显示 shell 和 shell 启动的进程的资源限制。 @var{limit} 的值可以是以下面指定的单位表示的数字，也可以是 `@t{unlimited}'（删除资源限制）或 `@t{hard}'（使用资源硬限制的当前值）中的一个值。"

#. type: table
#: zsh.texi:15321
msgid ""
"By default, only soft limits are manipulated. If the @t{-H} flag is given use hard limits instead of soft limits.  If the @t{-S} flag is given together with the @t{-H} flag set both hard and soft limits."
msgstr "默认情况下，只处理软限制。如果给出 @t{-H} 标志，则使用硬限值代替软限值。 如果同时给出 @t{-S} 标志和 @t{-H} 标志，则同时设置硬限值和软限值。"

#. type: table
#: zsh.texi:15324
msgid "If no options are used, the file size limit (@t{-f}) is assumed."
msgstr "如果没有使用选项，则假定使用文件大小限制 (@t{-f})。"

#. type: table
#: zsh.texi:15329
msgid "If @var{limit} is omitted the current value of the specified resources are printed.  When more than one resource value is printed, the limit name and unit is printed before each value."
msgstr "如果省略 @var{limit}，则打印指定资源的当前值。 如果打印的资源值不止一个，则会在每个值之前打印限制的名称和单位。"

#. type: table
#: zsh.texi:15338
msgid "Not all the following resources are supported on all systems.  Running @t{ulimit -a} will show which are supported."
msgstr "并非所有系统都支持以下所有资源。 运行 @t{ulimit -a} 将显示支持哪些资源。"

#. type: table
#: zsh.texi:15343
msgid "Lists all of the current resource limits."
msgstr "列出所有当前资源限制。"

#. type: table
#: zsh.texi:15345
msgid "Socket buffer size in bytes (N.B. not kilobytes)"
msgstr "以字节为单位的套接字缓冲区大小（注意：不是千字节）"

#. type: table
#: zsh.texi:15347
msgid "512-byte blocks on the size of core dumps."
msgstr "512 字节块，核心转储大小。"

#. type: table
#: zsh.texi:15349
msgid "Kilobytes on the size of the data segment."
msgstr "千字节，表示数据段的大小。"

#. type: table
#: zsh.texi:15351
msgid "512-byte blocks on the size of files written."
msgstr "写入文件大小的， 512 字节块。"

#. type: table
#: zsh.texi:15353
msgid "The number of pending signals."
msgstr "待处理信号的数量。"

#. type: table
#: zsh.texi:15355
msgid "The number of kqueues allocated."
msgstr "分配的 kqueues 数量。"

#. type: table
#: zsh.texi:15357
msgid "Kilobytes on the size of locked-in memory."
msgstr "千字节，锁定内存大小。"

#. type: table
#: zsh.texi:15359
msgid "Kilobytes on the size of physical memory."
msgstr "千字节，物理内存的大小。"

#. type: table
#: zsh.texi:15361
msgid "open file descriptors."
msgstr "打开文件描述符。"

#. type: table
#: zsh.texi:15363
msgid "The number of pseudo-terminals."
msgstr "伪终端的数量。"

#. type: table
#: zsh.texi:15365
msgid "Bytes in POSIX message queues."
msgstr "POSIX 消息队列中的字节数。"

#. type: table
#: zsh.texi:15369
msgid "Maximum real time priority.  On some systems where this is not available, such as NetBSD, this has the same effect as @t{-T} for compatibility with @t{sh}."
msgstr "最大实时优先级。 在某些没有这个的系统（如 NetBSD）中，为了与 @t{sh} 兼容，该选项与 @t{-T} 具有相同的效果。"

#. type: table
#: zsh.texi:15371
msgid "Kilobytes on the size of the stack."
msgstr "千字节，堆栈大小。"

#. type: table
#: zsh.texi:15373
msgid "The number of simultaneous threads available to the user."
msgstr "用户可同时使用的线程数。"

#. type: table
#: zsh.texi:15375
msgid "CPU seconds to be used."
msgstr "使用的 CPU 秒数。"

#. type: table
#: zsh.texi:15377
msgid "The number of processes available to the user."
msgstr "用户可使用的进程数。"

#. type: table
#: zsh.texi:15380
msgid "Kilobytes on the size of virtual memory.  On some systems this refers to the limit called `address space'."
msgstr "虚拟内存大小，千字节。 在某些系统中，这是指称为 `地址空间' 的限制。"

#. type: table
#: zsh.texi:15382
msgid "Kilobytes on the size of swapped out memory."
msgstr "千字节，表示被交换出去的内存大小。"

#. type: table
#: zsh.texi:15384
msgid "The number of locks on files."
msgstr "文件锁的数量。"

#. type: table
#: zsh.texi:15392
msgid ""
"A resource may also be specified by integer in the form `@t{-N} @var{resource}', where @var{resource} corresponds to the integer defined for the resource by the operating system.  This may be used to set "
"the limits for resources known to the shell which do not correspond to option letters.  Such limits will be shown by number in the output of `@t{ulimit -a}'."
msgstr ""
"资源也可以通过整数形式 `@t{-N} @var{resource}' 指定，其中 @var{resource} 对应于操作系统为资源定义的整数。 这可以用来设置 shell 已知的、与选项字母不对应的资源的限制。 这些限制将在 `@t{ulimit -a}' 的输出中以"
"数字显示。"

#. type: table
#: zsh.texi:15397
msgid "The number may alternatively be out of the range of limits compiled into the shell.  The shell will try to read or write the limit anyway, and will report an error if this fails."
msgstr "该数字也可能超出编译到 shell 中的限制范围。 shell 会尝试读取或写入限制值，如果失败则会报错。"

#. type: cindex
#: zsh.texi:15398 zsh.texi:15399
#, no-wrap
msgid "umask"
msgstr "umask"

#. type: item
#: zsh.texi:15400
#, no-wrap
msgid "@t{umask} [ @t{-S} ] [ @var{mask} ]"
msgstr "@t{umask} [ @t{-S} ] [ @var{mask} ]"

#. type: table
#: zsh.texi:15408
msgid ""
"The umask is set to @var{mask}.  @var{mask} can be either an octal number or a symbolic value as described in the chmod(1) man page.  If @var{mask} is omitted, the current value is printed.  The @t{-S} "
"option causes the mask to be printed as a symbolic value.  Otherwise, the mask is printed as an octal number.  Note that in the symbolic form the permissions you specify are those which are to be allowed "
"(not denied) to the users specified."
msgstr ""
"umask 设置为 @var{mask}。 @var{mask} 可以是八进制数，也可以是 chmod(1) 手册页中描述的符号值。 如果省略 @var{mask}，则打印当前值。 @t{-S} 选项会将掩码打印为符号值。 否则，掩码将以八进制数的形式打印。 请注"
"意，在符号形式下，您指定的权限是允许（而不是拒绝）给指定用户的权限。"

#. type: cindex
#: zsh.texi:15409
#, no-wrap
msgid "aliases, removing"
msgstr "别名, 删除"

#. type: item
#: zsh.texi:15410
#, no-wrap
msgid "@t{unalias} [ @t{-ams} ] @var{name} ..."
msgstr "@t{unalias} [ @t{-ams} ] @var{name} ..."

#. type: table
#: zsh.texi:15417
msgid ""
"Removes aliases.  This command works the same as @t{unhash -a}, except that the @t{-a} option removes all regular or global aliases, or with @t{-s} all suffix aliases: in this case no @var{name} arguments "
"may appear.  The options @t{-m} (remove by pattern) and @t{-s} without @t{-a} (remove listed suffix aliases) behave as for @t{unhash -a}.  Note that the meaning of @t{-a} is different between @t{unalias} "
"and @t{unhash}."
msgstr ""
"删除别名。 该命令的作用与 @t{unhash -a} 相同，但 @t{-a} 选项会移除所有常规或全局别名，或 @t{-s} 会移除所有后缀别名：在这种情况下，不能出现 @var{name} 参数。 选项 @t{-m}（按模式移除）和 @t{-s}（不含 @t{-"
"a}）（移除列出的后缀别名）的作用与 @t{unhash -a} 相同。 注意 @t{-a} 的含义在 @t{unalias} 和 @t{unhash} 中有所不同。"

#. type: cindex
#: zsh.texi:15418
#, no-wrap
msgid "functions, removing"
msgstr "函数, 删除"

#. type: t{#1}
#: zsh.texi:15419 zsh.texi:15420
#, no-wrap
msgid "unfunction"
msgstr "unfunction"

#. type: table
#: zsh.texi:15422
msgid "Same as @t{unhash -f}."
msgstr "与 @t{unhash -f} 相同."

#. type: findex
#: zsh.texi:15423
#, no-wrap
msgid "unhash"
msgstr "unhash"

#. type: item
#: zsh.texi:15424
#, no-wrap
msgid "@t{unhash} [ @t{-adfms} ] @var{name} ..."
msgstr "@t{unhash} [ @t{-adfms} ] @var{name} ..."

#. type: table
#: zsh.texi:15436
msgid ""
"Remove the element named @var{name} from an internal hash table.  The default is remove elements from the command hash table.  The @t{-a} option causes @t{unhash} to remove regular or global aliases; note "
"when removing a global aliases that the argument must be quoted to prevent it from being expanded before being passed to the command.  The @t{-s} option causes @t{unhash} to remove suffix aliases.  The "
"@t{-f} option causes @t{unhash} to remove shell functions.  The @t{-d} options causes @t{unhash} to remove named directories.  If the @t{-m} flag is given the arguments are taken as patterns (should be "
"quoted) and all elements of the corresponding hash table with matching names will be removed."
msgstr ""
"从内部哈希表中删除名为 @var{name} 的元素。 默认是从命令哈希表中移除元素。 使用 @t{-a} 选项，@t{unhash} 会移除常规或全局别名；注意移除全局别名时，参数必须加引号，以防止在传递给命令前被展开。 使用 @t{-s} 选"
"项，@t{unhash} 会移除后缀别名。 @t{-f} 选项会使 @t{unhash} 删除 shell 函数。 通过 @t{-d} 选项，@t{unhash} 会移除命名目录。 如果给定了 @t{-m} 标志，参数将被视为模式（应加引号），相应哈希表中名称匹配的所有元"
"素都将被移除。"

#. type: findex
#: zsh.texi:15437
#, no-wrap
msgid "unlimit"
msgstr "unlimit"

#. type: item
#: zsh.texi:15440
#, no-wrap
msgid "@t{unlimit} [ @t{-hs} ] @var{resource} ..."
msgstr "@t{unlimit} [ @t{-hs} ] @var{resource} ..."

#. type: table
#: zsh.texi:15446
msgid ""
"The resource limit for each @var{resource} is set to the hard limit.  If the @t{-h} flag is given and the shell has appropriate privileges, the hard resource limit for each @var{resource} is removed.  The "
"resources of the shell process are only changed if the @t{-s} flag is given."
msgstr ""
"每个 @var{resource} 的资源限制都会设置为硬限制。 如果给定了 @t{-h} 标志，且 shell 拥有相应权限，则会删除每个 @var{resource} 的硬资源限制。 只有在给出 @t{-s} 标志的情况下，shell 进程的资源才会被更改。"

#. type: table
#: zsh.texi:15451
msgid "The @t{unlimit} command is not made available by default when the shell starts in a mode emulating another shell.  It can be made available with the command `@t{zmodload -F zsh/rlimits b:unlimit}'."
msgstr "当 shell 以模拟其他 shell 的模式启动时，@t{unlimit} 命令默认不可用。 可以使用 `@t{zmodload -F zsh/rlimits b:unlimit}' 命令来使用它。"

#. type: findex
#: zsh.texi:15452
#, no-wrap
msgid "unset"
msgstr "unset"

#. type: cindex
#: zsh.texi:15453
#, no-wrap
msgid "parameters, unsetting"
msgstr "参数, 取消设置"

#. type: item
#: zsh.texi:15454
#, no-wrap
msgid "@t{unset} [ @t{-fmv} ] @var{name} ..."
msgstr "@t{unset} [ @t{-fmv} ] @var{name} ..."

#. type: table
#: zsh.texi:15458
msgid "Each named parameter is unset.  Local parameters remain local even if unset; they appear unset within scope, but the previous value will still reappear when the scope ends."
msgstr "每个已命名的参数都是未设置的。 即使未设置，本地参数仍是本地参数；它们在作用域内显示为未设置，但当作用域结束时，先前的值仍会重新出现。"

#. type: table
#: zsh.texi:15463
msgid ""
"Individual elements of associative array parameters may be unset by using subscript syntax on @var{name}, which should be quoted (or the entire command prefixed with @t{noglob}) to protect the subscript "
"from filename generation."
msgstr "关联数组参数的单个元素可以通过 @var{name} 上的下标语法取消设置，下标应加引号（或整个命令前加 @t{noglob}），以防止文件名生成。"

#. type: table
#: zsh.texi:15469
msgid ""
"If the @t{-m} flag is specified the arguments are taken as patterns (should be quoted) and all parameters with matching names are unset.  Note that this cannot be used when unsetting associative array "
"elements, as the subscript will be treated as part of the pattern."
msgstr "如果指定了 @t{-m} 标志，参数将被视为模式（应加引号），所有名称匹配的参数将被取消设置。 需要注意的是，该标志不能用于关联数组元素的取消设置，因为下标将被视为模式的一部分。"

#. type: table
#: zsh.texi:15473
msgid "The @t{-v} flag specifies that @var{name} refers to parameters. This is the default behaviour."
msgstr "@t{-v} 标志指定 @var{name} 指向参数。这是默认行为。"

#. type: table
#: zsh.texi:15476
msgid "@t{unset -f} is equivalent to @t{unfunction}."
msgstr "@t{unset -f} 等价于 @t{unfunction}。"

#. type: findex
#: zsh.texi:15477
#, no-wrap
msgid "unsetopt"
msgstr "unsetopt"

#. type: cindex
#: zsh.texi:15478
#, no-wrap
msgid "options, unsetting"
msgstr "选项, 取消设置"

#. type: item
#: zsh.texi:15479
#, no-wrap
msgid "@t{unsetopt} [ @{@t{+}|@t{-}@}@var{options} | @{@t{+}|@t{-}@}@t{o} @var{option_name} ] [ @var{name} ... ]"
msgstr "@t{unsetopt} [ @{@t{+}|@t{-}@}@var{options} | @{@t{+}|@t{-}@}@t{o} @var{option_name} ] [ @var{name} ... ]"

#. type: table
#: zsh.texi:15486
msgid ""
"Unset the options for the shell.  All options specified either with flags or by name are unset.  If no arguments are supplied, the names of all options currently unset are printed.  If the @t{-m} flag is "
"given the arguments are taken as patterns (which should be quoted to preserve them from being interpreted as glob patterns), and all options with names matching these patterns are unset."
msgstr ""
"取消设置 shell 的选项。 所有用标志或名称指定的选项都会被取消设置。 如果没有提供参数，则会打印当前未设置的所有选项名称。 如果给出 @t{-m} 标志，参数将作为模式（应加引号以防止被解释为 glob 模式），所有名称与"
"这些模式匹配的选项将被取消设置。"

#. type: t{#1}
#: zsh.texi:15487 zsh.texi:16500 zsh.texi:17040 zsh.texi:19676
#, no-wrap
msgid "vared"
msgstr "vared"

#. type: findex
#: zsh.texi:15490
#, no-wrap
msgid "wait"
msgstr "wait"

#. type: cindex
#: zsh.texi:15491
#, no-wrap
msgid "waiting for jobs"
msgstr "等待作业"

#. type: cindex
#: zsh.texi:15492
#, no-wrap
msgid "jobs, waiting for"
msgstr "作业, 等待"

#. type: item
#: zsh.texi:15493
#, no-wrap
msgid "@t{wait} [ @var{job} ... ]"
msgstr "@t{wait} [ @var{job} ... ]"

#. type: table
#: zsh.texi:15501
msgid ""
"Wait for the specified jobs or processes.  If @var{job} is not given then all currently active child processes are waited for.  Each @var{job} can be either a job specification or the process ID of a job "
"in the job table.  The exit status from this command is that of the job waited for.  If @var{job} represents an unknown job or process ID, a warning is printed (unless the @t{POSIX_BUILTINS} option is "
"set) and the exit status is 127."
msgstr ""
"等待指定的作业或进程。 如果未给出 @var{job}，则会等待所有当前活动的子进程。 每个 @var{job} 既可以是作业指示器，也可以是作业表中作业的进程 ID。 该命令的退出状态是所等待作业的退出状态。 如果 @var{job} 代表未"
"知作业或进程 ID，则会打印警告（除非设置了 @t{POSIX_BUILTINS} 选项），退出状态为 127。"

#. type: table
#: zsh.texi:15511
msgid ""
"It is possible to wait for recent processes (specified by process ID, not by job) that were running in the background even if the process has exited.  Typically the process ID will be recorded by "
"capturing the value of the variable @t{$!} immediately after the process has been started.  There is a limit on the number of process IDs remembered by the shell; this is given by the value of the system "
"configuration parameter @t{CHILD_MAX}.  When this limit is reached, older process IDs are discarded, least recently started processes first."
msgstr ""
"可以等待最近在后台运行的进程（由进程 ID 指定，而不是由作业指定），即使该进程已经退出。 通常情况下，进程 ID 会在进程启动后立即通过捕获变量 @t{$!} 的值记录下来。 shell 记忆的进程 ID 数量是有限制的，这个限制"
"由系统配置参数 @t{CHILD_MAX} 的值决定。 当达到这个限制时，较旧的进程 ID 将被丢弃，最近启动的进程将被优先丢弃。"

#. type: table
#: zsh.texi:15519
msgid ""
"Note there is no protection against the process ID wrapping, i.e. if the wait is not executed soon enough there is a chance the process waited for is the wrong one.  A conflict implies both process IDs "
"have been generated by the shell, as other processes are not recorded, and that the user is potentially interested in both, so this problem is intrinsic to process IDs."
msgstr ""
"注意，没有机制来防止进程ID的回绕，即如果等待操作没有足够快地执行，那么等待的可能是错误的进程。冲突意味着两个进程ID都是由shell生成的，因为其他进程并没有被记录下来，并且用户可能对这两个进程都感兴趣，所以这个"
"问题是进程ID固有的。"

#. type: findex
#: zsh.texi:15520
#, no-wrap
msgid "whence"
msgstr "whence"

#. type: item
#: zsh.texi:15521
#, no-wrap
msgid "@t{whence} [ @t{-vcwfpamsS} ] [ @t{-x} @var{num} ] @var{name} ..."
msgstr "@t{whence} [ @t{-vcwfpamsS} ] [ @t{-x} @var{num} ] @var{name} ..."

#. type: table
#: zsh.texi:15524
msgid "For each @var{name}, indicate how it would be interpreted if used as a command name."
msgstr "对于每个 @var{name}，指出如果用作命令名时，将如何解释。"

#. type: table
#: zsh.texi:15531
msgid ""
"If @var{name} is not an alias, built-in command, external command, shell function, hashed command, or a reserved word, the exit status shall be non-zero, and --- if @t{-v}, @t{-c}, or @t{-w} was passed "
"--- a message will be written to standard output.  (This is different from other shells that write that message to standard error.)"
msgstr ""
"如果 @var{name} 不是别名、内置命令、外部命令、shell 函数、散列的命令或保留字，则退出状态应为非零，并且 --- 如果传递了 @t{-v}、@t{-c} 或 @t{-w} --- 一条信息将被写入标准输出。 (这与其他 shell 将信息写入标准"
"错误不同）。"

#. type: table
#: zsh.texi:15537
msgid ""
"@t{whence} is most useful when @var{name} is only the last path component of a command, i.e. does not include a `@t{/}'; in particular, pattern matching only succeeds if just the non-directory component "
"of the command is passed."
msgstr "@t{whence} 在 @var{name} 只是命令的最后一个路径组件，即不包括 `@t{/}'时，最有用；特别是，只有在只传递命令的非目录组件时，模式匹配才会成功。"

#. type: table
#: zsh.texi:15542
msgid "Produce a more verbose report."
msgstr "生成更详细的报告。"

#. type: table
#: zsh.texi:15546
msgid "Print the results in a @cite{csh}-like format.  This takes precedence over @t{-v}."
msgstr "以 @cite{csh} 类似的格式打印结果。 其优先级高于 @t{-v}。"

#. type: table
#: zsh.texi:15555
msgid ""
"For each @var{name}, print `@var{name}@t{:} @var{word}' where @var{word} is one of @t{alias}, @t{builtin}, @t{command}, @t{function}, @t{hashed}, @t{reserved} or @t{none}, according as @var{name} "
"corresponds to an alias, a built-in command, an external command, a shell function, a command defined with the @t{hash} builtin, a reserved word, or is not recognised.  This takes precedence over @t{-v} "
"and @t{-c}."
msgstr ""
"对于每个 @var{name}，打印 `@var{name}@t{:} @var{word}' ，其中 @var{word}是 @t{alias}, @t{builtin}, @t{command}, @t{function}, @t{hashed}, @t{reserved} 或 @t{none}中的一个，根据 @var{name} 对应的别名、内置"
"命令、外部命令、shell 函数、使用 @t{hash} 内置命令定义的命令、保留字或未识别。 其优先级高于 @t{-v} 和 @t{-c}。"

#. type: table
#: zsh.texi:15560
msgid "Causes the contents of a shell function to be displayed, which would otherwise not happen unless the @t{-c} flag were used."
msgstr "显示 shell 函数的内容，这在不使用 @t{-c} 标志时，不会显示。"

#. type: table
#: zsh.texi:15564
msgid "Do a path search for @var{name} even if it is an alias, reserved word, shell function or builtin."
msgstr "对 @var{name} 进行路径搜索，即使它是别名、保留字、shell 函数或内置命令。"

#. type: table
#: zsh.texi:15569
msgid "Do a search for all occurrences of @var{name} throughout the command path.  Normally only the first occurrence is printed."
msgstr "在命令路径中搜索 @var{name} 的所有出现次数。 通常只打印第一次出现的内容。"

#. type: table
#: zsh.texi:15574
msgid "The arguments are taken as patterns (pattern characters should be quoted), and the information is displayed for each command matching one of these patterns."
msgstr "参数被视为模式（模式字符应加引号），每条与其中一个模式匹配的命令的信息都将显示。"

#. type: table
#: zsh.texi:15577
msgid "If a pathname contains symlinks, print the symlink-free pathname as well."
msgstr "如果路径名包含符号链接，则同时打印不含符号链接的路径名。"

#. type: table
#: zsh.texi:15582
msgid "As @t{-s}, but if the pathname had to be resolved by following multiple symlinks, the intermediate steps are printed, too.  The symlink resolved at each step might be anywhere in the path."
msgstr "与 @t{-s}相同，但如果需要通过多个符号链接来解析路径名，则也会打印中间步骤。 每一步解析的符号链接可能在路径的任何位置。"

#. type: item
#: zsh.texi:15583
#, no-wrap
msgid "@t{-x} @var{num}"
msgstr "@t{-x} @var{num}"

#. type: table
#: zsh.texi:15587
msgid "Expand tabs when outputting shell functions using the @t{-c} option.  This has the same effect as the @t{-x} option to the @t{functions} builtin."
msgstr "使用 @t{-c} 选项输出 shell 函数时展开制表符。 这与 @t{functions} 内置命令的选项 @t{-x} 的效果相同。"

#. type: findex
#: zsh.texi:15590
#, no-wrap
msgid "where"
msgstr "where"

#. type: item
#: zsh.texi:15591
#, no-wrap
msgid "@t{where} [ @t{-wpmsS} ] [ @t{-x} @var{num} ] @var{name} ..."
msgstr "@t{where} [ @t{-wpmsS} ] [ @t{-x} @var{num} ] @var{name} ..."

#. type: table
#: zsh.texi:15593
msgid "Equivalent to @t{whence -ca}."
msgstr "等价于 @t{whence -ca}."

#. type: findex
#: zsh.texi:15594
#, no-wrap
msgid "which"
msgstr "which"

#. type: item
#: zsh.texi:15595
#, no-wrap
msgid "@t{which} [ @t{-wpamsS} ] [ @t{-x} @var{num} ] @var{name} ..."
msgstr "@t{which} [ @t{-wpamsS} ] [ @t{-x} @var{num} ] @var{name} ..."

#. type: table
#: zsh.texi:15597
msgid "Equivalent to @t{whence -c}."
msgstr "等价于 @t{whence -c}."

#. type: findex
#: zsh.texi:15598
#, no-wrap
msgid "zcompile"
msgstr "zcompile"

#. type: cindex
#: zsh.texi:15599
#, no-wrap
msgid ".zwc files, creation"
msgstr ".zwc 文件, 创建"

#. type: cindex
#: zsh.texi:15600
#, no-wrap
msgid "compilation"
msgstr "编译"

#. type: item
#: zsh.texi:15601
#, no-wrap
msgid "@t{zcompile} [ @t{-U} ] [ @t{-z} | @t{-k} ] [ @t{-R} | @t{-M} ] @var{file} [ @var{name} ... ]"
msgstr "@t{zcompile} [ @t{-U} ] [ @t{-z} | @t{-k} ] [ @t{-R} | @t{-M} ] @var{file} [ @var{name} ... ]"

#. type: itemx
#: zsh.texi:15602
#, no-wrap
msgid "@t{zcompile} @t{-ca} [ @t{-m} ] [ @t{-R} | @t{-M} ] @var{file} [ @var{name} ... ]"
msgstr "@t{zcompile} @t{-ca} [ @t{-m} ] [ @t{-R} | @t{-M} ] @var{file} [ @var{name} ... ]"

#. type: itemx
#: zsh.texi:15603
#, no-wrap
msgid "@t{zcompile -t} @var{file} [ @var{name} ... ]"
msgstr "@t{zcompile -t} @var{file} [ @var{name} ... ]"

#. type: table
#: zsh.texi:15609
msgid ""
"This builtin command can be used to compile functions or scripts, storing the compiled form in a file, and to examine files containing the compiled form.  This allows faster autoloading of functions and "
"sourcing of scripts by avoiding parsing of the text when the files are read."
msgstr "该内置命令可用于编译函数或脚本，将编译后的形式存储在文件中，并检查包含编译后形式的文件。 这样可以避免在读取文件时对文本进行解析，从而加快函数的自动加载和脚本的引入。"

#. type: table
#: zsh.texi:15620
msgid ""
"The first form (without the @t{-c}, @t{-a} or @t{-t} options) creates a compiled file.  If only the @var{file} argument is given, the output file has the name `@var{file}@t{.zwc}' and will be placed in "
"the same directory as the @var{file}.  The shell will load the compiled file instead of the normal function file when the function is autoloaded; see @ref{Functions} for a description of how autoloaded "
"functions are searched.  The extension @t{.zwc} stands for `zsh word code'."
msgstr ""
"第一种形式（不含 @t{-c}、@t{-a} 或 @t{-t} 选项）会创建一个编译文件。 如果只给出 @var{file} 参数，输出文件的名称为 `@var{file}@t{.zwc}' ，并与 @var{file} 位于同一目录。 当函数被自动加载时，shell 将加载编译"
"后的文件，而不是普通的函数文件；关于如何搜索自动加载的函数，请参阅 @ref{函数}。 扩展名 @t{.zwc} 代表 `zsh word code'。"

#. type: vindex
#: zsh.texi:15622
#, no-wrap
msgid "fpath, with zcompile"
msgstr "fpath, 用 zcompile"

#. type: table
#: zsh.texi:15629
msgid ""
"If there is at least one @var{name} argument, all the named files are compiled into the output @var{file} given as the first argument.  If @var{file} does not end in @t{.zwc}, this extension is "
"automatically appended.  Files containing multiple compiled functions are called `digest' files, and are intended to be used as elements of the @t{FPATH}/@t{fpath} special array."
msgstr ""
"如果至少有一个 @var{name} 参数，所有命名的文件都会被编译到作为第一个参数给出的输出 @var{file} 中。 如果 @var{file} 不是以 @t{.zwc} 结尾，则会自动添加此扩展名。 包含多个编译函数的文件称为 `digest' 文件，可"
"用作 @t{FPATH}/@t{fpath} 特殊数组的元素。"

#. type: table
#: zsh.texi:15642
msgid ""
"The second form, with the @t{-c} or @t{-a} options, writes the compiled definitions for all the named functions into @var{file}.  For @t{-c}, the names must be functions currently defined in the shell, "
"not those marked for autoloading.  Undefined functions that are marked for autoloading may be written by using the @t{-a} option, in which case the @t{fpath} is searched and the contents of the definition "
"files for those functions, if found, are compiled into @var{file}.  If both @t{-c} and @t{-a} are given, names of both defined functions and functions marked for autoloading may be given.  In either case, "
"the functions in files written with the @t{-c} or @t{-a} option will be autoloaded as if the @t{KSH_AUTOLOAD} option were unset."
msgstr ""
"第二种形式是使用 @t{-c} 或 @t{-a} 选项，将所有指定函数的编译定义写入 @var{file}。 对于 @t{-c}，函数名必须是 shell 当前定义的函数，而不是标记为自动加载的函数。 标记为自动加载的未定义函数可以通过使用 @t{-a} "
"选项来编写，在这种情况下，系统会搜索 @t{fpath}，如果找到这些函数的定义文件，就会将其内容编译到 @var{file} 中。 如果同时给出 @t{-c} 和 @t{-a}，则可能同时给出已定义函数和标记为自动加载的函数的名称。 无论哪种"
"情况，使用 @t{-c} 或 @t{-a} 选项编写的文件中的函数都将被自动加载，就像未设置 @t{KSH_AUTOLOAD} 选项一样。"

#. type: table
#: zsh.texi:15651
msgid ""
"The reason for handling loaded and not-yet-loaded functions with different options is that some definition files for autoloading define multiple functions, including the function with the same name as the "
"file, and, at the end, call that function.  In such cases the output of `@t{zcompile -c}' does not include the additional functions defined in the file, and any other initialization code in the file is "
"lost.  Using `@t{zcompile -a}' captures all this extra information."
msgstr ""
"之所以要用不同的选项来处理已加载和尚未加载的函数，是因为有些自动加载的定义文件会定义多个函数，包括与文件同名的函数，并在最后调用该函数。 在这种情况下，`@t{zcompile -c}' 的输出不包括文件中定义的额外函数，文"
"件中的其他初始化代码也会丢失。 使用`@t{zcompile -a}' 可以捕获所有这些额外信息。"

#. type: table
#: zsh.texi:15658
msgid ""
"If the @t{-m} option is combined with @t{-c} or @t{-a}, the @var{name}s are used as patterns and all functions whose names match one of these patterns will be written. If no @var{name} is given, the "
"definitions of all functions currently defined or marked as autoloaded will be written."
msgstr "如果 @t{-m} 选项与 @t{-c} 或 @t{-a} 结合使用，则 @var{name}s 将被用作模式，所有名称与其中一个模式匹配的函数都将被写入。如果未给出 @var{name}，则将写入当前定义或标记为自动加载的所有函数的定义。"

#. type: table
#: zsh.texi:15663
msgid "Note the second form cannot be used for compiling functions that include redirections as part of the definition rather than within the body of the function; for example"
msgstr "注意，如果函数将重定向作为定义的一部分而不是在包含在函数主体中，第二种形式不能用于编译这样的一个函数，例如"

#. type: example
#: zsh.texi:15667
#, no-wrap
msgid "fn1() @{ @{ ... @} >~/logfile @}\n"
msgstr "fn1() @{ @{ ... @} >~/logfile @}\n"

#. type: table
#: zsh.texi:15671
msgid "can be compiled but"
msgstr "可以被编译，但是"

#. type: example
#: zsh.texi:15675
#, no-wrap
msgid "fn1() @{ ... @} >~/logfile\n"
msgstr "fn1() @{ ... @} >~/logfile\n"

#. type: table
#: zsh.texi:15681
msgid "cannot.  It is possible to use the first form of @t{zcompile} to compile autoloadable functions that include the full function definition instead of just the body of the function."
msgstr "不能。 可以使用 @t{zcompile} 的第一种形式来编译包含完整函数定义（而不仅仅是函数体）的可自动加载函数。"

#. type: table
#: zsh.texi:15692
msgid ""
"The third form, with the @t{-t} option, examines an existing compiled file.  Without further arguments, the names of the original files compiled into it are listed.  The first line of output shows the "
"version of the shell which compiled the file and how the file will be used (i.e. by reading it directly or by mapping it into memory).  With arguments, nothing is output and the return status is set to "
"zero if definitions for @emph{all} @var{name}s were found in the compiled file, and non-zero if the definition for at least one @var{name} was not found."
msgstr ""
"第三种形式是使用 @t{-t} 选项，检查现有的编译文件。 在没有其他参数的情况下，会列出编译到该文件中的原始文件名。 第一行输出显示编译该文件的 shell 版本，以及使用该文件的方式（即直接读取还是映射到内存中）。 如"
"果有参数，则不输出任何内容，如果 @emph{all} 和 @var{name}s 的定义被找到，则返回状态设为零；如果没有找到至少一个 @var{name} 的定义，则返回状态为非零。"

#. type: table
#: zsh.texi:15695
msgid "Other options:"
msgstr "其它选项："

#. type: table
#: zsh.texi:15700
msgid "Aliases are not expanded when compiling the @var{name}d files."
msgstr "编译（名为） @var{name} 文件时不会扩展别名。"

#. type: table
#: zsh.texi:15705
msgid "When the compiled file is read, its contents are copied into the shell's memory, rather than memory-mapped (see @t{-M}).  This happens automatically on systems that do not support memory mapping."
msgstr "读取编译文件时，其内容会被复制到 shell 的内存中，而不是内存映射（参见 @t{-M}）。 这在不支持内存映射的系统上会自动发生。"

#. type: table
#: zsh.texi:15711
msgid ""
"When compiling scripts instead of autoloadable functions, it is often desirable to use this option; otherwise the whole file, including the code to define functions which have already been defined, will "
"remain mapped, consequently wasting memory."
msgstr "在编译脚本而不是自动加载函数时，通常最好使用该选项；否则整个文件，包括定义已定义函数的代码，都将保持映射状态，从而浪费内存。"

#. type: table
#: zsh.texi:15718
msgid ""
"The compiled file is mapped into the shell's memory when read. This is done in such a way that multiple instances of the shell running on the same host will share this mapped file.  If neither @t{-R} nor "
"@t{-M} is given, the @t{zcompile} builtin decides what to do based on the size of the compiled file."
msgstr ""
"读取编译文件时，该文件会映射到 shell 的内存中。这样一来，在同一主机上运行的多个 shell 实例将共享这个映射文件。 如果既未给出 @t{-R} 也未给出 @t{-M}，@t{zcompile} 内置程序将根据编译文件的大小决定如何处理。"

#. type: table
#: zsh.texi:15731
msgid ""
"These options are used when the compiled file contains functions which are to be autoloaded. If @t{-z} is given, the function will be autoloaded as if the @t{KSH_AUTOLOAD} option is @emph{not} set, even "
"if it is set at the time the compiled file is read, while if the @t{-k} is given, the function will be loaded as if @t{KSH_AUTOLOAD} @emph{is} set.  These options also take precedence over any @t{-k} or "
"@t{-z} options specified to the @t{autoload} builtin. If neither of these options is given, the function will be loaded as determined by the setting of the @t{KSH_AUTOLOAD} option at the time the compiled "
"file is read."
msgstr ""
"当编译文件包含需要自动加载的函数时，将使用这些选项。如果给出 @t{-z}，函数将被自动加载，就像 @t{KSH_AUTOLOAD} 选项 @emph{没有} 设置一样，即使该选项在读取编译文件时已被设置；而如果给出 @t{-k}，函数将被加载，"
"就像 @t{KSH_AUTOLOAD} @emph{已被} 设置一样。这些选项优先于 @t{autoload} 内置函数中指定的 @t{-k} 或 @t{-z} 选项。如果没有给出这两个选项，函数将根据读取编译文件时 @t{KSH_AUTOLOAD} 选项的设置来加载。"

#. type: table
#: zsh.texi:15735
msgid "These options may also appear as many times as necessary between the listed @var{name}s to specify the loading style of all following functions, up to the next @t{-k} or @t{-z}."
msgstr "这些选项还可以根据需要多次出现在列出的 @var{name}s 之间，以指定所有后续函数的加载方式，直至下一个 @t{-k} 或 @t{-z}。"

#. type: table
#: zsh.texi:15744
msgid ""
"The created file always contains two versions of the compiled format, one for big-endian machines and one for small-endian machines.  The upshot of this is that the compiled file is machine independent "
"and if it is read or mapped, only one half of the file is actually used (and mapped)."
msgstr ""
"创建的文件总是包含两个版本的编译格式，一个适用于大二进制（big-endian）机器，另一个适用于小二进制机器。 这样做的结果是，编译后的文件与机器无关，如果对其进行读取或映射，实际上只会使用文件（和映射）的一半。"

#. type: findex
#: zsh.texi:15746 zsh.texi:32320
#, no-wrap
msgid "zformat"
msgstr "zformat"

#. type: table
#: zsh.texi:15748 zsh.texi:16057 zsh.texi:16066 zsh.texi:16072
msgid "See @ref{The zsh/zutil Module}."
msgstr "参见 @ref{zsh/zutil 模块}."

#. type: findex
#: zsh.texi:15749 zsh.texi:31301
#, no-wrap
msgid "zftp"
msgstr "zftp"

#. type: table
#: zsh.texi:15751
msgid "See @ref{The zsh/zftp Module}."
msgstr "参见 @ref{zsh/zftp 模块}。"

#. type: t{#1}
#: zsh.texi:15752 zsh.texi:16558 zsh.texi:16569
#, no-wrap
msgid "zle"
msgstr "zle"

#. type: findex
#: zsh.texi:15755
#, no-wrap
msgid "zmodload"
msgstr "zmodload"

#. type: cindex
#: zsh.texi:15756
#, no-wrap
msgid "modules, loading"
msgstr "模块, 加载"

#. type: cindex
#: zsh.texi:15757
#, no-wrap
msgid "loading modules"
msgstr "加载模块"

#. type: item
#: zsh.texi:15758
#, no-wrap
msgid "@t{zmodload} [ @t{-dL} ] [ @t{-s} ] [ ... ]"
msgstr "@t{zmodload} [ @t{-dL} ] [ @t{-s} ] [ ... ]"

#. type: itemx
#: zsh.texi:15759
#, no-wrap
msgid "@t{zmodload -F} [ @t{-alLme} @t{-P} @var{param} ] @var{module} [ [@t{+-}]@var{feature} ... ]"
msgstr "@t{zmodload -F} [ @t{-alLme} @t{-P} @var{param} ] @var{module} [ [@t{+-}]@var{feature} ... ]"

#. type: itemx
#: zsh.texi:15760
#, no-wrap
msgid "@t{zmodload -e} [ @t{-A} ] [ ... ]"
msgstr "@t{zmodload -e} [ @t{-A} ] [ ... ]"

#. type: itemx
#: zsh.texi:15761
#, no-wrap
msgid "@t{zmodload} [ @t{-a} [ @t{-bcpf} [ @t{-I} ] ] ] [ @t{-iL} ] ..."
msgstr "@t{zmodload} [ @t{-a} [ @t{-bcpf} [ @t{-I} ] ] ] [ @t{-iL} ] ..."

#. type: itemx
#: zsh.texi:15762
#, no-wrap
msgid "@t{zmodload} @t{-u} [ @t{-abcdpf} [ @t{-I} ] ] [ @t{-iL} ] ..."
msgstr "@t{zmodload} @t{-u} [ @t{-abcdpf} [ @t{-I} ] ] [ @t{-iL} ] ..."

#. type: item
#: zsh.texi:15763 zsh.texi:16004
#, no-wrap
msgid "@t{zmodload} @t{-A} [ @t{-L} ] [ @var{modalias}[@t{=}@var{module}] ... ]"
msgstr "@t{zmodload} @t{-A} [ @t{-L} ] [ @var{modalias}[@t{=}@var{module}] ... ]"

#. type: item
#: zsh.texi:15764 zsh.texi:16040
#, no-wrap
msgid "@t{zmodload} @t{-R} @var{modalias} ..."
msgstr "@t{zmodload} @t{-R} @var{modalias} ..."

#. type: table
#: zsh.texi:15771
msgid ""
"Performs operations relating to zsh's loadable modules.  Loading of modules while the shell is running (`dynamical loading') is not available on all operating systems, or on all installations on a "
"particular operating system, although the @t{zmodload} command itself is always available and can be used to manipulate modules built into versions of the shell executable without dynamical loading."
msgstr ""
"执行与 zsh 可加载模块相关的操作。 在 shell 运行时加载模块（\"动态加载\"）并不适用于所有操作系统，也不适用于特定操作系统上的所有安装，尽管 @t{zmodload} 命令本身总是可用的，并且可以用来操作内置于没有动态加载"
"的 shell 可执行文件版本中的模块。"

#. type: table
#: zsh.texi:15776
msgid "Without arguments the names of all currently loaded binary modules are printed.  The @t{-L} option causes this list to be in the form of a series of @t{zmodload} commands.  Forms with arguments are:"
msgstr "在不带参数的情况下，将打印当前加载的所有二进制模块的名称。 如果使用 @t{-L} 选项，则会以一系列 @t{zmodload} 命令的形式显示该列表。 带参数的形式有："

#. type: item
#: zsh.texi:15779
#, no-wrap
msgid "@t{zmodload} [ @t{-is} ] @var{name} ..."
msgstr "@t{zmodload} [ @t{-is} ] @var{name} ..."

#. type: itemx
#: zsh.texi:15780
#, no-wrap
msgid "@t{zmodload} @t{-u} [ @t{-i} ] @var{name} ..."
msgstr "@t{zmodload} @t{-u} [ @t{-i} ] @var{name} ..."

#. type: table
#: zsh.texi:15790
msgid ""
"In the simplest case, @t{zmodload} loads a binary module.  The module must be in a file with a name consisting of the specified @var{name} followed by a standard suffix, usually `@t{.so}' (`@t{.sl}' on "
"HPUX).  If the module to be loaded is already loaded the duplicate module is ignored.  If @t{zmodload} detects an inconsistency, such as an invalid module name or circular dependency list, the current "
"code block is aborted.  If it is available, the module is loaded if necessary, while if it is not available, non-zero status is silently returned.  The option @t{-i} is accepted for compatibility but has "
"no effect."
msgstr ""
"在最简单的情况下，@t{zmodload} 会加载一个二进制模块。 模块必须位于一个文件中，文件名由指定的 @var{name} 和标准后缀组成，通常为 `@t{.so}' （HPUX 上为`@t{.sl}' ）。 如果要加载的模块已经加载，重复的模块将被忽"
"略。 如果 @t{zmodload} 检测到不一致的情况，例如模块名称无效或循环依赖列表，当前代码块将被中止。 如果模块可用，则会在必要时加载模块；如果模块不可用，则会静默返回非零状态。 选项 @t{-i} 可以接受，但没有任何作"
"用。"

#. type: table
#: zsh.texi:15796
msgid ""
"The @var{name}d module is searched for in the same way a command is, using @t{$module_path} instead of @t{$path}.  However, the path search is performed even when the module name contains a `@t{/}', which "
"it usually does.  There is no way to prevent the path search."
msgstr ""
"搜索 @var{name} 模块的方式与搜索命令的方式相同，使用 @t{$module_path} 而不是 @t{$path}。 不过，即使模块名称中包含 `@t{/}'，路径搜索也会执行，而通常情况下模块名称中都会包含 `@t{/}'。 没有办法阻止路径搜索。"

#. type: table
#: zsh.texi:15801
msgid ""
"If the module supports features (see below), @t{zmodload} tries to enable all features when loading a module.  If the module was successfully loaded but not all features could be enabled, @t{zmodload} "
"returns status 2."
msgstr "如果模块支持功能（见下文），@t{zmodload} 会在加载模块时尝试启用所有功能。 如果模块已成功加载，但无法启用所有功能，@t{zmodload} 将返回状态 2。"

#. type: table
#: zsh.texi:15807
msgid ""
"If the option @t{-s} is given, no error is printed if the module was not available (though other errors indicating a problem with the module are printed).  The return status indicates if the module was "
"loaded.  This is appropriate if the caller considers the module optional."
msgstr "如果给出选项 @t{-s}，则在模块不可用的情况下不会打印错误信息（但会打印表明模块有问题的其他错误信息）。 返回状态则表明模块是否已加载。 如果调用者认为模块是可选的，则可以使用这种方式。"

#. type: table
#: zsh.texi:15814
msgid ""
"With @t{-u}, @t{zmodload} unloads modules.  The same @var{name} must be given that was given when the module was loaded, but it is not necessary for the module to exist in the file system.  The @t{-i} "
"option suppresses the error if the module is already unloaded (or was never loaded)."
msgstr "通过 @t{-u}，@t{zmodload} 可以卸载模块。 必须使用与加载模块时相同的 @var{name}，但模块不必存在于文件系统中。 如果模块已被卸载（或从未被加载），则 @t{-i} 选项会抑制错误。"

#. type: table
#: zsh.texi:15819
msgid "Each module has a boot and a cleanup function.  The module will not be loaded if its boot function fails.  Similarly a module can only be unloaded if its cleanup function runs successfully."
msgstr "每个模块都有启动和清理函数。 如果模块的启动函数失败，模块将无法加载。 同样，只有当模块的清理功能成功运行时，模块才能被卸载。"

#. type: item
#: zsh.texi:15820
#, no-wrap
msgid "@t{zmodload -F} [ @t{-almLe} @t{-P} @var{param} ] @var{module} [ [@t{+-}]@var{feature} ... ]"
msgstr "@t{zmodload -F} [ @t{-almLe} @t{-P} @var{param} ] @var{module} [ [@t{+-}]@var{feature} ... ]"

#. type: table
#: zsh.texi:15835
msgid ""
"@t{zmodload -F} allows more selective control over the features provided by modules.  With no options apart from @t{-F}, the module named @var{module} is loaded, if it was not already loaded, and the list "
"of @var{feature}s is set to the required state.  If no @var{feature}s are specified, the module is loaded, if it was not already loaded, but the state of features is unchanged.  Each feature may be "
"preceded by a @t{+} to turn the feature on, or @t{-} to turn it off; the @t{+} is assumed if neither character is present.  Any feature not explicitly mentioned is left in its current state; if the module "
"was not previously loaded this means any such features will remain disabled.  The return status is zero if all features were set, 1 if the module failed to load, and 2 if some features could not be set "
"(for example, a parameter couldn't be added because there was a different parameter of the same name) but the module was loaded."
msgstr ""
"@t{zmodload -F} 允许对模块提供的功能进行更有选择性的控制。 如果除 @t{-F} 之外没有其他选项，则会加载名为 @var{module} 的模块（如果尚未加载），并将 @var{feature} 列表设置为所需状态。 如果没有指定 "
"@var{feature}，则会加载尚未加载的模块，但特性（features）的状态保持不变。 每个特性前都可以使用 @t{+} 打开该特性，或使用 @t{-} 关闭该特性；如果两个字符都不存在，则假定使用 @t{+}。 任何未明确提及的特性都将保"
"持当前状态；如果模块之前未加载过，这意味着任何此类特性都将保持禁用状态。 如果所有特性都已设置，则返回状态为 0；如果模块加载失败，则返回状态为 1；如果某些特性无法设置（例如，由于存在同名的其他参数而无法添加"
"参数），但模块已加载，则返回状态为 2。"

#. type: table
#: zsh.texi:15845
msgid ""
"The standard features are builtins, conditions, parameters and math functions; these are indicated by the prefix `@t{b:}', `@t{c:}' (`@t{C:}' for an infix condition), `@t{p:}' and `@t{f:}', respectively, "
"followed by the name that the corresponding feature would have in the shell.  For example, `@t{b:strftime}' indicates a builtin named @t{strftime} and @t{p:EPOCHSECONDS} indicates a parameter named "
"@t{EPOCHSECONDS}.  The module may provide other (`abstract') features of its own as indicated by its documentation; these have no prefix."
msgstr ""
"标准功能包括内置命令、条件、参数和数学函数；它们分别用前缀  `@t{b:}', `@t{c:}'（`@t{C:}' 表示下位条件）、`@t{p:}' 和`@t{f:}' 表示，后跟相应特性在 shell 中的名称。 例如，`@t{b:strftime}' 表示名为 "
"@t{strftime} 的内置函数，@t{p:EPOCHSECONDS} 表示名为 @t{EPOCHSECONDS} 的参数。 模块可根据其文档提供其他（`抽象'）特性；这些功能没有前缀。"

#. type: table
#: zsh.texi:15856
msgid ""
"With @t{-l} or @t{-L}, features provided by the module are listed.  With @t{-l} alone, a list of features together with their states is shown, one feature per line.  With @t{-L} alone, a @t{zmodload -F} "
"command that would cause enabled features of the module to be turned on is shown.  With @t{-lL}, a @t{zmodload -F} command that would cause all the features to be set to their current state is shown.  If "
"one of these combinations is given with the option @t{-P} @var{param} then the parameter @var{param} is set to an array of features, either features together with their state or (if @t{-L} alone is given) "
"enabled features."
msgstr ""
"使用 @t{-l} 或 @t{-L} 时，将列出模块提供的特性。 如果只使用 @t{-l}，则会显示特性列表及其状态，每行一个功能。 如果仅使用 @t{-L}，则会显示一条 @t{zmodload -F} 命令，该命令将开启模块的已启用功能。 如果使用 "
"@t{-lL}，则会显示 @t{zmodload -F} 命令，该命令会将所有功能设置为当前状态。 如果使用  @t{-P} @var{param} 选项给出上述组合之一 ，则参数 @var{param} 将被设置为一个特性的数组，可以是特性及其状态，也可以是已启"
"用的特性（如果只给出 @t{-L}）。"

#. type: table
#: zsh.texi:15862
msgid ""
"With the option @t{-L} the module name may be omitted; then a list of all enabled features for all modules providing features is printed in the form of @t{zmodload -F} commands.  If @t{-l} is also given, "
"the state of both enabled and disabled features is output in that form."
msgstr "如果使用选项 @t{-L}，则可以省略模块名称；然后以 @t{zmodload -F} 命令的形式打印所有提供特性的模块的所有已启用特性列表。 如果同时给出 @t{-l}，启用和禁用特性的状态都会以这种形式输出。"

#. type: table
#: zsh.texi:15869
msgid ""
"A set of features may be provided together with @t{-l} or @t{-L} and a module name; in that case only the state of those features is considered.  Each feature may be preceded by @t{+} or @t{-} but the "
"character has no effect.  If no set of features is provided, all features are considered."
msgstr "在提供一组特性时，可以同时提供 @t{-l} 或 @t{-L} 和一个模块名称；在这种情况下，只考虑这些特性的状态。 每个特征前都可以加上 @t{+} 或 @t{-}，但该字符不起作用。 如果没有提供特性集，则会考虑所有特性。"

#. type: table
#: zsh.texi:15878
msgid ""
"With @t{-e}, the command first tests that the module is loaded; if it is not, status 1 is returned.  If the module is loaded, the list of features given as an argument is examined.  Any feature given with "
"no prefix is simply tested to see if the module provides it; any feature given with a prefix @t{+} or @t{-} is tested to see if is provided and in the given state.  If the tests on all features in the "
"list succeed, status 0 is returned, else status 1."
msgstr ""
"使用 @t{-e}，命令首先会测试模块是否已加载；如果未加载，则返回状态 1。 如果模块已加载，则检查作为参数给出的特性列表。 对于不带前缀的特性，只需测试模块是否提供；对于带前缀 @t{+} 或 @t{-} 的特性，则测试是否提"
"供并处于指定状态。 如果对列表中所有特性的测试都成功，则返回状态 0，否则返回状态 1。"

#. type: table
#: zsh.texi:15885
msgid ""
"With @t{-m}, each entry in the given list of features is taken as a pattern to be matched against the list of features provided by the module.  An initial @t{+} or @t{-} must be given explicitly.  This "
"may not be combined with the @t{-a} option as autoloads must be specified explicitly."
msgstr "使用 @t{-m}，给定的特性列表中的每个条目都将作为一个模式，与模块提供的特性列表进行匹配。 必须明确给出开头的 @t{+} 或 @t{-}。 该选项不能与 @t{-a} 选项结合使用，因为必须明确指定自动加载。"

#. type: table
#: zsh.texi:15897
msgid ""
"With @t{-a}, the given list of features is marked for autoload from the specified module, which may not yet be loaded.  An optional @t{+} may appear before the feature name.  If the feature is prefixed "
"with @t{-}, any existing autoload is removed.  The options @t{-l} and @t{-L} may be used to list autoloads.  Autoloading is specific to individual features; when the module is loaded only the requested "
"feature is enabled.  Autoload requests are preserved if the module is subsequently unloaded until an explicit `@t{zmodload -Fa} @var{module} @t{-}@var{feature}' is issued.  It is not an error to request "
"an autoload for a feature of a module that is already loaded."
msgstr ""
"使用 @t{-a}，给定的特性列表将被标记为从指定模块自动加载（该模块可能尚未加载）。 特性名称前可以出现一个可选的 @t{+}。 如果特性前缀为 @t{-}，则现有的自动加载将被移除。 选项 @t{-l} 和 @t{-L} 可用来列出自动加"
"载。 自动加载是针对单个特性的；加载模块时，只有请求的特性才会启用。 如果模块随后被卸载，自动加载请求将被保留，直到出现明确的 `@t{zmodload -Fa} @var{module} @t{-}@var{feature}'。 为已加载模块的特性请求自动"
"加载不会出错。"

#. type: table
#: zsh.texi:15906
msgid ""
"When the module is loaded each autoload is checked against the features actually provided by the module; if the feature is not provided the autoload request is deleted.  A warning message is output; if "
"the module is being loaded to provide a different feature, and that autoload is successful, there is no effect on the status of the current command.  If the module is already loaded at the time when "
"@t{zmodload -Fa} is run, an error message is printed and status 1 returned."
msgstr ""
"加载模块时，会根据模块实际提供的特性检查每个自动加载请求；如果未提供该特性，自动加载请求将被删除。输出警告信息；如果加载模块是为了提供其他特性，且自动加载成功，则不会影响当前命令的状态。 如果 @t{zmodload -"
"Fa} 运行时模块已被加载，则会打印一条错误信息并返回状态 1。"

#. type: table
#: zsh.texi:15912
msgid ""
"@t{zmodload -Fa} can be used with the @t{-l}, @t{-L}, @t{-e} and @t{-P} options for listing and testing the existence of autoloadable features.  In this case @t{-l} is ignored if @t{-L} is specified.  "
"@t{zmodload -FaL} with no module name lists autoloads for all modules."
msgstr ""
"@t{zmodload -Fa} 可以与 @t{-l}、@t{-L}、@t{-e} 和 @t{-P} 选项一起使用，用于列出和测试是否存在可自动加载的特性。 在这种情况下，如果指定了 @t{-L}，则 @t{-l} 将被忽略。 @t{zmodload -FaL} 不含模块名称，会列出"
"所有模块的自动加载。"

#. type: table
#: zsh.texi:15916
msgid "Note that only standard features as described above can be autoloaded; other features require the module to be loaded before enabling."
msgstr "请注意，只有上述标准特性可以自动加载；其他特性需要在启用前先加载模块。"

#. type: item
#: zsh.texi:15917
#, no-wrap
msgid "@t{zmodload} @t{-d} [ @t{-L} ] [ @var{name} ]"
msgstr "@t{zmodload} @t{-d} [ @t{-L} ] [ @var{name} ]"

#. type: itemx
#: zsh.texi:15918
#, no-wrap
msgid "@t{zmodload} @t{-d} @var{name} @var{dep} ..."
msgstr "@t{zmodload} @t{-d} @var{name} @var{dep} ..."

#. type: itemx
#: zsh.texi:15919
#, no-wrap
msgid "@t{zmodload} @t{-ud} @var{name} [ @var{dep} ... ]"
msgstr "@t{zmodload} @t{-ud} @var{name} [ @var{dep} ... ]"

#. type: table
#: zsh.texi:15923
msgid "The @t{-d} option can be used to specify module dependencies.  The modules named in the second and subsequent arguments will be loaded before the module named in the first argument."
msgstr "@t{-d} 选项可用于指定模块依赖关系。 第二个参数和后续参数中指定的模块将在第一个参数中指定的模块之前加载。"

#. type: table
#: zsh.texi:15929
msgid ""
"With @t{-d} and one argument, all dependencies for that module are listed.  With @t{-d} and no arguments, all module dependencies are listed.  This listing is by default in a Makefile-like format.  The "
"@t{-L} option changes this format to a list of @t{zmodload -d} commands."
msgstr ""
"使用 @t{-d} 和一个参数时，将列出该模块的所有依赖关系。 如果使用 @t{-d}，且没有参数，则会列出所有模块的依赖关系。 该列表默认采用类似 Makefile 的格式。 @t{-L} 选项会将格式更改为 @t{zmodload -d} 命令的列表。"

#. type: table
#: zsh.texi:15933
msgid "If @t{-d} and @t{-u} are both used, dependencies are removed.  If only one argument is given, all dependencies for that module are removed."
msgstr "如果同时使用 @t{-d} 和 @t{-u}，依赖关系将被移除。 如果只给出一个参数，则会移除该模块的所有依赖关系。"

#. type: item
#: zsh.texi:15934
#, no-wrap
msgid "@t{zmodload} @t{-ab} [ @t{-L} ]"
msgstr "@t{zmodload} @t{-ab} [ @t{-L} ]"

#. type: itemx
#: zsh.texi:15935
#, no-wrap
msgid "@t{zmodload} @t{-ab} [ @t{-i} ] @var{name} [ @var{builtin} ... ]"
msgstr "@t{zmodload} @t{-ab} [ @t{-i} ] @var{name} [ @var{builtin} ... ]"

#. type: itemx
#: zsh.texi:15936
#, no-wrap
msgid "@t{zmodload} @t{-ub} [ @t{-i} ] @var{builtin} ..."
msgstr "@t{zmodload} @t{-ub} [ @t{-i} ] @var{builtin} ..."

#. type: table
#: zsh.texi:15945
msgid ""
"The @t{-ab} option defines autoloaded builtins.  It defines the specified @var{builtin}s.  When any of those builtins is called, the module specified in the first argument is loaded and all its features "
"are enabled (for selective control of features use `@t{zmodload -F -a}' as described above).  If only the @var{name} is given, one builtin is defined, with the same name as the module.  @t{-i} suppresses "
"the error if the builtin is already defined or autoloaded, but not if another builtin of the same name is already defined."
msgstr ""
"@t{-ab} 选项定义自动加载的内置程序。 它定义了指定的 @var{builtin}s。 调用其中任何一个内置程序时，第一个参数中指定的模块将被加载并启用其所有特性（如需选择性控制特性，请使用 `@t{zmodload -F -a}' ，如上所"
"述）。 如果只给出 @var{name}，则会定义一个与模块同名的内置程序。 如果内置程序已被定义或自动加载，@t{-i} 会抑制错误，但如果另一个同名内置程序已被定义，@t{-i} 则不会抑制错误。"

#. type: table
#: zsh.texi:15951
msgid ""
"With @t{-ab} and no arguments, all autoloaded builtins are listed, with the module name (if different) shown in parentheses after the builtin name.  The @t{-L} option changes this format to a list of "
"@t{zmodload -a} commands."
msgstr "如果使用 @t{-ab} 且不带参数，则会列出所有自动加载的内置程序，内置程序名称后的括号中会显示模块名称（如果不同）。 使用 @t{-L} 选项后，格式将变为 @t{zmodload -a} 命令列表。"

#. type: table
#: zsh.texi:15957
msgid ""
"If @t{-b} is used together with the @t{-u} option, it removes builtins previously defined with @t{-ab}.  This is only possible if the builtin is not yet loaded.  @t{-i} suppresses the error if the builtin "
"is already removed (or never existed)."
msgstr "如果 @t{-b} 与 @t{-u} 选项一起使用，则会删除之前用 @t{-ab} 定义的内置程序。 这只有在内置程序尚未加载的情况下才会发生。 如果内置函数已被移除（或从未存在），则 @t{-i} 会抑制错误。"

#. type: table
#: zsh.texi:15961
msgid "Autoload requests are retained if the module is subsequently unloaded until an explicit `@t{zmodload -ub} @var{builtin}' is issued."
msgstr "如果模块随后被卸载，直到发出明确的`@t{zmodload -ub} @var{builtin}' ，自动加载请求将被保留。"

#. type: item
#: zsh.texi:15962
#, no-wrap
msgid "@t{zmodload} @t{-ac} [ @t{-IL} ]"
msgstr "@t{zmodload} @t{-ac} [ @t{-IL} ]"

#. type: itemx
#: zsh.texi:15963
#, no-wrap
msgid "@t{zmodload} @t{-ac} [ @t{-iI} ] @var{name} [ @var{cond} ... ]"
msgstr "@t{zmodload} @t{-ac} [ @t{-iI} ] @var{name} [ @var{cond} ... ]"

#. type: itemx
#: zsh.texi:15964
#, no-wrap
msgid "@t{zmodload} @t{-uc} [ @t{-iI} ] @var{cond} ..."
msgstr "@t{zmodload} @t{-uc} [ @t{-iI} ] @var{cond} ..."

#. type: table
#: zsh.texi:15969
msgid ""
"The @t{-ac} option is used to define autoloaded condition codes. The @var{cond} strings give the names of the conditions defined by the module. The optional @t{-I} option is used to define infix condition "
"names. Without this option prefix condition names are defined."
msgstr "@t{-ac} 选项用于定义自动加载的条件代码。@var{cond} 字符串给出模块定义的条件名称。可选的 @t{-I} 选项用于定义中缀条件名。如果没有该选项，则定义前缀条件名。"

#. type: table
#: zsh.texi:15973
msgid "If given no condition names, all defined names are listed (as a series of @t{zmodload} commands if the @t{-L} option is given)."
msgstr "如果没有给出条件名称，则会列出所有已定义的名称（如果给出 @t{-L} 选项，则会列出一系列 @t{zmodload} 命令）。"

#. type: table
#: zsh.texi:15976
msgid "The @t{-uc} option removes definitions for autoloaded conditions."
msgstr "选项 @t{-uc} 会删除自动加载条件的定义。"

#. type: item
#: zsh.texi:15977
#, no-wrap
msgid "@t{zmodload} @t{-ap} [ @t{-L} ]"
msgstr "@t{zmodload} @t{-ap} [ @t{-L} ]"

#. type: itemx
#: zsh.texi:15978
#, no-wrap
msgid "@t{zmodload} @t{-ap} [ @t{-i} ] @var{name} [ @var{parameter} ... ]"
msgstr "@t{zmodload} @t{-ap} [ @t{-i} ] @var{name} [ @var{parameter} ... ]"

#. type: itemx
#: zsh.texi:15979
#, no-wrap
msgid "@t{zmodload} @t{-up} [ @t{-i} ] @var{parameter} ..."
msgstr "@t{zmodload} @t{-up} [ @t{-i} ] @var{parameter} ..."

#. type: table
#: zsh.texi:15982
msgid "The @t{-p} option is like the @t{-b} and @t{-c} options, but makes @t{zmodload} work on autoloaded parameters instead."
msgstr "@t{-p} 选项与 @t{-b} 和 @t{-c} 选项类似，但它使 @t{zmodload} 对自动加载的参数起作用。"

#. type: item
#: zsh.texi:15983
#, no-wrap
msgid "@t{zmodload} @t{-af} [ @t{-L} ]"
msgstr "@t{zmodload} @t{-af} [ @t{-L} ]"

#. type: itemx
#: zsh.texi:15984
#, no-wrap
msgid "@t{zmodload} @t{-af} [ @t{-i} ] @var{name} [ @var{function} ... ]"
msgstr "@t{zmodload} @t{-af} [ @t{-i} ] @var{name} [ @var{function} ... ]"

#. type: itemx
#: zsh.texi:15985
#, no-wrap
msgid "@t{zmodload} @t{-uf} [ @t{-i} ] @var{function} ..."
msgstr "@t{zmodload} @t{-uf} [ @t{-i} ] @var{function} ..."

#. type: table
#: zsh.texi:15988
msgid "The @t{-f} option is like the @t{-b}, @t{-p}, and @t{-c} options, but makes @t{zmodload} work on autoloaded math functions instead."
msgstr "@t{-f} 选项与 @t{-b}、@t{-p} 和 @t{-c} 选项类似，但它使 @t{zmodload} 在自动加载的数学函数上工作。"

#. type: item
#: zsh.texi:15989
#, no-wrap
msgid "@t{zmodload} @t{-a} [ @t{-L} ]"
msgstr "@t{zmodload} @t{-a} [ @t{-L} ]"

#. type: itemx
#: zsh.texi:15990
#, no-wrap
msgid "@t{zmodload} @t{-a} [ @t{-i} ] @var{name} [ @var{builtin} ... ]"
msgstr "@t{zmodload} @t{-a} [ @t{-i} ] @var{name} [ @var{builtin} ... ]"

#. type: itemx
#: zsh.texi:15991
#, no-wrap
msgid "@t{zmodload} @t{-ua} [ @t{-i} ] @var{builtin} ..."
msgstr "@t{zmodload} @t{-ua} [ @t{-i} ] @var{builtin} ..."

#. type: table
#: zsh.texi:15993
msgid "Equivalent to @t{-ab} and @t{-ub}."
msgstr "等同于 @t{-ab} 和 @t{-ub}。"

#. type: item
#: zsh.texi:15994
#, no-wrap
msgid "@t{zmodload -e} [ @t{-A} ] [ @var{string} ... ]"
msgstr "@t{zmodload -e} [ @t{-A} ] [ @var{string} ... ]"

#. type: table
#: zsh.texi:16003
msgid ""
"The @t{-e} option without arguments lists all loaded modules; if the @t{-A} option is also given, module aliases corresponding to loaded modules are also shown.  If arguments are provided, nothing is "
"printed; the return status is set to zero if all @var{string}s given as arguments are names of loaded modules and to one if at least on @var{string} is not the name of a loaded module.  This can be used "
"to test for the availability of things implemented by modules.  In this case, any aliases are automatically resolved and the @t{-A} flag is not used."
msgstr ""
"不带参数的 @t{-e} 选项会列出所有已加载模块；如果同时给出 @t{-A} 选项，则也会显示与已加载模块相对应的模块别名。 如果提供了参数，则不会打印任何内容；如果参数 @var{string}s 都是已加载模块的名称，则返回状态设"
"为 0；如果至少有一个 @var{string} 不是已加载模块的名称，则返回状态设为 1。 这可用于测试模块实现的功能是否可用。 在这种情况下，任何别名都会自动解析，并且不会使用 @t{-A} 标志。"

#. type: table
#: zsh.texi:16013
msgid ""
"For each argument, if both @var{modalias} and @var{module} are given, define @var{modalias} to be an alias for the module @var{module}.  If the module @var{modalias} is ever subsequently requested, either "
"via a call to @t{zmodload} or implicitly, the shell will attempt to load @var{module} instead.  If @var{module} is not given, show the definition of @var{modalias}.  If no arguments are given, list all "
"defined module aliases.  When listing, if the @t{-L} flag was also given, list the definition as a @t{zmodload} command to recreate the alias."
msgstr ""
"对于每个参数，如果同时给出 @var{modalias} 和 @var{module}，则定义 @var{modalias} 为 @var{module} 模块的别名。 如果随后通过调用 @t{zmodload} 或隐式的方式请求 @var{modalias} 模块，shell 将尝试加载 "
"@var{module} 模块。 如果未给出 @var{module}，则显示 @var{modalias} 的定义。 如果未给出参数，则会列出所有已定义的模块别名。 在列出时，如果还给出了 @t{-L} 标志，则会以 @t{zmodload} 命令的形式列出定义，以重新"
"创建别名。"

#. type: table
#: zsh.texi:16026
msgid ""
"The existence of aliases for modules is completely independent of whether the name resolved is actually loaded as a module: while the alias exists, loading and unloading the module under any alias has "
"exactly the same effect as using the resolved name, and does not affect the connection between the alias and the resolved name which can be removed either by @t{zmodload -R} or by redefining the alias.  "
"Chains of aliases (i.e. where the first resolved name is itself an alias) are valid so long as these are not circular.  As the aliases take the same format as module names, they may include path "
"separators: in this case, there is no requirement for any part of the path named to exist as the alias will be resolved first.  For example, `@t{any/old/alias}' is always a valid alias."
msgstr ""
"模块别名的存在与解析的名称是否实际作为模块加载完全无关：当别名存在时，以任何别名加载或卸载模块都与使用解析后的名称具有完全相同的效果，并且不会影响别名与解析后名称之间的联系，这种联系可以通过 @t{zmodload -"
"R} 或重新定义别名来移除。 只要不循环，别名链（即第一个解析后名称本身就是一个别名）是有效的。 由于别名采用与模块名相同的格式，因此可以包含路径分隔符：在这种情况下，不要求指定路径的任何部分都存在，因为别名将"
"首先被解析。 例如，`@t{any/old/alias}'始终是一个有效的别名。"

#. type: table
#: zsh.texi:16034
msgid ""
"Dependencies added to aliased modules are actually added to the resolved module; these remain if the alias is removed.  It is valid to create an alias whose name is one of the standard shell modules and "
"which resolves to a different module.  However, if a module has dependencies, it will not be possible to use the module name as an alias as the module will already be marked as a loadable module in its "
"own right."
msgstr ""
"添加到别名模块的依赖关系实际上会添加到解析后的模块中；如果删除别名，这些依赖关系仍会保留。 创建名称为标准 shell 模块之一的别名，并将其解析为不同的模块是有效的。 但是，如果模块有依赖关系，则无法使用模块名称"
"作为别名，因为模块本身已被标记为可加载模块。"

#. type: table
#: zsh.texi:16039
msgid "Apart from the above, aliases can be used in the @t{zmodload} command anywhere module names are required.  However, aliases will not be shown in lists of loaded modules with a bare `@t{zmodload}'."
msgstr "除上述外，@t{zmodload} 命令还可在任何需要模块名的地方使用别名。 不过，别名将不会显示在已加载模块列表中，只显示 `@t{zmodload}'。"

#. type: table
#: zsh.texi:16044
msgid ""
"For each @var{modalias} argument that was previously defined as a module alias via @t{zmodload -A}, delete the alias.  If any was not defined, an error is caused and the remainder of the line is ignored."
msgstr "对于之前通过 @t{zmodload -A} 定义为模块别名的 @var{modalias} 参数，删除该别名。 如果未定义任何别名，将导致错误并忽略该行的其余部分。"

#. type: table
#: zsh.texi:16054
msgid ""
"Note that @t{zsh} makes no distinction between modules that were linked into the shell and modules that are loaded dynamically. In both cases this builtin command has to be used to make available the "
"builtins and other things defined by modules (unless the module is autoloaded on these definitions). This is true even for systems that don't support dynamic loading of modules."
msgstr ""
"请注意，@t{zsh} 并不区分链接到 shell 的模块和动态加载的模块。在这两种情况下，都必须使用这个内置命令来提供内置模块和其他由模块定义的内容（除非模块是根据这些定义自动加载的）。即使不支持动态加载模块的系统也是"
"如此。"

#. type: findex
#: zsh.texi:16055 zsh.texi:32400
#, no-wrap
msgid "zparseopts"
msgstr "zparseopts"

#. type: findex
#: zsh.texi:16058 zsh.texi:31902
#, no-wrap
msgid "zprof"
msgstr "zprof"

#. type: table
#: zsh.texi:16060
msgid "See @ref{The zsh/zprof Module}."
msgstr "参见 @ref{zsh/zprof 模块}."

#. type: table
#: zsh.texi:16063
msgid "See @ref{The zsh/zpty Module}."
msgstr "参见 @ref{zsh/zpty 模块}."

#. type: t{#1}
#: zsh.texi:16064 zsh.texi:32396 zsh.texi:32397
#, no-wrap
msgid "zregexparse"
msgstr "zregexparse"

#. type: findex
#: zsh.texi:16067 zsh.texi:30255
#, no-wrap
msgid "zsocket"
msgstr "zsocket"

#. type: table
#: zsh.texi:16069
msgid "See @ref{The zsh/net/socket Module}."
msgstr "参见 @ref{zsh/net/socket 模块}."

#. type: findex
#: zsh.texi:16070 zsh.texi:32157
#, no-wrap
msgid "zstyle"
msgstr "zstyle"

#. type: findex
#: zsh.texi:16073 zsh.texi:30857
#, no-wrap
msgid "ztcp"
msgstr "ztcp"

#. type: table
#: zsh.texi:16075
msgid "See @ref{The zsh/net/tcp Module}."
msgstr "参见 @ref{zsh/net/tcp 模块}."

#. type: cindex
#: zsh.texi:16083
#, no-wrap
msgid "line editor"
msgstr "行编辑器"

#. type: cindex
#: zsh.texi:16084
#, no-wrap
msgid "editor, line"
msgstr "编辑器, 行"

#. type: pindex
#: zsh.texi:16089
#, no-wrap
msgid "ZLE, use of"
msgstr "ZLE, use of"

#. type: Plain text
#: zsh.texi:16093
msgid "If the @t{ZLE} option is set (which it is by default in interactive shells)  and the shell input is attached to the terminal, the user is able to edit command lines."
msgstr "如果设置了 @t{ZLE} 选项（交互式 shell 的默认设置），并且 shell 输入连接到终端，用户就可以编辑命令行。"

#. type: Plain text
#: zsh.texi:16100
msgid ""
"There are two display modes.  The first, multiline mode, is the default.  It only works if the @t{TERM} parameter is set to a valid terminal type that can move the cursor up.  The second, single line "
"mode, is used if @t{TERM} is invalid or incapable of moving the cursor up, or if the @t{SINGLE_LINE_ZLE} option is set."
msgstr ""
"有两种显示模式。 第一种是默认的多行模式。 它只有在 @t{TERM} 参数设置成可以向上移动光标的有效终端类型时才起作用。 第二种是单行模式，如果 @t{TERM} 无效或无法向上移动光标，或者设置了 @t{SINGLE_LINE_ZLE} 选"
"项，则会使用这种模式。"

#. type: pindex
#: zsh.texi:16100
#, no-wrap
msgid "SINGLE_LINE_ZLE, use of"
msgstr "SINGLE_LINE_ZLE, use of"

#. type: cindex
#: zsh.texi:16101
#, no-wrap
msgid "ksh, editor mode"
msgstr "ksh, 编辑器模式"

#. type: cindex
#: zsh.texi:16102
#, no-wrap
msgid "editor ksh style"
msgstr "编辑器 ksh 风格"

#. type: Plain text
#: zsh.texi:16106
msgid "This mode is similar to @cite{ksh}, and uses no termcap sequences.  If @t{TERM} is \"emacs\", the @t{ZLE} option will be unset by default."
msgstr "该模式与 @cite{ksh} 类似，不使用 termcap 序列。 如果 @t{TERM} 为 \"emacs\"，则默认不设置 @t{ZLE} 选项。"

#. type: vindex
#: zsh.texi:16108
#, no-wrap
msgid "BAUD, use of"
msgstr "BAUD, use of"

#. type: vindex
#: zsh.texi:16109
#, no-wrap
msgid "COLUMNS, use of"
msgstr "COLUMNS, use of"

#. type: vindex
#: zsh.texi:16110
#, no-wrap
msgid "LINES, use of"
msgstr "LINES, use of"

#. type: Plain text
#: zsh.texi:16114
msgid "The parameters @t{BAUD}, @t{COLUMNS}, and @t{LINES} are also used by the line editor. See @ref{Parameters Used By The Shell}."
msgstr "行编辑器也会使用 @t{BAUD}、@t{COLUMNS} 和 @t{LINES} 参数。请参阅 @ref{Shell 使用的参数}。"

#. type: vindex
#: zsh.texi:16116
#, no-wrap
msgid "zle_highlight, use of"
msgstr "zle_highlight, use of"

#. type: Plain text
#: zsh.texi:16125
msgid ""
"The parameter @t{zle_highlight} is also used by the line editor; see @ref{Character Highlighting}.  Highlighting of special characters and the region between the cursor and the mark (as set with @t{set-"
"mark-command} in Emacs mode, or by @t{visual-mode} in Vi mode) is enabled by default; consult this reference for more information.  Irascible conservatives will wish to know that all highlighting may be "
"disabled by the following setting:"
msgstr ""
"行编辑器也使用 @t{zle_highlight} 参数；请参阅 @ref{字符高亮}。 特殊字符以及光标和标记之间区域的高亮（在 Emacs 模式下使用 @t{set-mark-command}，或在 Vi 模式下使用 @t{visual-mode}）默认为启用；更多信息请参阅"
"本参考文献。 不喜欢高亮的用户可以通过以下设置禁用所有高亮功能："

#. type: example
#: zsh.texi:16129
#, no-wrap
msgid "zle_highlight=(none)\n"
msgstr "zle_highlight=(none)\n"

#. type: Plain text
#: zsh.texi:16140
msgid ""
"In many places, references are made to the @t{numeric argument}.  This can by default be entered in emacs mode by holding the alt key and typing a number, or pressing escape before each digit, and in vi "
"command mode by typing the number before entering a command.  Generally the numeric argument causes the next command entered to be repeated the specified number of times, unless otherwise noted below; "
"this is implemented by the @t{digit-argument} widget. See also @ref{Arguments}for some other ways the numeric argument can be modified."
msgstr ""
"很多地方都会提到 @t{数字参数}。 默认情况下，在 emacs 模式下，可以按住 alt 键并输入数字，或在每个数字前按下 escape 键；在 vi 命令模式下，可以在输入命令前输入数字。 一般来说，除非下文另有说明，否则数字参数会"
"使下一条输入的命令重复指定的次数；这由 @t{digit-argument} 小部件实现。有关修改数字参数的其他方法，请参阅 @ref{参数}。"

#. type: node
#: zsh.texi:16152 zsh.texi:16154 zsh.texi:16273
#, no-wrap
msgid "Keymaps"
msgstr "键映射"

#. type: node
#: zsh.texi:16152 zsh.texi:16273 zsh.texi:16275 zsh.texi:16937
#, no-wrap
msgid "Zle Builtins"
msgstr "Zle 内置命令"

#. type: t{#1}
#: zsh.texi:16156 zsh.texi:16291 zsh.texi:21588 zsh.texi:31867 zsh.texi:31868
#, no-wrap
msgid "keymaps"
msgstr "键映射"

#. type: cindex
#: zsh.texi:16157
#, no-wrap
msgid "key bindings"
msgstr "键绑定"

#. type: cindex
#: zsh.texi:16158
#, no-wrap
msgid "bindings, key"
msgstr "绑定, 键"

#. type: Plain text
#: zsh.texi:16161
msgid "A keymap in ZLE contains a set of bindings between key sequences and ZLE commands.  The empty key sequence cannot be bound."
msgstr "ZLE 中的键映射包含键序列与 ZLE 命令之间的一组绑定。 空键序无法绑定。"

#. type: Plain text
#: zsh.texi:16165
msgid "There can be any number of keymaps at any time, and each keymap has one or more names.  If all of a keymap's names are deleted, it disappears."
msgstr "任何时候都可以有任意数量的键映射，每个键映射都有一个或多个名称。 如果删除了键映射的所有名称，它就会消失。"

#. type: findex
#: zsh.texi:16165
#, no-wrap
msgid "bindkey, use of"
msgstr "bindkey, use of"

#. type: Plain text
#: zsh.texi:16167
msgid "@t{bindkey} can be used to manipulate keymap names."
msgstr "@t{bindkey} 可用来操作键映射名称。"

#. type: Plain text
#: zsh.texi:16170
msgid "Initially, there are eight keymaps:"
msgstr "最初有八个键映射："

#. type: t{#1}
#: zsh.texi:16173
#, no-wrap
msgid "emacs"
msgstr "emacs"

#. type: table
#: zsh.texi:16175
msgid "EMACS emulation"
msgstr "EMACS 模拟"

#. type: t{#1}
#: zsh.texi:16175
#, no-wrap
msgid "viins"
msgstr "viins"

#. type: table
#: zsh.texi:16177
msgid "vi emulation - insert mode"
msgstr "vi 模拟 - 插入模式"

#. type: t{#1}
#: zsh.texi:16177
#, no-wrap
msgid "vicmd"
msgstr "vicmd"

#. type: table
#: zsh.texi:16179
msgid "vi emulation - command mode"
msgstr "vi 模拟 - 命令模式"

#. type: t{#1}
#: zsh.texi:16179
#, no-wrap
msgid "viopp"
msgstr "viopp"

#. type: table
#: zsh.texi:16181
msgid "vi emulation - operator pending"
msgstr "vi 模拟 - 操作符待处理（operator pending）"

#. type: t{#1}
#: zsh.texi:16181
#, no-wrap
msgid "visual"
msgstr "visual"

#. type: table
#: zsh.texi:16183
msgid "vi emulation - selection active"
msgstr "vi 模拟 - 选择激活"

#. type: t{#1}
#: zsh.texi:16183 zsh.texi:19003
#, no-wrap
msgid "isearch"
msgstr "isearch"

#. type: table
#: zsh.texi:16185
msgid "incremental search mode"
msgstr "增量搜索模式"

#. type: table
#: zsh.texi:16187
msgid "read a command name"
msgstr "读取命令名"

#. type: t{#1}
#: zsh.texi:16187
#, no-wrap
msgid ".safe"
msgstr ".safe"

#. type: table
#: zsh.texi:16189
msgid "fallback keymap"
msgstr "后备键映射"

#. type: Plain text
#: zsh.texi:16196
msgid ""
"The `@t{.safe}' keymap is special.  It can never be altered, and the name can never be removed.  However, it can be linked to other names, which can be removed.  In the future other special keymaps may be "
"added; users should avoid using names beginning with `@t{.}' for their own keymaps."
msgstr ""
" `@t{.safe}' 键映射是特殊的。 它永远无法更改，名称也永远无法删除。 不过，它可以链接到其他名称，这些名称可以删除。 将来可能会添加其他特殊的键映射；用户应避免在自己的键映射中使用以 `@t{.}' 开头的名称。"

#. type: vindex
#: zsh.texi:16198
#, no-wrap
msgid "VISUAL"
msgstr "VISUAL"

#. type: vindex
#: zsh.texi:16199
#, no-wrap
msgid "EDITOR"
msgstr "EDITOR"

#. type: Plain text
#: zsh.texi:16206
msgid ""
"In addition to these names, either `@t{emacs}' or `@t{viins}' is also linked to the name `@t{main}'.  If one of the @t{VISUAL} or @t{EDITOR} environment variables contain the string `@t{vi}' when the "
"shell starts up then it will be `@t{viins}', otherwise it will be `@t{emacs}'.  @t{bindkey}'s @t{-e} and @t{-v} options provide a convenient way to override this default choice."
msgstr ""
"除这些名称外，`@t{emacs}' 或 `@t{viins}' 也与名称 `@t{main}' 相关联。 当 shell 启动时，如果 @t{VISUAL} 或 @t{EDITOR} 环境变量之一包含字符串 `@t{vi}' ，那么它就是 `@t{viins}'，否则就是 `@t{emacs}' 。 "
"@t{bindkey} 的 @t{-e} 和 @t{-v} 选项提供了一种方便的方式来覆盖默认选择。"

#. type: Plain text
#: zsh.texi:16210
msgid "When the editor starts up, it will select the `@t{main}' keymap.  If that keymap doesn't exist, it will use `@t{.safe}' instead."
msgstr "当编辑器启动时，它会选择 `@t{main}' 键映射。 如果键映射不存在，则会使用 `@t{.safe}' 代替。"

#. type: Plain text
#: zsh.texi:16216
msgid ""
"In the `@t{.safe}' keymap, each single key is bound to @t{self-insert}, except for ^J (line feed) and ^M (return) which are bound to @t{accept-line}.  This is deliberately not pleasant to use; if you are "
"using it, it means you deleted the main keymap, and you should put it back."
msgstr ""
"在 `@t{.safe}' 键映射中，除了 ^J（换行）和 ^M（回车）与 @t{accept-line} 绑定外，每个单键都与 @t{self-insert} 绑定。 这种键映射方式故意让人觉得不好用；如果你正在使用它，就意味着你删除了主键映射，你应该把它"
"放回去。"

#. type: subsection
#: zsh.texi:16219
#, no-wrap
msgid "Reading Commands"
msgstr "读取命令"

#. type: Plain text
#: zsh.texi:16228
msgid ""
"When ZLE is reading a command from the terminal, it may read a sequence that is bound to some command and is also a prefix of a longer bound string.  In this case ZLE will wait a certain time to see if "
"more characters are typed, and if not (or they don't match any longer string) it will execute the binding.  This timeout is defined by the @t{KEYTIMEOUT} parameter; its default is 0.4 sec.  There is no "
"timeout if the prefix string is not itself bound to a command."
msgstr ""
"当 ZLE 从终端读取命令时，它可能会读取一个与某些命令绑定的序列，该序列也是一个更长绑定字符串的前缀。 在这种情况下，ZLE 会等待一段时间，看看是否有更多的字符被输入，如果没有（或者它们与更长的字符串不匹配），"
"它就会执行绑定。 超时时间由 @t{KEYTIMEOUT} 参数定义；默认值为 0.4 秒。 如果前缀字符串本身未与命令绑定，则不会超时。"

#. type: Plain text
#: zsh.texi:16237
msgid ""
"The key timeout is also applied when ZLE is reading the bytes from a multibyte character string when it is in the appropriate mode.  (This requires that the shell was compiled with multibyte mode enabled; "
"typically also the locale has characters with the UTF-8 encoding, although any multibyte encoding known to the operating system is supported.)  If the second or a subsequent byte is not read within the "
"timeout period, the shell acts as if @t{?} were typed and resets the input state."
msgstr ""
"当 ZLE 在适当模式下从多字节字符串读取字节时，也会应用按键超时。 (这要求 shell 在编译时启用了多字节模式；通常情况下，locale 中的字符也采用 UTF-8 编码，但也支持操作系统已知的任何多字节编码）。 如果在超时时间"
"内没有读取第二个或后续字节，shell 就会像键入 @t{?} 一样，并重置输入状态。"

#. type: Plain text
#: zsh.texi:16246
msgid ""
"As well as ZLE commands, key sequences can be bound to other strings, by using `@t{bindkey -s}'.  When such a sequence is read, the replacement string is pushed back as input, and the command reading "
"process starts again using these fake keystrokes.  This input can itself invoke further replacement strings, but in order to detect loops the process will be stopped if there are twenty such replacements "
"without a real command being read."
msgstr ""
"除了 ZLE 命令外，还可以使用 `@t{bindkey -s}' 将按键序列与其他字符串绑定。 当这样的序列被读取时，替换字符串会被推回作为输入，然后命令读取过程会使用这些假按键重新开始。 这种输入本身可以调用更多的替换字符串，"
"但为了检测循环，如果有 20 个这样的替换字符串而没有真正的命令被读取，进程就会停止。"

#. type: Plain text
#: zsh.texi:16251
msgid "A key sequence typed by the user can be turned into a command name for use in user-defined widgets with the @t{read-command} widget, described in @ref{Miscellaneous} below."
msgstr "用户输入的按键序列可以通过用 @t{read-command} 小部件定义的用户小部件转化为命令名称，在@ref{杂项}中描述。"

#. type: subsection
#: zsh.texi:16254
#, no-wrap
msgid "Local Keymaps"
msgstr "本地键映射"

#. type: cindex
#: zsh.texi:16256
#, no-wrap
msgid "local keymaps"
msgstr "本地键映射"

#. type: Plain text
#: zsh.texi:16262
msgid ""
"While for normal editing a single keymap is used exclusively, in many modes a local keymap allows for some keys to be customised. For example, in an incremental search mode, a binding in the @t{isearch} "
"keymap will override a binding in the @t{main} keymap but all keys that are not overridden can still be used."
msgstr "虽然在正常编辑中只使用一个键映射，但在许多模式下，本地键映射允许自定义某些键。例如，在增量搜索模式中，@t{isearch} 键映射中的绑定将覆盖 @t{main} 键映射中的绑定，但所有未覆盖的键仍可使用。"

#. type: Plain text
#: zsh.texi:16271
msgid ""
"If a key sequence is defined in a local keymap, it will hide a key sequence in the global keymap that is a prefix of that sequence. An example of this occurs with the binding of @t{iw} in @t{viopp} as "
"this hides the binding of @t{i} in @t{vicmd}. However, a longer sequence in the global keymap that shares the same prefix can still apply so for example the binding of @t{^Xa} in the global keymap will be "
"unaffected by the binding of @t{^Xb} in the local keymap."
msgstr ""
"如果在本地键映射中定义了一个键序列，它将隐藏全局键映射中作为该序列前缀的键序列。例如，在 @t{viopp} 中绑定 @t{iw} 会隐藏 @t{i} 在 @t{vicmd} 中的绑定。不过，全局键映射中共享相同前缀的更长序列仍然适用，例如，"
"全局键映射中 @t{^Xa} 的绑定将不受本地键映射中 @t{^Xb} 绑定的影响。"

#. type: node
#: zsh.texi:16273 zsh.texi:16937 zsh.texi:16939 zsh.texi:16964
#, no-wrap
msgid "Zle Widgets"
msgstr "Zle 小部件"

#. type: cindex
#: zsh.texi:16277
#, no-wrap
msgid "zle, builtin commands"
msgstr "zle, 内置命令"

#. type: Plain text
#: zsh.texi:16283
msgid ""
"The ZLE module contains three related builtin commands. The @t{bindkey} command manipulates keymaps and key bindings; the @t{vared} command invokes ZLE on the value of a shell parameter; and the @t{zle} "
"command manipulates editing widgets and allows command line access to ZLE commands from within shell functions."
msgstr "ZLE 模块包含三个相关的内置命令。@t{bindkey} 命令操作键映射和键绑定；@t{vared} 命令根据 shell 参数值调用 ZLE；@t{zle} 命令操作编辑小部件，并允许从 shell 函数中通过命令行访问 ZLE 命令。"

#. type: cindex
#: zsh.texi:16287
#, no-wrap
msgid "keys, rebinding"
msgstr "键, 重新绑定"

#. type: cindex
#: zsh.texi:16288
#, no-wrap
msgid "rebinding keys"
msgstr "重新绑定键"

#. type: cindex
#: zsh.texi:16289
#, no-wrap
msgid "keys, binding"
msgstr "键, 绑定"

#. type: cindex
#: zsh.texi:16290
#, no-wrap
msgid "binding keys"
msgstr "绑定键"

#. type: item
#: zsh.texi:16292
#, no-wrap
msgid "@t{bindkey} [ @var{options} ] @t{-l} [ @t{-L} ] [ @var{keymap} ... ]"
msgstr "@t{bindkey} [ @var{options} ] @t{-l} [ @t{-L} ] [ @var{keymap} ... ]"

#. type: itemx
#: zsh.texi:16293
#, no-wrap
msgid "@t{bindkey} [ @var{options} ] @t{-d}"
msgstr "@t{bindkey} [ @var{options} ] @t{-d}"

#. type: itemx
#: zsh.texi:16294
#, no-wrap
msgid "@t{bindkey} [ @var{options} ] @t{-D} @var{keymap} ..."
msgstr "@t{bindkey} [ @var{options} ] @t{-D} @var{keymap} ..."

#. type: itemx
#: zsh.texi:16295
#, no-wrap
msgid "@t{bindkey} [ @var{options} ] @t{-A} @var{old-keymap new-keymap}"
msgstr "@t{bindkey} [ @var{options} ] @t{-A} @var{old-keymap new-keymap}"

#. type: itemx
#: zsh.texi:16296
#, no-wrap
msgid "@t{bindkey} [ @var{options} ] @t{-N} @var{new-keymap} [ @var{old-keymap} ]"
msgstr "@t{bindkey} [ @var{options} ] @t{-N} @var{new-keymap} [ @var{old-keymap} ]"

#. type: itemx
#: zsh.texi:16297
#, no-wrap
msgid "@t{bindkey} [ @var{options} ] @t{-m}"
msgstr "@t{bindkey} [ @var{options} ] @t{-m}"

#. type: itemx
#: zsh.texi:16298
#, no-wrap
msgid "@t{bindkey} [ @var{options} ] @t{-r} @var{in-string} ..."
msgstr "@t{bindkey} [ @var{options} ] @t{-r} @var{in-string} ..."

#. type: itemx
#: zsh.texi:16299
#, no-wrap
msgid "@t{bindkey} [ @var{options} ] @t{-s} @var{in-string out-string} ..."
msgstr "@t{bindkey} [ @var{options} ] @t{-s} @var{in-string out-string} ..."

#. type: itemx
#: zsh.texi:16300
#, no-wrap
msgid "@t{bindkey} [ @var{options} ] @var{in-string command} ..."
msgstr "@t{bindkey} [ @var{options} ] @var{in-string command} ..."

#. type: itemx
#: zsh.texi:16301
#, no-wrap
msgid "@t{bindkey} [ @var{options} ] [ @var{in-string} ]"
msgstr "@t{bindkey} [ @var{options} ] [ @var{in-string} ]"

#. type: table
#: zsh.texi:16305
msgid "@t{bindkey}'s options can be divided into three categories: keymap selection for the current command, operation selection, and others.  The keymap selection options are:"
msgstr "@t{bindkey} 的选项可分为三类：当前命令的键映射选择、操作选择及其他。 键映射选择选项有："

#. type: table
#: zsh.texi:16312
msgid "Selects keymap `@t{emacs}' for any operations by the current command, and also links `@t{emacs}' to `@t{main}' so that it is selected by default the next time the editor starts."
msgstr "选择键映射 `@t{emacs}' 以执行当前命令的任何操作，并将 `@t{emacs}' 链接到 `@t{main}'，以便下次启动编辑器时默认选择该键映射。"

#. type: table
#: zsh.texi:16317
msgid "Selects keymap `@t{viins}' for any operations by the current command, and also links `@t{viins}' to `@t{main}' so that it is selected by default the next time the editor starts."
msgstr "选择键映射 `@t{viins}' 以执行当前命令的任何操作，并将 `@t{viins}' 链接到 `@t{main}'，以便下次启动编辑器时默认选择该键映射。"

#. type: table
#: zsh.texi:16320
msgid "Selects keymap `@t{vicmd}' for any operations by the current command."
msgstr "为当前命令的任何操作选择键映射 `@t{vicmd}'。"

#. type: item
#: zsh.texi:16321
#, no-wrap
msgid "@t{-M} @var{keymap}"
msgstr "@t{-M} @var{keymap}"

#. type: table
#: zsh.texi:16324
msgid "The @var{keymap} specifies a keymap name that is selected for any operations by the current command."
msgstr "@var{keymap} 指定了一个键映射名称，当前命令进行任何操作时都会选择该名称。"

#. type: table
#: zsh.texi:16331
msgid "If a keymap selection is required and none of the options above are used, the `@t{main}' keymap is used.  Some operations do not permit a keymap to be selected, namely:"
msgstr "如果需要选择键映射，且未使用上述任何选项，则使用 `@t{main}' 键映射。 某些操作不允许选择键映射，即"

#. type: table
#: zsh.texi:16337
msgid "List all existing keymap names; if any arguments are given, list just those keymaps."
msgstr "列出所有已存在的键映射名称；如果给出任何参数，则只列出这些键映射。"

#. type: table
#: zsh.texi:16346
msgid ""
"If the @t{-L} option is also used, list in the form of @t{bindkey} commands to create or link the keymaps.  `@t{bindkey -lL main}' shows which keymap is linked to `@t{main}', if any, and hence if the "
"standard emacs or vi emulation is in effect.  This option does not show the @t{.safe} keymap because it cannot be created in that fashion; however, neither is `@t{bindkey -lL .safe}' reported as an error, "
"it simply outputs nothing."
msgstr ""
"如果同时使用 @t{-L} 选项，则以 @t{bindkey} 命令的形式列出创建或链接键映射的命令。 `@t{bindkey -lL main}' 显示哪个键映射链接到了  `@t{main}'（如果有的话），从而显示标准 emacs 或 vi 模拟是否生效。 该选项不会"
"显示 @t{.safe} 键映射，因为它不能以这种方式创建；不过， `@t{bindkey -lL .safe}' 也不会被报告为错误，它只是什么也不输出。"

#. type: table
#: zsh.texi:16349
msgid "Delete all existing keymaps and reset to the default state."
msgstr "删除所有现有键映射并重置为默认状态。"

#. type: item
#: zsh.texi:16350
#, no-wrap
msgid "@t{-D} @var{keymap} ..."
msgstr "@t{-D} @var{keymap} ..."

#. type: table
#: zsh.texi:16352
msgid "Delete the named @var{keymap}s."
msgstr "删除已命名的 @var{keymap}s 键映射。"

#. type: item
#: zsh.texi:16353
#, no-wrap
msgid "@t{-A} @var{old-keymap new-keymap}"
msgstr "@t{-A} @var{old-keymap new-keymap}"

#. type: table
#: zsh.texi:16358
msgid ""
"Make the @var{new-keymap} name an alias for @var{old-keymap}, so that both names refer to the same keymap.  The names have equal standing; if either is deleted, the other remains.  If there is already a "
"keymap with the @var{new-keymap} name, it is deleted."
msgstr ""
"将 @var{new-keymap} 作为 @var{old-keymap} 的别名，这样两个名称就都指向同一个键映射。 这两个名称具有同等地位；如果其中一个被删除，另一个将保留。 如果已经有一个键映射使用 @var{new-keymap} 名称，则该名称将被"
"删除。"

#. type: item
#: zsh.texi:16359
#, no-wrap
msgid "@t{-N} @var{new-keymap} [ @var{old-keymap} ]"
msgstr "@t{-N} @var{new-keymap} [ @var{old-keymap} ]"

#. type: table
#: zsh.texi:16364
msgid ""
"Create a new keymap, named @var{new-keymap}.  If a keymap already has that name, it is deleted.  If an @var{old-keymap} name is given, the new keymap is initialized to be a duplicate of it, otherwise the "
"new keymap will be empty."
msgstr "创建一个新的键映射，命名为 @var{new-keymap}。 如果已有键映射使用该名称，则将其删除。 如果已给出 @var{old-keymap} 名称，新键映射将被初始化为该名称的副本，否则新键映射将为空。"

#. type: table
#: zsh.texi:16371
msgid ""
"To use a newly created keymap, it should be linked to @t{main}.  Hence the sequence of commands to create and use a new keymap `@t{mymap}' initialized from the @t{emacs} keymap (which remains unchanged) "
"is:"
msgstr "要使用新创建的键映射，必须将其链接到 @t{main}。 因此，创建并使用从 @t{emacs}键映射（保持不变）初始化的新键映射 `@t{mymap}' 的命令序列如下："

#. type: example
#: zsh.texi:16376
#, no-wrap
msgid ""
"bindkey -N mymap emacs\n"
"bindkey -A mymap main\n"
msgstr ""
"bindkey -N mymap emacs\n"
"bindkey -A mymap main\n"

#. type: table
#: zsh.texi:16382
msgid ""
"Note that while `@t{bindkey -A} @var{newmap} @t{main}' will work when @var{newmap} is @t{emacs} or @t{viins}, it will not work for @t{vicmd}, as switching from vi insert to command mode becomes impossible."
msgstr "请注意，虽然  `@t{bindkey -A} @var{newmap} @t{main}'  在 @var{newmap} 为 @t{emacs} 或 @t{viins} 时有效，但在 @t{vicmd} 时无效，因为无法从 vi 插入模式切换到命令模式。"

#. type: table
#: zsh.texi:16386
msgid "The following operations act on the `@t{main}' keymap if no keymap selection option was given:"
msgstr "如果没有给出键映射选择选项，下列操作将作用于 `@t{main}' 键映射："

#. type: table
#: zsh.texi:16392
msgid "Add the built-in set of meta-key bindings to the selected keymap.  Only keys that are unbound or bound to @t{self-insert} are affected."
msgstr "将内置的元键绑定集添加到选定的键映射中。 只有未绑定或绑定到 @t{self-insert} 的按键才会受到影响。"

#. type: item
#: zsh.texi:16393
#, no-wrap
msgid "@t{-r} @var{in-string} ..."
msgstr "@t{-r} @var{in-string} ..."

#. type: table
#: zsh.texi:16396
msgid "Unbind the specified @var{in-string}s in the selected keymap.  This is exactly equivalent to binding the strings to @t{undefined-key}."
msgstr "解除选定键映射中指定的 @var{in-string}s 的绑定。 这完全等同于将字符串绑定到 @t{undefined-key}。"

#. type: table
#: zsh.texi:16399
msgid "When @t{-R} is also used, interpret the @var{in-string}s as ranges."
msgstr "如果同时使用 @t{-R}，则将 @var{in-string}s 解释为范围。"

#. type: table
#: zsh.texi:16405
msgid ""
"When @t{-p} is also used, the @var{in-string}s specify prefixes.  Any binding that has the given @var{in-string} as a prefix, not including the binding for the @var{in-string} itself, if any, will be "
"removed.  For example,"
msgstr "当同时使用 @t{-p} 时，@var{in-string} 将指定前缀。 任何以给定的 @var{in-string} 为前缀的绑定（不包括 @var{in-string} 本身的绑定（如果有））都将被删除。 例如"

#. type: example
#: zsh.texi:16409
#, no-wrap
msgid "bindkey -rpM viins '^['\n"
msgstr "bindkey -rpM viins '^['\n"

#. type: table
#: zsh.texi:16416
msgid ""
"will remove all bindings in the vi-insert keymap beginning with an escape character (probably cursor keys), but leave the binding for the escape character itself (probably @t{vi-cmd-mode}).  This is "
"incompatible with the option @t{-R}."
msgstr "将删除 vi-insert 键映射中所有以转义字符开头的绑定（可能是光标键），但保留转义字符本身的绑定（可能是 @t{vi-cmd-mode}）。 这与选项 @t{-R} 不兼容。"

#. type: item
#: zsh.texi:16417
#, no-wrap
msgid "@t{-s} @var{in-string out-string} ..."
msgstr "@t{-s} @var{in-string out-string} ..."

#. type: table
#: zsh.texi:16422
msgid ""
"Bind each @var{in-string} to each @var{out-string}.  When @var{in-string} is typed, @var{out-string} will be pushed back and treated as input to the line editor.  When @t{-R} is also used, interpret the "
"@var{in-string}s as ranges."
msgstr "将每个 @var{in-string} 与每个 @var{out-string} 绑定。 输入 @var{in-string} 时，@var{out-string} 将被推回，并被视为行编辑器的输入。 当 @t{-R} 也被使用时，@var{in-string} 将被解释为范围。"

#. type: table
#: zsh.texi:16426
msgid "Note that both @var{in-string} and @var{out-string} are subject to the same form of interpretation, as described below."
msgstr "请注意，如下所述，@var{in-string} 和 @var{out-string} 都需要进行相同形式的解释。"

#. type: item
#: zsh.texi:16427
#, no-wrap
msgid "@var{in-string command} ..."
msgstr "@var{in-string command} ..."

#. type: table
#: zsh.texi:16430
msgid "Bind each @var{in-string} to each @var{command}.  When @t{-R} is used, interpret the @var{in-string}s as ranges."
msgstr "将每个 @var{in-string} 与每个 @var{command} 绑定。 当使用 @t{-R} 时，将 @var{in-string} 解释为范围。"

#. type: item
#: zsh.texi:16431
#, no-wrap
msgid "[ @var{in-string} ]"
msgstr "[ @var{in-string} ]"

#. type: table
#: zsh.texi:16438
msgid ""
"List key bindings.  If an @var{in-string} is specified, the binding of that string in the selected keymap is displayed.  Otherwise, all key bindings in the selected keymap are displayed.  (As a special "
"case, if the @t{-e} or @t{-v} option is used alone, the keymap is @emph{not} displayed - the implicit linking of keymaps is the only thing that happens.)"
msgstr ""
"列出按键绑定。 如果指定了 @var{in-string}，则会显示所选键映射中该字符串的绑定。 否则，将显示所选键映射中的所有按键绑定。 (作为特例，如果单独使用 @t{-e} 或 @t{-v} 选项，键映射将 @emph{不} 显示--键映射的隐式"
"链接是唯一会发生的情况）。"

#. type: table
#: zsh.texi:16443
msgid ""
"When the option @t{-p} is used, the @var{in-string} must be present.  The listing shows all bindings which have the given key sequence as a prefix, not including any bindings for the key sequence itself."
msgstr "当使用 @t{-p} 选项时，@var{in-string} 必须存在。 列表显示的是以给定键序为前缀的所有绑定，不包括键序本身的任何绑定。"

#. type: table
#: zsh.texi:16447
msgid "When the @t{-L} option is used, the list is in the form of @t{bindkey} commands to create the key bindings."
msgstr "当使用 @t{-L} 选项时，列表将是 @t{bindkey} 命令创建键绑定的形式。"

#. type: table
#: zsh.texi:16454
msgid ""
"When the @t{-R} option is used as noted above, a valid range consists of two characters, with an optional `@t{-}' between them.  All characters between the two specified, inclusive, are bound as specified."
msgstr "如上所述，使用 @t{-R} 选项时，有效范围由两个字符组成，两个字符之间还有一个可选的 `@t{-}' 。 指定的两个字符之间的所有字符（包括在内）都会按指定的方式绑定。"

#. type: table
#: zsh.texi:16458
msgid "For either @var{in-string} or @var{out-string}, the following escape sequences are recognised:"
msgstr "对于 @var{in-string} 或 @var{out-string}，可以识别以下转义序列："

#. type: item
#: zsh.texi:16465
#, no-wrap
msgid "@t{\\e}, @t{\\E}"
msgstr "@t{\\e}, @t{\\E}"

#. type: item
#: zsh.texi:16477
#, no-wrap
msgid "@t{\\}@var{NNN}"
msgstr "@t{\\}@var{NNN}"

#. type: item
#: zsh.texi:16485
#, no-wrap
msgid "@t{\\M}[@t{-}]@var{X}"
msgstr "@t{\\M}[@t{-}]@var{X}"

#. type: table
#: zsh.texi:16487
msgid "character with meta bit set"
msgstr "设置了元位的字符"

#. type: item
#: zsh.texi:16487
#, no-wrap
msgid "@t{\\C}[@t{-}]@var{X}"
msgstr "@t{\\C}[@t{-}]@var{X}"

#. type: table
#: zsh.texi:16489 zsh.texi:16491
msgid "control character"
msgstr "控制字符"

#. type: item
#: zsh.texi:16489
#, no-wrap
msgid "@t{^}@var{X}"
msgstr "@t{^}@var{X}"

#. type: table
#: zsh.texi:16499
msgid ""
"In all other cases, `@t{\\}' escapes the following character.  Delete is written as `@t{^?}'.  Note that `@t{\\M^?}' and `@t{^\\M?}' are not the same, and that (unlike emacs), the bindings `@t{\\M-}"
"@var{X}' and `@t{\\e}@var{X}' are entirely distinct, although they are initialized to the same bindings by `@t{bindkey -m}'."
msgstr ""
"在所有其他情况下，`@t{\\}' 会转义后面的字符。 删除则写成 `@t{^?}'。 请注意， `@t{\\M^?}' 和 `@t{^\\M?}' 并不相同，而且（与 emacs 不同）， `@t{\\M-}@var{X}' 和 `@t{\\e}@var{X}' 的绑定完全不同，尽管它们被 "
"`@t{bindkey -m}' 初始化为相同的绑定。"

#. type: cindex
#: zsh.texi:16501
#, no-wrap
msgid "parameters, editing"
msgstr "参数, 编辑"

#. type: cindex
#: zsh.texi:16502
#, no-wrap
msgid "editing parameters"
msgstr "编辑参数"

#. type: item
#: zsh.texi:16504
#, no-wrap
msgid "@t{vared }[ @t{-Aacghe} ] [ @t{-p} @var{prompt} ] [ @t{-r} @var{rprompt} ]"
msgstr "@t{vared }[ @t{-Aacghe} ] [ @t{-p} @var{prompt} ] [ @t{-r} @var{rprompt} ]"

#. type: itemx
#: zsh.texi:16505
#, no-wrap
msgid "@t{@ @ @ @ @ @ }[ @t{-M} @var{main-keymap} ] [ @t{-m} @var{vicmd-keymap} ]"
msgstr "@t{@ @ @ @ @ @ }[ @t{-M} @var{main-keymap} ] [ @t{-m} @var{vicmd-keymap} ]"

#. type: itemx
#: zsh.texi:16506
#, no-wrap
msgid "@t{@ @ @ @ @ @ }[ @t{-i} @var{init-widget} ] [ @t{-f} @var{finish-widget} ]"
msgstr "@t{@ @ @ @ @ @ }[ @t{-i} @var{init-widget} ] [ @t{-f} @var{finish-widget} ]"

#. type: itemx
#: zsh.texi:16507
#, no-wrap
msgid "@t{@ @ @ @ @ @ }[ @t{-t} @var{tty} ] @var{name}"
msgstr "@t{@ @ @ @ @ @ }[ @t{-t} @var{tty} ] @var{name}"

#. type: table
#: zsh.texi:16518
msgid ""
"The value of the parameter @var{name} is loaded into the edit buffer, and the line editor is invoked.  When the editor exits, @var{name} is set to the string value returned by the editor.  When the @t{-c} "
"flag is given, the parameter is created if it doesn't already exist.  The @t{-a} flag may be given with @t{-c} to create an array parameter, or the @t{-A} flag to create an associative array.  If the type "
"of an existing parameter does not match the type to be created, the parameter is unset and recreated.  The @t{-g} flag may be given to suppress warnings from the @t{WARN_CREATE_GLOBAL} and "
"@t{WARN_NESTED_VAR} options."
msgstr ""
"参数 @var{name} 的值被载入编辑缓冲区，并调用行编辑器。 编辑器退出后，@var{name} 将被设置为编辑器返回的字符串值。 如果给出 @t{-c} 标志，则会创建尚未存在的参数。 @t{-a} 标志可与 @t{-c} 一起使用，以创建数组参"
"数，或使用 @t{-A} 标志创建关联数组。 如果现有参数的类型与要创建的类型不匹配，参数将被取消设置并重新创建。 可以使用 @t{-g} 标志来抑制 @t{WARN_CREATE_GLOBAL} 和 @t{WARN_NESTED_VAR} 选项的警告。"

#. type: table
#: zsh.texi:16526
msgid ""
"If an array or array slice is being edited, separator characters as defined in @t{$IFS} will be shown quoted with a backslash, as will backslashes themselves.  Conversely, when the edited text is split "
"into an array, a backslash quotes an immediately following separator character or backslash; no other special handling of backslashes, or any handling of quotes, is performed."
msgstr ""
"如果正在编辑数组或数组片段，@t{$IFS} 中定义的分隔符会显示为用反斜线引用，反斜线本身也是如此。 相反，当编辑的文本被分割成一个数组时，反斜线会引用紧随其后的分隔符或反斜线；不会对反斜线进行其他特殊处理，也不"
"会对引号进行任何处理。"

#. type: table
#: zsh.texi:16531
msgid "Individual elements of existing array or associative array parameters may be edited by using subscript syntax on @var{name}.  New elements are created automatically, even without @t{-c}."
msgstr "可以使用 @var{name} 的下标语法编辑现有数组或关联数组参数的单个元素。 即使没有 @t{-c}，也会自动创建新元素。"

#. type: table
#: zsh.texi:16539
msgid ""
"If the @t{-p} flag is given, the following string will be taken as the prompt to display at the left.  If the @t{-r} flag is given, the following string gives the prompt to display at the right.  If the "
"@t{-h} flag is specified, the history can be accessed from ZLE. If the @t{-e} flag is given, typing @t{^D} (Control-D) on an empty line causes @t{vared} to exit immediately with a non-zero return value."
msgstr ""
"如果给出 @t{-p} 标志，则以下字符串将作为提示符显示在左侧。 如果给出 @t{-r} 标志，则下面的字符串将作为提示符显示在右侧。 如果指定了 @t{-h} 标志，则可以通过 ZLE 访问历史记录。如果给出 @t{-e} 标志，在空行上键"
"入 @t{^D} (Control-D) 会导致 @t{vared} 立即退出，并返回一个非零的返回值。"

#. type: table
#: zsh.texi:16547
msgid ""
"The @t{-M} option gives a keymap to link to the @t{main} keymap during editing, and the @t{-m} option gives a keymap to link to the @t{vicmd} keymap during editing.  For vi-style editing, this allows a "
"pair of keymaps to override @t{viins} and @t{vicmd}.  For emacs-style editing, only @t{-M} is normally needed but the @t{-m} option may still be used.  On exit, the previous keymaps will be restored."
msgstr ""
"@t{-M} 选项给出了一个键映射，在编辑过程中链接到 @t{main} 键映射，而 @t{-m} 选项给出了一个键映射，在编辑过程中链接到 @t{vicmd} 键映射。 对于 vi-style 编辑，这允许一对键映射覆盖 @t{viins} 和 @t{vicmd}。 对"
"于 emacs 风格的编辑，通常只需要 @t{-M}，但仍可使用 @t{-m} 选项。 退出时，将恢复之前的键映射。"

#. type: table
#: zsh.texi:16552
msgid ""
"@t{Vared} calls the usual `@t{zle-line-init}' and `@t{zle-line-finish}' hooks before and after it takes control. Using the @t{-i} and @t{-f} options, it is possible to replace these with other custom "
"widgets."
msgstr "@t{Vared} 会在控制之前和之后调用常规的 `@t{zle-line-init}' 和 `@t{zle-line-finish}' 钩子。使用 @t{-i} 和 @t{-f} 选项，可以用其他自定义小部件来替换这些钩子。"

#. type: table
#: zsh.texi:16557
msgid "If `@t{-t} @var{tty}' is given, @var{tty} is the name of a terminal device to be used instead of the default @t{/dev/tty}.  If @var{tty} does not refer to a terminal an error is reported."
msgstr "如果给出`@t{-t} @var{tty}' , 则 @var{tty} 是要使用的终端设备名称，而不是默认的 @t{/dev/tty}。 如果 @var{tty} 并非指向终端设备，系统将报错。"

#. type: cindex
#: zsh.texi:16559
#, no-wrap
msgid "widgets, rebinding"
msgstr "小部件, 重新绑定"

#. type: cindex
#: zsh.texi:16560
#, no-wrap
msgid "rebinding widgets"
msgstr "重新绑定小部件"

#. type: cindex
#: zsh.texi:16561
#, no-wrap
msgid "widgets, binding"
msgstr "小部件, 绑定"

#. type: cindex
#: zsh.texi:16562
#, no-wrap
msgid "binding widgets"
msgstr "绑定小部件"

#. type: cindex
#: zsh.texi:16563
#, no-wrap
msgid "widgets, invoking"
msgstr "小部件, 调用"

#. type: cindex
#: zsh.texi:16564
#, no-wrap
msgid "invoking widgets"
msgstr "调用小部件"

#. type: cindex
#: zsh.texi:16565
#, no-wrap
msgid "widgets, calling"
msgstr "小部件, 调用"

#. type: cindex
#: zsh.texi:16566
#, no-wrap
msgid "calling widgets"
msgstr "调用小部件"

#. type: cindex
#: zsh.texi:16567
#, no-wrap
msgid "widgets, defining"
msgstr "小部件, 定义"

#. type: cindex
#: zsh.texi:16568
#, no-wrap
msgid "defining widgets"
msgstr "定义小部件"

#. type: itemx
#: zsh.texi:16570
#, no-wrap
msgid "@t{zle} @t{-l} [ @t{-L} | @t{-a} ] [ @var{string} ... ]"
msgstr "@t{zle} @t{-l} [ @t{-L} | @t{-a} ] [ @var{string} ... ]"

#. type: itemx
#: zsh.texi:16571
#, no-wrap
msgid "@t{zle} @t{-D} @var{widget} ..."
msgstr "@t{zle} @t{-D} @var{widget} ..."

#. type: itemx
#: zsh.texi:16572
#, no-wrap
msgid "@t{zle} @t{-A} @var{old-widget} @var{new-widget}"
msgstr "@t{zle} @t{-A} @var{old-widget} @var{new-widget}"

#. type: itemx
#: zsh.texi:16573
#, no-wrap
msgid "@t{zle} @t{-N} @var{widget} [ @var{function} ]"
msgstr "@t{zle} @t{-N} @var{widget} [ @var{function} ]"

#. type: itemx
#: zsh.texi:16574
#, no-wrap
msgid "@t{zle} @t{-f} @var{flag} [ @var{flag}... ]"
msgstr "@t{zle} @t{-f} @var{flag} [ @var{flag}... ]"

#. type: itemx
#: zsh.texi:16575
#, no-wrap
msgid "@t{zle} @t{-C} @var{widget} @var{completion-widget} @var{function}"
msgstr "@t{zle} @t{-C} @var{widget} @var{completion-widget} @var{function}"

#. type: itemx
#: zsh.texi:16576
#, no-wrap
msgid "@t{zle} @t{-R} [ @t{-c} ] [ @var{display-string} ] [ @var{string} ... ]"
msgstr "@t{zle} @t{-R} [ @t{-c} ] [ @var{display-string} ] [ @var{string} ... ]"

#. type: itemx
#: zsh.texi:16577
#, no-wrap
msgid "@t{zle} @t{-M} @var{string}"
msgstr "@t{zle} @t{-M} @var{string}"

#. type: itemx
#: zsh.texi:16578
#, no-wrap
msgid "@t{zle} @t{-U} @var{string}"
msgstr "@t{zle} @t{-U} @var{string}"

#. type: itemx
#: zsh.texi:16579
#, no-wrap
msgid "@t{zle} @t{-K} @var{keymap}"
msgstr "@t{zle} @t{-K} @var{keymap}"

#. type: itemx
#: zsh.texi:16580
#, no-wrap
msgid "@t{zle} @t{-F} [ @t{-L} | @t{-w} ] [ @var{fd} [ @var{handler} ] ]"
msgstr "@t{zle} @t{-F} [ @t{-L} | @t{-w} ] [ @var{fd} [ @var{handler} ] ]"

#. type: itemx
#: zsh.texi:16581
#, no-wrap
msgid "@t{zle} @t{-I}"
msgstr "@t{zle} @t{-I}"

#. type: itemx
#: zsh.texi:16582
#, no-wrap
msgid "@t{zle} @t{-T} [ @t{tc} @var{function} | @t{-r} @t{tc} | @t{-L} ]"
msgstr "@t{zle} @t{-T} [ @t{tc} @var{function} | @t{-r} @t{tc} | @t{-L} ]"

#. type: itemx
#: zsh.texi:16583
#, no-wrap
msgid "@t{zle} @var{widget} [ @t{-n} @var{num} ] [ @t{-f} @var{flag} ] [ @t{-Nw} ] [ @t{-K} @var{keymap} ] @var{args} ..."
msgstr "@t{zle} @var{widget} [ @t{-n} @var{num} ] [ @t{-f} @var{flag} ] [ @t{-Nw} ] [ @t{-K} @var{keymap} ] @var{args} ..."

#. type: table
#: zsh.texi:16586
msgid "The @t{zle} builtin performs a number of different actions concerning ZLE."
msgstr "@t{zle} 内置命令会执行一系列与 ZLE 有关的不同操作。"

#. type: table
#: zsh.texi:16594
msgid ""
"With no options and no arguments, only the return status will be set.  It is zero if ZLE is currently active and widgets could be invoked using this builtin command and non-zero otherwise.  Note that even "
"if non-zero status is returned, zle may still be active as part of the completion system; this does not allow direct calls to ZLE widgets."
msgstr ""
"在没有选项和参数的情况下，只会设置返回状态。 如果 ZLE 当前处于激活状态，且可以使用该内置命令调用小部件，则状态为 0，否则为非 0。 请注意，即使返回非零状态，zle 仍可能作为补全系统的一部分处于活动状态；这不允"
"许直接调用 ZLE 小部件。"

#. type: table
#: zsh.texi:16597
msgid "Otherwise, which operation it performs depends on its options:"
msgstr "否则，执行哪种操作取决于其选项："

#. type: item
#: zsh.texi:16600
#, no-wrap
msgid "@t{-l} [ @t{-L} | @t{-a} ] [ @var{string} ]"
msgstr "@t{-l} [ @t{-L} | @t{-a} ] [ @var{string} ]"

#. type: table
#: zsh.texi:16604
msgid "List all existing user-defined widgets.  If the @t{-L} option is used, list in the form of @t{zle} commands to create the widgets."
msgstr "列出所有现有的用户自定义小部件。 如果使用 @t{-L} 选项，则以 @t{zle} 命令的形式列出创建小部件的命令。"

#. type: table
#: zsh.texi:16608
msgid "When combined with the @t{-a} option, all widget names are listed, including the builtin ones. In this case the @t{-L} option is ignored."
msgstr "与 @t{-a} 选项结合使用时，将列出所有小部件名称，包括内置命令名称。在这种情况下，@t{-L} 选项将被忽略。"

#. type: table
#: zsh.texi:16616
msgid ""
"If at least one @var{string} is given, and @t{-a} is present or @t{-L} is not used, nothing will be printed.  The return status will be zero if all @var{string}s are names of existing widgets and non-zero "
"if at least one @var{string} is not a name of a defined widget.  If @t{-a} is also present, all widget names are used for the comparison including builtin widgets, else only user-defined widgets are used."
msgstr ""
"如果至少给出一个 @var{string}，且 @t{-a} 已存在或 @t{-L} 未使用，则不会打印任何内容。 如果所有 @var{string} 都是已存在的小部件名称，则返回状态为 0；如果至少有一个 @var{string} 不是已定义的小部件名称，则返"
"回状态为非 0。 如果 @t{-a} 也存在，则所有小部件名称都将用于比较，包括内置小部件，否则只使用用户定义的小部件。"

#. type: table
#: zsh.texi:16621
msgid "If at least one @var{string} is present and the @t{-L} option is used, user-defined widgets matching any @var{string} are listed in the form of @t{zle} commands to create the widgets."
msgstr "如果存在至少一个 @var{string}，且使用了 @t{-L} 选项，则会以 @t{zle} 命令的形式列出与任何 @var{string} 匹配的用户自定义部件创建的命令。"

#. type: item
#: zsh.texi:16622
#, no-wrap
msgid "@t{-D} @var{widget} ..."
msgstr "@t{-D} @var{widget} ..."

#. type: table
#: zsh.texi:16624
msgid "Delete the named @var{widget}s."
msgstr "删除已命名的 @var{widget}s。"

#. type: item
#: zsh.texi:16625
#, no-wrap
msgid "@t{-A} @var{old-widget} @var{new-widget}"
msgstr "@t{-A} @var{old-widget} @var{new-widget}"

#. type: table
#: zsh.texi:16630
msgid ""
"Make the @var{new-widget} name an alias for @var{old-widget}, so that both names refer to the same widget.  The names have equal standing; if either is deleted, the other remains.  If there is already a "
"widget with the @var{new-widget} name, it is deleted."
msgstr ""
"将 @var{new-widget} 作为 @var{old-widget} 的别名，这样两个名称都指向同一个小部件。 这两个名称具有同等地位；如果其中一个被删除，另一个将保留。 如果已有一个名称为 @var{new-widget} 的小部件，它将被删除。"

#. type: item
#: zsh.texi:16631
#, no-wrap
msgid "@t{-N} @var{widget} [ @var{function} ]"
msgstr "@t{-N} @var{widget} [ @var{function} ]"

#. type: table
#: zsh.texi:16638
msgid ""
"Create a user-defined widget.  If there is already a widget with the specified name, it is overwritten.  When the new widget is invoked from within the editor, the specified shell @var{function} is "
"called.  If no function name is specified, it defaults to the same name as the widget.  For further information, see @ref{Zle Widgets}."
msgstr ""
"创建一个用户定义的小部件。 如果已经有一个名称为指定名称的小部件，它将被覆盖。 在编辑器中调用新的小部件时，会调用指定的 shell @var{function}。 如果没有指定函数名称，则默认使用与小部件相同的名称。 更多信息，"
"请参阅 @ref{Zle 小部件}。"

#. type: item
#: zsh.texi:16639
#, no-wrap
msgid "@t{-f} @var{flag} [ @var{flag}... ]"
msgstr "@t{-f} @var{flag} [ @var{flag}... ]"

#. type: table
#: zsh.texi:16641
msgid "Set various flags on the running widget.  Possible values for @var{flag} are:"
msgstr "为运行中的小部件设置各种标志。 @var{flag} 的可能值是："

#. type: table
#: zsh.texi:16649
msgid ""
"@t{yank} for indicating that the widget has yanked text into the buffer.  If the widget is wrapping an existing internal widget, no further action is necessary, but if it has inserted the text manually, "
"then it should also take care to set @t{YANK_START} and @t{YANK_END} correctly.  @t{yankbefore} does the same but is used when the yanked text appears after the cursor."
msgstr ""
"@t{yank} 用于指示小部件已将文本插入缓冲区。 如果小部件正在封装已有的内部部件，则无需进一步操作，但如果是手动插入文本，则还应注意正确设置 @t{YANK_START} 和 @t{YANK_END}。 @t{yankbefore} 的作用与此相同，但用"
"于在光标后出现复制的文本。"

#. type: table
#: zsh.texi:16655
msgid ""
"@t{kill} for indicating that text has been killed into the cutbuffer.  When repeatedly invoking a kill widget, text is appended to the cutbuffer instead of replacing it, but when wrapping such widgets, it "
"is necessary to call `@t{zle -f kill}' to retain this effect."
msgstr "@t{kill} 用于指示文本已被杀进入剪切缓冲区。 当重复调用 kill 小部件时，文本会被追加到剪切缓冲区而不是替换掉，但在封装此类小部件时，有必要调用 `@t{zle -f kill}' 来保留这种效果。"

#. type: table
#: zsh.texi:16663
msgid ""
"@t{vichange} for indicating that the widget represents a vi change that can be repeated as a whole with `@t{vi-repeat-change}'. The flag should be set early in the function before inspecting the value of "
"@t{NUMERIC} or invoking other widgets. This has no effect for a widget invoked from insert mode. If insert mode is active when the widget finishes, the change extends until next returning to command mode."
msgstr ""
"@t{vichange}，用于表示小部件代表的 vi 变化可以用 `@t{vi-repeat-change}' 整体重复。在检查 @t{NUMERIC} 的值或调用其他小部件之前，应在函数的早期设置该标志。对于从插入模式调用的小部件，该标志不起作用。如果小部"
"件结束时插入模式处于激活状态，则更改会持续到下一次返回命令模式。"

#. type: cindex
#: zsh.texi:16664
#, no-wrap
msgid "completion widgets, creating"
msgstr "补全小部件, 创建"

#. type: item
#: zsh.texi:16665
#, no-wrap
msgid "@t{-C} @var{widget} @var{completion-widget} @var{function}"
msgstr "@t{-C} @var{widget} @var{completion-widget} @var{function}"

#. type: table
#: zsh.texi:16672
msgid ""
"Create a user-defined completion widget named @var{widget}. The completion widget will behave like the built-in completion-widget whose name is given as @var{completion-widget}. To generate the "
"completions, the shell function @var{function} will be called.  For further information, see @ref{Completion Widgets}."
msgstr ""
"创建名为 @var{widget} 的用户自定义补全部件。该补全小部件的行为与内置的补全小部件类似，其名称为 @var{completion-widget}。要生成补全，将调用 shell 函数 @var{function}。 更多信息，请参阅 @ref{补全小部件}。"

#. type: item
#: zsh.texi:16673
#, no-wrap
msgid "@t{-R} [ @t{-c} ] [ @var{display-string} ] [ @var{string} ... ]"
msgstr "@t{-R} [ @t{-c} ] [ @var{display-string} ] [ @var{string} ... ]"

#. type: table
#: zsh.texi:16677
msgid "Redisplay the command line.  If a @var{display-string} is given and not empty, this is shown in the status line (immediately below the line being edited)."
msgstr "重新显示命令行。 如果给定了 @var{display-string}，且该字符串不为空，则会显示在状态行中（紧挨着正在编辑的行的下方）。"

#. type: table
#: zsh.texi:16683
msgid ""
"If the optional @var{string}s are given they are listed below the prompt in the same way as completion lists are printed. If no @var{string}s are given but the @t{-c} option is used such a list is cleared."
msgstr "如果给出了可选的 @var{string}s，它们将以与打印补全列表相同的方式列在提示符下方。如果没有给出 @var{string}s，但使用了 @t{-c} 选项，则会清除该列表。"

#. type: table
#: zsh.texi:16688
msgid ""
"Note that immediately after returning from running widgets, the command line will be redisplayed and the strings displayed will be erased.  Therefore, this option is only useful for widgets that do not "
"exit immediately after using it."
msgstr "请注意，运行小部件返回后，命令行会立即重新显示，显示的字符串也会被擦除。 因此，该选项只适用于使用后不会立即退出的小部件。"

#. type: table
#: zsh.texi:16694
msgid ""
"This command can safely be called outside user defined widgets; if zle is active, the display will be refreshed, while if zle is not active, the command has no effect.  In this case there will usually be "
"no other arguments."
msgstr "这条命令可以在用户定义的小部件之外安全地调用；如果 zle 处于活动状态，显示内容将被刷新，而如果 zle 未处于活动状态，这条命令则没有任何作用。 在这种情况下，通常不会有其他参数。"

#. type: table
#: zsh.texi:16697
msgid "The status is zero if zle was active, else one."
msgstr "如果 zle 处于活动状态，则状态为 0，否则为 1。"

#. type: item
#: zsh.texi:16698
#, no-wrap
msgid "@t{-M} @var{string}"
msgstr "@t{-M} @var{string}"

#. type: table
#: zsh.texi:16704
msgid ""
"As with the @t{-R} option, the @var{string} will be displayed below the command line; unlike the @t{-R} option, the string will not be put into the status line but will instead be printed normally below "
"the prompt.  This means that the @var{string} will still be displayed after the widget returns (until it is overwritten by subsequent commands)."
msgstr "与 @t{-R} 选项一样，@var{string} 将显示在命令行下方；与 @t{-R} 选项不同的是，字符串不会被放入状态行，而是正常打印在提示符下方。 这意味着小部件返回后，@var{string} 仍会显示（直到被后续命令覆盖）。"

#. type: item
#: zsh.texi:16705
#, no-wrap
msgid "@t{-U} @var{string}"
msgstr "@t{-U} @var{string}"

#. type: table
#: zsh.texi:16709
msgid ""
"This pushes the characters in the @var{string} onto the input stack of ZLE.  After the widget currently executed finishes ZLE will behave as if the characters in the @var{string} were typed by the user."
msgstr "这会将 @var{string} 中的字符推入 ZLE 的输入堆栈。 在当前执行的小部件结束后，ZLE 的行为就好像 @var{string} 中的字符是由用户输入的一样。"

#. type: table
#: zsh.texi:16715
msgid ""
"As ZLE uses a stack, if this option is used repeatedly the last string pushed onto the stack will be processed first.  However, the characters in each @var{string} will be processed in the order in which "
"they appear in the string."
msgstr "由于 ZLE 使用堆栈，如果重复使用该选项，最后推入堆栈的字符串将首先被处理。 不过，每个 @var{string} 中的字符将按照它们在字符串中出现的顺序进行处理。"

#. type: item
#: zsh.texi:16716
#, no-wrap
msgid "@t{-K} @var{keymap}"
msgstr "@t{-K} @var{keymap}"

#. type: table
#: zsh.texi:16719
msgid "Selects the keymap named @var{keymap}.  An error message will be displayed if there is no such keymap."
msgstr "选择名为 @var{keymap} 的键映射。 如果没有此键映射，系统将显示错误信息。"

#. type: table
#: zsh.texi:16724
msgid ""
"This keymap selection affects the interpretation of following keystrokes within this invocation of ZLE.  Any following invocation (e.g., the next command line) will start as usual with the `@t{main}' "
"keymap selected."
msgstr "键映射的选择会影响 ZLE 在本次调用中对后续按键的解释。 任何后续调用（例如下一条命令行）都将照常以 `@t{main}' 键映射开始。"

#. type: item
#: zsh.texi:16725
#, no-wrap
msgid "@t{-F} [ @t{-L} | @t{-w} ] [ @var{fd} [ @var{handler} ] ]"
msgstr "@t{-F} [ @t{-L} | @t{-w} ] [ @var{fd} [ @var{handler} ] ]"

#. type: table
#: zsh.texi:16728
msgid "Only available if your system supports one of the `poll' or `select' system calls; most modern systems do."
msgstr "只有当系统支持 `poll' 或  `select' 系统调用时才可用；大多数现代系统都支持。"

#. type: table
#: zsh.texi:16737
msgid ""
"Installs @var{handler} (the name of a shell function) to handle input from file descriptor @var{fd}.  Installing a handler for an @var{fd} which is already handled causes the existing handler to be "
"replaced.  Any number of handlers for any number of readable file descriptors may be installed.  Note that zle makes no attempt to check whether this @var{fd} is actually readable when installing the "
"handler.  The user must make their own arrangements for handling the file descriptor when zle is not active."
msgstr ""
"安装 @var{handler}（一个 shell 函数的名称），以处理来自文件描述符 @var{fd} 的输入。 为已处理过的 @var{fd} 安装处理程序会导致现有处理程序被替换。 可以为任意数量的可读文件描述符安装任意数量的处理程序。 请注"
"意，在安装处理程序时，zle 不会检查 @var{fd} 是否可读。 用户必须自行安排在zle未激活时如何处理文件描述符。"

#. type: table
#: zsh.texi:16747
msgid ""
"When zle is attempting to read data, it will examine both the terminal and the list of handled @var{fd}'s.  If data becomes available on a handled @var{fd}, zle calls @var{handler} with the fd which is "
"ready for reading as the first argument.  Under normal circumstances this is the only argument, but if an error was detected, a second argument provides details: `@t{hup}' for a disconnect, `@t{nval}' for "
"a closed or otherwise invalid descriptor, or `@t{err}' for any other condition.  Systems that support only the `select' system call always use `@t{err}'."
msgstr ""
"当 zle 尝试读取数据时，它会同时检查终端和已处理 @var{fd} 的列表。 如果已处理 @var{fd} 上的数据可用，zle 会调用 @var{handler}，并将已准备好读取的 fd 作为第一个参数。 正常情况下，这是唯一的参数，但如果检测到"
"错误，第二个参数会提供详细信息：`@t{hup}' 表示断开连接，`@t{nval}' 表示描述符已关闭或无效， `@t{err}' 表示任何其他情况。 只支持 `select' 系统调用的系统总是使用 `@t{err}'。"

#. type: table
#: zsh.texi:16758
msgid ""
"If the option @t{-w} is also given, the @var{handler} is instead a line editor widget, typically a shell function made into a widget using `@t{zle -N}'.  In that case @var{handler} can use all the "
"facilities of zle to update the current editing line.  Note, however, that as handling @var{fd} takes place at a low level changes to the display will not automatically appear; the widget should call "
"`@t{zle -R}' to force redisplay.  As of this writing, widget handlers only support a single argument and thus are never passed a string for error state, so widgets must be prepared to test the descriptor "
"themselves."
msgstr ""
"如果同时给定了 @t{-w} 选项，@var{handler} 则是一个行编辑器小部件，通常是使用 `@t{zle -N}' 制作成小部件的 shell 函数。 在这种情况下，@var{handler} 可以使用 zle 的所有功能来更新当前编辑行。 但需要注意的是，"
"由于 @var{fd} 的处理是在低层次上进行的，因此显示的更改不会自动出现；小部件应调用 `@t{zle -R}' 来强制重新显示。 截至本文撰写时，小部件处理程序只支持单个参数，因此不会传递错误状态字符串，所以小部件必须准备好"
"自行测试描述符。"

#. type: table
#: zsh.texi:16763
msgid "If either type of handler produces output to the terminal, it should call `@t{zle -I}' before doing so (see below).  Handlers should not attempt to read from the terminal."
msgstr "如果处理程序向终端输出内容，则应在输出前调用 `@t{zle -I}' （见下文）。 处理程序不应试图从终端读取数据。"

#. type: table
#: zsh.texi:16768
msgid "If no @var{handler} is given, but an @var{fd} is present, any handler for that @var{fd} is removed.  If there is none, an error message is printed and status 1 is returned."
msgstr "如果未给出 @var{handler}，但存在 @var{fd}，则会删除该 @var{fd} 的任何处理程序。 如果没有处理程序，将打印错误信息并返回状态 1。"

#. type: table
#: zsh.texi:16772
msgid "If no arguments are given, or the @t{-L} option is supplied, a list of handlers is printed in a form which can be stored for later execution."
msgstr "如果没有给定参数，或者提供了 @t{-L} 选项，则会以可存储的形式打印处理程序列表，以供之后执行。"

#. type: table
#: zsh.texi:16777
msgid "An @var{fd} (but not a @var{handler}) may optionally be given with the @t{-L} option; in this case, the function will list the handler if any, else silently return status 1."
msgstr "可选择使用 @t{-L} 选项给出 @var{fd}（但不包括 @var{handler}）；在这种情况下，如果有处理程序，函数将列出该处理程序，否则静默返回状态 1。"

#. type: table
#: zsh.texi:16783
msgid ""
"Note that this feature should be used with care.  Activity on one of the @var{fd}'s which is not properly handled can cause the terminal to become unusable.  Removing an @var{fd} handler from within a "
"signal trap may cause unpredictable behavior."
msgstr "请注意，使用该特性时应谨慎。 如果 @var{fd} 上的某个活动未得到正确处理，可能导致终端无法使用。 从信号陷阱中移除 @var{fd} 处理程序可能会导致不可预知的行为。"

#. type: table
#: zsh.texi:16792
msgid ""
"Here is a simple example of using this feature.  A connection to a remote TCP port is created using the ztcp command; see @ref{The zsh/net/tcp Module}.  Then a handler is installed which simply prints out "
"any data which arrives on this connection.  Note that `select' will indicate that the file descriptor needs handling if the remote side has closed the connection; we handle that by testing for a failed "
"read."
msgstr ""
"下面是一个使用此功能的简单示例。 使用 ztcp 命令创建与远程 TCP 端口的连接；参见 @ref{zsh/net/tcp 模块}。 然后安装一个处理程序，简单地打印出该连接上到达的任何数据。 需要注意的是，如果远端关闭了连接， "
"`select' 将指示文件描述符需要处理；我们通过测试读取失败来处理这种情况。"

#. type: example
#: zsh.texi:16811
#, no-wrap
msgid ""
"if ztcp pwspc 2811; then\n"
"  tcpfd=$REPLY\n"
"  handler() @{\n"
"    zle -I\n"
"    local line\n"
"    if ! read -r line <&$1; then\n"
"      # select marks this fd if we reach EOF,\n"
"      # so handle this specially.\n"
"      print \"[Read on fd $1 failed, removing.]\" >&2\n"
"      zle -F $1\n"
"      return 1\n"
"    fi\n"
"    print -r - $line\n"
"  @}\n"
"  zle -F $tcpfd handler\n"
"fi\n"
msgstr ""
"if ztcp pwspc 2811; then\n"
"  tcpfd=$REPLY\n"
"  handler() @{\n"
"    zle -I\n"
"    local line\n"
"    if ! read -r line <&$1; then\n"
"      # select marks this fd if we reach EOF,\n"
"      # so handle this specially.\n"
"      print \"[Read on fd $1 failed, removing.]\" >&2\n"
"      zle -F $1\n"
"      return 1\n"
"    fi\n"
"    print -r - $line\n"
"  @}\n"
"  zle -F $tcpfd handler\n"
"fi\n"

#. type: table
#: zsh.texi:16821
msgid ""
"Unusually, this option is most useful outside ordinary widget functions, though it may be used within if normal output to the terminal is required.  It invalidates the current zle display in preparation "
"for output; typically this will be from a trap function.  It has no effect if zle is not active.  When a trap exits, the shell checks to see if the display needs restoring, hence the following will print "
"output in such a way as not to disturb the line being edited:"
msgstr ""
"不同的是，这个选项在普通小部件函数之外最有用，不过如果需要向终端正常输出，也可以在内部使用。 它可以使当前的 zle 显示无效，以为输出做准备；通常是通过陷阱函数输出。 如果zle未激活，它将不起作用。 当陷阱退出"
"时，shell 会检查显示是否需要恢复，因此下面，将以不影响正在编辑的行的方式打印输出："

#. type: example
#: zsh.texi:16830
#, no-wrap
msgid ""
"TRAPUSR1() @{\n"
"  # Invalidate zle display\n"
"  [[ -o zle ]] && zle -I\n"
"  # Show output\n"
"  print Hello\n"
"@}\n"
msgstr ""
"TRAPUSR1() @{\n"
"  # Invalidate zle display\n"
"  [[ -o zle ]] && zle -I\n"
"  # Show output\n"
"  print Hello\n"
"@}\n"

#. type: table
#: zsh.texi:16836
msgid ""
"In general, the trap function may need to test whether zle is active before using this method (as shown in the example), since the @t{zsh/zle} module may not even be loaded; if it is not, the command can "
"be skipped."
msgstr "一般来说，在使用此方法之前，陷阱函数可能需要测试 zle 是否处于活动状态（如示例所示），因为 @t{zsh/zle} 模块可能根本没有加载；如果没有加载，则可以跳过该命令。"

#. type: table
#: zsh.texi:16841
msgid "It is possible to call `@t{zle -I}' several times before control is returned to the editor; the display will only be invalidated the first time to minimise disruption."
msgstr "在控制权返回编辑器之前，可以多次调用 `@t{zle -I}' ；为减少干扰，显示只会在第一次无效。"

#. type: table
#: zsh.texi:16845
msgid "Note that there are normally better ways of manipulating the display from within zle widgets; see, for example, `@t{zle -R}' above."
msgstr "请注意，在 zle 小部件中通常有更好的操作显示的方式；例如，请参阅上文的 `@t{zle -R}'。"

#. type: table
#: zsh.texi:16851
msgid ""
"The returned status is zero if zle was invalidated, even though this may have been by a previous call to `@t{zle -I}' or by a system notification.  To test if a zle widget may be called at this point, "
"execute @t{zle} with no arguments and examine the return status."
msgstr "如果 zle 已失效，则返回状态为零，尽管这可能是由于之前调用了 `@t{zle -I}' 或系统通知所致。 要测试此时是否可以调用 zle 小部件，可以不带参数执行 @t{zle}，并检查返回状态。"

#. type: table
#: zsh.texi:16857
msgid ""
"This is used to add, list or remove internal transformations on the processing performed by the line editor.  It is typically used only for debugging or testing and is therefore of little interest to the "
"general user."
msgstr "用于添加、列出或删除行编辑器处理过程中的内部转换。 它通常只用于调试或测试，因此一般用户对其兴趣不大。"

#. type: table
#: zsh.texi:16862
msgid "`@t{zle -T} @var{transformation} @var{func}' specifies that the given @var{transformation} (see below) is effected by shell function @var{func}."
msgstr "`@t{zle -T} @var{transformation} @var{func}' 指定指定的 @var{transformation}（见下文）由 shell 函数 @var{func} 执行（effected）。"

#. type: table
#: zsh.texi:16866
msgid "`@t{zle -Tr} @var{transformation}' removes the given @var{transformation} if it was present (it is not an error if none was)."
msgstr "`@t{zle -Tr} @var{transformation}' 会移除给定的 @var{transformation}（如果有的话，如果没有也不会出错）。"

#. type: table
#: zsh.texi:16870
msgid "`@t{zle -TL}' can be used to list all transformations currently in operation."
msgstr "`@t{zle -TL}'  可用于列出当前正在运行的所有转换。"

#. type: table
#: zsh.texi:16882
msgid ""
"Currently the only transformation is @t{tc}.  This is used instead of outputting termcap codes to the terminal.  When the transformation is in operation the shell function is passed the termcap code that "
"would be output as its first argument; if the operation required a numeric argument, that is passed as a second argument.  The function should set the shell variable @t{REPLY} to the transformed termcap "
"code.  Typically this is used to produce some simply formatted version of the code and optional argument for debugging or testing.  Note that this transformation is not applied to other non-printing "
"characters such as carriage returns and newlines."
msgstr ""
"目前唯一的转换是 @t{tc}。 它用来代替向终端输出 termcap 代码。 当转换执行时，shell 函数会将输出的 termcap 代码作为第一个参数传递给函数；如果转换操作需要数字参数，则会将数字参数作为第二个参数传递给函数。 函"
"数应将 shell 变量 @t{REPLY} 设置为转换后的 termcap 代码。 通常情况下，这用于生成一些简单格式化的代码版本，以及用于调试或测试的可选参数。 请注意，这种转换不适用于其他非打印字符，如回车符和换行符。"

#. type: item
#: zsh.texi:16883
#, no-wrap
msgid "@var{widget} [ @t{-n} @var{num} ] [ @t{-f} @var{flag} ] [ @t{-Nw} ] [ @t{-K} @var{keymap} ] @var{args} ..."
msgstr "@var{widget} [ @t{-n} @var{num} ] [ @t{-f} @var{flag} ] [ @t{-Nw} ] [ @t{-K} @var{keymap} ] @var{args} ..."

#. type: table
#: zsh.texi:16886
msgid "Invoke the specified @var{widget}.  This can only be done when ZLE is active; normally this will be within a user-defined widget."
msgstr "调用指定的 @var{widget}。 只有在 ZLE 处于活动状态时才能调用；通常是在用户自定义的小部件中调用。"

#. type: table
#: zsh.texi:16892
msgid ""
"With the options @t{-n} and @t{-N}, the current numeric argument will be saved and then restored after the call to @var{widget}; `@t{-n} @var{num}' sets the numeric argument temporarily to @var{num}, "
"while `@t{-N}' sets it to the default, i.e. as if there were none."
msgstr "使用选项 @t{-n} 和 @t{-N}，当前数字参数将被保存，并在调用 @var{widget} 后恢复； `@t{-n} @var{num}' 会将数字参数暂时设置为 @var{num}，而  `@t{-N}' 则会将其设置为默认值，即相当于没有 @var{num}。"

#. type: table
#: zsh.texi:16897
msgid "With the option @t{-K}, @var{keymap} will be used as the current keymap during the execution of the widget.  The previous keymap will be restored when the widget exits."
msgstr "如果使用选项 @t{-K}，@var{keymap} 将在小部件执行期间用作当前键映射。 退出小部件后，将恢复之前的键映射。"

#. type: table
#: zsh.texi:16904
msgid ""
"Normally, calling a widget in this way does not set the special parameter @t{WIDGET} and related parameters, so that the environment appears as if the top-level widget called by the user were still "
"active.  With the option @t{-w}, @t{WIDGET} and related parameters are set to reflect the widget being executed by the @t{zle} call."
msgstr ""
"通常情况下，以这种方式调用小部件不会设置特殊参数 @t{WIDGET} 和相关参数，因此环境看起来就好像用户调用的顶层小部件仍然处于活动状态。 使用 @t{-w} 选项后，@t{WIDGET} 和相关参数将被设置为反映 @t{zle} 调用正在执"
"行的小部件。"

#. type: table
#: zsh.texi:16908
msgid "Normally, when @var{widget} returns the special parameter @t{LASTWIDGET} will point to it.  This can be inhibited by passing the option @t{-f nolast}."
msgstr "通常，当 @var{widget} 返回时，特殊参数 @t{LASTWIDGET} 将指向它。 可以通过选项 @t{-f nolast} 来抑制这种情况。"

#. type: table
#: zsh.texi:16920
msgid ""
"Any further arguments will be passed to the widget; note that as standard argument handling is performed, any general argument list should be preceded by @t{-}@t{-}.  If it is a shell function, these are "
"passed down as positional parameters; for builtin widgets it is up to the widget in question what it does with them.  Currently arguments are only handled by the incremental-search commands, the "
"@t{history-search-forward} and @t{-backward} and the corresponding functions prefixed by @t{vi-}, and by @t{universal-argument}.  No error is flagged if the command does not use the arguments, or only "
"uses some of them."
msgstr ""
"任何进一步的参数都将传递给小部件；注意，由于执行的是标准参数处理，任何一般参数列表都应在前面加上 @t{-}@t{-}。 如果是 shell 函数，这些参数将作为位置参数传递下去；对于内置小部件，则由相关小部件自行决定如何处"
"理这些参数。 目前，只有增量搜索命令，@t{history-search-forward} 和 @t{-backward} 以及 @t{vi-} 前缀的相应函数和 @t{universal-argument} 可以处理参数。 如果命令未使用参数，或仅使用了部分参数，则不会标志错误。"

#. type: table
#: zsh.texi:16925
msgid "The return status reflects the success or failure of the operation carried out by the widget, or if it is a user-defined widget the return status of the shell function."
msgstr "返回状态反映了小部件执行操作的成功或失败，如果是用户定义的小部件，则反映 shell 函数的返回状态。"

#. type: table
#: zsh.texi:16931
msgid ""
"A non-zero return status causes the shell to beep when the widget exits, unless the @t{BEEP} options was unset or the widget was called via the @t{zle} command.  Thus if a user defined widget requires an "
"immediate beep, it should call the @t{beep} widget directly."
msgstr "除非未设置 @t{BEEP} 选项或通过 @t{zle} 命令调用小部件，否则非零返回状态会导致 shell 在小部件退出时发出蜂鸣声。 因此，如果用户定义的小部件需要立即发出蜂鸣声，应直接调用 @t{beep} 小部件。"

#. type: node
#: zsh.texi:16937 zsh.texi:16964 zsh.texi:16966 zsh.texi:17475
#, no-wrap
msgid "User-Defined Widgets"
msgstr "用户定义小部件"

#. type: t{#1}
#: zsh.texi:16941 zsh.texi:21778 zsh.texi:31871 zsh.texi:31872
#, no-wrap
msgid "widgets"
msgstr "小部件"

#. type: Plain text
#: zsh.texi:16946
msgid ""
"All actions in the editor are performed by `widgets'.  A widget's job is simply to perform some small action.  The ZLE commands that key sequences in keymaps are bound to are in fact widgets.  Widgets can "
"be user-defined or built in."
msgstr "编辑器中的所有操作都由`widgets' 执行。 小部件的工作就是执行一些小的操作。 键映射中的键序列所绑定的 ZLE 命令实际上就是小部件。 小部件可以是用户定义的，也可以是内置的。"

#. type: Plain text
#: zsh.texi:16955
msgid ""
"The standard widgets built into ZLE are listed in @ref{Standard Widgets}.  Other built-in widgets can be defined by other modules (see @ref{Zsh Modules}).  Each built-in widget has two names: its normal "
"canonical name, and the same name preceded by a `@t{.}'.  The `@t{.}' name is special: it can't be rebound to a different widget.  This makes the widget available even when its usual name has been "
"redefined."
msgstr ""
"@ref{标准小部件} 中列出了 ZLE 内置的标准小部件。 其他内置部件可由其他模块定义（参见 @ref{Zsh 模块}）。 每个内置小部件都有两个名称：一个是正常的规范名称，另一个是前缀为 `@t{.}' 的名称。 `@t{.}' 名称比较特"
"殊：它不能重新绑定到其他部件上。 这样，即使重新定义了部件的通常名称，该部件仍可使用。"

#. type: Plain text
#: zsh.texi:16962
msgid ""
"User-defined widgets are defined using `@t{zle -N}', and implemented as shell functions.  When the widget is executed, the corresponding shell function is executed, and can perform editing (or other) "
"actions.  It is recommended that user-defined widgets should not have names starting with `@t{.}'."
msgstr "用户自定义的小部件使用 `@t{zle -N}' 定义，并以 shell 函数的形式实现。 当小部件被执行时，相应的 shell 函数也会被执行，并可执行编辑（或其他）操作。 建议用户自定义小部件的名称不要以 `@t{.}' 开头。"

#. type: node
#: zsh.texi:16964 zsh.texi:17475 zsh.texi:17477 zsh.texi:17503 zsh.texi:17652 zsh.texi:18031 zsh.texi:18366 zsh.texi:18422 zsh.texi:18499 zsh.texi:18923 zsh.texi:18972
#, no-wrap
msgid "Standard Widgets"
msgstr "标准小部件"

#. type: cindex
#: zsh.texi:16968
#, no-wrap
msgid "widgets, user-defined"
msgstr "小部件, 用户定义的"

#. type: Plain text
#: zsh.texi:16977
msgid ""
"User-defined widgets, being implemented as shell functions, can execute any normal shell command.  They can also run other widgets (whether built-in or user-defined) using the @t{zle} builtin command. The "
"standard input of the function is redirected from /dev/null to prevent external commands from unintentionally blocking ZLE by reading from the terminal, but @t{read -k} or @t{read -q} can be used to read "
"characters.  Finally, they can examine and edit the ZLE buffer being edited by reading and setting the special parameters described below."
msgstr ""
"用户自定义的小部件作为 shell 函数实现，可以执行任何普通的 shell 命令。 它们还可以使用 @t{zle} 内置命令运行其他小部件（无论是内置的还是用户自定义的）。函数的标准输入是从 /dev/null 重定向的，以防止外部命令通"
"过从终端读取数据而无意中阻塞 ZLE，但 @t{read -k} 或 @t{read -q} 也可用于读取字符。 最后，它们可以通过读取和设置下文所述的特殊参数，检查和编辑正在编辑的 ZLE 缓冲区。"

#. type: cindex
#: zsh.texi:16979
#, no-wrap
msgid "parameters, editor"
msgstr "参数, 编辑器"

#. type: cindex
#: zsh.texi:16980
#, no-wrap
msgid "parameters, zle"
msgstr "参数, zle"

#. type: Plain text
#: zsh.texi:16986
msgid ""
"These special parameters are always available in widget functions, but are not in any way special outside ZLE.  If they have some normal value outside ZLE, that value is temporarily inaccessible, but will "
"return when the widget function exits.  These special parameters in fact have local scope, like parameters created in a function using @t{local}."
msgstr ""
"这些特殊参数在小部件函数中始终可用，但在 ZLE 外部却没有任何特殊性。 如果它们在 ZLE 外部有一些正常值，那么该值暂时无法访问，但在小部件函数退出时会返回。 事实上，这些特殊参数具有本地作用域，就像在函数中使用 "
"@t{local} 创建的参数一样。"

#. type: Plain text
#: zsh.texi:16990
msgid "Inside completion widgets and traps called while ZLE is active, these parameters are available read-only."
msgstr "在 ZLE 处于活动状态时调用的补全小部件和陷阱内，这些参数以只读方式提供。"

#. type: Plain text
#: zsh.texi:16995
msgid "Note that the parameters appear as local to any ZLE widget in which they appear.  Hence if it is desired to override them this needs to be done within a nested function:"
msgstr "请注意，这些参数在任何 ZLE 小部件中都是本地参数。 因此，如果要覆盖这些参数，需要在嵌套函数中进行："

#. type: example
#: zsh.texi:17008
#, no-wrap
msgid ""
"widget-function() @{\n"
"  # $WIDGET here refers to the special variable\n"
"  # that is local inside widget-function\n"
"  () @{\n"
"     # This anonymous nested function allows WIDGET\n"
"     # to be used as a local variable.  The -h\n"
"     # removes the special status of the variable.\n"
"     local -h WIDGET\n"
"  @}\n"
"@}\n"
msgstr ""
"widget-function() @{\n"
"  # $WIDGET here refers to the special variable\n"
"  # that is local inside widget-function\n"
"  () @{\n"
"     # This anonymous nested function allows WIDGET\n"
"     # to be used as a local variable.  The -h\n"
"     # removes the special status of the variable.\n"
"     local -h WIDGET\n"
"  @}\n"
"@}\n"

#. type: vindex
#: zsh.texi:17012
#, no-wrap
msgid "BUFFER"
msgstr "BUFFER"

#. type: item
#: zsh.texi:17013
#, no-wrap
msgid "@t{BUFFER} (scalar)"
msgstr "@t{BUFFER} (scalar)"

#. type: table
#: zsh.texi:17017
msgid "The entire contents of the edit buffer.  If it is written to, the cursor remains at the same offset, unless that would put it outside the buffer."
msgstr "编辑缓冲区的全部内容。 如果被写入，光标将保持在相同的偏移量，除非这样会将光标置于缓冲区之外。"

#. type: vindex
#: zsh.texi:17018
#, no-wrap
msgid "BUFFERLINES"
msgstr "BUFFERLINES"

#. type: item
#: zsh.texi:17019
#, no-wrap
msgid "@t{BUFFERLINES} (integer)"
msgstr "@t{BUFFERLINES} (integer)"

#. type: table
#: zsh.texi:17023
msgid "The number of screen lines needed for the edit buffer currently displayed on screen (i.e. without any changes to the preceding parameters done after the last redisplay); read-only."
msgstr "当前屏幕上显示的编辑缓冲区所需的屏幕行数（即上次重新显示后未对前面的参数进行任何更改）；只读。"

#. type: vindex
#: zsh.texi:17024
#, no-wrap
msgid "CONTEXT"
msgstr "CONTEXT"

#. type: item
#: zsh.texi:17025
#, no-wrap
msgid "@t{CONTEXT} (scalar)"
msgstr "@t{CONTEXT} (scalar)"

#. type: table
#: zsh.texi:17028
msgid "The context in which zle was called to read a line; read-only.  One of the values:"
msgstr "调用 zle 读取一行的上下文；只读。 值之一："

#. type: t{#1}
#: zsh.texi:17031
#, no-wrap
msgid "start"
msgstr "start"

#. type: table
#: zsh.texi:17033
msgid "The start of a command line (at prompt @t{PS1})."
msgstr "命令行的起始位置（提示符 @t{PS1}）。"

#. type: t{#1}
#: zsh.texi:17034
#, no-wrap
msgid "cont"
msgstr "cont"

#. type: table
#: zsh.texi:17036
msgid "A continuation to a command line (at prompt @t{PS2})."
msgstr "命令行的续行（提示符 @t{PS2}）。"

#. type: table
#: zsh.texi:17039
msgid "In a @t{select} loop (at prompt @t{PS3})."
msgstr "在 @t{select} 循环中（提示符 @t{PS3}）。"

#. type: table
#: zsh.texi:17042
msgid "Editing a variable in @t{vared}."
msgstr "编辑 @t{vared} 中的变量。"

#. type: vindex
#: zsh.texi:17045
#, no-wrap
msgid "CURSOR"
msgstr "CURSOR"

#. type: item
#: zsh.texi:17046
#, no-wrap
msgid "@t{CURSOR} (integer)"
msgstr "@t{CURSOR} (integer)"

#. type: table
#: zsh.texi:17051
msgid ""
"The offset of the cursor, within the edit buffer.  This is in the range 0 to @t{$#BUFFER}, and is by definition equal to @t{$#LBUFFER}.  Attempts to move the cursor outside the buffer will result in the "
"cursor being moved to the appropriate end of the buffer."
msgstr "光标在编辑缓冲区内的偏移量。 范围从 0 到 @t{$#BUFFER}，根据定义等于 @t{$#LBUFFER}。 如果试图将光标移出缓冲区，光标将被移至缓冲区的适当末端。"

#. type: vindex
#: zsh.texi:17052
#, no-wrap
msgid "CUTBUFFER"
msgstr "CUTBUFFER"

#. type: item
#: zsh.texi:17053
#, no-wrap
msgid "@t{CUTBUFFER} (scalar)"
msgstr "@t{CUTBUFFER} (scalar)"

#. type: table
#: zsh.texi:17060
msgid ""
"The last item cut using one of the `@t{kill-}' commands; the string which the next yank would insert in the line.  Later entries in the kill ring are in the array @t{killring}.  Note that the command "
"`@t{zle copy-region-as-kill} @var{string}' can be used to set the text of the cut buffer from a shell function and cycle the kill ring in the same way as interactively killing text."
msgstr ""
"使用 `@t{kill-}' 命令之一剪切的最后一个条目；下一次拖拽(yank)将插入该行的字符串。 删除环（kill ring） 中的后续条目位于 @t{killring} 数组中。 请注意，命令 `@t{zle copy-region-as-kill} @var{string}' 命令可用"
"于从 shell 函数中设置剪切缓冲区的文本，并以与交互式删除文本相同的方式循环 kill ring。"

#. type: vindex
#: zsh.texi:17061
#, no-wrap
msgid "HISTNO"
msgstr "HISTNO"

#. type: item
#: zsh.texi:17062
#, no-wrap
msgid "@t{HISTNO} (integer)"
msgstr "@t{HISTNO} (integer)"

#. type: table
#: zsh.texi:17070
msgid ""
"The current history number.  Setting this has the same effect as moving up or down in the history to the corresponding history line.  An attempt to set it is ignored if the line is not stored in the "
"history.  Note this is not the same as the parameter @t{HISTCMD}, which always gives the number of the history line being added to the main shell's history.  @t{HISTNO} refers to the line being retrieved "
"within zle."
msgstr ""
"当前历史记录编号。 设置它与在历史记录中向上或向下移动到相应的历史记录行具有相同的效果。 如果历史记录中没有该行，则设置该参数的尝试将被忽略。 请注意，这与参数 @t{HISTCMD} 并不相同，后者给出的是被添加到主 "
"shell 历史记录中的历史行的编号。 @t{HISTNO} 指的是在 zle 中检索的行。"

#. type: vindex
#: zsh.texi:17071
#, no-wrap
msgid "ISEARCHMATCH_ACTIVE"
msgstr "ISEARCHMATCH_ACTIVE"

#. type: vindex
#: zsh.texi:17072
#, no-wrap
msgid "ISEARCHMATCH_START"
msgstr "ISEARCHMATCH_START"

#. type: vindex
#: zsh.texi:17073
#, no-wrap
msgid "ISEARCHMATCH_END"
msgstr "ISEARCHMATCH_END"

#. type: item
#: zsh.texi:17074
#, no-wrap
msgid "@t{ISEARCHMATCH_ACTIVE} (integer)"
msgstr "@t{ISEARCHMATCH_ACTIVE} (integer)"

#. type: itemx
#: zsh.texi:17075
#, no-wrap
msgid "@t{ISEARCHMATCH_START} (integer)"
msgstr "@t{ISEARCHMATCH_START} (integer)"

#. type: itemx
#: zsh.texi:17076
#, no-wrap
msgid "@t{ISEARCHMATCH_END} (integer)"
msgstr "@t{ISEARCHMATCH_END} (integer)"

#. type: table
#: zsh.texi:17082
msgid ""
"@t{ISEARCHMATCH_ACTIVE} indicates whether a part of the @t{BUFFER} is currently matched by an incremental search pattern. @t{ISEARCHMATCH_START} and @t{ISEARCHMATCH_END} give the location of the matched "
"part and are in the same units as @t{CURSOR}. They are only valid for reading when @t{ISEARCHMATCH_ACTIVE} is non-zero."
msgstr ""
"@t{ISEARCHMATCH_ACTIVE} 表示 @t{BUFFER} 中的某个部分当前是否与增量搜索模式相匹配。@t{ISEARCHMATCH_START} 和 @t{ISEARCHMATCH_END} 显示匹配部分的位置，单位与 @t{CURSOR} 相同。只有当 @t{ISEARCHMATCH_ACTIVE} "
"非零时，读取才有效。"

#. type: table
#: zsh.texi:17085 zsh.texi:17286
msgid "All parameters are read-only."
msgstr "所有参数均为只读参数。"

#. type: vindex
#: zsh.texi:17086
#, no-wrap
msgid "KEYMAP"
msgstr "KEYMAP"

#. type: item
#: zsh.texi:17087
#, no-wrap
msgid "@t{KEYMAP} (scalar)"
msgstr "@t{KEYMAP} (scalar)"

#. type: table
#: zsh.texi:17089
msgid "The name of the currently selected keymap; read-only."
msgstr "当前选中的键映射的名称；只读。"

#. type: vindex
#: zsh.texi:17090
#, no-wrap
msgid "KEYS"
msgstr "KEYS"

#. type: item
#: zsh.texi:17091
#, no-wrap
msgid "@t{KEYS} (scalar)"
msgstr "@t{KEYS} (scalar)"

#. type: table
#: zsh.texi:17093
msgid "The keys typed to invoke this widget, as a literal string; read-only."
msgstr "调用该小部件时键入的字面字符串；只读。"

#. type: vindex
#: zsh.texi:17094
#, no-wrap
msgid "KEYS_QUEUED_COUNT"
msgstr "KEYS_QUEUED_COUNT"

#. type: item
#: zsh.texi:17095
#, no-wrap
msgid "@t{KEYS_QUEUED_COUNT} (integer)"
msgstr "@t{KEYS_QUEUED_COUNT} (integer)"

#. type: table
#: zsh.texi:17099
msgid "The number of bytes pushed back to the input queue and therefore available for reading immediately before any I/O is done; read-only.  See also @t{PENDING}; the two values are distinct."
msgstr "被推送回输入队列的字节数，因此在完成任何 I/O 操作之前可以立即读取；只读。 另请参阅 @t{PENDING}；这两个值是不同的。"

#. type: vindex
#: zsh.texi:17100
#, no-wrap
msgid "killring"
msgstr "killring"

#. type: item
#: zsh.texi:17101
#, no-wrap
msgid "@t{killring} (array)"
msgstr "@t{killring} (array)"

#. type: table
#: zsh.texi:17106
msgid ""
"The array of previously killed items, with the most recently killed first.  This gives the items that would be retrieved by a @t{yank-pop} in the same order.  Note, however, that the most recently killed "
"item is in @t{$CUTBUFFER}; @t{$killring} shows the array of previous entries."
msgstr "之前被删除的条目的数组，最近被删除的条目在前。 @t{yank-pop} 会以相同的顺序取出被删除的条目。 但请注意，最近被删除的条目位于 @t{$CUTBUFFER} 中；@t{$killring} 显示的是之前的条目数组。"

#. type: table
#: zsh.texi:17114
msgid ""
"The default size for the kill ring is eight, however the length may be changed by normal array operations.  Any empty string in the kill ring is ignored by the @t{yank-pop} command, hence the size of the "
"array effectively sets the maximum length of the kill ring, while the number of non-zero strings gives the current length, both as seen by the user at the command line."
msgstr ""
"删除环的默认大小为 8，但可以通过正常的数组操作改变长度。 删除环中的任何空字符串都会被 @t{yank-pop} 命令忽略，因此数组的大小实际上设定了删除环的最大长度，而非零字符串的数量则表示当前的长度，两者都是用户在命"
"令行中看到的长度。"

#. type: vindex
#: zsh.texi:17115
#, no-wrap
msgid "LASTABORTEDSEARCH"
msgstr "LASTABORTEDSEARCH"

#. type: item
#: zsh.texi:17116
#, no-wrap
msgid "@t{LASTABORTEDSEARCH} (scalar)"
msgstr "@t{LASTABORTEDSEARCH} (scalar)"

#. type: table
#: zsh.texi:17119
msgid "The last search string used by an interactive search that was aborted by the user (status 3 returned by the search widget)."
msgstr "用户放弃的交互式搜索所使用的最后一个搜索字符串（搜索小部件返回的状态 3）。"

#. type: vindex
#: zsh.texi:17120
#, no-wrap
msgid "LASTSEARCH"
msgstr "LASTSEARCH"

#. type: item
#: zsh.texi:17121
#, no-wrap
msgid "@t{LASTSEARCH} (scalar)"
msgstr "@t{LASTSEARCH} (scalar)"

#. type: table
#: zsh.texi:17125
msgid "The last search string used by an interactive search; read-only.  This is set even if the search failed (status 0, 1 or 2 returned by the search widget), but not if it was aborted by the user."
msgstr "交互式搜索使用的最后一个搜索字符串；只读。 即使搜索失败（搜索小部件返回的状态为 0、1 或 2）也会设置该字符串，但如果搜索被用户中止，则不会设置该字符串。"

#. type: vindex
#: zsh.texi:17126
#, no-wrap
msgid "LASTWIDGET"
msgstr "LASTWIDGET"

#. type: item
#: zsh.texi:17127
#, no-wrap
msgid "@t{LASTWIDGET} (scalar)"
msgstr "@t{LASTWIDGET} (scalar)"

#. type: table
#: zsh.texi:17129
msgid "The name of the last widget that was executed; read-only."
msgstr "最后执行的小部件的名称；只读。"

#. type: vindex
#: zsh.texi:17130
#, no-wrap
msgid "LBUFFER"
msgstr "LBUFFER"

#. type: item
#: zsh.texi:17131
#, no-wrap
msgid "@t{LBUFFER} (scalar)"
msgstr "@t{LBUFFER} (scalar)"

#. type: table
#: zsh.texi:17135
msgid ""
"The part of the buffer that lies to the left of the cursor position.  If it is assigned to, only that part of the buffer is replaced, and the cursor remains between the new @t{$LBUFFER} and the old "
"@t{$RBUFFER}."
msgstr "位于光标位置左边的缓冲区部分。 如果指定了该部分，则只有该部分缓冲区会被替换，光标将保留在新的 @t{$LBUFFER} 和旧的 @t{$RBUFFER} 之间。"

#. type: vindex
#: zsh.texi:17136
#, no-wrap
msgid "MARK"
msgstr "MARK"

#. type: item
#: zsh.texi:17137
#, no-wrap
msgid "@t{MARK} (integer)"
msgstr "@t{MARK} (integer)"

#. type: table
#: zsh.texi:17142
msgid ""
"Like @t{CURSOR}, but for the mark. With vi-mode operators that wait for a movement command to select a region of text, setting @t{MARK} allows the selection to extend in both directions from the initial "
"cursor position."
msgstr "与 @t{CURSOR}类似，但用于标记。对于等待移动命令来选择文本区域的 vi 模式操作符，设置 @t{MARK} 可以使选择范围从初始光标位置向两个方向扩展。"

#. type: vindex
#: zsh.texi:17143
#, no-wrap
msgid "NUMERIC"
msgstr "NUMERIC"

#. type: item
#: zsh.texi:17144
#, no-wrap
msgid "@t{NUMERIC} (integer)"
msgstr "@t{NUMERIC} (integer)"

#. type: table
#: zsh.texi:17150
msgid ""
"The numeric argument. If no numeric argument was given, this parameter is unset. When this is set inside a widget function, builtin widgets called with the @t{zle} builtin command will use the value "
"assigned. If it is unset inside a widget function, builtin widgets called behave as if no numeric argument was given."
msgstr ""
"数字参数。如果没有给出数字参数，则不设置该参数。在小部件函数中设置该参数后，使用 @t{zle} 内置命令调用的内置小部件将使用指定的数值。如果未在 widget 函数中设置该参数，则调用的内置小部件将视作未给定数字参数。"

#. type: vindex
#: zsh.texi:17151
#, no-wrap
msgid "PENDING"
msgstr "PENDING"

#. type: item
#: zsh.texi:17152
#, no-wrap
msgid "@t{PENDING} (integer)"
msgstr "@t{PENDING} (integer)"

#. type: table
#: zsh.texi:17158
msgid ""
"The number of bytes pending for input, i.e. the number of bytes which have already been typed and can immediately be read. On systems where the shell is not able to get this information, this parameter "
"will always have a value of zero.  Read-only.  See also @t{KEYS_QUEUED_COUNT}; the two values are distinct."
msgstr "等待输入的字节数，即已输入并可立即读取的字节数。在 shell 无法获取此信息的系统中，此参数的值始终为 0。 只读。 另请参见 @t{KEYS_QUEUED_COUNT}；这两个值是不同的。"

#. type: vindex
#: zsh.texi:17159
#, no-wrap
msgid "PREBUFFER"
msgstr "PREBUFFER"

#. type: item
#: zsh.texi:17160
#, no-wrap
msgid "@t{PREBUFFER} (scalar)"
msgstr "@t{PREBUFFER} (scalar)"

#. type: table
#: zsh.texi:17164
msgid "In a multi-line input at the secondary prompt, this read-only parameter contains the contents of the lines before the one the cursor is currently in."
msgstr "在二级提示符下的多行输入中，该只读参数包含光标当前所在行之前各行的内容。"

#. type: vindex
#: zsh.texi:17165
#, no-wrap
msgid "PREDISPLAY"
msgstr "PREDISPLAY"

#. type: item
#: zsh.texi:17166
#, no-wrap
msgid "@t{PREDISPLAY} (scalar)"
msgstr "@t{PREDISPLAY} (scalar)"

#. type: table
#: zsh.texi:17171
msgid ""
"Text to be displayed before the start of the editable text buffer.  This does not have to be a complete line; to display a complete line, a newline must be appended explicitly.  The text is reset on each "
"new invocation (but not recursive invocation) of zle."
msgstr "在可编辑文本缓冲区开始前显示的文本。 这不一定是完整的一行；要显示完整的一行，必须明确添加换行符。 每次调用（但不是递归调用）zle 时，文本都会重置。"

#. type: vindex
#: zsh.texi:17172
#, no-wrap
msgid "POSTDISPLAY"
msgstr "POSTDISPLAY"

#. type: item
#: zsh.texi:17173
#, no-wrap
msgid "@t{POSTDISPLAY} (scalar)"
msgstr "@t{POSTDISPLAY} (scalar)"

#. type: table
#: zsh.texi:17178
msgid ""
"Text to be displayed after the end of the editable text buffer.  This does not have to be a complete line; to display a complete line, a newline must be prepended explicitly.  The text is reset on each "
"new invocation (but not recursive invocation) of zle."
msgstr "在可编辑文本缓冲区结束后显示的文本。 这不一定是一行完整的文字；要显示一行完整的文字，必须明确预置换行符。 每次调用（但不是递归调用）zle 时，文本都会重置。"

#. type: vindex
#: zsh.texi:17179
#, no-wrap
msgid "RBUFFER"
msgstr "RBUFFER"

#. type: item
#: zsh.texi:17180
#, no-wrap
msgid "@t{RBUFFER} (scalar)"
msgstr "@t{RBUFFER} (scalar)"

#. type: table
#: zsh.texi:17184
msgid ""
"The part of the buffer that lies to the right of the cursor position.  If it is assigned to, only that part of the buffer is replaced, and the cursor remains between the old @t{$LBUFFER} and the new "
"@t{$RBUFFER}."
msgstr "位于光标位置右侧的缓冲区部分。 如果赋值给该部分，则只有这部分缓冲区会被替换，光标将保留在旧的 @t{$LBUFFER} 和新的 @t{$RBUFFER} 之间。"

#. type: vindex
#: zsh.texi:17185
#, no-wrap
msgid "REGION_ACTIVE"
msgstr "REGION_ACTIVE"

#. type: item
#: zsh.texi:17186
#, no-wrap
msgid "@t{REGION_ACTIVE} (integer)"
msgstr "@t{REGION_ACTIVE} (integer)"

#. type: table
#: zsh.texi:17192
msgid ""
"Indicates if the region is currently active.  It can be assigned 0 or 1 to deactivate and activate the region respectively. A value of 2 activates the region in line-wise mode with the highlighted text "
"extending for whole lines only; see @ref{Character Highlighting}."
msgstr "指示区域当前是否处于激活状态。 可以赋值 0 或 1 以分别停用和激活该区域。如果值为 2，则该区域将以整行模式激活，高亮显示的文本仅延伸至整行；请参阅 @ref{字符高亮}。"

#. type: vindex
#: zsh.texi:17193
#, no-wrap
msgid "region_highlight"
msgstr "region_highlight"

#. type: item
#: zsh.texi:17194
#, no-wrap
msgid "@t{region_highlight} (array)"
msgstr "@t{region_highlight} (array)"

#. type: table
#: zsh.texi:17201
msgid ""
"Each element of this array may be set to a string that describes highlighting for an arbitrary region of the command line that will take effect the next time the command line is redisplayed.  Highlighting "
"of the non-editable parts of the command line in @t{PREDISPLAY} and @t{POSTDISPLAY} are possible, but note that the @t{P} flag is needed for character indexing to include @t{PREDISPLAY}."
msgstr ""
"该数组的每个元素都可以设置为一个字符串，用于描述命令行任意区域的高亮效果，该效果将在下一次重新显示命令行时生效。 可以在 @t{PREDISPLAY} 和 @t{POSTDISPLAY} 中突出显示命令行中不可编辑的部分，但要注意，字符索"
"引需要使用 @t{P} 标志才能包含 @t{PREDISPLAY}。"

#. type: table
#: zsh.texi:17204
msgid "Each string consists of the following whitespace-separated parts:"
msgstr "每个字符串由以下以空白分隔的部分组成："

#. type: itemize
#: zsh.texi:17213
msgid ""
"Optionally, a `@t{P}' to signify that the start and end offset that follow include any string set by the @t{PREDISPLAY} special parameter; this is needed if the predisplay string itself is to be "
"highlighted.  Whitespace between the `@t{P}' and the start offset is optional."
msgstr "可选择使用 `@t{P}' ，表示后面的起始偏移和结束偏移包括 @t{PREDISPLAY} 特殊参数设置的任何字符串；如果要高亮显示预显示字符串本身，则需要这样做。  `@t{P}' 和起始偏移量之间的空格是可选的。"

#. type: itemize
#: zsh.texi:17215
msgid "A start offset in the same units as @t{CURSOR}."
msgstr "与 @t{CURSOR} 单位相同的起始偏移量。"

#. type: itemize
#: zsh.texi:17217
msgid "An end offset in the same units as @t{CURSOR}."
msgstr "与 @t{CURSOR} 单位相同的终点偏移量。"

#. type: itemize
#: zsh.texi:17222
msgid "A highlight specification in the same format as used for contexts in the parameter @t{zle_highlight}, see @ref{Character Highlighting}; for example, @t{standout} or @t{fg=red,bold}."
msgstr "高亮规范，格式与参数 @t{zle_highlight} 中用于上下文的格式相同，参见 @ref{字符高亮}；例如 @t{standout} 或 @t{fg=red,bold}。"

#. type: itemize
#: zsh.texi:17227
msgid ""
"Optionally, a string of the form `@t{memo=}@var{token}'.  The @var{token} consists of everything between the `@t{=}' and the next whitespace, comma, NUL, or the end of the string.  The @var{token} is "
"preserved verbatim but not parsed in any way."
msgstr "可选择使用 `@t{memo=}@var{token}' 形式的字符串。 @var{token} 包含从 `@t{=}' 到下一个空格、逗号、NUL 或字符串结尾之间的所有内容。 @var{token} 将被逐字保留，但不会进行任何解析。"

#. type: itemize
#: zsh.texi:17233
msgid ""
"Plugins may use this to identify array elements they have added: for example, a plugin might set @var{token} to its (the plugin's) name and then use `@t{region_highlight=( $@{region_highlight:#*memo=}"
"@var{token}@t{@} )}' in order to remove array elements it have added."
msgstr ""
"插件可以用它来识别自己添加的数组元素：例如，插件可以将 @var{token} 设置为自己（插件）的名称，然后使用  `@t{region_highlight=( $@{region_highlight:#*memo=}@var{token}@t{@} )}' 来删除自己添加的数组元素。"

#. type: itemize
#: zsh.texi:17238
msgid "(This example uses the `@t{$@{}@var{name}@t{:#}@var{pattern}@t{@}}' array-grepping syntax described in @ref{Parameter Expansion}.)"
msgstr "(本例使用了 @ref{参数扩展}中描述的 `@t{$@{}@var{name}@t{:#}@var{pattern}@t{@}}' 数组-grepping 语法）。"

#. type: example
#: zsh.texi:17246
#, no-wrap
msgid "region_highlight=(\"P0 20 bold memo=foobar\")\n"
msgstr "region_highlight=(\"P0 20 bold memo=foobar\")\n"

#. type: table
#: zsh.texi:17251
msgid "specifies that the first twenty characters of the text including any predisplay string should be highlighted in bold."
msgstr "指定文本的前 20 个字符（包括任何预显示字符串）以粗体高亮显示。"

#. type: table
#: zsh.texi:17255
msgid "Note that the effect of @t{region_highlight} is not saved and disappears as soon as the line is accepted."
msgstr "请注意，@t{region_highlight} 的效果不会保存，一旦接受行，它就会消失。"

#. type: table
#: zsh.texi:17260
msgid "Note that zsh 5.8 and older do not support the `@t{memo=}@var{token}' field and may misparse the third (highlight specification) field when a memo is given."
msgstr "请注意，zsh 5.8 及更早版本不支持 `@t{memo=}@var{token}' 字段，并且在给出备忘录（memo）时可能会误读第三个字段（高亮说明）。"

#. type: table
#: zsh.texi:17266
msgid "The final highlighting on the command line depends on both @t{region_highlight} and @t{zle_highlight}; see @ref{Character Highlighting} for details."
msgstr "命令行上的最终高亮效果取决于 @t{region_highlight} 和 @t{zle_highlight}；详情请参见 @ref{字符高亮}。"

#. type: vindex
#: zsh.texi:17267
#, no-wrap
msgid "registers"
msgstr "registers"

#. type: item
#: zsh.texi:17268
#, no-wrap
msgid "@t{registers} (associative array)"
msgstr "@t{registers} (associative array)"

#. type: table
#: zsh.texi:17272
msgid "The contents of each of the vi register buffers. These are typically set using @t{vi-set-buffer} followed by a delete, change or yank command."
msgstr "每个 vi 寄存器缓冲区的内容。通常使用 @t{vi-set-buffer}，然后使用删除、更改或复制（yank）命令来设置这些内容。"

#. type: vindex
#: zsh.texi:17273
#, no-wrap
msgid "SUFFIX_ACTIVE"
msgstr "SUFFIX_ACTIVE"

#. type: vindex
#: zsh.texi:17274
#, no-wrap
msgid "SUFFIX_START"
msgstr "SUFFIX_START"

#. type: vindex
#: zsh.texi:17275
#, no-wrap
msgid "SUFFIX_END"
msgstr "SUFFIX_END"

#. type: item
#: zsh.texi:17276
#, no-wrap
msgid "@t{SUFFIX_ACTIVE} (integer)"
msgstr "@t{SUFFIX_ACTIVE} (integer)"

#. type: itemx
#: zsh.texi:17277
#, no-wrap
msgid "@t{SUFFIX_START} (integer)"
msgstr "@t{SUFFIX_START} (integer)"

#. type: itemx
#: zsh.texi:17278
#, no-wrap
msgid "@t{SUFFIX_END} (integer)"
msgstr "@t{SUFFIX_END} (integer)"

#. type: table
#: zsh.texi:17283
msgid ""
"@t{SUFFIX_ACTIVE} indicates whether an auto-removable completion suffix is currently active. @t{SUFFIX_START} and @t{SUFFIX_END} give the location of the suffix and are in the same units as @t{CURSOR}. "
"They are only valid for reading when @t{SUFFIX_ACTIVE} is non-zero."
msgstr "@t{SUFFIX_ACTIVE} 表示自动删除的补全后缀当前是否处于激活状态。@t{SUFFIX_START} 和 @t{SUFFIX_END} 表示后缀的位置，单位与 @t{CURSOR} 相同。只有当 @t{SUFFIX_ACTIVE} 非零时，才能读取它们。"

#. type: vindex
#: zsh.texi:17287
#, no-wrap
msgid "UNDO_CHANGE_NO"
msgstr "UNDO_CHANGE_NO"

#. type: item
#: zsh.texi:17288
#, no-wrap
msgid "@t{UNDO_CHANGE_NO} (integer)"
msgstr "@t{UNDO_CHANGE_NO} (integer)"

#. type: table
#: zsh.texi:17292
msgid "A number representing the state of the undo history.  The only use of this is passing as an argument to the @t{undo} widget in order to undo back to the recorded point.  Read-only."
msgstr "代表撤销历史状态的数字。 它的唯一用途是作为参数传递给 @t{undo} 小部件，以撤销到记录的点。 只读。"

#. type: vindex
#: zsh.texi:17293
#, no-wrap
msgid "UNDO_LIMIT_NO"
msgstr "UNDO_LIMIT_NO"

#. type: item
#: zsh.texi:17294
#, no-wrap
msgid "@t{UNDO_LIMIT_NO} (integer)"
msgstr "@t{UNDO_LIMIT_NO} (integer)"

#. type: table
#: zsh.texi:17302
msgid ""
"A number corresponding to an existing change in the undo history; compare @t{UNDO_CHANGE_NO}.  If this is set to a value greater than zero, the @t{undo} command will not allow the line to be undone beyond "
"the given change number.  It is still possible to use `@t{zle undo} @var{change}' in a widget to undo beyond that point; in that case, it will not be possible to undo at all until @t{UNDO_LIMIT_NO} is "
"reduced.  Set to 0 to disable the limit."
msgstr ""
"与撤消历史中现有更改相对应的数字；比较 @t{UNDO_CHANGE_NO}。 如果设置的值大于零，@t{undo} 命令将不允许撤销超出给定更改次数的行。 但仍可以使用 `@t{zle undo} @var{change}' 在小部件中撤销超出该点的操作；在这种"
"情况下，直到 @t{UNDO_LIMIT_NO} 被减少，才会完全无法撤销。 设置为 0 则禁用限制。"

#. type: table
#: zsh.texi:17306
msgid "A typical use of this variable in a widget function is as follows (note the additional function scope is required):"
msgstr "在小部件函数中该变量的典型用法如下（注意需要附加函数作用域）："

#. type: example
#: zsh.texi:17313
#, no-wrap
msgid ""
"() @{\n"
"  local UNDO_LIMIT_NO=$UNDO_CHANGE_NO\n"
"  # Perform some form of recursive edit.\n"
"@}\n"
msgstr ""
"() @{\n"
"  local UNDO_LIMIT_NO=$UNDO_CHANGE_NO\n"
"  # Perform some form of recursive edit.\n"
"@}\n"

#. type: vindex
#: zsh.texi:17315
#, no-wrap
msgid "WIDGET"
msgstr "WIDGET"

#. type: item
#: zsh.texi:17316
#, no-wrap
msgid "@t{WIDGET} (scalar)"
msgstr "@t{WIDGET} (scalar)"

#. type: table
#: zsh.texi:17318
msgid "The name of the widget currently being executed; read-only."
msgstr "当前正在执行的小部件的名称；只读。"

#. type: vindex
#: zsh.texi:17319
#, no-wrap
msgid "WIDGETFUNC"
msgstr "WIDGETFUNC"

#. type: item
#: zsh.texi:17320
#, no-wrap
msgid "@t{WIDGETFUNC} (scalar)"
msgstr "@t{WIDGETFUNC} (scalar)"

#. type: table
#: zsh.texi:17327
msgid ""
"The name of the shell function that implements a widget defined with either @t{zle -N} or @t{zle -C}.  In the former case, this is the second argument to the @t{zle -N} command that defined the widget, or "
"the first argument if there was no second argument.  In the latter case this is the third argument to the @t{zle -C} command that defined the widget.  Read-only."
msgstr ""
"实现用 @t{zle -N} 或 @t{zle -C} 定义的小部件的 shell 函数名称。 在前一种情况下，这是定义小部件的 @t{zle -N} 命令的第二个参数，如果没有第二个参数，则是第一个参数。 在后一种情况下，这是定义小部件的 @t{zle -"
"C} 命令的第三个参数。 只读。"

#. type: vindex
#: zsh.texi:17328
#, no-wrap
msgid "WIDGETSTYLE"
msgstr "WIDGETSTYLE"

#. type: item
#: zsh.texi:17329
#, no-wrap
msgid "@t{WIDGETSTYLE} (scalar)"
msgstr "@t{WIDGETSTYLE} (scalar)"

#. type: table
#: zsh.texi:17334
msgid ""
"Describes the implementation behind the completion widget currently being executed; the second argument that followed @t{zle -C} when the widget was defined.  This is the name of a builtin completion "
"widget.  For widgets defined with @t{zle -N} this is set to the empty string.  Read-only."
msgstr "描述当前正在执行的补全小部件背后的实现；是定义小部件时 @t{zle -C} 后面的第二个参数。 这是内置补全小部件的名称。 对于使用 @t{zle -N} 定义的小部件，该参数将被设置为空字符串。 只读。"

#. type: vindex
#: zsh.texi:17335
#, no-wrap
msgid "YANK_ACTIVE"
msgstr "YANK_ACTIVE"

#. type: vindex
#: zsh.texi:17336
#, no-wrap
msgid "YANK_START"
msgstr "YANK_START"

#. type: vindex
#: zsh.texi:17337
#, no-wrap
msgid "YANK_END"
msgstr "YANK_END"

#. type: item
#: zsh.texi:17338
#, no-wrap
msgid "@t{YANK_ACTIVE} (integer)"
msgstr "@t{YANK_ACTIVE} (integer)"

#. type: itemx
#: zsh.texi:17339
#, no-wrap
msgid "@t{YANK_START} (integer)"
msgstr "@t{YANK_START} (integer)"

#. type: itemx
#: zsh.texi:17340
#, no-wrap
msgid "@t{YANK_END} (integer)"
msgstr "@t{YANK_END} (integer)"

#. type: table
#: zsh.texi:17347
msgid ""
"@t{YANK_ACTIVE} indicates whether text has just been yanked (pasted)  into the buffer.  @t{YANK_START} and @t{YANK_END} give the location of the pasted text and are in the same units as @t{CURSOR}.  They "
"are only valid for reading when @t{YANK_ACTIVE} is non-zero.  They can also be assigned by widgets that insert text in a yank-like fashion, for example wrappers of @t{bracketed-paste}.  See also @t{zle -"
"f}."
msgstr ""
"@t{YANK_ACTIVE} 表示文本是否刚刚被插入（粘贴）到缓冲区。 @t{YANK_START} 和 @t{YANK_END} 表示粘贴文本的位置，单位与 @t{CURSOR} 相同。 只有当 @t{YANK_ACTIVE} 非零时，它们才能读取。 以类似 yank-like 的方式插"
"入文本的小部件（例如 @t{bracketed-paste} 的封装）也可以分配它们。 另请参见 @t{zle -f}。"

#. type: table
#: zsh.texi:17350
msgid "@t{YANK_ACTIVE} is read-only."
msgstr "@t{YANK_ACTIVE} 是只读的。"

#. type: vindex
#: zsh.texi:17351
#, no-wrap
msgid "ZLE_RECURSIVE"
msgstr "ZLE_RECURSIVE"

#. type: item
#: zsh.texi:17352
#, no-wrap
msgid "@t{ZLE_RECURSIVE} (integer)"
msgstr "@t{ZLE_RECURSIVE} (integer)"

#. type: table
#: zsh.texi:17355
msgid "Usually zero, but incremented inside any instance of @t{recursive-edit}.  Hence indicates the current recursion level."
msgstr "通常为零，但在 @t{recursive-edit} 的任何实例中都会递增。 因此，它表示当前的递归级别。"

#. type: table
#: zsh.texi:17358
msgid "@t{ZLE_RECURSIVE} is read-only."
msgstr "@t{ZLE_RECURSIVE} 是只读的。"

#. type: vindex
#: zsh.texi:17359
#, no-wrap
msgid "ZLE_STATE"
msgstr "ZLE_STATE"

#. type: item
#: zsh.texi:17360
#, no-wrap
msgid "@t{ZLE_STATE} (scalar)"
msgstr "@t{ZLE_STATE} (scalar)"

#. type: table
#: zsh.texi:17363
msgid "Contains a set of space-separated words that describe the current @t{zle} state."
msgstr "包含描述当前 @t{zle} 状态的一组以空格分隔的单词。"

#. type: table
#: zsh.texi:17373
msgid ""
"Currently, the states shown are the insert mode as set by the @t{overwrite-mode} or @t{vi-replace} widgets and whether history commands will visit imported entries as controlled by the set-local-history "
"widget.  The string contains `@t{insert}' if characters to be inserted on the command line move existing characters to the right or `@t{overwrite}' if characters to be inserted overwrite existing "
"characters. It contains `@t{localhistory}' if only local history commands will be visited or `@t{globalhistory}' if imported history commands will also be visited."
msgstr ""
"目前，显示的状态是由 @t{overwrite-mode} 或 @t{vi-replace} 小部件设置的插入模式，以及由 set-local-history 小部件控制的历史命令是否会访问已导入的条目。如果要在命令行中插入的字符会将现有字符移到右边，则字符串"
"包含 `@t{insert}' ；如果要插入的字符会覆盖现有字符，则字符串包含 `@t{overwrite}' 。如果只访问本地历史命令，则字符串中包含 `@t{localhistory}' ；如果也访问导入的历史命令，则字符串中包含 "
"`@t{globalhistory}' 。"

#. type: table
#: zsh.texi:17378
msgid "The substrings are sorted in alphabetical order so that if you want to test for two specific substrings in a future-proof way, you can do match by doing:"
msgstr "子字符串按字母顺序排序，因此，如果您想以一种面向未来的方式测试两个特定的子字符串，就可以通过下面进行匹配："

#. type: example
#: zsh.texi:17382
#, no-wrap
msgid "if [[ $ZLE_STATE == *globalhistory*insert* ]]; then ...; fi\n"
msgstr "if [[ $ZLE_STATE == *globalhistory*insert* ]]; then ...; fi\n"

#. type: subsection
#: zsh.texi:17388
#, no-wrap
msgid "Special Widgets"
msgstr "特殊小部件"

#. type: Plain text
#: zsh.texi:17395
msgid "There are a few user-defined widgets which are special to the shell.  If they do not exist, no special action is taken.  The environment provided is identical to that for any other editing widget."
msgstr "有一些用户定义的小部件是 shell 特有的。 如果它们不存在，则不会采取任何特殊行为。 所提供的环境与其他编辑小部件相同。"

#. type: t{#1}
#: zsh.texi:17398 zsh.texi:17399
#, no-wrap
msgid "zle-isearch-exit"
msgstr "zle-isearch-exit"

#. type: table
#: zsh.texi:17403
msgid "Executed at the end of incremental search at the point where the isearch prompt is removed from the display.  See @t{zle-isearch-update} for an example."
msgstr "在增量搜索结束时，即从显示屏上删除 isearch 提示符时执行。 有关示例，请参阅 @t{zle-isearch-update}。"

#. type: t{#1}
#: zsh.texi:17404 zsh.texi:17405
#, no-wrap
msgid "zle-isearch-update"
msgstr "zle-isearch-update"

#. type: table
#: zsh.texi:17409
msgid ""
"Executed within incremental search when the display is about to be redrawn.  Additional output below the incremental search prompt can be generated by using `@t{zle -M}' within the widget.  For example,"
msgstr "当显示屏即将重绘时，在增量搜索中执行。 通过在小部件中使用 `@t{zle -M}' ，可以生成增量搜索提示符下方的附加输出。 例如"

#. type: example
#: zsh.texi:17414
#, no-wrap
msgid ""
"zle-isearch-update() @{ zle -M \"Line $HISTNO\"; @}\n"
"zle -N zle-isearch-update\n"
msgstr ""
"zle-isearch-update() @{ zle -M \"Line $HISTNO\"; @}\n"
"zle -N zle-isearch-update\n"

#. type: table
#: zsh.texi:17420
msgid "Note the line output by `@t{zle -M}' is not deleted on exit from incremental search.  This can be done from a @t{zle-isearch-exit} widget:"
msgstr "请注意，在退出增量搜索时， `@t{zle -M}' 输出的行不会被删除。 这可以通过 @t{zle-isearch-exit} 小部件来完成："

#. type: example
#: zsh.texi:17425
#, no-wrap
msgid ""
"zle-isearch-exit() @{ zle -M \"\"; @}\n"
"zle -N zle-isearch-exit\n"
msgstr ""
"zle-isearch-exit() @{ zle -M \"\"; @}\n"
"zle -N zle-isearch-exit\n"

#. type: t{#1}
#: zsh.texi:17427 zsh.texi:17428
#, no-wrap
msgid "zle-line-pre-redraw"
msgstr "zle-line-pre-redraw"

#. type: table
#: zsh.texi:17431
msgid "Executed whenever the input line is about to be redrawn, providing an opportunity to update the region_highlight array."
msgstr "每当输入行即将重绘时执行，为更新 region_highlight 数组提供机会。"

#. type: t{#1}
#: zsh.texi:17432 zsh.texi:17433
#, no-wrap
msgid "zle-line-init"
msgstr "zle-line-init"

#. type: table
#: zsh.texi:17437
msgid "Executed every time the line editor is started to read a new line of input.  The following example puts the line editor into vi command mode when it starts up."
msgstr "每次启动行编辑器读取新的输入行时执行。 下面的示例会在行编辑器启动时使其进入 vi 命令模式。"

#. type: example
#: zsh.texi:17442
#, no-wrap
msgid ""
"zle-line-init() @{ zle -K vicmd; @}\n"
"zle -N zle-line-init\n"
msgstr ""
"zle-line-init() @{ zle -K vicmd; @}\n"
"zle -N zle-line-init\n"

#. type: table
#: zsh.texi:17447
msgid "(The command inside the function sets the keymap directly; it is equivalent to @t{zle vi-cmd-mode}.)"
msgstr "(函数内部的命令直接设置键映射；相当于 @t{zle vi-cmd-mode}）。"

#. type: t{#1}
#: zsh.texi:17448 zsh.texi:17449
#, no-wrap
msgid "zle-line-finish"
msgstr "zle-line-finish"

#. type: table
#: zsh.texi:17452
msgid "This is similar to @t{zle-line-init} but is executed every time the line editor has finished reading a line of input."
msgstr "与 @t{zle-line-init}类似，但每次行编辑器读完一行输入时都会执行。"

#. type: t{#1}
#: zsh.texi:17453 zsh.texi:17454
#, no-wrap
msgid "zle-history-line-set"
msgstr "zle-history-line-set"

#. type: table
#: zsh.texi:17456
msgid "Executed when the history line changes."
msgstr "当历史行发生变化时执行。"

#. type: t{#1}
#: zsh.texi:17457 zsh.texi:17458
#, no-wrap
msgid "zle-keymap-select"
msgstr "zle-keymap-select"

#. type: table
#: zsh.texi:17463
msgid ""
"Executed every time the keymap changes, i.e. the special parameter @t{KEYMAP} is set to a different value, while the line editor is active.  Initialising the keymap when the line editor starts does not "
"cause the widget to be called."
msgstr "每当键映射发生变化，即特殊参数 @t{KEYMAP} 被设置为不同值时，且行编辑器活动时，都会执行调用。 行编辑器启动时初始化键映射不会导致小部件被调用。"

#. type: table
#: zsh.texi:17467
msgid "The value @t{$KEYMAP} within the function reflects the new keymap.  The old keymap is passed as the sole argument."
msgstr "函数中的 @t{$KEYMAP} 值反映了新的键映射。 旧的键映射作为唯一参数传递。"

#. type: table
#: zsh.texi:17471
msgid "This can be used for detecting switches between the vi command (@t{vicmd}) and insert (usually @t{main}) keymaps."
msgstr "可用于检测 vi 命令（@t{vicmd}）和插入（通常为 @t{main}）键映射之间的切换。"

#. type: cindex
#: zsh.texi:17479
#, no-wrap
msgid "widgets, standard"
msgstr "小部件, 标准"

#. type: Plain text
#: zsh.texi:17484
msgid "The following is a list of all the standard widgets, and their default bindings in emacs mode, vi command mode and vi insert mode (the `@t{emacs}', `@t{vicmd}' and `@t{viins}' keymaps, respectively)."
msgstr "下面列出了所有标准小部件，以及它们在 emacs 模式、vi 命令模式和 vi 插入模式下的默认绑定（分别为`@t{emacs}', `@t{vicmd}'  和 `@t{viins}' 键映射）。"

#. type: Plain text
#: zsh.texi:17494
msgid ""
"Note that cursor keys are bound to movement keys in all three keymaps; the shell assumes that the cursor keys send the key sequences reported by the terminal-handling library (termcap or terminfo).  The "
"key sequences shown in the list are those based on the VT100, common on many modern terminals, but in fact these are not necessarily bound.  In the case of the @t{viins} keymap, the initial escape "
"character of the sequences serves also to return to the @t{vicmd} keymap: whether this happens is determined by the @t{KEYTIMEOUT} parameter, see @ref{Parameters}."
msgstr ""
"请注意，光标键在所有三个键映射中都与移动键绑定；shell 假定光标键发送终端处理库（termcap 或 terminfo）报告的键序。 列表中显示的键序是基于 VT100 的键序，在许多现代终端上都很常见，但实际上这些键序并不一定是绑"
"定的。 在 @t{viins} 键映射中，序列的初始转义字符也用于返回 @t{vicmd} 键盘映射：这是否会发生由 @t{KEYTIMEOUT} 参数决定，参见 @ref{参数}。"

#. type: menuentry
#: zsh.texi:17502
msgid "Movement::"
msgstr "移动::"

#. type: menuentry
#: zsh.texi:17502
msgid "History Control::"
msgstr "历史控制::"

#. type: menuentry
#: zsh.texi:17502
msgid "Modifying Text::"
msgstr "文本修改::"

#. type: menuentry
#: zsh.texi:17502
msgid "Arguments::"
msgstr "参数::"

#. type: menuentry
#: zsh.texi:17502
msgid "Completion::"
msgstr "补全::"

#. type: menuentry
#: zsh.texi:17502
msgid "Miscellaneous::"
msgstr "杂项::"

#. type: subsection
#: zsh.texi:17502 zsh.texi:18499 zsh.texi:18923 zsh.texi:18925
#, no-wrap
msgid "Text Objects"
msgstr "文本对象"

#. type: node
#: zsh.texi:17503 zsh.texi:17505 zsh.texi:17652
#, no-wrap
msgid "Movement"
msgstr "移动"

#. type: node
#: zsh.texi:17503 zsh.texi:17652 zsh.texi:17654 zsh.texi:18031
#, no-wrap
msgid "History Control"
msgstr "历史控制"

#. type: t{#1}
#: zsh.texi:17508 zsh.texi:28333
#, no-wrap
msgid "vi-backward-blank-word"
msgstr "vi-backward-blank-word"

#. type: item
#: zsh.texi:17509
#, no-wrap
msgid "@t{vi-backward-blank-word} (unbound) (@t{B}) (unbound)"
msgstr "@t{vi-backward-blank-word} (unbound) (@t{B}) (unbound)"

#. type: table
#: zsh.texi:17512
msgid "Move backward one word, where a word is defined as a series of non-blank characters."
msgstr "向后移动一个单词，单词的定义是一系列非空白字符。"

#. type: tindex
#: zsh.texi:17513
#, no-wrap
msgid "vi-backward-blank-word-end"
msgstr "vi-backward-blank-word-end"

#. type: item
#: zsh.texi:17514
#, no-wrap
msgid "@t{vi-backward-blank-word-end} (unbound) (@t{gE}) (unbound)"
msgstr "@t{vi-backward-blank-word-end} (unbound) (@t{gE}) (unbound)"

#. type: table
#: zsh.texi:17517
msgid "Move to the end of the previous word, where a word is defined as a series of non-blank characters."
msgstr "移动到上一个单词的末尾，单词的定义是一系列非空白字符。"

#. type: tindex
#: zsh.texi:17518
#, no-wrap
msgid "backward-char"
msgstr "backward-char"

#. type: item
#: zsh.texi:17519
#, no-wrap
msgid "@t{backward-char} (@t{^B ESC-[D}) (unbound) (unbound)"
msgstr "@t{backward-char} (@t{^B ESC-[D}) (unbound) (unbound)"

#. type: table
#: zsh.texi:17521
msgid "Move backward one character."
msgstr "反向移动一个字符"

#. type: tindex
#: zsh.texi:17522
#, no-wrap
msgid "vi-backward-char"
msgstr "vi-backward-char"

#. type: item
#: zsh.texi:17523
#, no-wrap
msgid "@t{vi-backward-char} (unbound) (@t{^H h ^?}) (@t{ESC-[D})"
msgstr "@t{vi-backward-char} (unbound) (@t{^H h ^?}) (@t{ESC-[D})"

#. type: table
#: zsh.texi:17525
msgid "Move backward one character, without changing lines."
msgstr "反向移动一个字符，不改变行"

#. type: tindex
#: zsh.texi:17526
#, no-wrap
msgid "backward-word"
msgstr "backward-word"

#. type: item
#: zsh.texi:17527
#, no-wrap
msgid "@t{backward-word} (@t{ESC-B ESC-b}) (unbound) (unbound)"
msgstr "@t{backward-word} (@t{ESC-B ESC-b}) (unbound) (unbound)"

#. type: table
#: zsh.texi:17529 zsh.texi:17533
msgid "Move to the beginning of the previous word."
msgstr "移动到前一个词的开始。"

#. type: t{#1}
#: zsh.texi:17530 zsh.texi:17531
#, no-wrap
msgid "emacs-backward-word"
msgstr "emacs-backward-word"

#. type: tindex
#: zsh.texi:17534
#, no-wrap
msgid "vi-backward-word"
msgstr "vi-backward-word"

#. type: item
#: zsh.texi:17535
#, no-wrap
msgid "@t{vi-backward-word} (unbound) (@t{b}) (unbound)"
msgstr "@t{vi-backward-word} (unbound) (@t{b}) (unbound)"

#. type: table
#: zsh.texi:17537
msgid "Move to the beginning of the previous word, vi-style."
msgstr "移动到前一个词的开始, vi 风格."

#. type: tindex
#: zsh.texi:17538
#, no-wrap
msgid "vi-backward-word-end"
msgstr "vi-backward-word-end"

#. type: item
#: zsh.texi:17539
#, no-wrap
msgid "@t{vi-backward-word-end} (unbound) (@t{ge}) (unbound)"
msgstr "@t{vi-backward-word-end} (unbound) (@t{ge}) (unbound)"

#. type: table
#: zsh.texi:17541
msgid "Move to the end of the previous word, vi-style."
msgstr "vi-style 方式，移至前一个单词的末尾。"

#. type: tindex
#: zsh.texi:17542
#, no-wrap
msgid "beginning-of-line"
msgstr "beginning-of-line"

#. type: item
#: zsh.texi:17543
#, no-wrap
msgid "@t{beginning-of-line} (@t{^A}) (unbound) (unbound)"
msgstr "@t{beginning-of-line} (@t{^A}) (unbound) (unbound)"

#. type: table
#: zsh.texi:17546
msgid "Move to the beginning of the line.  If already at the beginning of the line, move to the beginning of the previous line, if any."
msgstr "移至行首。 如果已在行首，则移至上一行（如果有）的行首。"

#. type: t{#1}
#: zsh.texi:17547 zsh.texi:17548
#, no-wrap
msgid "vi-beginning-of-line"
msgstr "vi-beginning-of-line"

#. type: table
#: zsh.texi:17550
msgid "Move to the beginning of the line, without changing lines."
msgstr "移动到行首，但不换行。"

#. type: tindex
#: zsh.texi:17551
#, no-wrap
msgid "down-line"
msgstr "down-line"

#. type: item
#: zsh.texi:17552
#, no-wrap
msgid "@t{down-line} (unbound) (unbound) (unbound)"
msgstr "@t{down-line} (unbound) (unbound) (unbound)"

#. type: table
#: zsh.texi:17554
msgid "Move down a line in the buffer."
msgstr "在缓冲区中向下移动一行。"

#. type: tindex
#: zsh.texi:17555
#, no-wrap
msgid "end-of-line"
msgstr "end-of-line"

#. type: item
#: zsh.texi:17556
#, no-wrap
msgid "@t{end-of-line} (@t{^E}) (unbound) (unbound)"
msgstr "@t{end-of-line} (@t{^E}) (unbound) (unbound)"

#. type: table
#: zsh.texi:17559
msgid "Move to the end of the line.  If already at the end of the line, move to the end of the next line, if any."
msgstr "移至行尾。 如果已在行尾，则移至下一行（如果有）的行尾。"

#. type: tindex
#: zsh.texi:17560
#, no-wrap
msgid "vi-end-of-line"
msgstr "vi-end-of-line"

#. type: item
#: zsh.texi:17561
#, no-wrap
msgid "@t{vi-end-of-line} (unbound) (@t{$}) (unbound)"
msgstr "@t{vi-end-of-line} (unbound) (@t{$}) (unbound)"

#. type: table
#: zsh.texi:17565
msgid "Move to the end of the line.  If an argument is given to this command, the cursor will be moved to the end of the line (argument - 1) lines down."
msgstr "移至行尾。 如果该命令有一个参数，光标将被移到该行的末尾（参数 - 1）行。"

#. type: tindex
#: zsh.texi:17566
#, no-wrap
msgid "vi-forward-blank-word"
msgstr "vi-forward-blank-word"

#. type: item
#: zsh.texi:17567
#, no-wrap
msgid "@t{vi-forward-blank-word} (unbound) (@t{W}) (unbound)"
msgstr "@t{vi-forward-blank-word} (unbound) (@t{W}) (unbound)"

#. type: table
#: zsh.texi:17570
msgid "Move forward one word, where a word is defined as a series of non-blank characters."
msgstr "前进一个单词，单词的定义是一系列非空白字符。"

#. type: tindex
#: zsh.texi:17571
#, no-wrap
msgid "vi-forward-blank-word-end"
msgstr "vi-forward-blank-word-end"

#. type: item
#: zsh.texi:17572
#, no-wrap
msgid "@t{vi-forward-blank-word-end} (unbound) (@t{E}) (unbound)"
msgstr "@t{vi-forward-blank-word-end} (unbound) (@t{E}) (unbound)"

#. type: table
#: zsh.texi:17576
msgid "Move to the end of the current word, or, if at the end of the current word, to the end of the next word, where a word is defined as a series of non-blank characters."
msgstr "移动到当前单词的末尾，如果在当前单词的末尾，则移动到下一个单词的末尾，这里单词定义为一系列非空白字符。"

#. type: tindex
#: zsh.texi:17577
#, no-wrap
msgid "forward-char"
msgstr "forward-char"

#. type: item
#: zsh.texi:17578
#, no-wrap
msgid "@t{forward-char} (@t{^F ESC-[C}) (unbound) (unbound)"
msgstr "@t{forward-char} (@t{^F ESC-[C}) (unbound) (unbound)"

#. type: table
#: zsh.texi:17580 zsh.texi:17584
msgid "Move forward one character."
msgstr "向前移动一个字符"

#. type: tindex
#: zsh.texi:17581
#, no-wrap
msgid "vi-forward-char"
msgstr "vi-forward-char"

#. type: item
#: zsh.texi:17582
#, no-wrap
msgid "@t{vi-forward-char} (unbound) (@t{space l}) (@t{ESC-[C})"
msgstr "@t{vi-forward-char} (unbound) (@t{space l}) (@t{ESC-[C})"

#. type: tindex
#: zsh.texi:17585
#, no-wrap
msgid "vi-find-next-char"
msgstr "vi-find-next-char"

#. type: item
#: zsh.texi:17586
#, no-wrap
msgid "@t{vi-find-next-char} (@t{^X^F}) (@t{f}) (unbound)"
msgstr "@t{vi-find-next-char} (@t{^X^F}) (@t{f}) (unbound)"

#. type: table
#: zsh.texi:17589
msgid "Read a character from the keyboard, and move to the next occurrence of it in the line."
msgstr "从键盘上读取一个字符，并移动到该行中出现该字符的下一个位置。"

#. type: tindex
#: zsh.texi:17590
#, no-wrap
msgid "vi-find-next-char-skip"
msgstr "vi-find-next-char-skip"

#. type: item
#: zsh.texi:17591
#, no-wrap
msgid "@t{vi-find-next-char-skip} (unbound) (@t{t}) (unbound)"
msgstr "@t{vi-find-next-char-skip} (unbound) (@t{t}) (unbound)"

#. type: table
#: zsh.texi:17594
msgid "Read a character from the keyboard, and move to the position just before the next occurrence of it in the line."
msgstr "从键盘上读取一个字符，并移动到该行中下一个该字符出现之前的位置。"

#. type: tindex
#: zsh.texi:17595
#, no-wrap
msgid "vi-find-prev-char"
msgstr "vi-find-prev-char"

#. type: item
#: zsh.texi:17596
#, no-wrap
msgid "@t{vi-find-prev-char} (unbound) (@t{F}) (unbound)"
msgstr "@t{vi-find-prev-char} (unbound) (@t{F}) (unbound)"

#. type: table
#: zsh.texi:17599
msgid "Read a character from the keyboard, and move to the previous occurrence of it in the line."
msgstr "从键盘上读取一个字符，并移动到该行中出现该字符的前一个位置。"

#. type: tindex
#: zsh.texi:17600
#, no-wrap
msgid "vi-find-prev-char-skip"
msgstr "vi-find-prev-char-skip"

#. type: item
#: zsh.texi:17601
#, no-wrap
msgid "@t{vi-find-prev-char-skip} (unbound) (@t{T}) (unbound)"
msgstr "@t{vi-find-prev-char-skip} (unbound) (@t{T}) (unbound)"

#. type: table
#: zsh.texi:17604
msgid "Read a character from the keyboard, and move to the position just after the previous occurrence of it in the line."
msgstr "从键盘上读取一个字符，并移动到该行中前一个该字符之后的位置。"

#. type: tindex
#: zsh.texi:17605
#, no-wrap
msgid "vi-first-non-blank"
msgstr "vi-first-non-blank"

#. type: item
#: zsh.texi:17606
#, no-wrap
msgid "@t{vi-first-non-blank} (unbound) (@t{^}) (unbound)"
msgstr "@t{vi-first-non-blank} (unbound) (@t{^}) (unbound)"

#. type: table
#: zsh.texi:17608
msgid "Move to the first non-blank character in the line."
msgstr "移动到该行第一个非空白字符。"

#. type: tindex
#: zsh.texi:17609
#, no-wrap
msgid "vi-forward-word"
msgstr "vi-forward-word"

#. type: item
#: zsh.texi:17610
#, no-wrap
msgid "@t{vi-forward-word} (unbound) (@t{w}) (unbound)"
msgstr "@t{vi-forward-word} (unbound) (@t{w}) (unbound)"

#. type: table
#: zsh.texi:17612
msgid "Move forward one word, vi-style."
msgstr "前进一个字，vi-style。"

#. type: tindex
#: zsh.texi:17613
#, no-wrap
msgid "forward-word"
msgstr "forward-word"

#. type: item
#: zsh.texi:17614
#, no-wrap
msgid "@t{forward-word} (@t{ESC-F ESC-f}) (unbound) (unbound)"
msgstr "@t{forward-word} (@t{ESC-F ESC-f}) (unbound) (unbound)"

#. type: table
#: zsh.texi:17618
msgid "Move to the beginning of the next word.  The editor's idea of a word is specified with the @t{WORDCHARS} parameter."
msgstr "移动到下一个单词的开头。 编辑器对单词的概念由 @t{WORDCHARS} 参数指定。"

#. type: t{#1}
#: zsh.texi:17619 zsh.texi:17620
#, no-wrap
msgid "emacs-forward-word"
msgstr "emacs-forward-word"

#. type: table
#: zsh.texi:17622 zsh.texi:17626
msgid "Move to the end of the next word."
msgstr "移动到下一个单词的末尾。"

#. type: tindex
#: zsh.texi:17623
#, no-wrap
msgid "vi-forward-word-end"
msgstr "vi-forward-word-end"

#. type: item
#: zsh.texi:17624
#, no-wrap
msgid "@t{vi-forward-word-end} (unbound) (@t{e}) (unbound)"
msgstr "@t{vi-forward-word-end} (unbound) (@t{e}) (unbound)"

#. type: tindex
#: zsh.texi:17627
#, no-wrap
msgid "vi-goto-column"
msgstr "vi-goto-column"

#. type: item
#: zsh.texi:17628
#, no-wrap
msgid "@t{vi-goto-column} (@t{ESC-|}) (@t{|}) (unbound)"
msgstr "@t{vi-goto-column} (@t{ESC-|}) (@t{|}) (unbound)"

#. type: table
#: zsh.texi:17630
msgid "Move to the column specified by the numeric argument."
msgstr "移动到数字参数指定的列。"

#. type: tindex
#: zsh.texi:17631
#, no-wrap
msgid "vi-goto-mark"
msgstr "vi-goto-mark"

#. type: item
#: zsh.texi:17632
#, no-wrap
msgid "@t{vi-goto-mark} (unbound) (@t{`}) (unbound)"
msgstr "@t{vi-goto-mark} (unbound) (@t{`}) (unbound)"

#. type: table
#: zsh.texi:17634
msgid "Move to the specified mark."
msgstr "移动到指定标记。"

#. type: tindex
#: zsh.texi:17635
#, no-wrap
msgid "vi-goto-mark-line"
msgstr "vi-goto-mark-line"

#. type: item
#: zsh.texi:17636
#, no-wrap
msgid "@t{vi-goto-mark-line} (unbound) (@t{'}) (unbound)"
msgstr "@t{vi-goto-mark-line} (unbound) (@t{'}) (unbound)"

#. type: table
#: zsh.texi:17638
msgid "Move to beginning of the line containing the specified mark."
msgstr "移动到包含指定标记的行的起始位置。"

#. type: tindex
#: zsh.texi:17639
#, no-wrap
msgid "vi-repeat-find"
msgstr "vi-repeat-find"

#. type: item
#: zsh.texi:17640
#, no-wrap
msgid "@t{vi-repeat-find} (unbound) (@t{;}) (unbound)"
msgstr "@t{vi-repeat-find} (unbound) (@t{;}) (unbound)"

#. type: table
#: zsh.texi:17642
msgid "Repeat the last @t{vi-find} command."
msgstr "重复最后一条 @t{vi-find} 命令。"

#. type: tindex
#: zsh.texi:17643
#, no-wrap
msgid "vi-rev-repeat-find"
msgstr "vi-rev-repeat-find"

#. type: item
#: zsh.texi:17644
#, no-wrap
msgid "@t{vi-rev-repeat-find} (unbound) (@t{,}) (unbound)"
msgstr "@t{vi-rev-repeat-find} (unbound) (@t{,}) (unbound)"

#. type: table
#: zsh.texi:17646
msgid "Repeat the last @t{vi-find} command in the opposite direction."
msgstr "朝相反方向重复上一条 @t{vi-find} 命令。"

#. type: tindex
#: zsh.texi:17647
#, no-wrap
msgid "up-line"
msgstr "up-line"

#. type: item
#: zsh.texi:17648
#, no-wrap
msgid "@t{up-line} (unbound) (unbound) (unbound)"
msgstr "@t{up-line} (unbound) (unbound) (unbound)"

#. type: table
#: zsh.texi:17650
msgid "Move up a line in the buffer."
msgstr "在缓冲区中向上移动一行。"

#. type: node
#: zsh.texi:17652 zsh.texi:18031 zsh.texi:18033 zsh.texi:18366
#, no-wrap
msgid "Modifying Text"
msgstr "修改文本"

#. type: tindex
#: zsh.texi:17657
#, no-wrap
msgid "beginning-of-buffer-or-history"
msgstr "beginning-of-buffer-or-history"

#. type: item
#: zsh.texi:17658
#, no-wrap
msgid "@t{beginning-of-buffer-or-history} (@t{ESC-<}) (@t{gg}) (unbound)"
msgstr "@t{beginning-of-buffer-or-history} (@t{ESC-<}) (@t{gg}) (unbound)"

#. type: table
#: zsh.texi:17661
msgid "Move to the beginning of the buffer, or if already there, move to the first event in the history list."
msgstr "移动到缓冲区的起始位置，如果已经在那个位置，则移动到历史列表中的第一个事件。"

#. type: t{#1}
#: zsh.texi:17662 zsh.texi:17663
#, no-wrap
msgid "beginning-of-line-hist"
msgstr "beginning-of-line-hist"

#. type: table
#: zsh.texi:17666
msgid "Move to the beginning of the line.  If already at the beginning of the buffer, move to the previous history line."
msgstr "移至该行开头。 如果已在缓冲区的开头，则移至上一历史行。"

#. type: t{#1}
#: zsh.texi:17667 zsh.texi:17668 zsh.texi:28336
#, no-wrap
msgid "beginning-of-history"
msgstr "beginning-of-history"

#. type: table
#: zsh.texi:17670
msgid "Move to the first event in the history list."
msgstr "移动到历史列表中的第一个事件。"

#. type: tindex
#: zsh.texi:17671
#, no-wrap
msgid "down-line-or-history"
msgstr "down-line-or-history"

#. type: item
#: zsh.texi:17672
#, no-wrap
msgid "@t{down-line-or-history} (@t{^N ESC-[B}) (@t{j}) (@t{ESC-[B})"
msgstr "@t{down-line-or-history} (@t{^N ESC-[B}) (@t{j}) (@t{ESC-[B})"

#. type: table
#: zsh.texi:17675
msgid "Move down a line in the buffer, or if already at the bottom line, move to the next event in the history list."
msgstr "在缓冲区中向下移动一行，如果已在底行，则移动到历史列表中的下一个事件。"

#. type: tindex
#: zsh.texi:17676
#, no-wrap
msgid "vi-down-line-or-history"
msgstr "vi-down-line-or-history"

#. type: item
#: zsh.texi:17677
#, no-wrap
msgid "@t{vi-down-line-or-history} (unbound) (@t{+}) (unbound)"
msgstr "@t{vi-down-line-or-history} (unbound) (@t{+}) (unbound)"

#. type: table
#: zsh.texi:17681
msgid "Move down a line in the buffer, or if already at the bottom line, move to the next event in the history list.  Then move to the first non-blank character on the line."
msgstr "在缓冲区中向下移动一行，如果已在底行，则移动到历史列表中的下一个事件。 然后移动到该行第一个非空白字符处。"

#. type: t{#1}
#: zsh.texi:17682 zsh.texi:17683
#, no-wrap
msgid "down-line-or-search"
msgstr "down-line-or-search"

#. type: table
#: zsh.texi:17687
msgid "Move down a line in the buffer, or if already at the bottom line, search forward in the history for a line beginning with the first word in the buffer."
msgstr "在缓冲区中向下移动一行，如果已在最下面一行，则在历史记录中向前搜索以缓冲区中第一个单词开始的一行。"

#. type: table
#: zsh.texi:17692 zsh.texi:17871 zsh.texi:17905 zsh.texi:17915 zsh.texi:18012
msgid "If called from a function by the @t{zle} command with arguments, the first argument is taken as the string for which to search, rather than the first word in the buffer."
msgstr "如果使用带有参数的 @t{zle} 命令从函数中调用，第一个参数将作为要搜索的字符串，而不是缓冲区中的第一个单词。"

#. type: tindex
#: zsh.texi:17693
#, no-wrap
msgid "down-history"
msgstr "down-history"

#. type: item
#: zsh.texi:17694
#, no-wrap
msgid "@t{down-history} (unbound) (@t{^N}) (unbound)"
msgstr "@t{down-history} (unbound) (@t{^N}) (unbound)"

#. type: table
#: zsh.texi:17696
msgid "Move to the next event in the history list."
msgstr "移动到历史列表中的下一个事件。"

#. type: t{#1}
#: zsh.texi:17697 zsh.texi:17698
#, no-wrap
msgid "history-beginning-search-backward"
msgstr "history-beginning-search-backward"

#. type: table
#: zsh.texi:17702
msgid "Search backward in the history for a line beginning with the current line up to the cursor.  This leaves the cursor in its original position."
msgstr "在历史记录中向后搜索从当前行开始到光标处的一行。 这样光标就会停留在原来的位置。"

#. type: tindex
#: zsh.texi:17703
#, no-wrap
msgid "end-of-buffer-or-history"
msgstr "end-of-buffer-or-history"

#. type: item
#: zsh.texi:17704
#, no-wrap
msgid "@t{end-of-buffer-or-history} (@t{ESC->}) (unbound) (unbound)"
msgstr "@t{end-of-buffer-or-history} (@t{ESC->}) (unbound) (unbound)"

#. type: table
#: zsh.texi:17707
msgid "Move to the end of the buffer, or if already there, move to the last event in the history list."
msgstr "移动到缓冲区的末尾，或者如果已经移动到末尾，则移动到历史列表中的最后一个事件。"

#. type: t{#1}
#: zsh.texi:17708 zsh.texi:17709
#, no-wrap
msgid "end-of-line-hist"
msgstr "end-of-line-hist"

#. type: table
#: zsh.texi:17712
msgid "Move to the end of the line.  If already at the end of the buffer, move to the next history line."
msgstr "移至行尾。 如果已到缓冲区末尾，则移至下一个历史行。"

#. type: t{#1}
#: zsh.texi:17713 zsh.texi:17714 zsh.texi:28339
#, no-wrap
msgid "end-of-history"
msgstr "end-of-history"

#. type: table
#: zsh.texi:17716
msgid "Move to the last event in the history list."
msgstr "移动到历史列表中的最后一个事件。"

#. type: tindex
#: zsh.texi:17717
#, no-wrap
msgid "vi-fetch-history"
msgstr "vi-fetch-history"

#. type: item
#: zsh.texi:17718
#, no-wrap
msgid "@t{vi-fetch-history} (unbound) (@t{G}) (unbound)"
msgstr "@t{vi-fetch-history} (unbound) (@t{G}) (unbound)"

#. type: table
#: zsh.texi:17722
msgid "Fetch the history line specified by the numeric argument.  This defaults to the current history line (i.e. the one that isn't history yet)."
msgstr "获取数字参数指定的历史行。 默认为当前历史行（即尚未成为历史的一行）。"

#. type: t{#1}
#: zsh.texi:17723 zsh.texi:17777 zsh.texi:28368
#, no-wrap
msgid "history-incremental-search-backward"
msgstr "history-incremental-search-backward"

#. type: item
#: zsh.texi:17724
#, no-wrap
msgid "@t{history-incremental-search-backward} (@t{^R ^Xr}) (unbound) (unbound)"
msgstr "@t{history-incremental-search-backward} (@t{^R ^Xr}) (unbound) (unbound)"

#. type: table
#: zsh.texi:17732
msgid ""
"Search backward incrementally for a specified string.  The search is case-insensitive if the search string does not have uppercase letters and no numeric argument was given.  The string may begin with "
"`@t{^}' to anchor the search to the beginning of the line.  When called from a user-defined function returns the following statuses: 0, if the search succeeded; 1, if the search failed; 2, if the search "
"term was a bad pattern; 3, if the search was aborted by the @t{send-break} command."
msgstr ""
"向后递增搜索指定字符串。 如果搜索字符串中没有大写字母，也没有给出数字参数，则搜索不区分大小写。 字符串可以以 `@t{^}' 开头，以便将搜索锚定在行首。 从用户自定义函数调用时，将返回以下状态： 0，如果搜索成功；"
"1，如果搜索失败；2，如果搜索项是错误的模式；3，如果搜索被 @t{send-break} 命令中止。"

#. type: table
#: zsh.texi:17744
msgid ""
"A restricted set of editing functions is available in the mini-buffer.  Keys are looked up in the special @t{isearch} keymap, and if not found there in the main keymap (note that by default the "
"@t{isearch} keymap is empty).  An interrupt signal, as defined by the stty setting, will stop the search and go back to the original line.  An undefined key will have the same effect.  Note that the "
"following always perform the same task within incremental searches and cannot be replaced by user defined widgets, nor can the set of functions be extended.  The supported functions are:"
msgstr ""
"在迷你缓冲区中可以使用一组受限的编辑功能。 键将在特殊的 @t{isearch} 键映射中查找，如果找不到，则在主键映射中查找（注意 @t{isearch} 键映射默认为空）。 由 stty 设置定义的中断信号将停止搜索并返回原始行。 未定"
"义的按键也会产生同样的效果。 请注意，以下功能在增量搜索中始终执行相同的任务，不能由用户定义的小部件代替，也不能扩展函数集。 支持的函数有"

#. type: tindex
#: zsh.texi:17747 zsh.texi:18504
#, no-wrap
msgid "accept-and-hold"
msgstr "accept-and-hold"

#. type: t{#1}
#: zsh.texi:17748 zsh.texi:18509 zsh.texi:18510 zsh.texi:28296
#, no-wrap
msgid "accept-and-infer-next-history"
msgstr "accept-and-infer-next-history"

#. type: tindex
#: zsh.texi:17749 zsh.texi:18515
#, no-wrap
msgid "accept-line"
msgstr "accept-line"

#. type: tindex
#: zsh.texi:17750 zsh.texi:18520
#, no-wrap
msgid "accept-line-and-down-history"
msgstr "accept-line-and-down-history"

#. type: table
#: zsh.texi:17753
msgid "Perform the usual function after exiting incremental search.  The command line displayed is executed."
msgstr "退出增量搜索后执行常规函数。 显示的命令行将被执行。"

#. type: tindex
#: zsh.texi:17754 zsh.texi:18044
#, no-wrap
msgid "backward-delete-char"
msgstr "backward-delete-char"

#. type: tindex
#: zsh.texi:17755 zsh.texi:18048
#, no-wrap
msgid "vi-backward-delete-char"
msgstr "vi-backward-delete-char"

#. type: table
#: zsh.texi:17759
msgid "Back up one place in the search history.  If the search has been repeated this does not immediately erase a character in the minibuffer."
msgstr "备份搜索历史中的一个位置。 如果重复搜索，则不会立即删除迷你缓冲区中的字符。"

#. type: t{#1}
#: zsh.texi:17760 zsh.texi:28169
#, no-wrap
msgid "accept-search"
msgstr "accept-search"

#. type: table
#: zsh.texi:17764
msgid "Exit incremental search, retaining the command line but performing no further action.  Note that this function is not bound by default and has no effect outside incremental search."
msgstr "退出增量搜索，保留命令行但不再执行其他操作。 请注意，该功能默认情况下未绑定，在增量搜索之外没有任何作用。"

#. type: t{#1}
#: zsh.texi:17765 zsh.texi:18054 zsh.texi:18055
#, no-wrap
msgid "backward-delete-word"
msgstr "backward-delete-word"

#. type: tindex
#: zsh.texi:17766 zsh.texi:18062
#, no-wrap
msgid "backward-kill-word"
msgstr "backward-kill-word"

#. type: tindex
#: zsh.texi:17767 zsh.texi:18066
#, no-wrap
msgid "vi-backward-kill-word"
msgstr "vi-backward-kill-word"

#. type: table
#: zsh.texi:17773
msgid ""
"Back up one character in the minibuffer; if multiple searches have been performed since the character was inserted the search history is rewound to the point just before the character was entered.  Hence "
"this has the effect of repeating @t{backward-delete-char}."
msgstr "备份 minibuffer 中的一个字符；如果在插入该字符后进行了多次搜索，则搜索历史将倒退到输入该字符之前的位置。 因此，这具有重复 @t{backward-delete-char} 的效果。"

#. type: tindex
#: zsh.texi:17774 zsh.texi:18584
#, no-wrap
msgid "clear-screen"
msgstr "clear-screen"

#. type: table
#: zsh.texi:17776
msgid "Clear the screen, remaining in incremental search mode."
msgstr "清空屏幕，保持增量搜索模式。"

#. type: table
#: zsh.texi:17781
msgid "Find the next occurrence of the contents of the mini-buffer. If the mini-buffer is empty, the most recent previously used search string is reinstated."
msgstr "查找迷你缓冲区内容的下一次出现。如果迷你缓冲区为空，则恢复最近一次使用的搜索字符串。"

#. type: t{#1}
#: zsh.texi:17782 zsh.texi:17832 zsh.texi:28367
#, no-wrap
msgid "history-incremental-search-forward"
msgstr "history-incremental-search-forward"

#. type: table
#: zsh.texi:17784
msgid "Invert the sense of the search."
msgstr "颠倒搜索的意义。"

#. type: t{#1}
#: zsh.texi:17785 zsh.texi:18472 zsh.texi:18473
#, no-wrap
msgid "magic-space"
msgstr "magic-space"

#. type: table
#: zsh.texi:17787
msgid "Inserts a non-magical space."
msgstr "插入一个非魔法空格。"

#. type: tindex
#: zsh.texi:17788 zsh.texi:18246
#, no-wrap
msgid "quoted-insert"
msgstr "quoted-insert"

#. type: tindex
#: zsh.texi:17789 zsh.texi:18251
#, no-wrap
msgid "vi-quoted-insert"
msgstr "vi-quoted-insert"

#. type: table
#: zsh.texi:17791
msgid "Quote the character to insert into the minibuffer."
msgstr "为要插入 minibuffer 的字符加引号。"

#. type: tindex
#: zsh.texi:17792 zsh.texi:18763
#, no-wrap
msgid "redisplay"
msgstr "redisplay"

#. type: table
#: zsh.texi:17794
msgid "Redisplay the command line, remaining in incremental search mode."
msgstr "重新显示命令行，保持增量搜索模式。"

#. type: tindex
#: zsh.texi:17795 zsh.texi:18573
#, no-wrap
msgid "vi-cmd-mode"
msgstr "vi-cmd-mode"

#. type: table
#: zsh.texi:17798
msgid "Select the `@t{vicmd}' keymap; the `@t{main}' keymap (insert mode) will be selected initially."
msgstr "选择 `@t{vicmd}' 键映射；初始时将选择 `@t{main}' 键映射（插入模式）。"

#. type: table
#: zsh.texi:17802
msgid "In addition, the modifications that were made while in vi insert mode are merged to form a single undo event."
msgstr "此外，在 vi 插入模式下所做的修改会合并成一个撤销事件。"

#. type: tindex
#: zsh.texi:17803 zsh.texi:17983
#, no-wrap
msgid "vi-repeat-search"
msgstr "vi-repeat-search"

#. type: tindex
#: zsh.texi:17804 zsh.texi:17987
#, no-wrap
msgid "vi-rev-repeat-search"
msgstr "vi-rev-repeat-search"

#. type: table
#: zsh.texi:17807
msgid "Repeat the search.  The direction of the search is indicated in the mini-buffer."
msgstr "重复搜索。 迷你缓冲区会显示搜索方向。"

#. type: table
#: zsh.texi:17815
msgid ""
"Any character that is not bound to one of the above functions, or @t{self-insert} or @t{self-insert-unmeta}, will cause the mode to be exited.  The character is then looked up and executed in the keymap "
"in effect at that point."
msgstr "任何未与上述函数、@t{self-insert} 或 @t{self-insert-unmeta}绑定的字符都会导致模式退出。 然后，该字符将在当时有效的键映射中查找并执行。"

#. type: table
#: zsh.texi:17822
msgid ""
"When called from a widget function by the @t{zle} command, the incremental search commands can take a string argument.  This will be treated as a string of keys, as for arguments to the @t{bindkey} "
"command, and used as initial input for the command.  Any characters in the string which are unused by the incremental search will be silently ignored.  For example,"
msgstr ""
"当用 @t{zle} 命令从小部件函数调用时，增量搜索命令可以接受一个字符串参数。 与 @t{bindkey} 命令的参数一样，字符串将被视为键的字符串，并用作命令的初始输入。 字符串中任何未被增量搜索使用的字符都将被忽略。 例如"

#. type: example
#: zsh.texi:17826
#, no-wrap
msgid "zle history-incremental-search-backward forceps\n"
msgstr "zle history-incremental-search-backward forceps\n"

#. type: table
#: zsh.texi:17831
msgid "will search backwards for @t{forceps}, leaving the minibuffer containing the string `@t{forceps}'."
msgstr "将向后搜索 @t{forceps}，留下包含 `@t{forceps}' 字符串的迷你缓冲。"

#. type: item
#: zsh.texi:17833
#, no-wrap
msgid "@t{history-incremental-search-forward} (@t{^S ^Xs}) (unbound) (unbound)"
msgstr "@t{history-incremental-search-forward} (@t{^S ^Xs}) (unbound) (unbound)"

#. type: table
#: zsh.texi:17839
msgid ""
"Search forward incrementally for a specified string.  The search is case-insensitive if the search string does not have uppercase letters and no numeric argument was given.  The string may begin with "
"`@t{^}' to anchor the search to the beginning of the line.  The functions available in the mini-buffer are the same as for @t{history-incremental-search-backward}."
msgstr ""
"向前递增搜索指定字符串。 如果搜索字符串中没有大写字母，也没有给出数字参数，则搜索不区分大小写。 字符串可以以 `@t{^}' 开头，以便将搜索锚定在行首。 迷你缓冲区中可用的函数与 @t{history-incremental-search-"
"backward} 相同。"

#. type: t{#1}
#: zsh.texi:17840 zsh.texi:17842
#, no-wrap
msgid "history-incremental-pattern-search-backward"
msgstr "history-incremental-pattern-search-backward"

#. type: t{#1}
#: zsh.texi:17841 zsh.texi:17843
#, no-wrap
msgid "history-incremental-pattern-search-forward"
msgstr "history-incremental-pattern-search-forward"

#. type: table
#: zsh.texi:17852
msgid ""
"These widgets behave similarly to the corresponding widgets with no @t{-pattern}, but the search string typed by the user is treated as a pattern, respecting the current settings of the various options "
"affecting pattern matching.  See @ref{Filename Generation} for a description of patterns.  If no numeric argument was given lowercase letters in the search string may match uppercase letters in the "
"history.  The string may begin with `@t{^}' to anchor the search to the beginning of the line."
msgstr ""
"这些小部件的行为与不带 @t{-pattern} 的相应小部件类似，但用户输入的搜索字符串会被视为一种模式，并尊重影响模式匹配的各种选项的当前设置。 有关模式的描述，请参阅 @ref{文件名生成}。 如果没有给出数字参数，搜索字"
"符串中的小写字母可能与历史记录中的大写字母匹配。 字符串可以以 `@t{^}' 开头，以便将搜索锚定在行首。"

#. type: table
#: zsh.texi:17856
msgid "The prompt changes to indicate an invalid pattern; this may simply indicate the pattern is not yet complete."
msgstr "提示符改变以指示无效模式；这可能只是表示模式尚未完成。"

#. type: table
#: zsh.texi:17861
msgid "Note that only non-overlapping matches are reported, so an expression with wildcards may return fewer matches on a line than are visible by inspection."
msgstr "请注意，只报告不重叠的匹配结果，因此带有通配符的表达式在一行中返回的匹配结果可能少于通过检查可以看到的结果。"

#. type: tindex
#: zsh.texi:17862
#, no-wrap
msgid "history-search-backward"
msgstr "history-search-backward"

#. type: item
#: zsh.texi:17863
#, no-wrap
msgid "@t{history-search-backward} (@t{ESC-P ESC-p}) (unbound) (unbound)"
msgstr "@t{history-search-backward} (@t{ESC-P ESC-p}) (unbound) (unbound)"

#. type: table
#: zsh.texi:17866
msgid "Search backward in the history for a line beginning with the first word in the buffer."
msgstr "在历史记录中向后搜索以缓冲区中第一个单词开头的行。"

#. type: tindex
#: zsh.texi:17872
#, no-wrap
msgid "vi-history-search-backward"
msgstr "vi-history-search-backward"

#. type: item
#: zsh.texi:17873
#, no-wrap
msgid "@t{vi-history-search-backward} (unbound) (@t{/}) (unbound)"
msgstr "@t{vi-history-search-backward} (unbound) (@t{/}) (unbound)"

#. type: table
#: zsh.texi:17877
msgid "Search backward in the history for a specified string.  The string may begin with `@t{^}' to anchor the search to the beginning of the line."
msgstr "在历史记录中向后搜索指定字符串。 字符串可以以 `@t{^}' 开头，以便搜索锚定到该行的开头。"

#. type: table
#: zsh.texi:17893
msgid ""
"A restricted set of editing functions is available in the mini-buffer.  An interrupt signal, as defined by the stty setting, will stop the search.  The functions available in the mini-buffer are: "
"@t{accept-line}, @t{backward-delete-char}, @t{vi-backward-delete-char}, @t{backward-kill-word}, @t{vi-backward-kill-word}, @t{clear-screen}, @t{redisplay}, @t{quoted-insert} and @t{vi-quoted-insert}."
msgstr ""
"在迷你缓冲区中可以使用一套受限的编辑功能。 由 stty 设置定义的中断信号将停止搜索。 迷你缓冲区中可用的函数有 @t{accept-line}, @t{backward-delete-char}, @t{vi-backward-delete-char}, @t{backward-kill-word}, "
"@t{vi-backward-kill-word}, @t{clear-screen}, @t{redisplay}, @t{quoted-insert} 和 @t{vi-quoted-insert}。"

#. type: table
#: zsh.texi:17900
msgid ""
"@t{vi-cmd-mode} is treated the same as accept-line, and @t{magic-space} is treated as a space.  Any other character that is not bound to self-insert or self-insert-unmeta will beep and be ignored. If the "
"function is called from vi command mode, the bindings of the current insert mode will be used."
msgstr ""
"@t{vi-cmd-mode} 的处理方式与 accept-line 相同，而 @t{magic-space} 则被视为空格。 任何其他未绑定到 self-insert 或 self-insert-unmeta 的字符都会发出哔哔声并被忽略。如果在 vi 命令模式下调用该函数，将使用当前"
"插入模式的绑定。"

#. type: tindex
#: zsh.texi:17906
#, no-wrap
msgid "history-search-forward"
msgstr "history-search-forward"

#. type: item
#: zsh.texi:17907
#, no-wrap
msgid "@t{history-search-forward} (@t{ESC-N ESC-n}) (unbound) (unbound)"
msgstr "@t{history-search-forward} (@t{ESC-N ESC-n}) (unbound) (unbound)"

#. type: table
#: zsh.texi:17910
msgid "Search forward in the history for a line beginning with the first word in the buffer."
msgstr "在历史记录中向前搜索以缓冲区中第一个单词开头的行。"

#. type: tindex
#: zsh.texi:17916
#, no-wrap
msgid "vi-history-search-forward"
msgstr "vi-history-search-forward"

#. type: item
#: zsh.texi:17917
#, no-wrap
msgid "@t{vi-history-search-forward} (unbound) (@t{?}) (unbound)"
msgstr "@t{vi-history-search-forward} (unbound) (@t{?}) (unbound)"

#. type: table
#: zsh.texi:17923
msgid ""
"Search forward in the history for a specified string.  The string may begin with `@t{^}' to anchor the search to the beginning of the line. The functions available in the mini-buffer are the same as for "
"@t{vi-history-search-backward}.  Argument handling is also the same as for that command."
msgstr "在历史记录中向前搜索指定字符串。 字符串可以以 `@t{^}' 开头，以便将搜索锚定到行的开头。迷你缓冲区中可用的函数与 @t{vi-history-search-backward} 相同。 参数处理也与该命令相同。"

#. type: tindex
#: zsh.texi:17924
#, no-wrap
msgid "infer-next-history"
msgstr "infer-next-history"

#. type: item
#: zsh.texi:17925
#, no-wrap
msgid "@t{infer-next-history} (@t{^X^N}) (unbound) (unbound)"
msgstr "@t{infer-next-history} (@t{^X^N}) (unbound) (unbound)"

#. type: table
#: zsh.texi:17928
msgid "Search in the history list for a line matching the current one and fetch the event following it."
msgstr "在历史记录列表中搜索与当前行匹配的行，并获取其后的事件。"

#. type: tindex
#: zsh.texi:17929
#, no-wrap
msgid "insert-last-word"
msgstr "insert-last-word"

#. type: item
#: zsh.texi:17930
#, no-wrap
msgid "@t{insert-last-word} (@t{ESC-_ ESC-.}) (unbound) (unbound)"
msgstr "@t{insert-last-word} (@t{ESC-_ ESC-.}) (unbound) (unbound)"

#. type: table
#: zsh.texi:17939
msgid ""
"Insert the last word from the previous history event at the cursor position.  If a positive numeric argument is given, insert that word from the end of the previous history event.  If the argument is zero "
"or negative insert that word from the left (zero inserts the previous command word).  Repeating this command replaces the word just inserted with the last word from the history event prior to the one just "
"used; numeric arguments can be used in the same way to pick a word from that event."
msgstr ""
"在光标位置插入上一个历史事件的最后一个单词。 如果参数为正数，则从上一个历史事件的末尾插入该字。 如果参数为零或负数，则从左侧插入该字（零插入前一个命令字）。 重复该命令后，刚才插入的单词将替换为历史事件中在"
"刚才使用的单词之前的最后一个单词； 数字参数也可以同样的方式从历史事件中选取一个单词。"

#. type: table
#: zsh.texi:17949
msgid ""
"When called from a shell function invoked from a user-defined widget, the command can take one to three arguments.  The first argument specifies a history offset which applies to successive calls to this "
"widget: if it is -1, the default behaviour is used, while if it is 1, successive calls will move forwards through the history.  The value 0 can be used to indicate that the history line examined by the "
"previous execution of the command will be reexamined.  Note that negative numbers should be preceded by a `@t{-}@t{-}' argument to avoid confusing them with options."
msgstr ""
"从用户定义的小部件调用 shell 函数时，命令可以包含一到三个参数。 第一个参数指定历史偏移量，该偏移量适用于对该小部件的连续调用：如果为-1，则使用默认行为；如果为1，则连续调用将在历史中向前移动。 如果数值为 "
"0，则表示将重新检查上一次执行命令时检查过的历史行。 需要注意的是，负数前面应加上 `@t{-}@t{-}' 参数，以免与选项混淆。"

#. type: table
#: zsh.texi:17955
msgid ""
"If two arguments are given, the second specifies the word on the command line in normal array index notation (as a more natural alternative to the numeric argument).  Hence 1 is the first word, and -1 "
"(the default) is the last word."
msgstr "如果给定两个参数，第二个参数将以普通数组索引符号指定命令行上的字词（作为数字参数更自然的替代）。 因此，1 是第一个字，-1（默认值）是最后一个字。"

#. type: table
#: zsh.texi:17961
msgid ""
"If a third argument is given, its value is ignored, but it is used to signify that the history offset is relative to the current history line, rather than the one remembered after the previous invocations "
"of @t{insert-last-word}."
msgstr "如果给出第三个参数，其值将被忽略，但它用于表示历史偏移量是相对于当前历史行的，而不是之前调用 @t{insert-last-word} 后记住的历史行。"

#. type: table
#: zsh.texi:17964
msgid "For example, the default behaviour of the command corresponds to"
msgstr "例如，该命令的默认行为相当于"

#. type: example
#: zsh.texi:17968
#, no-wrap
msgid "zle insert-last-word -- -1 -1\n"
msgstr "zle insert-last-word -- -1 -1\n"

#. type: table
#: zsh.texi:17972
msgid "while the command"
msgstr "而命令"

#. type: example
#: zsh.texi:17976
#, no-wrap
msgid "zle insert-last-word -- -1 1 -\n"
msgstr "zle insert-last-word -- -1 1 -\n"

#. type: table
#: zsh.texi:17982
msgid "always copies the first word of the line in the history immediately before the line being edited.  This has the side effect that later invocations of the widget will be relative to that line."
msgstr "总是复制紧接着被编辑行之前的历史行的第一个单词。 这样做的副作用是，以后调用小部件时将相对于该行。"

#. type: item
#: zsh.texi:17984
#, no-wrap
msgid "@t{vi-repeat-search} (unbound) (@t{n}) (unbound)"
msgstr "@t{vi-repeat-search} (unbound) (@t{n}) (unbound)"

#. type: table
#: zsh.texi:17986
msgid "Repeat the last vi history search."
msgstr "重复上次的 vi 历史记录搜索。"

#. type: item
#: zsh.texi:17988
#, no-wrap
msgid "@t{vi-rev-repeat-search} (unbound) (@t{N}) (unbound)"
msgstr "@t{vi-rev-repeat-search} (unbound) (@t{N}) (unbound)"

#. type: table
#: zsh.texi:17990
msgid "Repeat the last vi history search, but in reverse."
msgstr "重复上次的 vi 历史记录搜索，但以相反的方向进行。"

#. type: tindex
#: zsh.texi:17991
#, no-wrap
msgid "up-line-or-history"
msgstr "up-line-or-history"

#. type: item
#: zsh.texi:17992
#, no-wrap
msgid "@t{up-line-or-history} (@t{^P ESC-[A}) (@t{k}) (@t{ESC-[A})"
msgstr "@t{up-line-or-history} (@t{^P ESC-[A}) (@t{k}) (@t{ESC-[A})"

#. type: table
#: zsh.texi:17995
msgid "Move up a line in the buffer, or if already at the top line, move to the previous event in the history list."
msgstr "在缓冲区中向上移动一行，或者如果已经在最上面一行，则移动到历史列表中的上一个事件。"

#. type: tindex
#: zsh.texi:17996
#, no-wrap
msgid "vi-up-line-or-history"
msgstr "vi-up-line-or-history"

#. type: item
#: zsh.texi:17997
#, no-wrap
msgid "@t{vi-up-line-or-history} (unbound) (@t{-}) (unbound)"
msgstr "@t{vi-up-line-or-history} (unbound) (@t{-}) (unbound)"

#. type: table
#: zsh.texi:18001
msgid "Move up a line in the buffer, or if already at the top line, move to the previous event in the history list.  Then move to the first non-blank character on the line."
msgstr "在缓冲区中向上移动一行，如果已在顶行，则移动到历史列表中的上一个事件。 然后移动到该行第一个非空白字符处。"

#. type: t{#1}
#: zsh.texi:18002 zsh.texi:18003
#, no-wrap
msgid "up-line-or-search"
msgstr "up-line-or-search"

#. type: table
#: zsh.texi:18007
msgid "Move up a line in the buffer, or if already at the top line, search backward in the history for a line beginning with the first word in the buffer."
msgstr "在缓冲区中向上移动一行，如果已在顶行，则在历史记录中向后搜索以缓冲区中第一个单词开始的一行。"

#. type: tindex
#: zsh.texi:18013
#, no-wrap
msgid "up-history"
msgstr "up-history"

#. type: item
#: zsh.texi:18014
#, no-wrap
msgid "@t{up-history} (unbound) (@t{^P}) (unbound)"
msgstr "@t{up-history} (unbound) (@t{^P}) (unbound)"

#. type: table
#: zsh.texi:18016
msgid "Move to the previous event in the history list."
msgstr "移动到历史列表中的上一个事件。"

#. type: t{#1}
#: zsh.texi:18017 zsh.texi:18018
#, no-wrap
msgid "history-beginning-search-forward"
msgstr "history-beginning-search-forward"

#. type: table
#: zsh.texi:18022
msgid "Search forward in the history for a line beginning with the current line up to the cursor.  This leaves the cursor in its original position."
msgstr "在历史记录中向前搜索从当前行开始到光标处的一行。 光标就会停留在原来的位置。"

#. type: t{#1}
#: zsh.texi:18023 zsh.texi:18024
#, no-wrap
msgid "set-local-history"
msgstr "set-local-history"

#. type: table
#: zsh.texi:18029
msgid ""
"By default, history movement commands visit the imported lines as well as the local lines. This widget lets you toggle this on and off, or set it with the numeric argument. Zero for both local and "
"imported lines and nonzero for only local lines."
msgstr "默认情况下，历史记录移动命令会同时访问导入的行和本地行。这个小部件可以让你切换开关，或者用数字参数设置。如果为零，则本地行和导入行都访问；如果不为零，则只访问本地行。"

#. type: node
#: zsh.texi:18031 zsh.texi:18366 zsh.texi:18368 zsh.texi:18422
#, no-wrap
msgid "Arguments"
msgstr "实参"

#. type: tindex
#: zsh.texi:18036
#, no-wrap
msgid "vi-add-eol"
msgstr "vi-add-eol"

#. type: item
#: zsh.texi:18037
#, no-wrap
msgid "@t{vi-add-eol} (unbound) (@t{A}) (unbound)"
msgstr "@t{vi-add-eol} (unbound) (@t{A}) (unbound)"

#. type: table
#: zsh.texi:18039
msgid "Move to the end of the line and enter insert mode."
msgstr "移至行尾，进入插入模式。"

#. type: tindex
#: zsh.texi:18040
#, no-wrap
msgid "vi-add-next"
msgstr "vi-add-next"

#. type: item
#: zsh.texi:18041
#, no-wrap
msgid "@t{vi-add-next} (unbound) (@t{a}) (unbound)"
msgstr "@t{vi-add-next} (unbound) (@t{a}) (unbound)"

#. type: table
#: zsh.texi:18043
msgid "Enter insert mode after the current cursor position, without changing lines."
msgstr "在当前光标位置后进入插入模式，不换行。"

#. type: item
#: zsh.texi:18045
#, no-wrap
msgid "@t{backward-delete-char} (@t{^H ^?}) (unbound) (unbound)"
msgstr "@t{backward-delete-char} (@t{^H ^?}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18047
msgid "Delete the character behind the cursor."
msgstr "删除光标后面的字符。"

#. type: item
#: zsh.texi:18049
#, no-wrap
msgid "@t{vi-backward-delete-char} (unbound) (@t{X}) (@t{^H})"
msgstr "@t{vi-backward-delete-char} (unbound) (@t{X}) (@t{^H})"

#. type: table
#: zsh.texi:18053
msgid "Delete the character behind the cursor, without changing lines.  If in insert mode, this won't delete past the point where insert mode was last entered."
msgstr "删除光标后面的字符，不换行。 如果在插入模式下，则不会删除上次进入插入模式的位置。"

#. type: table
#: zsh.texi:18057
msgid "Delete the word behind the cursor."
msgstr "删除光标后面的单词。"

#. type: t{#1}
#: zsh.texi:18058 zsh.texi:18059
#, no-wrap
msgid "backward-kill-line"
msgstr "backward-kill-line"

#. type: table
#: zsh.texi:18061
msgid "Kill from the beginning of the line to the cursor position."
msgstr "从行首删除到光标位置。"

#. type: item
#: zsh.texi:18063
#, no-wrap
msgid "@t{backward-kill-word} (@t{^W ESC-^H ESC-^?}) (unbound) (unbound)"
msgstr "@t{backward-kill-word} (@t{^W ESC-^H ESC-^?}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18065
msgid "Kill the word behind the cursor."
msgstr "删除光标后面的字。"

#. type: item
#: zsh.texi:18067
#, no-wrap
msgid "@t{vi-backward-kill-word} (unbound) (unbound) (@t{^W})"
msgstr "@t{vi-backward-kill-word} (unbound) (unbound) (@t{^W})"

#. type: table
#: zsh.texi:18070
msgid "Kill the word behind the cursor, without going past the point where insert mode was last entered."
msgstr "删除光标后面的字，但不越过上次进入插入模式的位置。"

#. type: tindex
#: zsh.texi:18071
#, no-wrap
msgid "capitalize-word"
msgstr "capitalize-word"

#. type: item
#: zsh.texi:18072
#, no-wrap
msgid "@t{capitalize-word} (@t{ESC-C ESC-c}) (unbound) (unbound)"
msgstr "@t{capitalize-word} (@t{ESC-C ESC-c}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18074
msgid "Capitalize the current word and move past it."
msgstr "将当前单词大写，然后移过去。"

#. type: tindex
#: zsh.texi:18075
#, no-wrap
msgid "vi-change"
msgstr "vi-change"

#. type: item
#: zsh.texi:18076
#, no-wrap
msgid "@t{vi-change} (unbound) (@t{c}) (unbound)"
msgstr "@t{vi-change} (unbound) (@t{c}) (unbound)"

#. type: table
#: zsh.texi:18081
msgid "Read a movement command from the keyboard, and kill from the cursor position to the endpoint of the movement.  Then enter insert mode.  If the command is @t{vi-change}, change the current line."
msgstr "从键盘读取移动命令，从光标位置删除到移动终点。 然后进入插入模式。 如果命令是 @t{vi-change}，则更改当前行。"

#. type: table
#: zsh.texi:18087
msgid ""
"For compatibility with vi, if the command is @t{vi-forward-word} or @t{vi-forward-blank-word}, the whitespace after the word is not included. If you prefer the more consistent behaviour with the "
"whitespace included use the following key binding:"
msgstr "为了与 vi 兼容，如果命令为 @t{vi-forward-word} 或 @t{vi-forward-blank-word}，则单词后的空白不包括在内。如果您更喜欢包含空白的一致行为，请使用以下按键绑定："

#. type: example
#: zsh.texi:18091
#, no-wrap
msgid "bindkey -a -s cw dwi\n"
msgstr "bindkey -a -s cw dwi\n"

#. type: tindex
#: zsh.texi:18093
#, no-wrap
msgid "vi-change-eol"
msgstr "vi-change-eol"

#. type: item
#: zsh.texi:18094
#, no-wrap
msgid "@t{vi-change-eol} (unbound) (@t{C}) (unbound)"
msgstr "@t{vi-change-eol} (unbound) (@t{C}) (unbound)"

#. type: table
#: zsh.texi:18096
msgid "Kill to the end of the line and enter insert mode."
msgstr "删除到行尾，进入插入模式。"

#. type: tindex
#: zsh.texi:18097
#, no-wrap
msgid "vi-change-whole-line"
msgstr "vi-change-whole-line"

#. type: item
#: zsh.texi:18098
#, no-wrap
msgid "@t{vi-change-whole-line} (unbound) (@t{S}) (unbound)"
msgstr "@t{vi-change-whole-line} (unbound) (@t{S}) (unbound)"

#. type: table
#: zsh.texi:18100
msgid "Kill the current line and enter insert mode."
msgstr "删除当前行，进入插入模式。"

#. type: tindex
#: zsh.texi:18101
#, no-wrap
msgid "copy-region-as-kill"
msgstr "copy-region-as-kill"

#. type: item
#: zsh.texi:18102
#, no-wrap
msgid "@t{copy-region-as-kill} (@t{ESC-W ESC-w}) (unbound) (unbound)"
msgstr "@t{copy-region-as-kill} (@t{ESC-W ESC-w}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18104
msgid "Copy the area from the cursor to the mark to the kill buffer."
msgstr "将从光标到标记的区域复制到删除缓冲区。"

#. type: table
#: zsh.texi:18110
msgid ""
"If called from a ZLE widget function in the form `@t{zle copy-region-as-kill} @var{string}' then @var{string} will be taken as the text to copy to the kill buffer.  The cursor, the mark and the text on "
"the command line are not used in this case."
msgstr "如果从 ZLE 小部件函数中以 `@t{zle copy-region-as-kill} @var{string}' 的形式调用，则 @var{string} 将作为文本复制到删除缓冲区。 在这种情况下，光标、标记和命令行上的文本将不会被使用。"

#. type: tindex
#: zsh.texi:18111
#, no-wrap
msgid "copy-prev-word"
msgstr "copy-prev-word"

#. type: item
#: zsh.texi:18112
#, no-wrap
msgid "@t{copy-prev-word} (@t{ESC-^_}) (unbound) (unbound)"
msgstr "@t{copy-prev-word} (@t{ESC-^_}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18114
msgid "Duplicate the word to the left of the cursor."
msgstr "复制光标左侧的单词。"

#. type: t{#1}
#: zsh.texi:18115 zsh.texi:18116
#, no-wrap
msgid "copy-prev-shell-word"
msgstr "copy-prev-shell-word"

#. type: table
#: zsh.texi:18120
msgid "Like @t{copy-prev-word}, but the word is found by using shell parsing, whereas @t{copy-prev-word} looks for blanks. This makes a difference when the word is quoted and contains spaces."
msgstr "与 @t{copy-prev-word}类似，但单词是通过 shell 解析找到的，而 @t{copy-prev-word} 则是查找空格。当单词带引号并包含空格时，这一点就会有所不同。"

#. type: tindex
#: zsh.texi:18121
#, no-wrap
msgid "vi-delete"
msgstr "vi-delete"

#. type: item
#: zsh.texi:18122
#, no-wrap
msgid "@t{vi-delete} (unbound) (@t{d}) (unbound)"
msgstr "@t{vi-delete} (unbound) (@t{d}) (unbound)"

#. type: table
#: zsh.texi:18126
msgid "Read a movement command from the keyboard, and kill from the cursor position to the endpoint of the movement.  If the command is @t{vi-delete}, kill the current line."
msgstr "从键盘读取移动命令，并从光标位置到移动终点进行删除。 如果命令是 @t{vi-delete}，则删除当前行。"

#. type: t{#1}
#: zsh.texi:18127 zsh.texi:18128
#, no-wrap
msgid "delete-char"
msgstr "delete-char"

#. type: table
#: zsh.texi:18130
msgid "Delete the character under the cursor."
msgstr "删除光标下的字符。"

#. type: tindex
#: zsh.texi:18131
#, no-wrap
msgid "vi-delete-char"
msgstr "vi-delete-char"

#. type: item
#: zsh.texi:18132
#, no-wrap
msgid "@t{vi-delete-char} (unbound) (@t{x}) (unbound)"
msgstr "@t{vi-delete-char} (unbound) (@t{x}) (unbound)"

#. type: table
#: zsh.texi:18135
msgid "Delete the character under the cursor, without going past the end of the line."
msgstr "删除光标下的字符，但不越过行尾。"

#. type: t{#1}
#: zsh.texi:18136 zsh.texi:18137
#, no-wrap
msgid "delete-word"
msgstr "delete-word"

#. type: table
#: zsh.texi:18139
msgid "Delete the current word."
msgstr "删除当前单词。"

#. type: tindex
#: zsh.texi:18140
#, no-wrap
msgid "down-case-word"
msgstr "down-case-word"

#. type: item
#: zsh.texi:18141
#, no-wrap
msgid "@t{down-case-word} (@t{ESC-L ESC-l}) (unbound) (unbound)"
msgstr "@t{down-case-word} (@t{ESC-L ESC-l}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18143
msgid "Convert the current word to all lowercase and move past it."
msgstr "将当前单词转换为全小写，然后移动过去。"

#. type: tindex
#: zsh.texi:18144
#, no-wrap
msgid "vi-down-case"
msgstr "vi-down-case"

#. type: item
#: zsh.texi:18145
#, no-wrap
msgid "@t{vi-down-case} (unbound) (@t{gu}) (unbound)"
msgstr "@t{vi-down-case} (unbound) (@t{gu}) (unbound)"

#. type: table
#: zsh.texi:18150
msgid ""
"Read a movement command from the keyboard, and convert all characters from the cursor position to the endpoint of the movement to lowercase.  If the movement command is @t{vi-down-case}, swap the case of "
"all characters on the current line."
msgstr "从键盘读取移动命令，并将从光标位置到移动终点的所有字符转换为小写。 如果移动命令是 @t{vi-down-case}，则交换当前行中所有字符的大小写。"

#. type: tindex
#: zsh.texi:18151
#, no-wrap
msgid "kill-word"
msgstr "kill-word"

#. type: item
#: zsh.texi:18152
#, no-wrap
msgid "@t{kill-word} (@t{ESC-D ESC-d}) (unbound) (unbound)"
msgstr "@t{kill-word} (@t{ESC-D ESC-d}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18154
msgid "Kill the current word."
msgstr "删除当前单词。"

#. type: t{#1}
#: zsh.texi:18155 zsh.texi:18156
#, no-wrap
msgid "gosmacs-transpose-chars"
msgstr "gosmacs-transpose-chars"

#. type: table
#: zsh.texi:18158
msgid "Exchange the two characters behind the cursor."
msgstr "交换光标后面的两个字符。"

#. type: tindex
#: zsh.texi:18159
#, no-wrap
msgid "vi-indent"
msgstr "vi-indent"

#. type: item
#: zsh.texi:18160
#, no-wrap
msgid "@t{vi-indent} (unbound) (@t{>}) (unbound)"
msgstr "@t{vi-indent} (unbound) (@t{>}) (unbound)"

#. type: table
#: zsh.texi:18162
msgid "Indent a number of lines."
msgstr "缩进若干行。"

#. type: t{#1}
#: zsh.texi:18163 zsh.texi:28357
#, no-wrap
msgid "vi-insert"
msgstr "vi-insert"

#. type: item
#: zsh.texi:18164
#, no-wrap
msgid "@t{vi-insert} (unbound) (@t{i}) (unbound)"
msgstr "@t{vi-insert} (unbound) (@t{i}) (unbound)"

#. type: table
#: zsh.texi:18166
msgid "Enter insert mode."
msgstr "进入插入模式。"

#. type: tindex
#: zsh.texi:18167
#, no-wrap
msgid "vi-insert-bol"
msgstr "vi-insert-bol"

#. type: item
#: zsh.texi:18168
#, no-wrap
msgid "@t{vi-insert-bol} (unbound) (@t{I}) (unbound)"
msgstr "@t{vi-insert-bol} (unbound) (@t{I}) (unbound)"

#. type: table
#: zsh.texi:18170
msgid "Move to the first non-blank character on the line and enter insert mode."
msgstr "移动到该行第一个非空白字符处，进入插入模式。"

#. type: tindex
#: zsh.texi:18171
#, no-wrap
msgid "vi-join"
msgstr "vi-join"

#. type: item
#: zsh.texi:18172
#, no-wrap
msgid "@t{vi-join} (@t{^X^J}) (@t{J}) (unbound)"
msgstr "@t{vi-join} (@t{^X^J}) (@t{J}) (unbound)"

#. type: table
#: zsh.texi:18174
msgid "Join the current line with the next one."
msgstr "将当前行与下一行连接起来。"

#. type: tindex
#: zsh.texi:18175
#, no-wrap
msgid "kill-line"
msgstr "kill-line"

#. type: item
#: zsh.texi:18176
#, no-wrap
msgid "@t{kill-line} (@t{^K}) (unbound) (unbound)"
msgstr "@t{kill-line} (@t{^K}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18179
msgid "Kill from the cursor to the end of the line.  If already on the end of the line, kill the newline character."
msgstr "删除从光标到行尾的字符。 如果已在行尾，则删除换行符。"

#. type: tindex
#: zsh.texi:18180
#, no-wrap
msgid "vi-kill-line"
msgstr "vi-kill-line"

#. type: item
#: zsh.texi:18181
#, no-wrap
msgid "@t{vi-kill-line} (unbound) (unbound) (@t{^U})"
msgstr "@t{vi-kill-line} (unbound) (unbound) (@t{^U})"

#. type: table
#: zsh.texi:18183
msgid "Kill from the cursor back to wherever insert mode was last entered."
msgstr "从光标处往回删除到上次进入插入模式的位置。"

#. type: tindex
#: zsh.texi:18184
#, no-wrap
msgid "vi-kill-eol"
msgstr "vi-kill-eol"

#. type: item
#: zsh.texi:18185
#, no-wrap
msgid "@t{vi-kill-eol} (unbound) (@t{D}) (unbound)"
msgstr "@t{vi-kill-eol} (unbound) (@t{D}) (unbound)"

#. type: table
#: zsh.texi:18187
msgid "Kill from the cursor to the end of the line."
msgstr "从光标删除到行尾。"

#. type: t{#1}
#: zsh.texi:18188 zsh.texi:18189
#, no-wrap
msgid "kill-region"
msgstr "kill-region"

#. type: table
#: zsh.texi:18191
msgid "Kill from the cursor to the mark."
msgstr "从光标删除到标记。"

#. type: tindex
#: zsh.texi:18192
#, no-wrap
msgid "kill-buffer"
msgstr "kill-buffer"

#. type: item
#: zsh.texi:18193
#, no-wrap
msgid "@t{kill-buffer} (@t{^X^K}) (unbound) (unbound)"
msgstr "@t{kill-buffer} (@t{^X^K}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18195
msgid "Kill the entire buffer."
msgstr "删除整个缓冲区。"

#. type: tindex
#: zsh.texi:18196
#, no-wrap
msgid "kill-whole-line"
msgstr "kill-whole-line"

#. type: item
#: zsh.texi:18197
#, no-wrap
msgid "@t{kill-whole-line} (@t{^U}) (unbound) (unbound)"
msgstr "@t{kill-whole-line} (@t{^U}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18199
msgid "Kill the current line."
msgstr "删除当前行。"

#. type: tindex
#: zsh.texi:18200
#, no-wrap
msgid "vi-match-bracket"
msgstr "vi-match-bracket"

#. type: item
#: zsh.texi:18201
#, no-wrap
msgid "@t{vi-match-bracket} (@t{^X^B}) (@t{%}) (unbound)"
msgstr "@t{vi-match-bracket} (@t{^X^B}) (@t{%}) (unbound)"

#. type: table
#: zsh.texi:18206
msgid ""
"Move to the bracket character (one of @t{@{@}}, @t{()} or @t{[]}) that matches the one under the cursor.  If the cursor is not on a bracket character, move forward without going past the end of the line "
"to find one, and then go to the matching bracket."
msgstr "移动到与光标下的括号相匹配的括号字符（@t{@{@}}、@t{()} 或 @t{[]}之一）。 如果光标不在括号字符上，则在不超过行尾的情况下向前移动，找到一个括号字符，然后移至匹配的括号处。"

#. type: tindex
#: zsh.texi:18207
#, no-wrap
msgid "vi-open-line-above"
msgstr "vi-open-line-above"

#. type: item
#: zsh.texi:18208
#, no-wrap
msgid "@t{vi-open-line-above} (unbound) (@t{O}) (unbound)"
msgstr "@t{vi-open-line-above} (unbound) (@t{O}) (unbound)"

#. type: table
#: zsh.texi:18210
msgid "Open a line above the cursor and enter insert mode."
msgstr "在光标上方打开一行，进入插入模式。"

#. type: tindex
#: zsh.texi:18211
#, no-wrap
msgid "vi-open-line-below"
msgstr "vi-open-line-below"

#. type: item
#: zsh.texi:18212
#, no-wrap
msgid "@t{vi-open-line-below} (unbound) (@t{o}) (unbound)"
msgstr "@t{vi-open-line-below} (unbound) (@t{o}) (unbound)"

#. type: table
#: zsh.texi:18214
msgid "Open a line below the cursor and enter insert mode."
msgstr "在光标下方打开一行，进入插入模式。"

#. type: tindex
#: zsh.texi:18215
#, no-wrap
msgid "vi-oper-swap-case"
msgstr "vi-oper-swap-case"

#. type: item
#: zsh.texi:18216
#, no-wrap
msgid "@t{vi-oper-swap-case} (unbound) (@t{g~}) (unbound)"
msgstr "@t{vi-oper-swap-case} (unbound) (@t{g~}) (unbound)"

#. type: table
#: zsh.texi:18222
msgid ""
"Read a movement command from the keyboard, and swap the case of all characters from the cursor position to the endpoint of the movement.  If the movement command is @t{vi-oper-swap-case}, swap the case of "
"all characters on the current line."
msgstr "从键盘读取移动命令，并交换从光标位置到移动终点的所有字符的大小写。 如果移动命令是 @t{vi-oper-swap-case}，则交换当前行中所有字符的大小写。"

#. type: tindex
#: zsh.texi:18223
#, no-wrap
msgid "overwrite-mode"
msgstr "overwrite-mode"

#. type: item
#: zsh.texi:18224
#, no-wrap
msgid "@t{overwrite-mode} (@t{^X^O}) (unbound) (unbound)"
msgstr "@t{overwrite-mode} (@t{^X^O}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18226
msgid "Toggle between overwrite mode and insert mode."
msgstr "在覆盖模式和插入模式之间切换。"

#. type: tindex
#: zsh.texi:18227
#, no-wrap
msgid "vi-put-before"
msgstr "vi-put-before"

#. type: item
#: zsh.texi:18228
#, no-wrap
msgid "@t{vi-put-before} (unbound) (@t{P}) (unbound)"
msgstr "@t{vi-put-before} (unbound) (@t{P}) (unbound)"

#. type: table
#: zsh.texi:18232
msgid "Insert the contents of the kill buffer before the cursor.  If the kill buffer contains a sequence of lines (as opposed to characters), paste it above the current line."
msgstr "在光标之前插入删除缓冲区的内容。 如果删除缓冲区包含一系列行（而不是字符），则将其粘贴到当前行的上方。"

#. type: tindex
#: zsh.texi:18233
#, no-wrap
msgid "vi-put-after"
msgstr "vi-put-after"

#. type: item
#: zsh.texi:18234
#, no-wrap
msgid "@t{vi-put-after} (unbound) (@t{p}) (unbound)"
msgstr "@t{vi-put-after} (unbound) (@t{p}) (unbound)"

#. type: table
#: zsh.texi:18238
msgid "Insert the contents of the kill buffer after the cursor.  If the kill buffer contains a sequence of lines (as opposed to characters), paste it below the current line."
msgstr "在光标后插入删除缓冲区的内容。 如果删除缓冲区包含一系列行（而不是字符），则将其粘贴到当前行的下方。"

#. type: tindex
#: zsh.texi:18239
#, no-wrap
msgid "put-replace-selection"
msgstr "put-replace-selection"

#. type: item
#: zsh.texi:18240
#, no-wrap
msgid "@t{put-replace-selection} (unbound) (unbound) (unbound)"
msgstr "@t{put-replace-selection} (unbound) (unbound) (unbound)"

#. type: table
#: zsh.texi:18245
msgid ""
"Replace the contents of the current region or selection with the contents of the kill buffer. If the kill buffer contains a sequence of lines (as opposed to characters), the current line will be split by "
"the pasted lines."
msgstr "用删除缓冲区的内容替换当前区域或选区的内容。如果删除缓冲区包含一系列行（而不是字符），则当前行将被粘贴的行分割。"

#. type: item
#: zsh.texi:18247
#, no-wrap
msgid "@t{quoted-insert} (@t{^V}) (unbound) (unbound)"
msgstr "@t{quoted-insert} (@t{^V}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18250
msgid "Insert the next character typed into the buffer literally.  An interrupt character will not be inserted."
msgstr "将输入的下一个字面字符插入缓冲区。 不会插入中断字符。"

#. type: item
#: zsh.texi:18252
#, no-wrap
msgid "@t{vi-quoted-insert} (unbound) (unbound) (@t{^Q ^V})"
msgstr "@t{vi-quoted-insert} (unbound) (unbound) (@t{^Q ^V})"

#. type: table
#: zsh.texi:18256
msgid "Display a `@t{^}' at the cursor position, and insert the next character typed into the buffer literally.  An interrupt character will not be inserted."
msgstr "在光标位置显示 `@t{^}' ，并将输入的下一个字面字符插入缓冲区。 不会插入中断字符。"

#. type: tindex
#: zsh.texi:18257
#, no-wrap
msgid "quote-line"
msgstr "quote-line"

#. type: item
#: zsh.texi:18258
#, no-wrap
msgid "@t{quote-line} (@t{ESC-'}) (unbound) (unbound)"
msgstr "@t{quote-line} (@t{ESC-'}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18262
msgid "Quote the current line; that is, put a `@t{'}' character at the beginning and the end, and convert all `@t{'}' characters to `@t{'\\@value{dsq}}'."
msgstr "为当前行加引号，即在行首和行尾添加一个 `@t{'}' 字符，并将所有 `@t{'}' 字符转换为 `@t{'\\@value{dsq}}'。"

#. type: tindex
#: zsh.texi:18263
#, no-wrap
msgid "quote-region"
msgstr "quote-region"

#. type: item
#: zsh.texi:18264
#, no-wrap
msgid "@t{quote-region} (@t{ESC-\"}) (unbound) (unbound)"
msgstr "@t{quote-region} (@t{ESC-\"}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18266
msgid "Quote the region from the cursor to the mark."
msgstr "为从光标到标记的区域加引号。"

#. type: tindex
#: zsh.texi:18267
#, no-wrap
msgid "vi-replace"
msgstr "vi-replace"

#. type: item
#: zsh.texi:18268
#, no-wrap
msgid "@t{vi-replace} (unbound) (@t{R}) (unbound)"
msgstr "@t{vi-replace} (unbound) (@t{R}) (unbound)"

#. type: table
#: zsh.texi:18270
msgid "Enter overwrite mode."
msgstr "进入覆盖模式。"

#. type: tindex
#: zsh.texi:18271
#, no-wrap
msgid "vi-repeat-change"
msgstr "vi-repeat-change"

#. type: item
#: zsh.texi:18272
#, no-wrap
msgid "@t{vi-repeat-change} (unbound) (@t{.}) (unbound)"
msgstr "@t{vi-repeat-change} (unbound) (@t{.}) (unbound)"

#. type: table
#: zsh.texi:18278
msgid ""
"Repeat the last vi mode text modification.  If a count was used with the modification, it is remembered.  If a count is given to this command, it overrides the remembered count, and is remembered for "
"future uses of this command.  The cut buffer specification is similarly remembered."
msgstr "重复上一次 vi 模式文本修改。 如果修改时使用了计数，该计数将被记住。 如果为该命令指定了计数，则该计数将覆盖已记住的计数，并在以后使用该命令时被记住。 同样，剪切缓冲区规范也会类似的被记住。"

#. type: tindex
#: zsh.texi:18279
#, no-wrap
msgid "vi-replace-chars"
msgstr "vi-replace-chars"

#. type: item
#: zsh.texi:18280
#, no-wrap
msgid "@t{vi-replace-chars} (unbound) (@t{r}) (unbound)"
msgstr "@t{vi-replace-chars} (unbound) (@t{r}) (unbound)"

#. type: table
#: zsh.texi:18283
msgid "Replace the character under the cursor with a character read from the keyboard."
msgstr "用从键盘读取的字符替换光标下的字符。"

#. type: tindex
#: zsh.texi:18284
#, no-wrap
msgid "self-insert"
msgstr "self-insert"

#. type: item
#: zsh.texi:18285
#, no-wrap
msgid "@t{self-insert} (printable characters) (unbound) (printable characters and some control characters)"
msgstr "@t{self-insert} (printable characters) (unbound) (printable characters and some control characters)"

#. type: table
#: zsh.texi:18287
msgid "Insert a character into the buffer at the cursor position."
msgstr "在光标位置向缓冲区中插入一个字符。"

#. type: tindex
#: zsh.texi:18288
#, no-wrap
msgid "self-insert-unmeta"
msgstr "self-insert-unmeta"

#. type: item
#: zsh.texi:18289
#, no-wrap
msgid "@t{self-insert-unmeta} (@t{ESC-^I ESC-^J ESC-^M}) (unbound) (unbound)"
msgstr "@t{self-insert-unmeta} (@t{ESC-^I ESC-^J ESC-^M}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18292
msgid "Insert a character into the buffer after stripping the meta bit and converting ^M to ^J."
msgstr "在去除元位并将 ^M 转换为 ^J 后，将字符插入缓冲区。"

#. type: tindex
#: zsh.texi:18293
#, no-wrap
msgid "vi-substitute"
msgstr "vi-substitute"

#. type: item
#: zsh.texi:18294
#, no-wrap
msgid "@t{vi-substitute} (unbound) (@t{s}) (unbound)"
msgstr "@t{vi-substitute} (unbound) (@t{s}) (unbound)"

#. type: table
#: zsh.texi:18296
msgid "Substitute the next character(s)."
msgstr "替换下一个字符。"

#. type: tindex
#: zsh.texi:18297
#, no-wrap
msgid "vi-swap-case"
msgstr "vi-swap-case"

#. type: item
#: zsh.texi:18298
#, no-wrap
msgid "@t{vi-swap-case} (unbound) (@t{~}) (unbound)"
msgstr "@t{vi-swap-case} (unbound) (@t{~}) (unbound)"

#. type: table
#: zsh.texi:18300
msgid "Swap the case of the character under the cursor and move past it."
msgstr "调换光标下字符的大小写并移动过去。"

#. type: tindex
#: zsh.texi:18301
#, no-wrap
msgid "transpose-chars"
msgstr "transpose-chars"

#. type: item
#: zsh.texi:18302
#, no-wrap
msgid "@t{transpose-chars} (@t{^T}) (unbound) (unbound)"
msgstr "@t{transpose-chars} (@t{^T}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18307
msgid "Exchange the two characters to the left of the cursor if at end of line, else exchange the character under the cursor with the character to the left."
msgstr "如果在行尾，交换光标左侧的两个字符，否则交换光标下的字符和左侧的字符。"

#. type: tindex
#: zsh.texi:18308
#, no-wrap
msgid "transpose-words"
msgstr "transpose-words"

#. type: item
#: zsh.texi:18309
#, no-wrap
msgid "@t{transpose-words} (@t{ESC-T ESC-t}) (unbound) (unbound)"
msgstr "@t{transpose-words} (@t{ESC-T ESC-t}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18311
msgid "Exchange the current word with the one before it."
msgstr "将当前单词与前面的单词交换。"

#. type: table
#: zsh.texi:18317
msgid ""
"With a positive numeric argument @emph{N}, the word around the cursor, or following it if the cursor is between words, is transposed with the preceding @emph{N} words.  The cursor is put at the end of the "
"resulting group of words."
msgstr "如果使用正数参数 @emph{N}，光标周围的字（如果光标位于字与字之间，则光标后面的字）将与前面的 @emph{N} 个字换位。 光标将被置于结果字组的末尾。"

#. type: table
#: zsh.texi:18322
msgid ""
"With a negative numeric argument @emph{-N}, the effect is the same as using a positive argument @emph{N} except that the original cursor position is retained, regardless of how the words are rearranged."
msgstr "如果使用负数参数 @emph{-N}，效果与使用正数参数 @emph{N} 相同，只是无论如何重新排列单词，都会保留原来的光标位置。"

#. type: tindex
#: zsh.texi:18323
#, no-wrap
msgid "vi-unindent"
msgstr "vi-unindent"

#. type: item
#: zsh.texi:18324
#, no-wrap
msgid "@t{vi-unindent} (unbound) (@t{<}) (unbound)"
msgstr "@t{vi-unindent} (unbound) (@t{<}) (unbound)"

#. type: table
#: zsh.texi:18326
msgid "Unindent a number of lines."
msgstr "取消若干行的缩进。"

#. type: tindex
#: zsh.texi:18327
#, no-wrap
msgid "vi-up-case"
msgstr "vi-up-case"

#. type: item
#: zsh.texi:18328
#, no-wrap
msgid "@t{vi-up-case} (unbound) (@t{gU}) (unbound)"
msgstr "@t{vi-up-case} (unbound) (@t{gU}) (unbound)"

#. type: table
#: zsh.texi:18333
msgid ""
"Read a movement command from the keyboard, and convert all characters from the cursor position to the endpoint of the movement to lowercase.  If the movement command is @t{vi-up-case}, swap the case of "
"all characters on the current line."
msgstr "从键盘读取移动命令，并将从光标位置到移动终点的所有字符转换为小写。 如果移动命令是 @t{vi-up-case}，则交换当前行中所有字符的大小写。"

#. type: tindex
#: zsh.texi:18334
#, no-wrap
msgid "up-case-word"
msgstr "up-case-word"

#. type: item
#: zsh.texi:18335
#, no-wrap
msgid "@t{up-case-word} (@t{ESC-U ESC-u}) (unbound) (unbound)"
msgstr "@t{up-case-word} (@t{ESC-U ESC-u}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18337
msgid "Convert the current word to all caps and move past it."
msgstr "将当前单词转换为全大写字母，然后移动过去。"

#. type: tindex
#: zsh.texi:18338
#, no-wrap
msgid "yank"
msgstr "yank"

#. type: item
#: zsh.texi:18339
#, no-wrap
msgid "@t{yank} (@t{^Y}) (unbound) (unbound)"
msgstr "@t{yank} (@t{^Y}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18341
msgid "Insert the contents of the kill buffer at the cursor position."
msgstr "在光标位置插入删除缓冲区的内容。"

#. type: tindex
#: zsh.texi:18342
#, no-wrap
msgid "yank-pop"
msgstr "yank-pop"

#. type: item
#: zsh.texi:18343
#, no-wrap
msgid "@t{yank-pop} (@t{ESC-y}) (unbound) (unbound)"
msgstr "@t{yank-pop} (@t{ESC-y}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18347
msgid "Remove the text just yanked, rotate the kill-ring (the history of previously killed text) and yank the new top.  Only works following @t{yank}, @t{vi-put-before}, @t{vi-put-after} or @t{yank-pop}."
msgstr "删除刚刚复制的文本，旋转删除环（之前删除文本的历史记录），然后复制新的顶部。 仅在 @t{yank}、@t{vi-put-before}、@t{vi-put-after} 或 @t{yank-pop} 之后起作用。"

#. type: tindex
#: zsh.texi:18348
#, no-wrap
msgid "vi-yank"
msgstr "vi-yank"

#. type: item
#: zsh.texi:18349
#, no-wrap
msgid "@t{vi-yank} (unbound) (@t{y}) (unbound)"
msgstr "@t{vi-yank} (unbound) (@t{y}) (unbound)"

#. type: table
#: zsh.texi:18354
msgid "Read a movement command from the keyboard, and copy the region from the cursor position to the endpoint of the movement into the kill buffer.  If the command is @t{vi-yank}, copy the current line."
msgstr "从键盘读取移动命令，并将从光标位置到移动终点的区域复制到删除缓冲区。 如果命令是 @t{vi-yank}，则复制当前行。"

#. type: tindex
#: zsh.texi:18355
#, no-wrap
msgid "vi-yank-whole-line"
msgstr "vi-yank-whole-line"

#. type: item
#: zsh.texi:18356
#, no-wrap
msgid "@t{vi-yank-whole-line} (unbound) (@t{Y}) (unbound)"
msgstr "@t{vi-yank-whole-line} (unbound) (@t{Y}) (unbound)"

#. type: table
#: zsh.texi:18358
msgid "Copy the current line into the kill buffer."
msgstr "将当前行复制到删除缓冲区。"

#. type: t{#1}
#: zsh.texi:18359 zsh.texi:18360
#, no-wrap
msgid "vi-yank-eol"
msgstr "vi-yank-eol"

#. type: table
#: zsh.texi:18364
msgid "Copy the region from the cursor position to the end of the line into the kill buffer.  Arguably, this is what Y should do in vi, but it isn't what it actually does."
msgstr "将从光标位置到行尾的区域复制到删除缓冲区。 可以说，这就是 Y 在 vi 中应该做的事情，但实际上它并没有这么做。"

#. type: tindex
#: zsh.texi:18371
#, no-wrap
msgid "digit-argument"
msgstr "digit-argument"

#. type: item
#: zsh.texi:18372
#, no-wrap
msgid "@t{digit-argument} (@t{ESC-0}..@t{ESC-9}) (@t{1}-@t{9}) (unbound)"
msgstr "@t{digit-argument} (@t{ESC-0}..@t{ESC-9}) (@t{1}-@t{9}) (unbound)"

#. type: table
#: zsh.texi:18376
msgid "Start a new numeric argument, or add to the current one.  See also @t{vi-digit-or-beginning-of-line}.  This only works if bound to a key sequence ending in a decimal digit."
msgstr "开始一个新的数字参数，或添加到当前参数。 另请参阅 @t{vi-digit-or-beginning-of-line}。 只有绑定到以十进制数字结尾的按键序列时才有效。"

#. type: table
#: zsh.texi:18380
msgid "Inside a widget function, a call to this function treats the last key of the key sequence which called the widget as the digit."
msgstr "在小部件函数内部，调用该函数时会将调用小部件的按键序列中的最后一个按键视为数字。"

#. type: tindex
#: zsh.texi:18381
#, no-wrap
msgid "neg-argument"
msgstr "neg-argument"

#. type: item
#: zsh.texi:18382
#, no-wrap
msgid "@t{neg-argument} (@t{ESC-}@t{-}) (unbound) (unbound)"
msgstr "@t{neg-argument} (@t{ESC-}@t{-}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18384
msgid "Changes the sign of the following argument."
msgstr "更改后面参数的符号。"

#. type: t{#1}
#: zsh.texi:18385 zsh.texi:18386
#, no-wrap
msgid "universal-argument"
msgstr "universal-argument"

#. type: table
#: zsh.texi:18394
msgid ""
"Multiply the argument of the next command by 4.  Alternatively, if this command is followed by an integer (positive or negative), use that as the argument for the next command.  Thus digits cannot be "
"repeated using this command.  For example, if this command occurs twice, followed immediately by @t{forward-char}, move forward sixteen spaces; if instead it is followed by @t{-2}, then @t{forward-char}, "
"move backward two spaces."
msgstr ""
"将下一条命令的参数乘以 4。或者，如果该命令后跟一个整数（正数或负数），则将该整数作为下一条命令的参数。 因此，使用这条命令不能重复输入数字。 例如，如果这条命令出现两次，紧接着是 @t{-forward-char}，则向前移"
"动 16 个空格；如果紧接着是 @t{-2}，然后是 @t{-forward-char}，则向后移动 2 个空格。"

#. type: table
#: zsh.texi:18399
msgid "Inside a widget function, if passed an argument, i.e. `@t{zle universal-argument} @var{num}', the numeric argument will be set to @var{num}; this is equivalent to `@t{NUMERIC=}@var{num}'."
msgstr ""
"在小部件函数内部，如果传递一个参数，即 `@t{zle universal-argument} @var{num}'，数字参数将被设置为 @var{num}；这相当于`@t{NUMERIC=}@var{num}。@var{num}'，数字参数将被设置为 @var{num}；这相当于 `@t{NUMERIC=}"
"@var{num}'。"

#. type: t{#1}
#: zsh.texi:18400 zsh.texi:18401
#, no-wrap
msgid "argument-base"
msgstr "argument-base"

#. type: table
#: zsh.texi:18409
msgid ""
"Use the existing numeric argument as a numeric base, which must be in the range 2 to 36 inclusive.  Subsequent use of @t{digit-argument} and @t{universal-argument} will input a new numeric argument in the "
"given base.  The usual hexadecimal convention is used: the letter @t{a} or @t{A} corresponds to 10, and so on.  Arguments in bases requiring digits from 10 upwards are more conveniently input with "
"@t{universal-argument}, since @t{ESC-a} etc. are not usually bound to @t{digit-argument}."
msgstr ""
"使用现有的数字参数作为基数，基数范围必须是 2 至 36（含）。 随后使用 @t{digit-argument} 和 @t{universal-argument} 将以给定的基数输入新的数字参数。 使用的是通常的十六进制约定：字母 @t{a} 或 @t{A} 对应 10，以"
"此类推。 使用 @t{universal-argument} 输入需要 10 位以上数字的基数参数更方便，因为 @t{ESC-a} 等通常不会绑定到 @t{digit-argument}。"

#. type: table
#: zsh.texi:18414
msgid ""
"The function can be used with a command argument inside a user-defined widget.  The following code sets the base to 16 and lets the user input a hexadecimal argument until a key out of the digit range is "
"typed:"
msgstr "该函数可与用户自定义小部件内的命令参数一起使用。 下面的代码将基数设置为 16，并让用户输入十六进制参数，直到键入超出数字范围的按键为止："

#. type: example
#: zsh.texi:18419
#, no-wrap
msgid ""
"zle argument-base 16\n"
"zle universal-argument\n"
msgstr ""
"zle argument-base 16\n"
"zle universal-argument\n"

#. type: node
#: zsh.texi:18422 zsh.texi:18499 zsh.texi:18501 zsh.texi:18923
#, no-wrap
msgid "Miscellaneous"
msgstr "杂项"

#. type: t{#1}
#: zsh.texi:18427 zsh.texi:18428
#, no-wrap
msgid "accept-and-menu-complete"
msgstr "accept-and-menu-complete"

#. type: table
#: zsh.texi:18431
msgid "In a menu completion, insert the current completion into the buffer, and advance to the next possible completion."
msgstr "在菜单补全中，将当前补全插入缓冲区，并前进到下一个可能的补全。"

#. type: t{#1}
#: zsh.texi:18432 zsh.texi:18433
#, no-wrap
msgid "complete-word"
msgstr "complete-word"

#. type: table
#: zsh.texi:18435
msgid "Attempt completion on the current word."
msgstr "尝试补全当前单词。"

#. type: tindex
#: zsh.texi:18436
#, no-wrap
msgid "delete-char-or-list"
msgstr "delete-char-or-list"

#. type: item
#: zsh.texi:18437
#, no-wrap
msgid "@t{delete-char-or-list} (@t{^D}) (unbound) (unbound)"
msgstr "@t{delete-char-or-list} (@t{^D}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18441
msgid "Delete the character under the cursor.  If the cursor is at the end of the line, list possible completions for the current word."
msgstr "删除光标下的字符。 如果光标位于行尾，则列出当前单词可能的补全。"

#. type: t{#1}
#: zsh.texi:18442 zsh.texi:18443
#, no-wrap
msgid "expand-cmd-path"
msgstr "expand-cmd-path"

#. type: table
#: zsh.texi:18445
msgid "Expand the current command to its full pathname."
msgstr "将当前命令扩展为其完整路径名。"

#. type: tindex
#: zsh.texi:18446
#, no-wrap
msgid "expand-or-complete"
msgstr "expand-or-complete"

#. type: item
#: zsh.texi:18447
#, no-wrap
msgid "@t{expand-or-complete} (@t{TAB}) (unbound) (@t{TAB})"
msgstr "@t{expand-or-complete} (@t{TAB}) (unbound) (@t{TAB})"

#. type: table
#: zsh.texi:18451
msgid "Attempt shell expansion on the current word.  If that fails, attempt completion."
msgstr "尝试对当前单词进行 shell 扩展。 如果失败，则尝试补全。"

#. type: t{#1}
#: zsh.texi:18452 zsh.texi:18453
#, no-wrap
msgid "expand-or-complete-prefix"
msgstr "expand-or-complete-prefix"

#. type: table
#: zsh.texi:18455
msgid "Attempt shell expansion on the current word up to cursor."
msgstr "尝试对当前单词直到光标前的部分进行 shell 扩展。"

#. type: tindex
#: zsh.texi:18456
#, no-wrap
msgid "expand-history"
msgstr "expand-history"

#. type: item
#: zsh.texi:18457
#, no-wrap
msgid "@t{expand-history} (@t{ESC-space ESC-!}) (unbound) (unbound)"
msgstr "@t{expand-history} (@t{ESC-space ESC-!}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18459
msgid "Perform history expansion on the edit buffer."
msgstr "在编辑缓冲区上执行历史记录扩展。"

#. type: tindex
#: zsh.texi:18460
#, no-wrap
msgid "expand-word"
msgstr "expand-word"

#. type: item
#: zsh.texi:18461
#, no-wrap
msgid "@t{expand-word} (@t{^X*}) (unbound) (unbound)"
msgstr "@t{expand-word} (@t{^X*}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18463
msgid "Attempt shell expansion on the current word."
msgstr "尝试对当前单词进行 shell 扩展。"

#. type: tindex
#: zsh.texi:18464
#, no-wrap
msgid "list-choices"
msgstr "list-choices"

#. type: item
#: zsh.texi:18465
#, no-wrap
msgid "@t{list-choices} (@t{ESC-^D}) (@t{^D =}) (@t{^D})"
msgstr "@t{list-choices} (@t{ESC-^D}) (@t{^D =}) (@t{^D})"

#. type: table
#: zsh.texi:18467
msgid "List possible completions for the current word."
msgstr "列出当前单词可能的补全。"

#. type: tindex
#: zsh.texi:18468
#, no-wrap
msgid "list-expand"
msgstr "list-expand"

#. type: item
#: zsh.texi:18469
#, no-wrap
msgid "@t{list-expand} (@t{^Xg ^XG}) (@t{^G}) (@t{^G})"
msgstr "@t{list-expand} (@t{^Xg ^XG}) (@t{^G}) (@t{^G})"

#. type: table
#: zsh.texi:18471
msgid "List the expansion of the current word."
msgstr "列出当前单词的扩展。"

#. type: table
#: zsh.texi:18476
msgid "Perform history expansion and insert a space into the buffer.  This is intended to be bound to space."
msgstr "执行历史扩展并在缓冲区中插入一个空格。 这预期与空格绑定。"

#. type: t{#1}
#: zsh.texi:18477 zsh.texi:18479
#, no-wrap
msgid "menu-complete"
msgstr "menu-complete"

#. type: pindex
#: zsh.texi:18478
#, no-wrap
msgid "MENU_COMPLETE, use of"
msgstr "MENU_COMPLETE, use of"

#. type: table
#: zsh.texi:18482
msgid "Like @t{complete-word}, except that menu completion is used.  See the @t{MENU_COMPLETE} option."
msgstr "与 @t{complete-word} 类似，但使用菜单补全功能。 参见 @t{MENU_COMPLETE} 选项。"

#. type: t{#1}
#: zsh.texi:18483 zsh.texi:18484
#, no-wrap
msgid "menu-expand-or-complete"
msgstr "menu-expand-or-complete"

#. type: table
#: zsh.texi:18486
msgid "Like @t{expand-or-complete}, except that menu completion is used."
msgstr "与 @t{expand-or-complete} 类似，只是使用菜单补全。"

#. type: t{#1}
#: zsh.texi:18487 zsh.texi:18488 zsh.texi:28354
#, no-wrap
msgid "reverse-menu-complete"
msgstr "reverse-menu-complete"

#. type: table
#: zsh.texi:18492
msgid "Perform menu completion, like @t{menu-complete}, except that if a menu completion is already in progress, move to the @emph{previous} completion rather than the next."
msgstr "执行菜单补全，与 @t{menu-complete} 类似，但如果菜单补全已在进行中，则移动到 @emph{前一个} 补全，而不是下一个。"

#. type: t{#1}
#: zsh.texi:18493 zsh.texi:18494
#, no-wrap
msgid "end-of-list"
msgstr "end-of-list"

#. type: table
#: zsh.texi:18497
msgid "When a previous completion displayed a list below the prompt, this widget can be used to move the prompt below the list."
msgstr "当之前的补全在提示符下方显示列表时，可使用此小部件将提示符移到列表下方。"

#. type: item
#: zsh.texi:18505
#, no-wrap
msgid "@t{accept-and-hold} (@t{ESC-A ESC-a}) (unbound) (unbound)"
msgstr "@t{accept-and-hold} (@t{ESC-A ESC-a}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18508
msgid "Push the contents of the buffer on the buffer stack and execute it."
msgstr "将缓冲区的内容推入缓冲区堆栈并执行。"

#. type: table
#: zsh.texi:18514
msgid "Execute the contents of the buffer.  Then search the history list for a line matching the current one and push the event following onto the buffer stack."
msgstr "执行缓冲区的内容。 然后在历史记录列表中搜索与当前事件相匹配的行，并将后面的事件推入缓冲堆栈。"

#. type: item
#: zsh.texi:18516
#, no-wrap
msgid "@t{accept-line} (@t{^J ^M}) (@t{^J ^M}) (@t{^J ^M})"
msgstr "@t{accept-line} (@t{^J ^M}) (@t{^J ^M}) (@t{^J ^M})"

#. type: table
#: zsh.texi:18519
msgid "Finish editing the buffer.  Normally this causes the buffer to be executed as a shell command."
msgstr "完成对缓冲区的编辑。 通常，这会使缓冲区作为 shell 命令执行。"

#. type: item
#: zsh.texi:18521
#, no-wrap
msgid "@t{accept-line-and-down-history} (@t{^O}) (unbound) (unbound)"
msgstr "@t{accept-line-and-down-history} (@t{^O}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18524
msgid "Execute the current line, and push the next history event on the buffer stack."
msgstr "执行当前行，并将下一个历史事件推入缓冲堆栈。"

#. type: t{#1}
#: zsh.texi:18525 zsh.texi:18526
#, no-wrap
msgid "auto-suffix-remove"
msgstr "auto-suffix-remove"

#. type: table
#: zsh.texi:18530
msgid "If the previous action added a suffix (space, slash, etc.) to the word on the command line, remove it.  Otherwise do nothing.  Removing the suffix ends any active menu completion or menu selection."
msgstr "如果前一个操作给命令行中的单词添加了后缀（空格、斜线等），则将其删除。 否则什么也不做。 删除后缀会结束任何活动的菜单补全或菜单选择。"

#. type: table
#: zsh.texi:18534
msgid "This widget is intended to be called from user-defined widgets to enforce a desired suffix-removal behavior."
msgstr "该小部件用于从用户自定义的小部件中调用，以强制执行所需的后缀移除行为。"

#. type: t{#1}
#: zsh.texi:18535 zsh.texi:18536
#, no-wrap
msgid "auto-suffix-retain"
msgstr "auto-suffix-retain"

#. type: table
#: zsh.texi:18540
msgid ""
"If the previous action added a suffix (space, slash, etc.) to the word on the command line, force it to be preserved.  Otherwise do nothing.  Retaining the suffix ends any active menu completion or menu "
"selection."
msgstr "如果前一个操作为命令行中的单词添加了后缀（空格、斜线等），则强制保留该后缀。 否则什么也不做。 保留后缀会终止任何激活的菜单补全或菜单选择。"

#. type: table
#: zsh.texi:18544
msgid "This widget is intended to be called from user-defined widgets to enforce a desired suffix-preservation behavior."
msgstr "该小部件用于从用户自定义的小部件中调用，以强制执行所需的后缀保护行为。"

#. type: t{#1}
#: zsh.texi:18545 zsh.texi:18546
#, no-wrap
msgid "beep"
msgstr "beep"

#. type: table
#: zsh.texi:18548
msgid "Beep, unless the @t{BEEP} option is unset."
msgstr "蜂鸣声，除非 @t{BEEP} 选项未设置。"

#. type: tindex
#: zsh.texi:18549
#, no-wrap
msgid "bracketed-paste"
msgstr "bracketed-paste"

#. type: item
#: zsh.texi:18550
#, no-wrap
msgid "@t{bracketed-paste} (@t{^[[200~}) (@t{^[[200~}) (@t{^[[200~})"
msgstr "@t{bracketed-paste} (@t{^[[200~}) (@t{^[[200~}) (@t{^[[200~})"

#. type: table
#: zsh.texi:18554
msgid ""
"This widget is invoked when text is pasted to the terminal emulator. It is not intended to be bound to actual keys but instead to the special sequence generated by the terminal emulator when text is "
"pasted."
msgstr "当文本粘贴到终端模拟器时，会调用该小部件。它不打算与实际按键绑定，而是与粘贴文本时终端模拟器生成的特殊序列绑定。"

#. type: table
#: zsh.texi:18560
msgid ""
"When invoked interactively, the pasted text is inserted to the buffer and placed in the cutbuffer.  If a numeric argument is given, shell quoting will be applied to the pasted text before it is inserted."
msgstr "当以交互方式调用时，粘贴的文本将插入缓冲区并放入剪切缓冲区。 如果给定了数字参数，则会在插入粘贴文本前对其应用 shell 引号。"

#. type: table
#: zsh.texi:18564
msgid "When a named buffer is specified with @t{vi-set-buffer} (@t{\"x}), the pasted text is stored in that named buffer but not inserted."
msgstr "如果使用 @t{vi-set-buffer} (@t{\"x}) 指定了一个命名缓冲区，粘贴的文本将存储在该命名缓冲区中，但不是插入。"

#. type: table
#: zsh.texi:18569
msgid "When called from a widget function as `@t{bracketed-paste} @var{name}`, the pasted text is assigned to the variable @var{name} and no other processing is done."
msgstr "在小部件函数中以  `@t{bracketed-paste} @var{name}` 调用时，粘贴的文本将赋值给变量 @var{name}，而不会进行其他处理。"

#. type: table
#: zsh.texi:18572
msgid "See also the @t{zle_bracketed_paste} parameter."
msgstr "另请参阅 @t{zle_bracketed_paste} 参数。"

#. type: item
#: zsh.texi:18574
#, no-wrap
msgid "@t{vi-cmd-mode} (@t{^X^V}) (unbound) (@t{^[})"
msgstr "@t{vi-cmd-mode} (@t{^X^V}) (unbound) (@t{^[})"

#. type: table
#: zsh.texi:18577
msgid "Enter command mode; that is, select the `@t{vicmd}' keymap.  Yes, this is bound by default in emacs mode."
msgstr "进入命令模式；即选择 `@t{vicmd}' 键映射。 是的，默认情况下在 emacs 模式下是绑定的。"

#. type: t{#1}
#: zsh.texi:18578 zsh.texi:18579
#, no-wrap
msgid "vi-caps-lock-panic"
msgstr "vi-caps-lock-panic"

#. type: table
#: zsh.texi:18583
msgid "Hang until any lowercase key is pressed.  This is for vi users without the mental capacity to keep track of their caps lock key (like the author)."
msgstr "挂起，直到按下任何小写键。 这是为那些没有心理承受能力去追踪大写锁定键的 vi 用户准备的（比如笔者）。"

#. type: item
#: zsh.texi:18585
#, no-wrap
msgid "@t{clear-screen} (@t{^L ESC-^L}) (@t{^L}) (@t{^L})"
msgstr "@t{clear-screen} (@t{^L ESC-^L}) (@t{^L}) (@t{^L})"

#. type: table
#: zsh.texi:18587
msgid "Clear the screen and redraw the prompt."
msgstr "清除屏幕并重新绘制提示符。"

#. type: t{#1}
#: zsh.texi:18588 zsh.texi:18589
#, no-wrap
msgid "deactivate-region"
msgstr "deactivate-region"

#. type: table
#: zsh.texi:18592
msgid "Make the current region inactive. This disables vim-style visual selection mode if it is active."
msgstr "使当前区域处于非激活状态。如果 vim 风格的可视化选择模式处于激活状态，则会禁用该模式。"

#. type: t{#1}
#: zsh.texi:18593 zsh.texi:18594
#, no-wrap
msgid "describe-key-briefly"
msgstr "describe-key-briefly"

#. type: table
#: zsh.texi:18596
msgid "Reads a key sequence, then prints the function bound to that sequence."
msgstr "读取按键序列，然后打印与该序列绑定的函数。"

#. type: tindex
#: zsh.texi:18597
#, no-wrap
msgid "exchange-point-and-mark"
msgstr "exchange-point-and-mark"

#. type: item
#: zsh.texi:18598
#, no-wrap
msgid "@t{exchange-point-and-mark} (@t{^X^X}) (unbound) (unbound)"
msgstr "@t{exchange-point-and-mark} (@t{^X^X}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18604
msgid ""
"Exchange the cursor position (point) with the position of the mark.  Unless a negative numeric argument is given, the region between point and mark is activated so that it can be highlighted.  If a zero "
"numeric argument is given, the region is activated but point and mark are not swapped."
msgstr "交换光标位置（点）和标记位置。 除非给出负数参数，否则点和标记之间的区域将被激活，以便高亮显示。 如果给定的数字参数为零，该区域将被激活，但点和标记不会交换。"

#. type: tindex
#: zsh.texi:18605
#, no-wrap
msgid "execute-named-cmd"
msgstr "execute-named-cmd"

#. type: item
#: zsh.texi:18606
#, no-wrap
msgid "@t{execute-named-cmd} (@t{ESC-x}) (@t{:}) (unbound)"
msgstr "@t{execute-named-cmd} (@t{ESC-x}) (@t{:}) (unbound)"

#. type: table
#: zsh.texi:18611
msgid ""
"Read the name of an editor command and execute it.  Aliasing this widget with `@t{zle -A}' or replacing it with `@t{zle -N}' has no effect when interpreting key bindings, but `@t{zle execute-named-cmd}' "
"will invoke such an alias or replacement."
msgstr "读取编辑器命令的名称并执行。 在解释按键绑定时，用 `@t{zle -A}' 为该小部件建别名或用 `@t{zle -N}' 替换该小部件没有任何作用，但 `@t{zle execute-named-cmd}' 将调用此类别名或替换。"

#. type: table
#: zsh.texi:18638
msgid ""
"A restricted set of editing functions is available in the mini-buffer.  Keys are looked up in the special @t{command} keymap, and if not found there in the main keymap.  An interrupt signal, as defined by "
"the stty setting, will abort the function.  Note that the following always perform the same task within the @t{executed-named-cmd} environment and cannot be replaced by user defined widgets, nor can the "
"set of functions be extended.  The allowed functions are: @t{backward-delete-char}, @t{vi-backward-delete-char}, @t{clear-screen}, @t{redisplay}, @t{quoted-insert}, @t{vi-quoted-insert}, @t{backward-kill-"
"word}, @t{vi-backward-kill-word}, @t{kill-whole-line}, @t{vi-kill-line}, @t{backward-kill-line}, @t{list-choices}, @t{delete-char-or-list}, @t{complete-word}, @t{accept-line}, @t{expand-or-complete} and "
"@t{expand-or-complete-prefix}."
msgstr ""
"在迷你缓冲区中可以使用一套受限的编辑功能。 键将在特殊的 @t{command} 键映射中查找，如果找不到，则在主键映射中查找。 由 stty 设置定义的中断信号将中止该功能。 请注意，以下函数始终在 @t{executed-named-cmd} 环"
"境中执行相同的任务，不能被用户定义的小部件替代，也不能扩展函数集。 允许使用的函数包括: @t{backward-delete-char}, @t{vi-backward-delete-char}, @t{clear-screen}, @t{redisplay}, @t{quoted-insert}, @t{vi-"
"quoted-insert}, @t{backward-kill-word}, @t{vi-backward-kill-word}, @t{kill-whole-line}, @t{vi-kill-line}, @t{backward-kill-line}, @t{list-choices}, @t{delete-char-or-list}, @t{complete-word}, @t{accept-"
"line}, @t{expand-or-complete} and @t{expand-or-complete-prefix}。"

#. type: table
#: zsh.texi:18648
msgid ""
"@t{kill-region} kills the last word, and vi-cmd-mode is treated the same as accept-line.  The space and tab characters, if not bound to one of these functions, will complete the name and then list the "
"possibilities if the @t{AUTO_LIST} option is set.  Any other character that is not bound to @t{self-insert} or @t{self-insert-unmeta} will beep and be ignored.  The bindings of the current insert mode "
"will be used."
msgstr ""
"@t{kill-region} 会删除最后一个单词，vi-cmd-mode 的处理方式与 accept-line 相同。 空格和制表符如果没有绑定到这些函数中的任何一个，就会补全名称，然后在 @t{AUTO_LIST} 选项设置的情况下列出各种可能性。 任何未与 "
"@t{self-insert} 或 @t{self-insert-unmeta} 绑定的其他字符都会发出蜂鸣声并被忽略。 将使用当前插入模式的绑定。"

#. type: table
#: zsh.texi:18651
msgid "Currently this command may not be redefined or called by name."
msgstr "目前该命令不能重新定义或通过名称调用。"

#. type: tindex
#: zsh.texi:18652
#, no-wrap
msgid "execute-last-named-cmd"
msgstr "execute-last-named-cmd"

#. type: item
#: zsh.texi:18653
#, no-wrap
msgid "@t{execute-last-named-cmd} (@t{ESC-z}) (unbound) (unbound)"
msgstr "@t{execute-last-named-cmd} (@t{ESC-z}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18655
msgid "Redo the last function executed with @t{execute-named-cmd}."
msgstr "重做使用 @t{execute-named-cmd} 执行的最后一个函数。"

#. type: table
#: zsh.texi:18659
msgid "Like @t{execute-named-cmd}, this command may not be redefined, but it may be called by name."
msgstr "与 @t{execute-named-cmd} 一样，该命令不能重新定义，但可以通过名称调用。"

#. type: tindex
#: zsh.texi:18660
#, no-wrap
msgid "get-line"
msgstr "get-line"

#. type: item
#: zsh.texi:18661
#, no-wrap
msgid "@t{get-line} (@t{ESC-G ESC-g}) (unbound) (unbound)"
msgstr "@t{get-line} (@t{ESC-G ESC-g}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18664
msgid "Pop the top line off the buffer stack and insert it at the cursor position."
msgstr "从缓冲堆栈中弹出顶行，并将其插入光标位置。"

#. type: tindex
#: zsh.texi:18665
#, no-wrap
msgid "pound-insert"
msgstr "pound-insert"

#. type: item
#: zsh.texi:18666
#, no-wrap
msgid "@t{pound-insert} (unbound) (@t{#}) (unbound)"
msgstr "@t{pound-insert} (unbound) (@t{#}) (unbound)"

#. type: table
#: zsh.texi:18673
msgid ""
"If there is no # character at the beginning of the buffer, add one to the beginning of each line.  If there is one, remove a # from each line that has one.  In either case, accept the current line.  The "
"@t{INTERACTIVE_COMMENTS} option must be set for this to have any usefulness."
msgstr "如果缓冲区开头没有 # 字符，则在每行开头添加一个 # 字符。 如果有 # 字符，则在有 # 字符的每一行中删除一个 # 字符。 无论哪种情况，都接受当前行。 必须设置 @t{INTERACTIVE_COMMENTS} 选项才有用。"

#. type: t{#1}
#: zsh.texi:18674 zsh.texi:18675
#, no-wrap
msgid "vi-pound-insert"
msgstr "vi-pound-insert"

#. type: table
#: zsh.texi:18680
msgid "If there is no # character at the beginning of the current line, add one.  If there is one, remove it.  The @t{INTERACTIVE_COMMENTS} option must be set for this to have any usefulness."
msgstr "如果当前行开头没有 # 字符，则添加一个。 如果有，则将其删除。 必须设置 @t{INTERACTIVE_COMMENTS} 选项才有用。"

#. type: t{#1}
#: zsh.texi:18681 zsh.texi:18682
#, no-wrap
msgid "push-input"
msgstr "push-input"

#. type: table
#: zsh.texi:18690
msgid ""
"Push the entire current multiline construct onto the buffer stack and return to the top-level (@t{PS1}) prompt.  If the current parser construct is only a single line, this is exactly like @t{push-line}.  "
"Next time the editor starts up or is popped with @t{get-line}, the construct will be popped off the top of the buffer stack and loaded into the editing buffer."
msgstr ""
"将整个当前多行结构体推入缓冲堆栈，并返回顶层 (@t{PS1}) 提示符。 如果当前解析器结构体只有一行，则与 @t{push-line} 完全相同。 下次编辑器启动或使用 @t{get-line} 弹出时，该结构体将从缓冲堆栈顶部弹出并加载到编"
"辑缓冲区。"

#. type: tindex
#: zsh.texi:18691
#, no-wrap
msgid "push-line"
msgstr "push-line"

#. type: item
#: zsh.texi:18692
#, no-wrap
msgid "@t{push-line} (@t{^Q ESC-Q ESC-q}) (unbound) (unbound)"
msgstr "@t{push-line} (@t{^Q ESC-Q ESC-q}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18698
msgid "Push the current buffer onto the buffer stack and clear the buffer.  Next time the editor starts up, the buffer will be popped off the top of the buffer stack and loaded into the editing buffer."
msgstr "将当前缓冲区推入缓冲区堆栈并清除缓冲区。 下次编辑器启动时，缓冲区将从缓冲区堆栈顶部弹出，并载入编辑缓冲区。"

#. type: t{#1}
#: zsh.texi:18699 zsh.texi:18700
#, no-wrap
msgid "push-line-or-edit"
msgstr "push-line-or-edit"

#. type: table
#: zsh.texi:18705
msgid ""
"At the top-level (@t{PS1}) prompt, equivalent to @t{push-line}.  At a secondary (@t{PS2}) prompt, move the entire current multiline construct into the editor buffer.  The latter is equivalent to @t{push-"
"input} followed by @t{get-line}."
msgstr "在顶层 (@t{PS1}) 提示符下，相当于 @t{push-line}。 在二级（@t{PS2}）提示符下，将整个当前多行结构移入编辑缓冲区。 后者相当于 @t{push-input} 后接 @t{get-line}。"

#. type: t{#1}
#: zsh.texi:18706 zsh.texi:18707
#, no-wrap
msgid "read-command"
msgstr "read-command"

#. type: table
#: zsh.texi:18715
msgid ""
"Only useful from a user-defined widget.  A keystroke is read just as in normal operation, but instead of the command being executed the name of the command that would be executed is stored in the shell "
"parameter @t{REPLY}.  This can be used as the argument of a future @t{zle} command.  If the key sequence is not bound, status 1 is returned; typically, however, @t{REPLY} is set to @t{undefined-key} to "
"indicate a useless key sequence."
msgstr ""
"仅对用户自定义小部件有用。 按键操作与正常操作一样被读取，但将被执行的命令名称存储在 shell 参数 @t{REPLY} 中，而不是正在执行的命令。 该参数可用作未来 @t{zle} 命令的参数。 如果键序未被绑定，则返回状态 1；但"
"通常情况下，@t{REPLY} 会被设置为 @t{undefined-key}，以表示键序无用。"

#. type: t{#1}
#: zsh.texi:18716 zsh.texi:18717
#, no-wrap
msgid "recursive-edit"
msgstr "recursive-edit"

#. type: table
#: zsh.texi:18726
msgid ""
"Only useful from a user-defined widget.  At this point in the function, the editor regains control until one of the standard widgets which would normally cause zle to exit (typically an @t{accept-line} "
"caused by hitting the return key) is executed.  Instead, control returns to the user-defined widget.  The status returned is non-zero if the return was caused by an error, but the function still continues "
"executing and hence may tidy up.  This makes it safe for the user-defined widget to alter the command line or key bindings temporarily."
msgstr ""
"仅对用户定义的小部件有用。 此时，编辑器会重新获得控制权，直到执行了一个通常会导致 zle 退出的标准小部件（通常是由按回车键引起的 @t{accept-line}）。 相反，控制权会返回到用户定义的小部件。 如果返回是由错误引"
"起的，则返回的状态为非零，但函数仍在继续执行，因此可能会进行整理工作。 这使得用户自定义小部件可以安全地临时更改命令行或按键绑定。"

#. type: table
#: zsh.texi:18729
msgid "The following widget, @t{caps-lock}, serves as an example."
msgstr "下面这个小部件 @t{caps-lock} 就是一个例子。"

#. type: example
#: zsh.texi:18735
#, no-wrap
msgid ""
"self-insert-ucase() @{\n"
"  LBUFFER+=$@{(U)KEYS[-1]@}\n"
"@}\n"
"\n"
msgstr ""
"self-insert-ucase() @{\n"
"  LBUFFER+=$@{(U)KEYS[-1]@}\n"
"@}\n"
"\n"

#. type: example
#: zsh.texi:18737
#, no-wrap
msgid ""
"integer stat\n"
"\n"
msgstr ""
"integer stat\n"
"\n"

#. type: example
#: zsh.texi:18741
#, no-wrap
msgid ""
"zle -N self-insert self-insert-ucase\n"
"zle -A caps-lock save-caps-lock\n"
"zle -A accept-line caps-lock\n"
"\n"
msgstr ""
"zle -N self-insert self-insert-ucase\n"
"zle -A caps-lock save-caps-lock\n"
"zle -A accept-line caps-lock\n"
"\n"

#. type: example
#: zsh.texi:18744
#, no-wrap
msgid ""
"zle recursive-edit\n"
"stat=$?\n"
"\n"
msgstr ""
"zle recursive-edit\n"
"stat=$?\n"
"\n"

#. type: example
#: zsh.texi:18748
#, no-wrap
msgid ""
"zle -A .self-insert self-insert\n"
"zle -A save-caps-lock caps-lock\n"
"zle -D save-caps-lock\n"
"\n"
msgstr ""
"zle -A .self-insert self-insert\n"
"zle -A save-caps-lock caps-lock\n"
"zle -D save-caps-lock\n"
"\n"

#. type: example
#: zsh.texi:18750
#, no-wrap
msgid ""
"(( stat )) && zle send-break\n"
"\n"
msgstr ""
"(( stat )) && zle send-break\n"
"\n"

#. type: example
#: zsh.texi:18752
#, no-wrap
msgid "return $stat\n"
msgstr "return $stat\n"

#. type: table
#: zsh.texi:18762
msgid ""
"This causes typed letters to be inserted capitalised until either @t{accept-line} (i.e. typically the return key) is typed or the @t{caps-lock} widget is invoked again; the later is handled by saving the "
"old definition of @t{caps-lock} as @t{save-caps-lock} and then rebinding it to invoke @t{accept-line}.  Note that an error from the recursive edit is detected as a non-zero return status and propagated by "
"using the @t{send-break} widget."
msgstr ""
"在输入 @t{accept-line}（即通常的返回键）或再次调用 @t{caps-lock} 小部件之前，输入的字母都会大写。  @t{caps-lock} 的处理方式是把旧定义保存为 @t{save-caps-lock}，然后重新绑定以调用 @t{accept-line}。请注意，"
"递归编辑产生的错误会被检测为非零返回状态，并通过 @t{send-break} 小部件传播。"

#. type: item
#: zsh.texi:18764
#, no-wrap
msgid "@t{redisplay} (unbound) (@t{^R}) (@t{^R})"
msgstr "@t{redisplay} (unbound) (@t{^R}) (@t{^R})"

#. type: table
#: zsh.texi:18766
msgid "Redisplays the edit buffer."
msgstr "重新显示编辑缓冲区。"

#. type: tindex
#: zsh.texi:18767
#, no-wrap
msgid "reset-prompt"
msgstr "reset-prompt"

#. type: item
#: zsh.texi:18768
#, no-wrap
msgid "@t{reset-prompt} (unbound) (unbound) (unbound)"
msgstr "@t{reset-prompt} (unbound) (unbound) (unbound)"

#. type: table
#: zsh.texi:18775
msgid ""
"Force the prompts on both the left and right of the screen to be re-expanded, then redisplay the edit buffer.  This reflects changes both to the prompt variables themselves and changes in the expansion of "
"the values (for example, changes in time or directory, or changes to the value of variables referred to by the prompt)."
msgstr "强制重新展开屏幕左右两边的提示符，然后重新显示编辑缓冲区。 这既反映了提示符变量本身的变化，也反映了扩展值的变化（例如时间或目录的变化，或提示符所指变量值的变化）。"

#. type: table
#: zsh.texi:18781
msgid ""
"Otherwise, the prompt is only expanded each time zle starts, and when the display has been interrupted by output from another part of the shell (such as a job notification) which causes the command line "
"to be reprinted."
msgstr "否则，提示符只会在每次 zle 启动时展开，以及在显示被 shell 其他部分的输出（如作业通知）打断时展开（这会导致命令行被重新打印）。"

#. type: table
#: zsh.texi:18784
msgid "@t{reset-prompt} doesn't alter the special parameter @t{LASTWIDGET}."
msgstr "@t{reset-prompt} 不会改变特殊参数 @t{LASTWIDGET}。"

#. type: t{#1}
#: zsh.texi:18787 zsh.texi:28158 zsh.texi:28285
#, no-wrap
msgid "send-break"
msgstr "send-break"

#. type: item
#: zsh.texi:18788
#, no-wrap
msgid "@t{send-break} (@t{^G ESC-^G}) (unbound) (unbound)"
msgstr "@t{send-break} (@t{^G ESC-^G}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18794
msgid ""
"Abort the current editor function, e.g. @t{execute-named-command}, or the editor itself, e.g. if you are in @t{vared}. Otherwise abort the parsing of the current line; in this case the aborted line is "
"available in the shell variable @t{ZLE_LINE_ABORTED}.  If the editor is aborted from within @t{vared}, the variable @t{ZLE_VARED_ABORTED} is set."
msgstr ""
"终止当前编辑器函数，例如 @t{execute-named-command}，或编辑器本身，例如 @t{vared}。否则，将中止当前行的解析；在这种情况下，中止的行可以在 shell 变量 @t{ZLE_LINE_ABORTED} 中找到。 如果在 @t{vared} 中中止编辑"
"器，变量 @t{ZLE_VARED_ABORTED} 将被设置。"

#. type: findex
#: zsh.texi:18795 zsh.texi:40824
#, no-wrap
msgid "run-help"
msgstr "run-help"

#. type: item
#: zsh.texi:18796
#, no-wrap
msgid "@t{run-help} (@t{ESC-H ESC-h}) (unbound) (unbound)"
msgstr "@t{run-help} (@t{ESC-H ESC-h}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18800
msgid "Push the buffer onto the buffer stack, and execute the command `@t{run-help} @var{cmd}', where @var{cmd} is the current command.  @t{run-help} is normally aliased to @t{man}."
msgstr "将缓冲区推入缓冲栈，然后执行命令 `@t{run-help} @var{cmd}' 其中 @var{cmd} 是当前命令。@var{cmd}'，其中 @var{cmd} 是当前命令。 @t{run-help} 通常为 @t{man} 的别名。"

#. type: tindex
#: zsh.texi:18801
#, no-wrap
msgid "vi-set-buffer"
msgstr "vi-set-buffer"

#. type: item
#: zsh.texi:18802
#, no-wrap
msgid "@t{vi-set-buffer} (unbound) (@t{\"}) (unbound)"
msgstr "@t{vi-set-buffer} (unbound) (@t{\"}) (unbound)"

#. type: table
#: zsh.texi:18808
msgid ""
"Specify a buffer to be used in the following command.  There are 37 buffers that can be specified: the 26 `named' buffers @t{\"a} to @t{\"z}, the `yank' buffer @t{\"0}, the nine `queued' buffers @t{\"1} "
"to @t{\"9} and the `black hole' buffer @t{\"_}.  The named buffers can also be specified as @t{\"A} to @t{\"Z}."
msgstr ""
"指定要在随后命令中使用的缓冲区。 可指定的缓冲区有 37 个：26 个 `命名' 缓冲区 @t{\"a} 至 @t{\"z}、`yank' 缓冲区 @t{\"0}、9 个`queued' 缓冲区 @t{\"1} 至 @t{\"9} 和 `黑洞' 缓冲区 @t{\"_}。 命名的缓冲区也可以"
"指定为 @t{\"A} 至 @t{\"Z}。"

#. type: table
#: zsh.texi:18816
msgid ""
"When a buffer is specified for a cut, change or yank command, the text concerned replaces the previous contents of the specified buffer. If a named buffer is specified using a capital, the newly cut text "
"is appended to the buffer instead of overwriting it. When using the @t{\"_} buffer, nothing happens. This can be useful for deleting text without affecting any buffers."
msgstr ""
"如果为剪切、更改或复制命令指定了缓冲区，相关文本将替换指定缓冲区中以前的内容。如果使用大写字母指定了一个已命名的缓冲区，则新剪切的文本将附加到缓冲区，而不是覆盖缓冲区。使用 @t{\"_} 缓冲区时，不会发生任何操"
"作。这对于删除文本而不影响任何缓冲区非常有用。"

#. type: table
#: zsh.texi:18824
msgid ""
"If no buffer is specified for a cut or change command, @t{\"1} is used, and the contents of @t{\"1} to @t{\"8} are each shifted along one buffer; the contents of @t{\"9} is lost. If no buffer is specified "
"for a yank command, @t{\"0} is used. Finally, a paste command without a specified buffer will paste the text from the most recent command regardless of any buffer that might have been used with that "
"command."
msgstr ""
"如果剪切或更改命令没有指定缓冲区，则使用 @t{\"1}，@t{\"1} 至 @t{\"8} 中的内容分别沿一个缓冲区移动；@t{\"9} 中的内容丢失。如果 yank 命令没有指定缓冲区，则使用 @t{\"0}。最后，没有指定缓冲区的粘贴命令将粘贴来"
"自最近一条命令的文本，而与该命令可能使用的缓冲区无关。"

#. type: table
#: zsh.texi:18828
msgid "When called from a widget function by the @t{zle} command, the buffer can optionally be specified with an argument. For example,"
msgstr "当使用 @t{zle} 命令从小部件函数中调用时，可以选择使用参数指定缓冲区。例如"

#. type: example
#: zsh.texi:18832
#, no-wrap
msgid "zle vi-set-buffer A\n"
msgstr "zle vi-set-buffer A\n"

#. type: tindex
#: zsh.texi:18834
#, no-wrap
msgid "vi-set-mark"
msgstr "vi-set-mark"

#. type: item
#: zsh.texi:18835
#, no-wrap
msgid "@t{vi-set-mark} (unbound) (@t{m}) (unbound)"
msgstr "@t{vi-set-mark} (unbound) (@t{m}) (unbound)"

#. type: table
#: zsh.texi:18837
msgid "Set the specified mark at the cursor position."
msgstr "在光标位置设置指定标记。"

#. type: tindex
#: zsh.texi:18838
#, no-wrap
msgid "set-mark-command"
msgstr "set-mark-command"

#. type: item
#: zsh.texi:18839
#, no-wrap
msgid "@t{set-mark-command} (@t{^@@}) (unbound) (unbound)"
msgstr "@t{set-mark-command} (@t{^@@}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18844
msgid ""
"Set the mark at the cursor position.  If called with a negative numeric argument, do not set the mark but deactivate the region so that it is no longer highlighted (it is still usable for other "
"purposes).  Otherwise the region is marked as active."
msgstr "在光标位置设置标记。 如果调用的参数为负数，则不设置标记，而是停用该区域，使其不再高亮显示（仍可用于其他目的）。 否则，该区域将被标记为激活状态。"

#. type: tindex
#: zsh.texi:18845
#, no-wrap
msgid "spell-word"
msgstr "spell-word"

#. type: item
#: zsh.texi:18846
#, no-wrap
msgid "@t{spell-word} (@t{ESC-$ ESC-S ESC-s}) (unbound) (unbound)"
msgstr "@t{spell-word} (@t{ESC-$ ESC-S ESC-s}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18848
msgid "Attempt spelling correction on the current word."
msgstr "尝试对当前单词进行拼写更正。"

#. type: t{#1}
#: zsh.texi:18849 zsh.texi:18850
#, no-wrap
msgid "split-undo"
msgstr "split-undo"

#. type: table
#: zsh.texi:18855
msgid ""
"Breaks the undo sequence at the current change.  This is useful in vi mode as changes made in insert mode are coalesced on entering command mode.  Similarly, @t{undo} will normally revert as one all the "
"changes made by a user-defined widget."
msgstr "在当前更改处打破撤销序列。 这在 vi 模式下非常有用，因为在插入模式下所做的更改会在进入命令模式时合并。 类似地，@t{undo} 通常会将用户定义的小部件所做的所有更改统一复原。"

#. type: t{#1}
#: zsh.texi:18856 zsh.texi:18857
#, no-wrap
msgid "undefined-key"
msgstr "undefined-key"

#. type: table
#: zsh.texi:18860
msgid "This command is executed when a key sequence that is not bound to any command is typed.  By default it beeps."
msgstr "当键入未与任何命令绑定的按键序列时，将执行该命令。 默认情况下会发出蜂鸣声。"

#. type: t{#1}
#: zsh.texi:18861 zsh.texi:28305
#, no-wrap
msgid "undo"
msgstr "undo"

#. type: item
#: zsh.texi:18862
#, no-wrap
msgid "@t{undo} (@t{^_ ^Xu ^X^U}) (@t{u}) (unbound)"
msgstr "@t{undo} (@t{^_ ^Xu ^X^U}) (@t{u}) (unbound)"

#. type: table
#: zsh.texi:18868
msgid ""
"Incrementally undo the last text modification.  When called from a user-defined widget, takes an optional argument indicating a previous state of the undo history as returned by the @t{UNDO_CHANGE_NO} "
"variable; modifications are undone until that state is reached, subject to any limit imposed by the @t{UNDO_LIMIT_NO} variable."
msgstr ""
"递增撤销最后一次文本修改。 从用户定义的小部件调用时，会接收一个可选参数，该参数表示 @t{UNDO_CHANGE_NO} 变量返回的撤销历史的前一个状态；在达到该状态之前，所作修改都会被撤销，但会受到 @t{UNDO_LIMIT_NO} 变量"
"的限制。"

#. type: table
#: zsh.texi:18873
msgid "Note that when invoked from vi command mode, the full prior change made in insert mode is reverted, the changes having been merged when command mode was selected."
msgstr "请注意，在 vi 命令模式下调用时，插入模式下的全部修改将被还原（reverted），因为在选择命令模式时，这些修改已被合并。"

#. type: tindex
#: zsh.texi:18874
#, no-wrap
msgid "redo"
msgstr "redo"

#. type: item
#: zsh.texi:18875
#, no-wrap
msgid "@t{redo} (unbound) (@t{^R}) (unbound)"
msgstr "@t{redo} (unbound) (@t{^R}) (unbound)"

#. type: table
#: zsh.texi:18877
msgid "Incrementally redo undone text modifications."
msgstr "增量重做未完成的文本修改。"

#. type: tindex
#: zsh.texi:18878
#, no-wrap
msgid "vi-undo-change"
msgstr "vi-undo-change"

#. type: item
#: zsh.texi:18879
#, no-wrap
msgid "@t{vi-undo-change} (unbound) (unbound) (unbound)"
msgstr "@t{vi-undo-change} (unbound) (unbound) (unbound)"

#. type: table
#: zsh.texi:18882
msgid "Undo the last text modification.  If repeated, redo the modification."
msgstr "撤销上次文本修改。 如果重复，则重做修改。"

#. type: tindex
#: zsh.texi:18883
#, no-wrap
msgid "visual-mode"
msgstr "visual-mode"

#. type: item
#: zsh.texi:18884
#, no-wrap
msgid "@t{visual-mode} (unbound) (@t{v}) (unbound)"
msgstr "@t{visual-mode} (unbound) (@t{v}) (unbound)"

#. type: table
#: zsh.texi:18889
msgid ""
"Toggle vim-style visual selection mode. If line-wise visual mode is currently enabled then it is changed to being character-wise. If used following an operator, it forces the subsequent movement command "
"to be treated as a character-wise movement."
msgstr "切换 vim 风格的可视化选择模式。如果当前已启用按行选择的可视化模式，则会将其改为按字符选择。如果在操作符之后使用，则会强制将随后的移动命令视为按字符移动。"

#. type: tindex
#: zsh.texi:18890
#, no-wrap
msgid "visual-line-mode"
msgstr "visual-line-mode"

#. type: item
#: zsh.texi:18891
#, no-wrap
msgid "@t{visual-line-mode} (unbound) (@t{V}) (unbound)"
msgstr "@t{visual-line-mode} (unbound) (@t{V}) (unbound)"

#. type: table
#: zsh.texi:18896
msgid ""
"Toggle vim-style line-wise visual selection mode. If character-wise visual mode is currently enabled then it is changed to being line-wise. If used following an operator, it forces the subsequent movement "
"command to be treated as a line-wise movement."
msgstr "切换 vim 风格的逐行可视化选择模式。如果当前启用的是按字符的可视化模式，则会将其改为按行的可视化模式。如果在操作符之后使用，则会强制将随后的移动命令视为按行移动。"

#. type: tindex
#: zsh.texi:18897
#, no-wrap
msgid "what-cursor-position"
msgstr "what-cursor-position"

#. type: item
#: zsh.texi:18898
#, no-wrap
msgid "@t{what-cursor-position} (@t{^X=}) (@t{ga}) (unbound)"
msgstr "@t{what-cursor-position} (@t{^X=}) (@t{ga}) (unbound)"

#. type: table
#: zsh.texi:18902
msgid "Print the character under the cursor, its code as an octal, decimal and hexadecimal number, the current cursor position within the buffer and the column of the cursor in the current line."
msgstr "打印光标下的字符，以八进制、十进制和十六进制数的形式显示其代码，以及光标在缓冲区中的当前位置和当前行中的列数。"

#. type: t{#1}
#: zsh.texi:18903 zsh.texi:18904
#, no-wrap
msgid "where-is"
msgstr "where-is"

#. type: table
#: zsh.texi:18910
msgid ""
"Read the name of an editor command and print the listing of key sequences that invoke the specified command.  A restricted set of editing functions is available in the mini-buffer.  Keys are looked up in "
"the special @t{command} keymap, and if not found there in the main keymap."
msgstr "读取编辑器命令的名称，并打印调用指定命令的按键序列列表。 迷你缓冲区中提供了一组受限的编辑功能。 按键在特殊的 @t{command} 键映射中查找，如果找不到，则在主键映射中查找。"

#. type: t{#1}
#: zsh.texi:18911 zsh.texi:39468 zsh.texi:39469
#, no-wrap
msgid "which-command"
msgstr "which-command"

#. type: item
#: zsh.texi:18912
#, no-wrap
msgid "@t{which-command} (@t{ESC-?}) (unbound) (unbound)"
msgstr "@t{which-command} (@t{ESC-?}) (unbound) (unbound)"

#. type: table
#: zsh.texi:18916
msgid "Push the buffer onto the buffer stack, and execute the command `@t{which-command} @var{cmd}'. where @var{cmd} is the current command.  @t{which-command} is normally aliased to @t{whence}."
msgstr "将缓冲区推入缓冲堆栈，然后执行命令 `@t{which-command} @var{cmd}' 。其中 @var{cmd} 是当前命令。 @t{which-command} 通常是 @t{whence} 的别名。"

#. type: tindex
#: zsh.texi:18917
#, no-wrap
msgid "vi-digit-or-beginning-of-line"
msgstr "vi-digit-or-beginning-of-line"

#. type: item
#: zsh.texi:18918
#, no-wrap
msgid "@t{vi-digit-or-beginning-of-line} (unbound) (@t{0}) (unbound)"
msgstr "@t{vi-digit-or-beginning-of-line} (unbound) (@t{0}) (unbound)"

#. type: table
#: zsh.texi:18921
msgid "If the last command executed was a digit as part of an argument, continue the argument.  Otherwise, execute vi-beginning-of-line."
msgstr "如果最后执行的命令是作为参数一部分的数字，则继续执行参数。 否则，执行 vi-beginning-of-line。"

#. type: cindex
#: zsh.texi:18927
#, no-wrap
msgid "text objects"
msgstr "文本对象"

#. type: Plain text
#: zsh.texi:18934
msgid ""
"Text objects are commands that can be used to select a block of text according to some criteria. They are a feature of the vim text editor and so are primarily intended for use with vi operators or from "
"visual selection mode. However, they can also be used from vi-insert or emacs mode. Key bindings listed below apply to the @t{viopp} and @t{visual} keymaps."
msgstr ""
"文本对象是用于根据某些标准选择文本块的命令。它们是 vim 文本编辑器的一项功能，因此主要用于 vi 操作符或可视化选择模式。不过，它们也可以在 vi-insert 或 emacs 模式下使用。下面列出的键绑定适用于 @t{viopp} 和 "
"@t{visual} 键映射。"

#. type: tindex
#: zsh.texi:18937
#, no-wrap
msgid "select-a-blank-word"
msgstr "select-a-blank-word"

#. type: item
#: zsh.texi:18938
#, no-wrap
msgid "@t{select-a-blank-word} (@t{aW})"
msgstr "@t{select-a-blank-word} (@t{aW})"

#. type: table
#: zsh.texi:18942
msgid "Select a word including adjacent blanks, where a word is defined as a series of non-blank characters. With a numeric argument, multiple words will be selected."
msgstr "选择包括相邻空格的单词，单词的定义是一系列非空格字符。使用数字参数时，将选择多个单词。"

#. type: tindex
#: zsh.texi:18943
#, no-wrap
msgid "select-a-shell-word"
msgstr "select-a-shell-word"

#. type: item
#: zsh.texi:18944
#, no-wrap
msgid "@t{select-a-shell-word} (@t{aa})"
msgstr "@t{select-a-shell-word} (@t{aa})"

#. type: table
#: zsh.texi:18947
msgid "Select the current command argument applying the normal rules for quoting."
msgstr "选择当前的命令参数，并应用正常的引号规则。"

#. type: tindex
#: zsh.texi:18948
#, no-wrap
msgid "select-a-word"
msgstr "select-a-word"

#. type: item
#: zsh.texi:18949
#, no-wrap
msgid "@t{select-a-word} (@t{aw})"
msgstr "@t{select-a-word} (@t{aw})"

#. type: table
#: zsh.texi:18952
msgid "Select a word including adjacent blanks, using the normal vi-style word definition. With a numeric argument, multiple words will be selected."
msgstr "使用普通的 vi-style 单词定义，选择包括相邻空白在内的单词。使用数字参数时，将选择多个单词。"

#. type: tindex
#: zsh.texi:18953
#, no-wrap
msgid "select-in-blank-word"
msgstr "select-in-blank-word"

#. type: item
#: zsh.texi:18954
#, no-wrap
msgid "@t{select-in-blank-word} (@t{iW})"
msgstr "@t{select-in-blank-word} (@t{iW})"

#. type: table
#: zsh.texi:18957
msgid "Select a word, where a word is defined as a series of non-blank characters. With a numeric argument, multiple words will be selected."
msgstr "选择一个单词，单词的定义是一系列非空格字符。使用数字参数时，将选择多个单词。"

#. type: tindex
#: zsh.texi:18958
#, no-wrap
msgid "select-in-shell-word"
msgstr "select-in-shell-word"

#. type: item
#: zsh.texi:18959
#, no-wrap
msgid "@t{select-in-shell-word} (@t{ia})"
msgstr "@t{select-in-shell-word} (@t{ia})"

#. type: table
#: zsh.texi:18963
msgid "Select the current command argument applying the normal rules for quoting. If the argument begins and ends with matching quote characters, these are not included in the selection."
msgstr "按常规引号规则选择当前命令参数。如果参数以匹配的引号字符开始和结束，则不在选择范围内。"

#. type: tindex
#: zsh.texi:18964
#, no-wrap
msgid "select-in-word"
msgstr "select-in-word"

#. type: item
#: zsh.texi:18965
#, no-wrap
msgid "@t{select-in-word} (@t{iw})"
msgstr "@t{select-in-word} (@t{iw})"

#. type: table
#: zsh.texi:18968
msgid "Select a word, using the normal vi-style word definition. With a numeric argument, multiple words will be selected."
msgstr "使用普通的 vi-style 单词定义选择一个单词, 使用数字参数时，将选择多个单词。"

#. type: vindex
#: zsh.texi:18978
#, no-wrap
msgid "zle_highlight, setting"
msgstr "zle_highlight, setting"

#. type: Plain text
#: zsh.texi:18982
msgid ""
"The line editor has the ability to highlight characters or regions of the line that have a particular significance.  This is controlled by the array parameter @t{zle_highlight}, if it has been set by the "
"user."
msgstr "行编辑器可以高亮显示行中具有特殊意义的字符或区域。 如果用户设置了这一功能，则由数组参数 @t{zle_highlight} 控制。"

#. type: Plain text
#: zsh.texi:18986
msgid "If the parameter contains the single entry @t{none} all highlighting is turned off.  Note the parameter is still expected to be an array."
msgstr "如果参数只包含 @t{none}，则所有高亮都会关闭。 请注意，该参数仍应是一个数组。"

#. type: Plain text
#: zsh.texi:18991
msgid "Otherwise each entry of the array should consist of a word indicating a context for highlighting, then a colon, then a comma-separated list of the types of highlighting to apply in that context."
msgstr "否则，数组的每个条目都应由一个表示高亮上下文的单词，然后一个冒号，接着一个用逗号分隔的列表组成，列表中列出了在该上下文中应用的高亮类型。"

#. type: Plain text
#: zsh.texi:18994
msgid "The contexts available for highlighting are the following:"
msgstr "可用于高亮显示的上下文如下："

#. type: cindex
#: zsh.texi:18997
#, no-wrap
msgid "region, highlighting"
msgstr "区域, 高亮"

#. type: cindex
#: zsh.texi:18998
#, no-wrap
msgid "highlighting, region"
msgstr "高亮, 区域"

#. type: t{#1}
#: zsh.texi:18999 zsh.texi:21492 zsh.texi:36728 zsh.texi:38177
#, no-wrap
msgid "default"
msgstr "default"

#. type: table
#: zsh.texi:19002
msgid "Any text within the command line not affected by any other highlighting.  Text outside the editable area of the command line is not affected."
msgstr "Any text within the command line not affected by any other highlighting.  Text outside the editable area of the command line is not affected."

#. type: table
#: zsh.texi:19006
msgid "When one of the incremental history search widgets is active, the area of the command line matched by the search string or pattern."
msgstr "当增量历史搜索小部件之一处于活动状态时，搜索字符串或模式所匹配的命令行区域。"

#. type: t{#1}
#: zsh.texi:19007
#, no-wrap
msgid "region"
msgstr "region"

#. type: table
#: zsh.texi:19016
msgid ""
"The currently selected text. In emacs terminology, this is referred to as the region and is bounded by the cursor (point) and the mark. The region is only highlighted if it is active, which is the case "
"after the mark is modified with @t{set-mark-command} or @t{exchange-point-and-mark}.  Note that whether or not the region is active has no effect on its use within emacs style widgets, it simply "
"determines whether it is highlighted. In vi mode, the region corresponds to selected text in visual mode."
msgstr ""
"当前选中的文本。在 emacs 术语中，这被称为区域，以光标（点）和标记为边界。只有在使用 @t{set-mark-command} 或 @t{exchange-point-and-mark} 命令修改标记后，该区域才会突出显示。 需要注意的是，区域是否激活对其"
"在 emacs 风格小部件中的使用没有影响，它只是决定是否高亮显示。在 vi 模式下，该区域与可视化模式下的选定文本相对应。"

#. type: cindex
#: zsh.texi:19017
#, no-wrap
msgid "special characters, highlighting"
msgstr "特殊字符, 高亮"

#. type: cindex
#: zsh.texi:19018
#, no-wrap
msgid "highlighting, special characters"
msgstr "高亮, 特殊字符"

#. type: table
#: zsh.texi:19023
msgid "Individual characters that have no direct printable representation but are shown in a special manner by the line editor.  These characters are described below."
msgstr "没有直接可打印表示，但行编辑器以特殊方式显示的单个字符。 下文将对这些字符进行说明。"

#. type: cindex
#: zsh.texi:19024
#, no-wrap
msgid "completion removable suffix, highlighting"
msgstr "补全可删除后缀, 高亮"

#. type: cindex
#: zsh.texi:19025
#, no-wrap
msgid "suffix, highlighting removable, in completion"
msgstr "后缀, 高亮可删除, 在补全中"

#. type: cindex
#: zsh.texi:19026
#, no-wrap
msgid "removable suffix, highlighting in completion"
msgstr "可删除后缀, 在补全中高亮"

#. type: t{#1}
#: zsh.texi:19027 zsh.texi:23519
#, no-wrap
msgid "suffix"
msgstr "suffix"

#. type: table
#: zsh.texi:19034
msgid ""
"This context is used in completion for characters that are marked as suffixes that will be removed if the completion ends at that point, the most obvious example being a slash (@t{/}) after a directory "
"name.  Note that suffix removal is configurable; the circumstances under which the suffix will be removed may differ for different completions."
msgstr "该上下文在补全中用于标记为后缀的字符，如果补全在该处结束，这些字符将被移除，最明显的例子是目录名后的斜线 (@t{/})。 请注意，后缀移除是可配置的；不同的补全可能会在不同的情况下移除后缀。"

#. type: t{#1}
#: zsh.texi:19035
#, no-wrap
msgid "paste"
msgstr "paste"

#. type: table
#: zsh.texi:19037
msgid "Following a command to paste text, the characters that were inserted."
msgstr "执行粘贴文本的命令后，会显示插入的字符。"

#. type: Plain text
#: zsh.texi:19046
msgid ""
"When @t{region_highlight} is set, the contexts that describe a region --- @t{isearch}, @t{region}, @t{suffix}, and @t{paste} --- are applied first, then @t{region_highlight} is applied, then the remaining "
"@t{zle_highlight} contexts are applied.  If a particular character is affected by multiple specifications, the last specification wins."
msgstr ""
"设置 @t{region_highlight} 时，首先应用描述区域的上下文 --- @t{isearch}、@t{region}、@t{suffix} 和 @t{paste} --- 然后应用 @t{region_highlight}，最后应用其余的 @t{zle_highlight} 上下文。 如果某个字符受到多个"
"规范的影响，则最后一个规范胜出。"

#. type: Plain text
#: zsh.texi:19053
msgid ""
"@t{zle_highlight} may contain additional fields for controlling how terminal sequences to change colours are output.  Each of the following is followed by a colon and a string in the same form as for key "
"bindings.  This will not be necessary for the vast majority of terminals as the defaults shown in parentheses are widely used."
msgstr ""
"@t{zle_highlight} 可能包含其他字段，用于控制如何输出改变颜色的终端序列。 以下每个字段后面都有一个冒号和一个字符串，形式与按键绑定相同。 由于括号中显示的默认值已被广泛使用，因此绝大多数终端都不需要这样做。"

#. type: cindex
#: zsh.texi:19056
#, no-wrap
msgid "escape sequences, terminal, for highlighting"
msgstr "转义序列, 终端, 用于高亮"

#. type: cindex
#: zsh.texi:19057
#, no-wrap
msgid "terminal escape sequences for highlighting"
msgstr "用于高亮的终端转义序列"

#. type: item
#: zsh.texi:19058
#, no-wrap
msgid "@t{fg_start_code} (@t{\\e[3})"
msgstr "@t{fg_start_code} (@t{\\e[3})"

#. type: table
#: zsh.texi:19063
msgid ""
"The start of the escape sequence for the foreground colour.  This is followed by one to three ASCII digits representing the colour.  Only used for palette colors, i.e. not 24-bit colors specified via a "
"color triplet."
msgstr "前景色转义序列的起始位置。 随后是代表颜色的一至三位 ASCII 数字。 仅用于调色板颜色，即不是通过颜色三连字符指定的 24 位颜色。"

#. type: item
#: zsh.texi:19064
#, no-wrap
msgid "@t{fg_default_code} (@t{9})"
msgstr "@t{fg_default_code} (@t{9})"

#. type: table
#: zsh.texi:19067
msgid "The number to use instead of the colour to reset the default foreground colour."
msgstr "用来代替颜色的数字，以重置默认前景色。"

#. type: item
#: zsh.texi:19068
#, no-wrap
msgid "@t{fg_end_code} (@t{m})"
msgstr "@t{fg_end_code} (@t{m})"

#. type: table
#: zsh.texi:19070
msgid "The end of the escape sequence for the foreground colour."
msgstr "前景色转义序列的终点。"

#. type: item
#: zsh.texi:19071
#, no-wrap
msgid "@t{bg_start_code} (@t{\\e[4})"
msgstr "@t{bg_start_code} (@t{\\e[4})"

#. type: table
#: zsh.texi:19074
msgid "The start of the escape sequence for the background colour.  See @t{fg_start_code} above."
msgstr "背景色转义序列的起始位置。 参见上文 @t{fg_start_code}。"

#. type: item
#: zsh.texi:19075
#, no-wrap
msgid "@t{bg_default_code} (@t{9})"
msgstr "@t{bg_default_code} (@t{9})"

#. type: table
#: zsh.texi:19078
msgid "The number to use instead of the colour to reset the default background colour."
msgstr "用来代替颜色的数字，以重置默认背景颜色。"

#. type: item
#: zsh.texi:19079
#, no-wrap
msgid "@t{bg_end_code} (@t{m})"
msgstr "@t{bg_end_code} (@t{m})"

#. type: table
#: zsh.texi:19081
msgid "The end of the escape sequence for the background colour."
msgstr "背景色转义序列的结束。"

#. type: Plain text
#: zsh.texi:19087
msgid "The available types of highlighting are the following.  Note that not all types of highlighting are available on all terminals:"
msgstr "可用的高亮类型如下。请注意，并非所有终端都支持所有类型的高亮："

#. type: t{#1}
#: zsh.texi:19090
#, no-wrap
msgid "none"
msgstr "none"

#. type: table
#: zsh.texi:19094
msgid "No highlighting is applied to the given context.  It is not useful for this to appear with other types of highlighting; it is used to override a default."
msgstr "不对给定上下文应用高亮。 与其他类型的高亮同时出现并无用处；它用于覆盖默认值。"

#. type: item
#: zsh.texi:19095
#, no-wrap
msgid "@t{fg=}@var{colour}"
msgstr "@t{fg=}@var{colour}"

#. type: table
#: zsh.texi:19099
msgid "The foreground colour should be set to @var{colour}, a decimal integer, the name of one of the eight most widely-supported colours or as a `@t{#}' followed by an RGB triplet in hexadecimal format."
msgstr "前景色应设置为 @var{colour}，即一个十进制整数，最广泛支持的八种颜色之一的名称，或者设置为 `@t{#}' 后面跟一个十六进制格式的 RGB 三连字符。"

#. type: table
#: zsh.texi:19109
msgid ""
"Not all terminals support this and, of those that do, not all provide facilities to test the support, hence the user should decide based on the terminal type.  Most terminals support the colours "
"@t{black}, @t{red}, @t{green}, @t{yellow}, @t{blue}, @t{magenta}, @t{cyan} and @t{white}, which can be set by name.  In addition. @t{default} may be used to set the terminal's default foreground colour.  "
"Abbreviations are allowed; @t{b} or @t{bl} selects black.  Some terminals may generate additional colours if the @t{bold} attribute is also present."
msgstr ""
"并非所有终端都支持此功能，而在支持此功能的终端中，也并非所有终端都提供测试功能，因此用户应根据终端类型来决定。 大多数终端都支持 @t{black}, @t{red}, @t{green}, @t{yellow}, @t{blue}, @t{magenta}, @t{cyan} "
"和 @t{white}，这些颜色可以通过名称来设置。 此外 @t{default} 可用于设置终端的默认前景色。 可以使用缩写；@t{b} 或 @t{bl} 选择黑色。 如果同时存在 @t{bold} 属性，某些终端可能会生成其他颜色。"

#. type: table
#: zsh.texi:19116
msgid ""
"On recent terminals and on systems with an up-to-date terminal database the number of colours supported may be tested by the command `@t{echotc Co}'; if this succeeds, it indicates a limit on the number "
"of colours which will be enforced by the line editor.  The number of colours is in any case limited to 256 (i.e. the range 0 to 255)."
msgstr ""
"在最新的终端和拥有最新终端数据库的系统上，可以通过命令  `@t{echotc Co}' 来测试支持的颜色数量；如果测试成功，则表明行编辑器将执行的颜色数量限制。 在任何情况下，颜色数都不得超过 256 种（即范围 0 至 255）。"

#. type: table
#: zsh.texi:19124
msgid ""
"Some modern terminal emulators have support for 24-bit true colour (16 million colours). In this case, the hex triplet format can be used. This consists of a `@t{#}' followed by either a three or six "
"digit hexadecimal number describing the red, green and blue components of the colour. Hex triplets can also be used with 88 and 256 colour terminals via the @t{zsh/nearcolor} module (see @ref{The zsh/"
"nearcolor Module})."
msgstr ""
"某些现代终端模拟器支持 24 位真彩色（1600 万色）。在这种情况下，可以使用十六进制三连字符格式。这包括一个 `@t{#}' ，后面跟一个三位或六位十六进制数，描述颜色的红、绿、蓝分量。通过 @t{zsh/nearcolor} 模块（参"
"见 @ref{zsh/nearcolor 模块}），十六进制三连串也可用于 88 和 256 色终端。"

#. type: table
#: zsh.texi:19127
msgid "Colour is also known as color."
msgstr "Colour 也是 color。"

#. type: item
#: zsh.texi:19128
#, no-wrap
msgid "@t{bg=}@var{colour}"
msgstr "@t{bg=}@var{colour}"

#. type: table
#: zsh.texi:19132
msgid "The background colour should be set to @var{colour}.  This works similarly to the foreground colour, except the background is not usually affected by the bold attribute."
msgstr "背景颜色应设置为 @var{colour}。 其作用与前景色类似，只是背景色通常不受粗体属性的影响。"

#. type: t{#1}
#: zsh.texi:19133
#, no-wrap
msgid "bold"
msgstr "bold"

#. type: table
#: zsh.texi:19136
msgid "The characters in the given context are shown in a bold font.  Not all terminals distinguish bold fonts."
msgstr "给定上下文中的字符以粗体显示。 并非所有终端都能区分粗体字体。"

#. type: t{#1}
#: zsh.texi:19137
#, no-wrap
msgid "standout"
msgstr "standout"

#. type: table
#: zsh.texi:19144
msgid ""
"The characters in the given context are shown in the terminal's standout mode.  The actual effect is specific to the terminal; on many terminals it is inverse video.  On some such terminals, where the "
"cursor does not blink it appears with standout mode negated, making it less than clear where the cursor actually is.  On such terminals one of the other effects may be preferable for highlighting the "
"region and matched search string."
msgstr ""
"给定上下文中的字符以终端的突出模式显示。 实际效果因终端而异；在许多终端上是反向视频。 在某些终端上，如果光标不闪烁，它就会以与突出模式相反出现，从而使光标的实际位置不太清晰。 在这些终端上，其他效果之一可能"
"更适合高亮显示区域和匹配的搜索字符串。"

#. type: t{#1}
#: zsh.texi:19145
#, no-wrap
msgid "underline"
msgstr "underline"

#. type: table
#: zsh.texi:19149
msgid "The characters in the given context are shown underlined.  Some terminals show the foreground in a different colour instead; in this case whitespace will not be highlighted."
msgstr "给定上下文中的字符以下划线显示。 有些终端会用不同的颜色显示前景；在这种情况下，空白不会高亮显示。"

#. type: Plain text
#: zsh.texi:19156
msgid "The characters described above as `special' are as follows.  The formatting described here is used irrespective of whether the characters are highlighted:"
msgstr "上述 `特殊' 字符如下。 无论这些字符是否高亮显示，此处描述的格式都将使用："

#. type: item
#: zsh.texi:19159
#, no-wrap
msgid "ASCII control characters"
msgstr "ASCII 控制字符"

#. type: table
#: zsh.texi:19162
msgid "Control characters in the ASCII range are shown as `@t{^}' followed by the base character."
msgstr "ASCII 范围内的控制字符显示为 `@t{^}' ，后跟基本字符。"

#. type: item
#: zsh.texi:19163
#, no-wrap
msgid "Unprintable multibyte characters"
msgstr "不可打印的多字节字符"

#. type: table
#: zsh.texi:19171
msgid ""
"This item applies to control characters not in the ASCII range, plus other characters as follows.  If the @t{MULTIBYTE} option is in effect, multibyte characters not in the ASCII character set that are "
"reported as having zero width are treated as combining characters when the option @t{COMBINING_CHARS} is on.  If the option is off, or if a character appears where a combining character is not valid, the "
"character is treated as unprintable."
msgstr ""
"该项适用于不在 ASCII 范围内的控制字符，以及以下其他字符。 如果 @t{MULTIBYTE} 选项有效，当 @t{COMBINING_CHARS} 选项开启时，不在 ASCII 字符集中的多字节字符如果被报告为宽度为零，则会被视为组合字符。 如果该选"
"项处于关闭状态，或者出现的字符不是有效的组合字符，则该字符将被视为不可打印字符。"

#. type: table
#: zsh.texi:19177
msgid ""
"Unprintable multibyte characters are shown as a hexadecimal number between angle brackets.  The number is the code point of the character in the wide character set; this may or may not be Unicode, "
"depending on the operating system."
msgstr "无法打印的多字节字符以十六进制数字显示在角括号之间。 该数字是该字符在广义字符集中的码位；这可能是也可能不是 Unicode，取决于操作系统。"

#. type: item
#: zsh.texi:19178
#, no-wrap
msgid "Invalid multibyte characters"
msgstr "无效多字节字符"

#. type: table
#: zsh.texi:19187
msgid ""
"If the @t{MULTIBYTE} option is in effect, any sequence of one or more bytes that does not form a valid character in the current character set is treated as a series of bytes each shown as a special "
"character.  This case can be distinguished from other unprintable characters as the bytes are represented as two hexadecimal digits between angle brackets, as distinct from the four or eight digits that "
"are used for unprintable characters that are nonetheless valid in the current character set."
msgstr ""
"如果 @t{MULTIBYTE} 选项生效，那么任何一个或多个字节的序列，如果在当前字符集中不构成有效字符，将被视为一系列以特殊字符显示的字节。这种情况可以与其他不可打印字符加以区分，因为这些字节将以尖括号内的两个十六进"
"制数字表示，与那些在当前字符集中仍然有效但不可打印的字符所用的四个或八个数字是不同的。"

#. type: table
#: zsh.texi:19192
msgid "Not all systems support this: for it to work, the system's representation of wide characters must be code values from the Universal Character Set, as defined by IS0 10646 (also known as Unicode)."
msgstr "并非所有系统都支持这种方法：要使其有效，系统对宽字符的表示必须是 IS0 10646（也称作 Unicode）定义的通用字符集中的代码值。"

#. type: item
#: zsh.texi:19193
#, no-wrap
msgid "Wrapped double-width characters"
msgstr "封装的双宽度字符"

#. type: table
#: zsh.texi:19197
msgid "When a double-width character appears in the final column of a line, it is instead shown on the next line. The empty space left in the original position is highlighted as a special character."
msgstr "当双倍宽度字符出现在一行的最后一列时，它将显示在下一行。原位置留下的空格将作为特殊字符高亮显示。"

#. type: Plain text
#: zsh.texi:19203
msgid "If @t{zle_highlight} is not set or no value applies to a particular context, the defaults applied are equivalent to"
msgstr "如果未设置 @t{zle_highlight}，或者没有适用于特定上下文的值，则应用的默认值相当于"

#. type: example
#: zsh.texi:19208
#, no-wrap
msgid ""
"zle_highlight=(region:standout special:standout\n"
"suffix:bold isearch:underline paste:standout)\n"
msgstr ""
"zle_highlight=(region:standout special:standout\n"
"suffix:bold isearch:underline paste:standout)\n"

#. type: Plain text
#: zsh.texi:19212
msgid "i.e. both the region and special characters are shown in standout mode."
msgstr "即区域字符和特殊字符都以高亮模式显示。"

#. type: Plain text
#: zsh.texi:19217
msgid "Within widgets, arbitrary regions may be highlighted by setting the special array parameter @t{region_highlight}; see @ref{Zle Widgets}."
msgstr "在小部件中，可以通过设置特殊数组参数 @t{region_highlight} 来突出显示任意区域；请参阅 @ref{Zle 小部件}。"

#. type: cindex
#: zsh.texi:19225
#, no-wrap
msgid "completion, widgets"
msgstr "补全, 小部件"

#. type: cindex
#: zsh.texi:19226 zsh.texi:20551 zsh.texi:26825
#, no-wrap
msgid "completion, programmable"
msgstr "补全, 可编程"

#. type: cindex
#: zsh.texi:19227 zsh.texi:20552 zsh.texi:26826
#, no-wrap
msgid "completion, controlling"
msgstr "补全, 控制"

#. type: Plain text
#: zsh.texi:19241
msgid ""
"The shell's programmable completion mechanism can be manipulated in two ways; here the low-level features supporting the newer, function-based mechanism are defined.  A complete set of shell functions "
"based on these features is described in the next chapter, @ref{Completion System}, and users with no interest in adding to that system (or, potentially, writing their own --- see dictionary entry for "
"`hubris') should skip the current section.  The older system based on the @t{compctl} builtin command is described in @ref{Completion Using compctl}."
msgstr ""
"shell 的可编程补全机制有两种操作方式；这里定义了支持较新的、基于函数的机制的底层特性。 基于这些特性的一整套 shell 函数将在下一章 @ref{补全系统} 中介绍，没有兴趣添加到该系统（或编写自己的系统 -- 参见词典中"
"的 `hubris' 条目<dictionary entry>）的用户可以跳过本节。 基于 @t{compctl} 内置命令的旧版系统将在 @ref{用 compctl 补全} 中介绍。"

#. type: Plain text
#: zsh.texi:19246
msgid "Completion widgets are defined by the @t{-C} option to the @t{zle} builtin command provided by the @t{zsh/zle} module (see @ref{The zsh/zle Module}). For example,"
msgstr "补全部件由 @t{zsh/zle} 模块提供的 @t{zle} 内置命令的 @t{-C} 选项定义（参见 @ref{zsh/zle 模块}）。例如"

#. type: example
#: zsh.texi:19250
#, no-wrap
msgid "zle -C complete expand-or-complete completer\n"
msgstr "zle -C complete expand-or-complete completer\n"

#. type: Plain text
#: zsh.texi:19260
msgid ""
"defines a widget named `@t{complete}'.  The second argument is the name of any of the builtin widgets that handle completions: @t{complete-word}, @t{expand-or-complete}, @t{expand-or-complete-prefix}, "
"@t{menu-complete}, @t{menu-expand-or-complete}, @t{reverse-menu-complete}, @t{list-choices}, or @t{delete-char-or-list}.  Note that this will still work even if the widget in question has been re-bound."
msgstr ""
"定义了一个名为 `@t{complete}' 的小部件。 第二个参数是处理补全的任何内置小部件的名称： @t{complete-word}、@t{expand-or-complete}、@t{expand-or-complete-prefix}、@t{menu-complete}、@t{menu-expand-or-"
"complete}、@t{reverse-menu-complete}、@t{list-choices} 或 @t{delete-char-or-list}。 请注意，即使相关小部件已被重新绑定，该功能仍将有效。"

#. type: Plain text
#: zsh.texi:19268
msgid ""
"When this newly defined widget is bound to a key using the @t{bindkey} builtin command defined in the @t{zsh/zle} module (@ref{Zsh Line Editor}), typing that key will call the shell function "
"`@t{completer}'. This function is responsible for generating completion matches using the builtins described below.  As with other ZLE widgets, the function is called with its standard input closed."
msgstr ""
"当使用 @t{zsh/zle} 模块（@ref{Zsh 行编辑器}）中定义的 @t{bindkey} 内置命令将这个新定义的 小部件 与某个按键绑定时，键入该按键将调用 shell 函数 `@t{completer}'。该函数负责使用下文所述的内置命令生成补全匹"
"配。 与其他 ZLE 小部件一样，该函数在调用时关闭了标准输入。"

#. type: Plain text
#: zsh.texi:19273
msgid "Once the function returns, the completion code takes over control again and treats the matches in the same manner as the specified builtin widget, in this case @t{expand-or-complete}."
msgstr "一旦函数返回，补全代码将再次接管控制权，并以与指定的内置小部件（在本例中为 @t{expand-or-complete}）相同的方式处理匹配结果。"

#. type: node
#: zsh.texi:19284 zsh.texi:19286 zsh.texi:19692
#, no-wrap
msgid "Completion Special Parameters"
msgstr "补全特殊参数"

#. type: node
#: zsh.texi:19284 zsh.texi:19692 zsh.texi:19694 zsh.texi:20146
#, no-wrap
msgid "Completion Builtin Commands"
msgstr "补全内置命令"

#. type: Plain text
#: zsh.texi:19293
msgid "The parameters @t{ZLE_REMOVE_SUFFIX_CHARS} and @t{ZLE_SPACE_SUFFIX_CHARS} are used by the completion mechanism, but are not special. See @ref{Parameters Used By The Shell}."
msgstr "参数 @t{ZLE_REMOVE_SUFFIX_CHARS} 和 @t{ZLE_SPACE_SUFFIX_CHARS} 用于补全机制，但并不特殊。请参阅 @ref{Shell 使用的参数}。"

#. type: Plain text
#: zsh.texi:19305
msgid ""
"Inside completion widgets, and any functions called from them, some parameters have special meaning; outside these functions they are not special to the shell in any way.  These parameters are used to "
"pass information between the completion code and the completion widget. Some of the builtin commands and the condition codes use or change the current values of these parameters.  Any existing values will "
"be hidden during execution of completion widgets; except for @t{compstate}, the parameters are reset on each function exit (including nested function calls from within the completion widget) to the values "
"they had when the function was entered."
msgstr ""
"在补全小部件内部，以及从它们调用的任何函数中，有些参数具有特殊意义；在这些函数之外，它们对 shell 没有任何特殊意义。 这些参数用于在补全代码和补全小部件之间传递信息。某些内置命令和条件代码会使用或更改这些参"
"数的当前值。 在执行补全小部件时，任何现有的值都将被隐藏；除了 @t{compstate} 之外，这些参数在每次函数退出时（包括补全小部件内部的嵌套函数调用）都会被重置为进入函数时的值。"

#. type: t{#1}
#: zsh.texi:19308 zsh.texi:19309
#, no-wrap
msgid "CURRENT"
msgstr "CURRENT"

#. type: table
#: zsh.texi:19313
msgid "This is the number of the current word, i.e. the word the cursor is currently on in the @t{words} array.  Note that this value is only correct if the @t{ksharrays} option is not set."
msgstr "这是当前单词的编号，即 @t{words} 数组中光标当前所在单词的编号。 请注意，只有在未设置 @t{ksharrays} 选项的情况下，此值才是正确的。"

#. type: t{#1}
#: zsh.texi:19314 zsh.texi:19315
#, no-wrap
msgid "IPREFIX"
msgstr "IPREFIX"

#. type: table
#: zsh.texi:19321
msgid ""
"Initially this will be set to the empty string.  This parameter functions like @t{PREFIX}; it contains a string which precedes the one in @t{PREFIX} and is not considered part of the list of matches.  "
"Typically, a string is transferred from the beginning of @t{PREFIX} to the end of @t{IPREFIX}, for example:"
msgstr "初始值为空字符串。 该参数的功能与 @t{PREFIX} 类似；它包含的字符串在 @t{PREFIX} 之前，不被视为匹配列表的一部分。 例如，通常情况下，一个字符串会从 @t{PREFIX} 的开头转到 @t{IPREFIX} 的结尾："

#. type: example
#: zsh.texi:19326
#, no-wrap
msgid ""
"IPREFIX=$@{PREFIX%%\\=*@}=\n"
"PREFIX=$@{PREFIX#*=@}\n"
msgstr ""
"IPREFIX=$@{PREFIX%%\\=*@}=\n"
"PREFIX=$@{PREFIX#*=@}\n"

#. type: table
#: zsh.texi:19332
msgid "causes the part of the prefix up to and including the first equal sign not to be treated as part of a matched string.  This can be done automatically by the @t{compset} builtin, see below."
msgstr "会导致前缀中包括第一个等号在内的部分不被视为匹配字符串的一部分。 @t{compset} 内置函数可以自动做到这一点，见下文。"

#. type: t{#1}
#: zsh.texi:19333 zsh.texi:19334
#, no-wrap
msgid "ISUFFIX"
msgstr "ISUFFIX"

#. type: table
#: zsh.texi:19338
msgid "As @t{IPREFIX}, but for a suffix that should not be considered part of the matches; note that the @t{ISUFFIX} string follows the @t{SUFFIX} string."
msgstr "与 @t{IPREFIX}相同，但后缀不应被视为匹配的一部分；注意 @t{ISUFFIX} 字符串位于 @t{SUFFIX} 字符串之后。"

#. type: t{#1}
#: zsh.texi:19339 zsh.texi:19340
#, no-wrap
msgid "PREFIX"
msgstr "PREFIX"

#. type: table
#: zsh.texi:19344
msgid "Initially this will be set to the part of the current word from the beginning of the word up to the position of the cursor; it may be altered to give a common prefix for all matches."
msgstr "最初，将设置为当前单词从开头到光标位置的部分；也可以更改，以便为所有匹配提供一个通用前缀。"

#. type: t{#1}
#: zsh.texi:19345 zsh.texi:19346
#, no-wrap
msgid "QIPREFIX"
msgstr "QIPREFIX"

#. type: table
#: zsh.texi:19352
msgid ""
"This parameter is read-only and contains the quoted string up to the word being completed. E.g. when completing `@t{\"foo}', this parameter contains the double quote. If the @t{-q} option of @t{compset} "
"is used (see below), and the original string was `@t{\"foo bar}' with the cursor on the `@t{bar}', this parameter contains `@t{\"foo }'."
msgstr ""
"这个参数是只读的，包含引号字符串到正在补全的单词为止。例如，在补全 `@t{\"foo}' 时，该参数包含双引号。如果使用了@t{compset}的@t{-q}选项(见下文)，并且原始字符串是 `@t{\"foo bar}'，且光标在 `@t{bar}' 上，那么"
"这个参数包含 `@t{\"foo }'。"

#. type: t{#1}
#: zsh.texi:19353 zsh.texi:19354
#, no-wrap
msgid "QISUFFIX"
msgstr "QISUFFIX"

#. type: table
#: zsh.texi:19356
msgid "Like @t{QIPREFIX}, but containing the suffix."
msgstr "与 @t{QIPREFIX} 类似，但包含后缀。"

#. type: t{#1}
#: zsh.texi:19357 zsh.texi:19358
#, no-wrap
msgid "SUFFIX"
msgstr "SUFFIX"

#. type: table
#: zsh.texi:19364
msgid ""
"Initially this will be set to the part of the current word from the cursor position to the end; it may be altered to give a common suffix for all matches.  It is most useful when the option "
"@t{COMPLETE_IN_WORD} is set, as otherwise the whole word on the command line is treated as a prefix."
msgstr "初始，它将被设置为当前单词从光标位置到末尾的部分；也可以进行修改，为所有匹配的单词提供一个共同的后缀。 当设置了 @t{COMPLETE_IN_WORD} 选项时，它的作用最大，否则命令行中的整个单词都会被视为前缀。"

#. type: t{#1}
#: zsh.texi:19365 zsh.texi:19367
#, no-wrap
msgid "compstate"
msgstr "compstate"

#. type: cindex
#: zsh.texi:19366
#, no-wrap
msgid "completion widgets, examining and setting state in"
msgstr "补全小部件，测试和设置状态为"

#. type: table
#: zsh.texi:19371
msgid "This is an associative array with various keys and values that the completion code uses to exchange information with the completion widget.  The keys are:"
msgstr "这是一个关联数组，包含不同的键和值，补全代码用它来与补全小部件交换信息。 键是"

#. type: vindex
#: zsh.texi:19374
#, no-wrap
msgid "all_quotes, compstate"
msgstr "all_quotes, compstate"

#. type: t{#1}
#: zsh.texi:19375
#, no-wrap
msgid "all_quotes"
msgstr "all_quotes"

#. type: table
#: zsh.texi:19387
msgid ""
"The @t{-q} option of the @t{compset} builtin command (see below)  allows a quoted string to be broken into separate words; if the cursor is on one of those words, that word will be completed, possibly "
"invoking `@t{compset -q}' recursively.  With this key it is possible to test the types of quoted strings which are currently broken into parts in this fashion.  Its value contains one character for each "
"quoting level.  The characters are a single quote or a double quote for strings quoted with these characters, a dollars sign for strings quoted with @t{$'}@var{...}@t{'} and a backslash for strings not "
"starting with a quote character.  The first character in the value always corresponds to the innermost quoting level."
msgstr ""
"@t{compset} 内置命令的 @t{-q} 选项（见下文）允许将引号字符串分解为不同的单词；如果光标位于其中一个单词上，该单词将被补全，并可能递归调用 `@t{compset -q}' 。 使用该键可以测试当前以这种方式分解的引号字符串类"
"型。 它的值包含每个引号级别的一个字符。 对于使用单引号或双引号加引号的字符串，这些字符是单引号或双引号；对于使用 @t{$'}@var{...}@t{'}  加引号的字符串，这些字符是美元符号；对于不以引号字符开头的字符串，这些"
"字符是反斜杠。 值中的第一个字符始终对应于最内层的引号。"

#. type: vindex
#: zsh.texi:19388
#, no-wrap
msgid "context, compstate"
msgstr "context, compstate"

#. type: t{#1}
#: zsh.texi:19389 zsh.texi:37476
#, no-wrap
msgid "context"
msgstr "context"

#. type: table
#: zsh.texi:19392
msgid "This will be set by the completion code to the overall context in which completion is attempted. Possible values are:"
msgstr "这将由补全代码设置为尝试补全的整体上下文。可能的取值包括："

#. type: t{#1}
#: zsh.texi:19395
#, no-wrap
msgid "array_value"
msgstr "array_value"

#. type: table
#: zsh.texi:19398
msgid "when completing inside the value of an array parameter assignment; in this case the @t{words} array contains the words inside the parentheses."
msgstr "在数组参数赋值的值内补全时；在本例中，@t{words} 数组包含括号内的单词。"

#. type: t{#1}
#: zsh.texi:19399
#, no-wrap
msgid "brace_parameter"
msgstr "brace_parameter"

#. type: table
#: zsh.texi:19405
msgid ""
"when completing the name of a parameter in a parameter expansion beginning with @t{$@{}.  This context will also be set when completing parameter flags following @t{$@{(}; the full command line argument "
"is presented and the handler must test the value to be completed to ascertain that this is the case."
msgstr "在以 @t{$@{} 开头的参数扩展中补全参数名称时，也会设置该上下文。 在@t{$@{(}之后补全参数标志时，也将设置这种上下文；完整的命令行参数会呈现出来，处理程序必须测试要补全的值，以确定情况是否如此。"

#. type: t{#1}
#: zsh.texi:19406
#, no-wrap
msgid "assign_parameter"
msgstr "assign_parameter"

#. type: table
#: zsh.texi:19408
msgid "when completing the name of a parameter in a parameter assignment."
msgstr "在参数赋值中补全参数名称时。"

#. type: table
#: zsh.texi:19412
msgid "when completing for a normal command (either in command position or for an argument of the command)."
msgstr "补全普通命令时（在命令位置或用于命令参数）。"

#. type: t{#1}
#: zsh.texi:19413 zsh.texi:22052
#, no-wrap
msgid "condition"
msgstr "condition"

#. type: table
#: zsh.texi:19417
msgid "when completing inside a `@t{[[}...@t{]]}' conditional expression; in this case the @t{words} array contains only the words inside the conditional expression."
msgstr "在 `@t{[[}...@t{]]}' 条件表达式中补全时；在这种情况下，@t{words} 数组只包含条件表达式中的单词。"

#. type: t{#1}
#: zsh.texi:19418
#, no-wrap
msgid "math"
msgstr "math"

#. type: table
#: zsh.texi:19421
msgid "when completing in a mathematical environment such as a `@t{((}...@t{))}' construct."
msgstr "在数学环境中完成时，如 `@t{((}...@t{))}' 构造。"

#. type: t{#1}
#: zsh.texi:19422 zsh.texi:19587
#, no-wrap
msgid "parameter"
msgstr "parameter"

#. type: table
#: zsh.texi:19425
msgid "when completing the name of a parameter in a parameter expansion beginning with @t{$} but not @t{$@{}."
msgstr "在以 @t{$} 开头而不是 @t{$@{} 开头的参数扩展中，补全参数名称时。"

#. type: t{#1}
#: zsh.texi:19426 zsh.texi:19629
#, no-wrap
msgid "redirect"
msgstr "redirect"

#. type: table
#: zsh.texi:19428
msgid "when completing after a redirection operator."
msgstr "当在重定向操作后补全时。"

#. type: t{#1}
#: zsh.texi:19429
#, no-wrap
msgid "subscript"
msgstr "subscript"

#. type: table
#: zsh.texi:19431
msgid "when completing inside a parameter subscript."
msgstr "在参数下标内补全时。"

#. type: t{#1}
#: zsh.texi:19432
#, no-wrap
msgid "value"
msgstr "value"

#. type: table
#: zsh.texi:19434
msgid "when completing the value of a parameter assignment."
msgstr "当补全参数赋值的值时。"

#. type: vindex
#: zsh.texi:19437
#, no-wrap
msgid "exact, compstate"
msgstr "exact, compstate"

#. type: t{#1}
#: zsh.texi:19438
#, no-wrap
msgid "exact"
msgstr "exact"

#. type: table
#: zsh.texi:19442
msgid "Controls the behaviour when the @t{REC_EXACT} option is set.  It will be set to @t{accept} if an exact match would be accepted, and will be unset otherwise."
msgstr "控制设置 @t{REC_EXACT} 选项时的行为。 如果接受精确匹配，则设置为 @t{accept}，否则不设置。"

#. type: table
#: zsh.texi:19446
msgid "If it was set when at least one match equal to the string on the line was generated, the match is accepted."
msgstr "如果在生成行上，至少一个匹配与行上字符串相同时设置了该值，则接受该匹配。"

#. type: vindex
#: zsh.texi:19447
#, no-wrap
msgid "exact_string, compstate"
msgstr "exact_string, compstate"

#. type: t{#1}
#: zsh.texi:19448
#, no-wrap
msgid "exact_string"
msgstr "exact_string"

#. type: table
#: zsh.texi:19450
msgid "The string of an exact match if one was found, otherwise unset."
msgstr "如果找到完全匹配的字符串，则为该字符串，否则为未设置字符串。"

#. type: vindex
#: zsh.texi:19451
#, no-wrap
msgid "ignored, compstate"
msgstr "ignored, compstate"

#. type: t{#1}
#: zsh.texi:19452
#, no-wrap
msgid "ignored"
msgstr "ignored"

#. type: table
#: zsh.texi:19456
msgid "The number of completions that were ignored because they matched one of the patterns given with the @t{-F} option to the @t{compadd} builtin command."
msgstr "由于与 @t{compadd} 内置命令 @t{-F} 选项中给出的模式之一相匹配而被忽略的补全次数。"

#. type: vindex
#: zsh.texi:19457
#, no-wrap
msgid "insert, compstate"
msgstr "insert, compstate"

#. type: t{#1}
#: zsh.texi:19458 zsh.texi:22604
#, no-wrap
msgid "insert"
msgstr "insert"

#. type: table
#: zsh.texi:19471
msgid ""
"This controls the manner in which a match is inserted into the command line.  On entry to the widget function, if it is unset the command line is not to be changed; if set to @t{unambiguous}, any prefix "
"common to all matches is to be inserted; if set to @t{automenu-unambiguous}, the common prefix is to be inserted and the next invocation of the completion code may start menu completion (due to the "
"@t{AUTO_MENU} option being set); if set to @t{menu} or @t{automenu} menu completion will be started for the matches currently generated (in the latter case this will happen because the @t{AUTO_MENU} is "
"set). The value may also contain the string `@t{tab}' when the completion code would normally not really do completion, but only insert the TAB character."
msgstr ""
"它控制着将匹配信息插入命令行的方式。 在进入小部件函数时，如果未设置，命令行将不会被更改；如果设置为 @t{unambiguous}，则会插入所有匹配的通用前缀；如果设置为 @t{automenu-unambiguous}，则会插入通用前缀，下次"
"调用补全代码时可能会启动菜单补全（由于设置了 @t{AUTO_MENU}选项）； 如果设置为 @t{menu} 或 @t{automenu}，则将为当前生成的匹配启动菜单补全（在后一种情况下，这是因为设置了 @t{AUTO_MENU}）。该值还可能包含字符"
"串 `@t{tab}' ，此时补全代码通常不会真正执行补全，而只会插入 TAB 字符。"

#. type: table
#: zsh.texi:19482
msgid ""
"On exit it may be set to any of the values above (where setting it to the empty string is the same as unsetting it), or to a number, in which case the match whose number is given will be inserted into the "
"command line.  Negative numbers count backward from the last match (with `@t{-1}' selecting the last match) and out-of-range values are wrapped around, so that a value of zero selects the last match and a "
"value one more than the maximum selects the first. Unless the value of this key ends in a space, the match is inserted as in a menu completion, i.e. without automatically appending a space."
msgstr ""
"退出时，它可以被设置为上述任意值（设置为空字符串与取消设置相同），也可以被设置为一个数字，在这种情况下，给出数字的匹配项将被插入命令行。 负数从最后一个匹配项开始倒数（ `@t{-1}' 选择最后一个匹配项），超出范"
"围的数值会被回绕，因此数值为 0 会选择最后一个匹配项，而比最大值大 1 的数值会选择第一个匹配项。除非该键的值以空格结束，否则会像菜单补全一样插入匹配，即不会自动添加空格。"

#. type: table
#: zsh.texi:19487
msgid "Both @t{menu} and @t{automenu} may also specify the number of the match to insert, given after a colon.  For example, `@t{menu:2}' says to start menu completion, beginning with the second match."
msgstr "@t{menu} 和 @t{automenu} 还可以在冒号后指定要插入的匹配项的编号。 例如，`@t{menu:2}' 表示从第二个匹配开始菜单补全。"

#. type: table
#: zsh.texi:19491
msgid "Note that a value containing the substring `@t{tab}' makes the matches generated be ignored and only the TAB be inserted."
msgstr "请注意，如果值包含子字符串 `@t{tab}' ，则生成的匹配将被忽略，只插入 TAB。"

#. type: table
#: zsh.texi:19495
msgid "Finally, it may also be set to @t{all}, which makes all matches generated be inserted into the line."
msgstr "最后，也可以将其设置为 @t{all}，这样就可以将生成的所有匹配结果插入到行中。"

#. type: vindex
#: zsh.texi:19496
#, no-wrap
msgid "insert_positions, compstate"
msgstr "insert_positions, compstate"

#. type: t{#1}
#: zsh.texi:19497
#, no-wrap
msgid "insert_positions"
msgstr "insert_positions"

#. type: table
#: zsh.texi:19503
msgid ""
"When the completion system inserts an unambiguous string into the line, there may be multiple places where characters are missing or where the character inserted differs from at least one match.  The "
"value of this key contains a colon separated list of all these positions, as indexes into the command line."
msgstr "当补全系统在行中插入一个无歧义的字符串时，可能会有多个位置缺少字符或插入的字符与至少一个匹配字符不同。 此键的值包含所有这些位置的冒号分隔列表，作为命令行的索引。"

#. type: vindex
#: zsh.texi:19504
#, no-wrap
msgid "last_prompt, compstate"
msgstr "last_prompt, compstate"

#. type: t{#1}
#: zsh.texi:19505
#, no-wrap
msgid "last_prompt"
msgstr "last_prompt"

#. type: table
#: zsh.texi:19510
msgid ""
"If this is set to a non-empty string for every match added, the completion code will move the cursor back to the previous prompt after the list of completions has been displayed.  Initially this is set or "
"unset according to the @t{ALWAYS_LAST_PROMPT} option."
msgstr "如果为每一个添加的匹配设置为非空字符串，则在显示补全信息列表后，补全代码会将光标移回上一个提示符。 最初，该值的设置与否取决于 @t{ALWAYS_LAST_PROMPT} 选项。"

#. type: vindex
#: zsh.texi:19511
#, no-wrap
msgid "list, compstate"
msgstr "list, compstate"

#. type: table
#: zsh.texi:19519
msgid ""
"This controls whether or how the list of matches will be displayed.  If it is unset or empty they will never be listed; if its value begins with @t{list}, they will always be listed; if it begins with "
"@t{autolist} or @t{ambiguous}, they will be listed when the @t{AUTO_LIST} or @t{LIST_AMBIGUOUS} options respectively would normally cause them to be."
msgstr ""
"用于控制是否显示匹配列表或如何显示匹配列表。 如果未设置或为空，则永远不显示匹配结果；如果以 @t{list} 开头，则始终显示匹配结果；如果以 @t{autolist} 或 @t{ambiguous} 开头，则在 @t{AUTO_LIST} 或 "
"@t{LIST_AMBIGUOUS} 选项通常会分别显示匹配结果时，显示匹配结果。"

#. type: table
#: zsh.texi:19524
msgid "If the substring @t{force} appears in the value, this makes the list be shown even if there is only one match. Normally, the list would be shown only if there are at least two matches."
msgstr "如果子字符串 @t{force} 出现在值中，即使只有一个匹配项，也会显示列表。通常，只有当至少有两个匹配项时，列表才会显示。"

#. type: table
#: zsh.texi:19530
msgid ""
"The value contains the substring @t{packed} if the @t{LIST_PACKED} option is set. If this substring is given for all matches added to a group, this group will show the @t{LIST_PACKED} behavior. The same "
"is done for the @t{LIST_ROWS_FIRST} option with the substring @t{rows}."
msgstr ""
"如果设置了 @t{LIST_PACKED} 选项，则该值包含子字符串 @t{packed}。如果为添加到组中的所有匹配给出了该子串，则该组将显示 @t{LIST_PACKED} 行为。同样，带子字符串 @t{rows} 的 @t{LIST_ROWS_FIRST} 选项也是如此。"

#. type: table
#: zsh.texi:19539
msgid ""
"Finally, if the value contains the string @t{explanations}, only the explanation strings, if any, will be listed and if it contains @t{messages}, only the messages (added with the @t{-x} option of "
"@t{compadd}) will be listed.  If it contains both @t{explanations} and @t{messages} both kinds of explanation strings will be listed.  It will be set appropriately on entry to a completion widget and may "
"be changed there."
msgstr ""
"最后，如果值中包含字符串 @t{explanations}，则只会列出解释字符串（如果有）；如果值中包含 @t{messages}，则只会列出消息（通过 @t{compadd} 的 @t{-x} 选项添加）。 如果同时包含 @t{explanations} 和 @t{messages}，"
"则会列出两种解释字符串。 在进入补全小部件时，它将被适当设置，并可在此处更改。"

#. type: vindex
#: zsh.texi:19540
#, no-wrap
msgid "list_lines, compstate"
msgstr "list_lines, compstate"

#. type: t{#1}
#: zsh.texi:19541
#, no-wrap
msgid "list_lines"
msgstr "list_lines"

#. type: table
#: zsh.texi:19547
msgid ""
"This gives the number of lines that are needed to display the full list of completions.  Note that to calculate the total number of lines to display you need to add the number of lines needed for the "
"command line to this value, this is available as the value of the @t{BUFFERLINES} special parameter."
msgstr "这给出了显示完整的补全列表所需的行数。 请注意，要计算显示的总行数，需要在此值上加上命令行所需的行数，这可以通过 @t{BUFFERLINES} 特殊参数的值获得。"

#. type: vindex
#: zsh.texi:19548
#, no-wrap
msgid "list_max, compstate"
msgstr "list_max, compstate"

#. type: t{#1}
#: zsh.texi:19549
#, no-wrap
msgid "list_max"
msgstr "list_max"

#. type: table
#: zsh.texi:19553
msgid "Initially this is set to the value of the @t{LISTMAX} parameter.  It may be set to any other value; when the widget exits this value will be used in the same way as the value of @t{LISTMAX}."
msgstr "初始值为 @t{LISTMAX} 参数的值。也可以设置为任何其他值；小部件退出时，该值的使用方式与 @t{LISTMAX} 值相同。"

#. type: vindex
#: zsh.texi:19554
#, no-wrap
msgid "nmatches, compstate"
msgstr "nmatches, compstate"

#. type: t{#1}
#: zsh.texi:19555
#, no-wrap
msgid "nmatches"
msgstr "nmatches"

#. type: table
#: zsh.texi:19557
msgid "The number of matches added by the completion code so far."
msgstr "目前补全代码添加的匹配数。"

#. type: vindex
#: zsh.texi:19558
#, no-wrap
msgid "old_insert, compstate"
msgstr "old_insert, compstate"

#. type: t{#1}
#: zsh.texi:19559
#, no-wrap
msgid "old_insert"
msgstr "old_insert"

#. type: table
#: zsh.texi:19563
msgid "On entry to the widget this will be set to the number of the match of an old list of completions that is currently inserted into the command line. If no match has been inserted, this is unset."
msgstr "在进入小部件时，该值将被设置为当前插入命令行的旧补全列表的匹配编号。如果没有插入匹配项，则不设置。"

#. type: table
#: zsh.texi:19570
msgid ""
"As with @t{old_list}, the value of this key will only be used if it is the string @t{keep}. If it was set to this value by the widget and there was an old match inserted into the command line, this match "
"will be kept and if the value of the @t{insert} key specifies that another match should be inserted, this will be inserted after the old one."
msgstr ""
"与 @t{old_list} 一样，该键的值只有在是   @t{keep} 字符串时才会被使用。如果它被小部件设置为这个值，并且有一个旧的匹配项插入到命令行中，那么这个匹配项将被保留；如果 @t{insert} 键的值指定插入另一个匹配项，那"
"么这个匹配项将被插入到旧的匹配项之后。"

#. type: vindex
#: zsh.texi:19571
#, no-wrap
msgid "old_list, compstate"
msgstr "old_list, compstate"

#. type: t{#1}
#: zsh.texi:19572
#, no-wrap
msgid "old_list"
msgstr "old_list"

#. type: table
#: zsh.texi:19579
msgid ""
"This is set to @t{yes} if there is still a valid list of completions from a previous completion at the time the widget is invoked.  This will usually be the case if and only if the previous editing "
"operation was a completion widget or one of the builtin completion functions.  If there is a valid list and it is also currently shown on the screen, the value of this key is @t{shown}."
msgstr ""
"如果在调用该小部件时，前一个补全操作的补全列表仍然有效，则将其设置为 @t{yes}。 通常只有在上一次编辑操作是使用补全小部件或内置补全函数时，才会出现这种情况。 如果有一个有效的列表，并且当前也显示在屏幕上，则"
"此键的值为 @t{shown}。"

#. type: table
#: zsh.texi:19585
msgid ""
"After the widget has exited the value of this key is only used if it was set to @t{keep}.  In this case the completion code will continue to use this old list.  If the widget generated new matches, they "
"will not be used."
msgstr "小部件退出后，该键的值只有在被设置为 @t{keep} 时才会被使用。 在这种情况下，补全代码将继续使用旧列表。 如果小部件生成了新的匹配项，则不会使用这些匹配项。"

#. type: vindex
#: zsh.texi:19586
#, no-wrap
msgid "parameter, compstate"
msgstr "parameter, compstate"

#. type: table
#: zsh.texi:19590
msgid "The name of the parameter when completing in a subscript or in the value of a parameter assignment."
msgstr "在下标或参数赋值中值中补全时，参数名称。"

#. type: vindex
#: zsh.texi:19591
#, no-wrap
msgid "pattern_insert, compstate"
msgstr "pattern_insert, compstate"

#. type: t{#1}
#: zsh.texi:19592
#, no-wrap
msgid "pattern_insert"
msgstr "pattern_insert"

#. type: table
#: zsh.texi:19599
msgid ""
"Normally this is set to @t{menu}, which specifies that menu completion will be used whenever a set of matches was generated using @t{pattern_match} (see below).  If it is set to any other non-empty string "
"by the user and menu completion is not selected by other option settings, the code will instead insert any common prefix for the generated matches as with normal completion."
msgstr ""
"通常情况下，它被设置为 @t{menu}，即指定在使用 @t{pattern_match}（见下文）生成匹配集时使用菜单补全。 如果用户将其设置为任何其他非空字符串，且没有通过其他选项设置选择菜单补全，则代码会像普通补全一样，为生成"
"的匹配插入任何通用前缀。"

#. type: vindex
#: zsh.texi:19600
#, no-wrap
msgid "pattern_match, compstate"
msgstr "pattern_match, compstate"

#. type: t{#1}
#: zsh.texi:19601
#, no-wrap
msgid "pattern_match"
msgstr "pattern_match"

#. type: table
#: zsh.texi:19610
msgid ""
"Locally controls the behaviour given by the @t{GLOB_COMPLETE} option.  Initially it is set to `@t{*}' if and only if the option is set.  The completion widget may set it to this value, to an empty string "
"(which has the same effect as unsetting it), or to any other non-empty string.  If it is non-empty, unquoted metacharacters on the command line will be treated as patterns; if it is `@t{*}', then "
"additionally a wildcard `@t{*}' is assumed at the cursor position; if it is empty or unset, metacharacters will be treated literally."
msgstr ""
"本地控制 @t{GLOB_COMPLETE} 选项的行为。 初始化时，当且仅当该选项被设置时，它才会被设置为`@t{*}'。 补全小部件可以将其设置为该值、空字符串（与取消设置的效果相同）或任何其他非空字符串。 如果它为非空字符串，命"
"令行中未加引号的元字符将被视为模式；如果它为 `@t{*}'，则光标位置上会出现通配符 `@t{*}' ；如果它为空字符串或未设置，元字符将按字面意思处理。"

#. type: table
#: zsh.texi:19614
msgid "Note that the match specifications given to the @t{compadd} builtin command are not used if this is set to a non-empty string."
msgstr "请注意，如果将这（ @t{compadd} ）设置为非空字符串，则不会使用内置命令 @t{compadd} 的匹配规范。"

#. type: vindex
#: zsh.texi:19615
#, no-wrap
msgid "quote, compstate"
msgstr "quote, compstate"

#. type: t{#1}
#: zsh.texi:19616
#, no-wrap
msgid "quote"
msgstr "quote"

#. type: table
#: zsh.texi:19620
msgid "When completing inside quotes, this contains the quotation character (i.e. either a single quote, a double quote, or a backtick).  Otherwise it is unset."
msgstr "在引号内补全时，该值包含引号字符（即单引号、双引号或反引号）。 否则未设置。"

#. type: vindex
#: zsh.texi:19621
#, no-wrap
msgid "quoting, compstate"
msgstr "quoting, compstate"

#. type: table
#: zsh.texi:19627
msgid "When completing inside single quotes, this is set to the string @t{single}; inside double quotes, the string @t{double}; inside backticks, the string @t{backtick}.  Otherwise it is unset."
msgstr "如果在单引号内补全，则设置为字符串 @t{single}；在双引号内补全，则设置为字符串 @t{double}；在反引号内补全，则设置为字符串 @t{backtick}。 否则不设置。"

#. type: vindex
#: zsh.texi:19628
#, no-wrap
msgid "redirect, compstate"
msgstr "redirect, compstate"

#. type: table
#: zsh.texi:19632
msgid "The redirection operator when completing in a redirection position, i.e. one of @t{<}, @t{>}, etc."
msgstr "在重定向位置补全时的重定向操作符，即 @t{<}、@t{>} 等中的一个。"

#. type: vindex
#: zsh.texi:19633
#, no-wrap
msgid "restore, compstate"
msgstr "restore, compstate"

#. type: t{#1}
#: zsh.texi:19634
#, no-wrap
msgid "restore"
msgstr "restore"

#. type: table
#: zsh.texi:19640
msgid ""
"This is set to @t{auto} before a function is entered, which forces the special parameters mentioned above (@t{words}, @t{CURRENT}, @t{PREFIX}, @t{IPREFIX}, @t{SUFFIX}, and @t{ISUFFIX}) to be restored to "
"their previous values when the function exits.  If a function unsets it or sets it to any other string, they will not be restored."
msgstr ""
"在进入函数前将其设置为 @t{auto}，会强制上述特殊参数（@t{words}、@t{CURRENT}、@t{PREFIX}、@t{IPREFIX}、@t{SUFFIX} 和 @t{ISUFFIX}）在函数退出时恢复为之前的值。 如果函数取消设置或将其设置为任何其他字符串，它"
"们将不会被恢复。"

#. type: vindex
#: zsh.texi:19641
#, no-wrap
msgid "to_end, compstate"
msgstr "to_end, compstate"

#. type: t{#1}
#: zsh.texi:19642
#, no-wrap
msgid "to_end"
msgstr "to_end"

#. type: table
#: zsh.texi:19649
msgid ""
"Specifies the occasions on which the cursor is moved to the end of a string when a match is inserted.  On entry to a widget function, it may be @t{single} if this will happen when a single unambiguous "
"match was inserted or @t{match} if it will happen any time a match is inserted (for example, by menu completion; this is likely to be the effect of the @t{ALWAYS_TO_END} option)."
msgstr ""
"指定插入匹配时光标移动到字符串末尾的场合。 在进入小部件函数时，可能是 @t{single}（如果在插入单个明确的匹配项时会发生）或者 @t{match}（如果在插入任何匹配项时都会发生）。（例如，通过菜单补全；这很可能是 "
"@t{ALWAYS_TO_END} 选项的效果）"

#. type: table
#: zsh.texi:19655
msgid ""
"On exit, it may be set to @t{single} as above.  It may also be set to @t{always}, or to the empty string or unset; in those cases the cursor will be moved to the end of the string always or never "
"respectively.  Any other string is treated as @t{match}."
msgstr "退出时，它可能会被设置为 @t{single}。 也可以设置为 @t{always}、空字符串或未设置；在这些情况下，光标将分别移动到字符串的末尾（始终或从不）。 任何其他字符串都将被视为 @t{match}。"

#. type: vindex
#: zsh.texi:19656
#, no-wrap
msgid "unambiguous, compstate"
msgstr "unambiguous, compstate"

#. type: t{#1}
#: zsh.texi:19657
#, no-wrap
msgid "unambiguous"
msgstr "unambiguous"

#. type: table
#: zsh.texi:19660
msgid "This key is read-only and will always be set to the common (unambiguous)  prefix the completion code has generated for all matches added so far."
msgstr "此键为只读键，将始终设置为补全代码为迄今添加的所有匹配生成的通用（无歧义）前缀。"

#. type: vindex
#: zsh.texi:19661
#, no-wrap
msgid "unambiguous_cursor, compstate"
msgstr "unambiguous_cursor, compstate"

#. type: t{#1}
#: zsh.texi:19662
#, no-wrap
msgid "unambiguous_cursor"
msgstr "unambiguous_cursor"

#. type: table
#: zsh.texi:19667
msgid ""
"This gives the position the cursor would be placed at if the common prefix in the @t{unambiguous} key were inserted, relative to the value of that key. The cursor would be placed before the character "
"whose index is given by this key."
msgstr "如果插入 @t{unambiguous} 键中的普通前缀，则光标将位于该键值的相对位置。光标将被置于该键给出的索引的字符之前。"

#. type: vindex
#: zsh.texi:19668
#, no-wrap
msgid "unambiguous_positions, compstate"
msgstr "unambiguous_positions, compstate"

#. type: t{#1}
#: zsh.texi:19669
#, no-wrap
msgid "unambiguous_positions"
msgstr "unambiguous_positions"

#. type: table
#: zsh.texi:19674
msgid ""
"This contains all positions where characters in the unambiguous string are missing or where the character inserted differs from at least one of the matches.  The positions are given as indexes into the "
"string given by the value of the @t{unambiguous} key."
msgstr "其中包含在无歧义字符串中缺少字符或插入的字符与至少一个匹配字符不同的所有位置。 这些位置以 @t{unambiguous} 键值所给字符串的索引形式给出。"

#. type: vindex
#: zsh.texi:19675
#, no-wrap
msgid "vared, compstate"
msgstr "vared, compstate"

#. type: table
#: zsh.texi:19681
msgid ""
"If completion is called while editing a line using the @t{vared} builtin, the value of this key is set to the name of the parameter given as an argument to @t{vared}.  This key is only set while a "
"@t{vared} command is active."
msgstr "如果在使用 @t{vared} 内置函数编辑一行时调用了补全，则此键的值将被设置为作为 @t{vared} 参数给出的参数的名称。 只有在 @t{vared} 命令激活时，才会设置此键。"

#. type: t{#1}
#: zsh.texi:19684 zsh.texi:19685
#, no-wrap
msgid "words"
msgstr "words"

#. type: table
#: zsh.texi:19688
msgid "This array contains the words present on the command line currently being edited."
msgstr "该数组包含当前正在编辑的命令行中出现的单词。"

#. type: node
#: zsh.texi:19692 zsh.texi:20146 zsh.texi:20148 zsh.texi:20177
#, no-wrap
msgid "Completion Condition Codes"
msgstr "补全条件代码"

#. type: findex
#: zsh.texi:19697
#, no-wrap
msgid "compadd"
msgstr "compadd"

#. type: cindex
#: zsh.texi:19698
#, no-wrap
msgid "completion widgets, adding specified matches"
msgstr "补全小部件, 增加指定的匹配"

#. type: item
#: zsh.texi:19700
#, no-wrap
msgid "@t{compadd }[ @t{-akqQfenUl12C} ] [ @t{-F} @var{array} ]"
msgstr "@t{compadd }[ @t{-akqQfenUl12C} ] [ @t{-F} @var{array} ]"

#. type: itemx
#: zsh.texi:19701
#, no-wrap
msgid "@t{@ @ @ @ @ @ @ @ }[@t{-P} @var{prefix} ] [ @t{-S} @var{suffix} ]"
msgstr "@t{@ @ @ @ @ @ @ @ }[@t{-P} @var{prefix} ] [ @t{-S} @var{suffix} ]"

#. type: itemx
#: zsh.texi:19702
#, no-wrap
msgid "@t{@ @ @ @ @ @ @ @ }[@t{-p} @var{hidden-prefix} ] [ @t{-s} @var{hidden-suffix} ]"
msgstr "@t{@ @ @ @ @ @ @ @ }[@t{-p} @var{hidden-prefix} ] [ @t{-s} @var{hidden-suffix} ]"

#. type: itemx
#: zsh.texi:19703
#, no-wrap
msgid "@t{@ @ @ @ @ @ @ @ }[@t{-i} @var{ignored-prefix} ] [ @t{-I} @var{ignored-suffix} ]"
msgstr "@t{@ @ @ @ @ @ @ @ }[@t{-i} @var{ignored-prefix} ] [ @t{-I} @var{ignored-suffix} ]"

#. type: itemx
#: zsh.texi:19704
#, no-wrap
msgid "@t{@ @ @ @ @ @ @ @ }[@t{-W} @var{file-prefix} ] [ @t{-d} @var{array} ]"
msgstr "@t{@ @ @ @ @ @ @ @ }[@t{-W} @var{file-prefix} ] [ @t{-d} @var{array} ]"

#. type: itemx
#: zsh.texi:19705
#, no-wrap
msgid "@t{@ @ @ @ @ @ @ @ }[@t{-J} @var{group-name} ] [ @t{-X} @var{explanation} ] [ @t{-x} @var{message} ]"
msgstr "@t{@ @ @ @ @ @ @ @ }[@t{-J} @var{group-name} ] [ @t{-X} @var{explanation} ] [ @t{-x} @var{message} ]"

#. type: itemx
#: zsh.texi:19706
#, no-wrap
msgid "@t{@ @ @ @ @ @ @ @ }[@t{-V} @var{group-name} ] [ @t{-o} [ @var{order} ] ]"
msgstr "@t{@ @ @ @ @ @ @ @ }[@t{-V} @var{group-name} ] [ @t{-o} [ @var{order} ] ]"

#. type: itemx
#: zsh.texi:19707
#, no-wrap
msgid "@t{@ @ @ @ @ @ @ @ }[@t{-r} @var{remove-chars} ] [ @t{-R} @var{remove-func} ]"
msgstr "@t{@ @ @ @ @ @ @ @ }[@t{-r} @var{remove-chars} ] [ @t{-R} @var{remove-func} ]"

#. type: itemx
#: zsh.texi:19708
#, no-wrap
msgid "@t{@ @ @ @ @ @ @ @ }[@t{-D} @var{array} ] [ @t{-O} @var{array} ] [ @t{-A} @var{array} ]"
msgstr "@t{@ @ @ @ @ @ @ @ }[@t{-D} @var{array} ] [ @t{-O} @var{array} ] [ @t{-A} @var{array} ]"

#. type: itemx
#: zsh.texi:19709
#, no-wrap
msgid "@t{@ @ @ @ @ @ @ @ }[@t{-E} @var{number} ]"
msgstr "@t{@ @ @ @ @ @ @ @ }[@t{-E} @var{number} ]"

#. type: itemx
#: zsh.texi:19710
#, no-wrap
msgid "@t{@ @ @ @ @ @ @ @ }[@t{-M} @var{match-spec} ] [ @t{-}@t{-} ] [ @var{completions} ... ]"
msgstr "@t{@ @ @ @ @ @ @ @ }[@t{-M} @var{match-spec} ] [ @t{-}@t{-} ] [ @var{completions} ... ]"

#. type: table
#: zsh.texi:19717
msgid ""
"This builtin command can be used to add matches directly and control all the information the completion code stores with each possible completion. The return status is zero if at least one match was added "
"and non-zero if no matches were added."
msgstr "该内置命令可用于直接添加匹配信息，并控制补全代码在每个可能补全时存储的所有信息。如果至少添加了一个匹配项，返回状态为 0；如果没有添加匹配项，返回状态为非 0。"

#. type: table
#: zsh.texi:19720
msgid "The completion code breaks each match into seven fields in the order:"
msgstr "补全代码将每个匹配项按顺序分解为七个字段："

#. type: var{#1}
#: zsh.texi:19724
msgid "<ipre><apre><hpre><body><hsuf><asuf><isuf>"
msgstr "<ipre><apre><hpre><body><hsuf><asuf><isuf>"

#. type: table
#: zsh.texi:19742
msgid ""
"The first field is an ignored prefix taken from the command line, the contents of the @t{IPREFIX} parameter plus the string given with the @t{-i} option. With the @t{-U} option, only the string from the "
"@t{-i} option is used. The field @var{<apre>} is an optional prefix string given with the @t{-P} option.  The @var{<hpre>} field is a string that is considered part of the match but that should not be "
"shown when listing completions, given with the @t{-p} option; for example, functions that do filename generation might specify a common path prefix this way.  @var{<body>} is the part of the match that "
"should appear in the list of matches shown to the user.  The suffixes @var{<hsuf>}, @var{<asuf>} and @var{<isuf>} correspond to the prefixes @var{<hpre>}, @var{<apre>} and @var{<ipre>} and are given by "
"the options @t{-s}, @t{-S} and @t{-I}, respectively."
msgstr ""
"第一个字段是来自命令行的忽略的前缀，即 @t{IPREFIX} 参数的内容加上 @t{-i} 选项的字符串。使用 @t{-U} 选项时，只使用 @t{-i} 选项中的字符串。字段 @var{<apre>} 是通过 @t{-P} 选项给出的可选前缀字符串。 "
"@var{<hpre>} 字段是通过 @t{-p} 选项给出的字符串，它被视为匹配的一部分，但在列出补全时不应显示；例如，生成文件名的函数可能会以这种方式指定常用路径前缀。 @var{<body>} 是应出现在向用户显示的匹配列表中的匹配部"
"分。 后缀 @var{<hsuf>}、@var{<asuf>} 和 @var{<isuf>} 与前缀 @var{<hpre>}、@var{<apre>} 和 @var{<ipre>} 相对应，分别由选项 @t{-s}、@t{-S} 和 @t{-I} 指定。"

#. type: table
#: zsh.texi:19745
msgid "The supported flags are:"
msgstr "支持的标志是："

#. type: item
#: zsh.texi:19748 zsh.texi:27212
#, no-wrap
msgid "@t{-P} @var{prefix}"
msgstr "@t{-P} @var{prefix}"

#. type: table
#: zsh.texi:19752
msgid "This gives a string to be inserted before each match.  The string given is not considered as part of the match and any shell metacharacters in it will not be quoted when the string is inserted."
msgstr "这将在每次匹配之前插入一个字符串。 给定的字符串不会被视为匹配的一部分，在插入字符串时，其中的任何 shell 元字符都不会被加引号。"

#. type: item
#: zsh.texi:19753 zsh.texi:27225
#, no-wrap
msgid "@t{-S} @var{suffix}"
msgstr "@t{-S} @var{suffix}"

#. type: table
#: zsh.texi:19755
msgid "Like @t{-P}, but gives a string to be inserted after each match."
msgstr "类似于 @t{-P}，但会在每次匹配后插入一个字符串。"

#. type: item
#: zsh.texi:19756
#, no-wrap
msgid "@t{-p} @var{hidden-prefix}"
msgstr "@t{-p} @var{hidden-prefix}"

#. type: table
#: zsh.texi:19761
msgid ""
"This gives a string that should be inserted before each match but that should not appear in the list of matches. Unless the @t{-U} option is given, this string must be matched as part of the string on the "
"command line."
msgstr "这给出了一个应插入到每个匹配字符串之前的字符串，但该字符串不应出现在匹配字符串列表中。除非给出 @t{-U} 选项，否则该字符串必须作为命令行字符串的一部分进行匹配。"

#. type: item
#: zsh.texi:19762
#, no-wrap
msgid "@t{-s} @var{hidden-suffix}"
msgstr "@t{-s} @var{hidden-suffix}"

#. type: table
#: zsh.texi:19764
msgid "Like `@t{-p}', but gives a string to insert after each match."
msgstr "类似于 `@t{-p}'，但会在每次匹配后插入一个字符串。"

#. type: item
#: zsh.texi:19765
#, no-wrap
msgid "@t{-i} @var{ignored-prefix}"
msgstr "@t{-i} @var{ignored-prefix}"

#. type: table
#: zsh.texi:19770
msgid "This gives a string to insert just before any string given with the `@t{-P}' option.  Without `@t{-P}' the string is inserted before the string given with `@t{-p}' or directly before each match."
msgstr "这将给出一个字符串，插入到任何使用 `@t{-P}' 选项给出的字符串之前。 如果不使用 `@t{-P}'，字符串会被插入到使用 `@t{-p}'的字符串之前，或者直接插入到每个匹配的字符串之前。"

#. type: item
#: zsh.texi:19771
#, no-wrap
msgid "@t{-I} @var{ignored-suffix}"
msgstr "@t{-I} @var{ignored-suffix}"

#. type: table
#: zsh.texi:19773
msgid "Like @t{-i}, but gives an ignored suffix."
msgstr "与 @t{-i}类似，但给出了一个被忽略的后缀。"

#. type: table
#: zsh.texi:19779
msgid ""
"With this flag the @var{completions} are taken as names of arrays and the actual completions are their values.  If only some elements of the arrays are needed, the @var{completions} may also contain "
"subscripts, as in `@t{foo[2,-1]}'."
msgstr "使用该标志后，@var{completions} 将作为数组的名称，而实际补全则是它们的值。 如果只需要数组中的某些元素，@var{completions} 也可以包含下标，如 `@t{foo[2,-1]}'。"

#. type: table
#: zsh.texi:19784
msgid ""
"With this flag the @var{completions} are taken as names of associative arrays and the actual completions are their keys.  As for @t{-a}, the @var{words} may also contain subscripts, as in "
"`@t{foo[(R)*bar*]}'."
msgstr "使用此标志时，@var{completions} 将被视为关联数组的名称，而实际补全则是其键。 与 @t{-a} 一样，@var{words} 也可以包含下标，如  `@t{foo[(R)*bar*]}'。"

#. type: item
#: zsh.texi:19785
#, no-wrap
msgid "@t{-d} @var{array}"
msgstr "@t{-d} @var{array}"

#. type: table
#: zsh.texi:19791
msgid ""
"This adds per-completion display strings. The @var{array} should contain one element per @var{completion} given. The completion code will then display the first element instead of the first "
"@var{completion}, and so on. The @var{array} may be given as the name of an array parameter or directly as a space-separated list of words in parentheses."
msgstr ""
"这将添加按补全显示的字符串。每个 @var{completion} 都应在 @var{array} 中包含一个元素。补全代码将显示第一个元素，而不是第一个 @var{completion}，以此类推。@var{array} 可以作为数组参数的名称给出，也可以直接作"
"为括号中空格分隔的单词列表给出。"

#. type: table
#: zsh.texi:19797
msgid ""
"If there are fewer display strings than @var{completions}, the leftover @var{completions} will be displayed unchanged and if there are more display strings than @var{completions}, the leftover display "
"strings will be silently ignored."
msgstr "如果显示字符串少于 @var{completions}，剩余的 @var{completions} 将保持不变；如果显示字符串多于 @var{completions}，剩余的显示字符串将被静默忽略。"

#. type: table
#: zsh.texi:19802
msgid "This option only has an effect if used together with the @t{-d} option. If it is given, the display strings are listed one per line, not arrayed in columns."
msgstr "该选项只有与 @t{-d} 选项一起使用时才有效。如果给定了该选项，显示字符串将按行列出，而不是按列排列。"

#. type: item
#: zsh.texi:19803
#, no-wrap
msgid "@t{-o} [ @var{order} ]"
msgstr "@t{-o} [ @var{order} ]"

#. type: table
#: zsh.texi:19809
msgid ""
"This controls the order in which matches are sorted. @var{order} is a comma-separated list comprising the following possible values.  These values can be abbreviated to their initial two or three "
"characters.  Note that the order forms part of the group name space so matches with different orderings will not be in the same group."
msgstr "这将控制匹配结果的排序顺序。@var{order} 是一个以逗号分隔的列表，包含以下可能的值。 这些值可以缩写为前两个或三个字符。 请注意，排序是组名空间的一部分，因此不同排序的匹配结果不会出现在同一个组中。"

#. type: table
#: zsh.texi:19817
msgid ""
"If given, the order of the output is determined by the match strings; otherwise it is determined by the display strings (i.e. the strings given by the @t{-d} option). This is the default if `@t{-o}' is "
"specified but the @var{order} argument is omitted."
msgstr "如果给定，输出的顺序由匹配字符串决定；否则由显示字符串（即 @t{-d} 选项给定的字符串）决定。如果指定了`@t{-o}' 但省略了 @var{order} 参数，则默认情况下也是如此。"

#. type: t{#1}
#: zsh.texi:19818
#, no-wrap
msgid "nosort"
msgstr "nosort"

#. type: table
#: zsh.texi:19823
msgid "This specifies that the @var{completions} are pre-sorted and their order should be preserved.  This value only makes sense alone and cannot be combined with any others."
msgstr "这表示 @var{completions} 已预先排序，其顺序应保持不变。 此值只能单独使用，不能与其他值结合使用。"

#. type: t{#1}
#: zsh.texi:19824
#, no-wrap
msgid "numeric"
msgstr "numeric"

#. type: table
#: zsh.texi:19827
msgid "If the matches include numbers, sort them numerically rather than lexicographically."
msgstr "如果匹配项包含数字，则按数字排序，而不是按词典排序。"

#. type: t{#1}
#: zsh.texi:19828
#, no-wrap
msgid "reverse"
msgstr "reverse"

#. type: table
#: zsh.texi:19830
msgid "Arrange the matches backwards by reversing the sort ordering."
msgstr "颠倒排序顺序，反向排列匹配项。"

#. type: item
#: zsh.texi:19833
#, no-wrap
msgid "@t{-J} @var{group-name}"
msgstr "@t{-J} @var{group-name}"

#. type: table
#: zsh.texi:19835
msgid "Gives the name of the group that the matches should be stored in."
msgstr "给出存储匹配信息的组名称。"

#. type: item
#: zsh.texi:19836
#, no-wrap
msgid "@t{-V} @var{group-name}"
msgstr "@t{-V} @var{group-name}"

#. type: table
#: zsh.texi:19839
msgid "Like @t{-J} but naming an unsorted group. This option is identical to the combination of @t{-J} and @t{-o nosort}."
msgstr "与 @t{-J} 类似，但命名的是一个未排序的分组。该选项与 @t{-J} 和 @t{-o nosort} 的组合相同。"

#. type: table
#: zsh.texi:19845
msgid ""
"If given together with the @t{-V} option, makes only consecutive duplicates in the group be removed. If combined with the @t{-J} option, this has no visible effect. Note that groups with and without this "
"flag are in different name spaces."
msgstr "如果与 @t{-V} 选项一起使用，则只删除组内连续的重复数据。如果与 @t{-J} 选项一起使用，则没有明显效果。请注意，有此标志和无此标志的组处于不同的名称空间。"

#. type: table
#: zsh.texi:19850 zsh.texi:27411
msgid "If given together with the @t{-J} or @t{-V} option, makes all duplicates be kept. Again, groups with and without this flag are in different name spaces."
msgstr "如果与 @t{-J} 或 @t{-V} 选项一起使用，则会保留所有重复。同样，有此标志和无此标志的组处于不同的名称空间。"

#. type: item
#: zsh.texi:19851 zsh.texi:27322
#, no-wrap
msgid "@t{-X} @var{explanation}"
msgstr "@t{-X} @var{explanation}"

#. type: table
#: zsh.texi:19854
msgid "The @var{explanation} string will be printed with the list of matches, above the group currently selected."
msgstr "@var{explanation} 字符串将与匹配列表一起打印，位于当前选择的组之上。"

#. type: table
#: zsh.texi:19865
msgid ""
"Within the @var{explanation}, the following sequences may be used to specify output attributes (see @ref{Prompt Expansion}): `@t{%B}', `@t{%S}', `@t{%U}', `@t{%F}', `@t{%K}' and their lower case "
"counterparts, as well as `@t{%@{}...@t{%@}}'.  `@t{%F}', `@t{%K}' and `@t{%@{}...@t{%@}}' take arguments in the same form as prompt expansion.  (Note that the sequence `@t{%G}' is not available; an "
"argument to `@t{%@{}' should be used instead.)  The sequence `@t{%%}' produces a literal `@t{%}'."
msgstr ""
"在 @var{explanation} 中，可使用以下序列指定输出属性（参见 @ref{提示符扩展}）： `@t{%B}', `@t{%S}', `@t{%U}', `@t{%F}', `@t{%K}'及其小写对应序列，以及`@t{%@{}...@t{%@}}'.  `@t{%F}', `@t{%K}'  并且 "
"`@t{%@{}...@t{%@}}'  的参数形式与提示符扩展相同。 (注意，`@t{%G}' 序列不可用；应使用 `@t{%@{}' 的参数代替）。 序列 `@t{%%}' 产生一个字面意义上的 `@t{%}'。"

#. type: table
#: zsh.texi:19876
msgid ""
"These sequences are most often employed by users when customising the @t{format} style (see @ref{Completion System}), but they must also be taken into account when writing completion functions, as passing "
"descriptions with unescaped `@t{%}' characters to utility functions such as @t{_arguments} and @t{_message} may produce unexpected results. If arbitrary text is to be passed in a description, it can be "
"escaped using e.g. @t{$@{my_str//\\%/%%@}}."
msgstr ""
"用户在自定义 @t{format} 样式时最常使用这些序列（参见 @ref{补全系统}），但在编写补全函数时也必须考虑到这些序列，因为将带有未转义 `@t{%}' 字符的描述传递给 @t{_arguments} 和 @t{_message} 等实用函数时，可能会"
"产生意想不到的结果。如果要在描述（description）中传递任意文本，可以使用 @t{$@{my_str//\\%/%%@}} 等方式转义。"

#. type: item
#: zsh.texi:19877
#, no-wrap
msgid "@t{-x} @var{message}"
msgstr "@t{-x} @var{message}"

#. type: table
#: zsh.texi:19880
msgid "Like @t{-X}, but the @var{message} will be printed even if there are no matches in the group."
msgstr "与 @t{-X} 类似，但即使组中没有匹配项，也会打印 @var{message} 。"

#. type: table
#: zsh.texi:19886
msgid ""
"The suffix given with @t{-S} will be automatically removed if the next character typed is a blank or does not insert anything, or if the suffix consists of only one character and the next character typed "
"is the same character."
msgstr "如果键入的下一个字符是空白或没有插入任何内容，或者后缀只有一个字符，且键入的下一个字符是相同的字符，则 @t{-S} 指定的后缀将自动删除。"

#. type: item
#: zsh.texi:19887
#, no-wrap
msgid "@t{-r} @var{remove-chars}"
msgstr "@t{-r} @var{remove-chars}"

#. type: table
#: zsh.texi:19900
msgid ""
"This is a more versatile form of the @t{-q} option.  The suffix given with @t{-S} or the slash automatically added after completing directories will be automatically removed if the next character typed "
"inserts one of the characters given in the @var{remove-chars}.  This string is parsed as a characters class and understands the backslash sequences used by the @t{print} command.  For example, `@t{-r \"a-"
"z\\t\"}' removes the suffix if the next character typed inserts a lower case character or a TAB, and `@t{-r \"^0-9\"}' removes the suffix if the next character typed inserts anything but a digit. One "
"extra backslash sequence is understood in this string: `@t{\\-}' stands for all characters that insert nothing. Thus `@t{-S \"=\" -q}' is the same as `@t{-S \"=\" -r \"= \\t\\n\\-\"}'."
msgstr ""
"这是 @t{-q} 选项的更加多功能的形式。 如果输入的下一个字符插入了 @var{remove-chars} 中给出的字符之一，则 @t{-S} 给出的后缀或补全目录后自动添加的斜线将被自动删除。 该字符串会被解析为字符类，并理解 @t{print} "
"命令使用的反斜线序列。 例如， `@t{-r \"a-z\\t\"}' 会在输入的下一个字符为小写字母或 TAB 时删除后缀， `@t{-r \"^0-9\"}' 会在输入的下一个字符为数字以外的字符时删除后缀。在这个字符串中，有一个额外的反斜杠序列"
"是可以被理解的： `@t{\\-}' 代表所有不插入任何内容的字符。因此， `@t{-S \"=\" -q}' 与 `@t{-S \"=\" -r \"= \\t\\n\\-\"}' 相同。"

#. type: table
#: zsh.texi:19905
msgid "This option may also be used without the @t{-S} option; then any automatically added space will be removed when one of the characters in the list is typed."
msgstr "该选项也可在不使用 @t{-S} 选项的情况下使用；这样，当输入列表中的一个字符时，任何自动添加的空格都会被删除。"

#. type: item
#: zsh.texi:19906
#, no-wrap
msgid "@t{-R} @var{remove-func}"
msgstr "@t{-R} @var{remove-func}"

#. type: table
#: zsh.texi:19913
msgid ""
"This is another form of the @t{-r} option. When a match has been accepted and a suffix has been inserted, the function @var{remove-func} will be called after the next character typed.  It is passed the "
"length of the suffix as an argument and can use the special parameters available in ordinary (non-completion) zle widgets (see @ref{Zsh Line Editor}) to analyse and modify the command line."
msgstr ""
"这是 @t{-r} 选项的另一种形式。在接受匹配并插入后缀后，将在输入下一个字符后调用 @var{remove-func} 函数。 函数将后缀的长度作为参数传递给它，并可以使用普通（非完成）zle widget（参见 @ref{Zsh 行编辑器}）中的特"
"殊参数来分析和修改命令行。"

#. type: table
#: zsh.texi:19921
msgid ""
"If this flag is given, all of the matches built from the @var{completions} are marked as being the names of files.  They are not required to be actual filenames, but if they are, and the option "
"@t{LIST_TYPES} is set, the characters describing the types of the files in the completion lists will be shown. This also forces a slash to be added when the name of a directory is completed."
msgstr ""
"如果给定了该标志，从 @var{completions} 生成的所有匹配结果都会被标记为文件名。 它们不一定是实际文件名，但如果是实际文件名，且选项 @t{LIST_TYPES} 已设置，则会在补全列表中显示描述文件类型的字符。这也会强制在"
"补全目录名称时添加斜线。"

#. type: table
#: zsh.texi:19927
msgid ""
"This flag can be used to tell the completion code that the matches added are parameter names for a parameter expansion. This will make the @t{AUTO_PARAM_SLASH} and @t{AUTO_PARAM_KEYS} options be used for "
"the matches."
msgstr "该标志可用于告诉补全代码所添加的匹配是参数扩展的参数名。这将使 @t{AUTO_PARAM_SLASH} 和 @t{AUTO_PARAM_KEYS} 选项用于匹配。"

#. type: item
#: zsh.texi:19928 zsh.texi:27231
#, no-wrap
msgid "@t{-W} @var{file-prefix}"
msgstr "@t{-W} @var{file-prefix}"

#. type: table
#: zsh.texi:19933
msgid ""
"This string is a pathname that will be prepended to each match together with any prefix specified by the @t{-p} option to form a complete filename for testing.  Hence it is only useful if combined with "
"the @t{-f} flag, as the tests will not otherwise be performed."
msgstr "该字符串是一个路径名，将与 @t{-p} 选项指定的任何前缀一起被添加到每个匹配项的前缀中，以形成一个完整的文件名进行测试。 因此，它只有与 @t{-f} 标志结合使用时才有用，否则不会执行测试。"

#. type: item
#: zsh.texi:19934
#, no-wrap
msgid "@t{-F} @var{array}"
msgstr "@t{-F} @var{array}"

#. type: table
#: zsh.texi:19937
msgid "Specifies an array containing patterns.  @var{completions} that match one of these patterns are ignored, that is, not considered to be matches."
msgstr "指定一个包含模式的数组。 与其中一个模式匹配的 @var{completions} 将被忽略，即不被视为匹配项。"

#. type: table
#: zsh.texi:19943
msgid ""
"The @var{array} may be the name of an array parameter or a list of literal patterns enclosed in parentheses and quoted, as in `@t{-F \"(*?.o *?.h)\"}'. If the name of an array is given, the elements of "
"the array are taken as the patterns."
msgstr "@var{array} 可以是一个数组参数的名称，也可以是一个用括号和引号括起来的字面模式列表，如  `@t{-F \"(*?.o *?.h)\"}' 中。如果给出的是数组名称，则数组元素将作为模式。"

#. type: table
#: zsh.texi:19948
msgid "This flag instructs the completion code not to quote any metacharacters in the matches when inserting them into the command line."
msgstr "该标志指示补全代码在将匹配插入命令行时，不对匹配符中的任何元字符加引号。"

#. type: item
#: zsh.texi:19949 zsh.texi:27412
#, no-wrap
msgid "@t{-M} @var{match-spec}"
msgstr "@t{-M} @var{match-spec}"

#. type: table
#: zsh.texi:19955
msgid ""
"This gives local match specifications as described below in @ref{Completion Matching Control}. This option may be given more than once.  In this case all @var{match-spec}s given are concatenated with "
"spaces between them to form the specification string to use.  Note that they will only be used if the @t{-U} option is not given."
msgstr ""
"这将提供 @ref{ 补全匹配控制} 中描述的本地匹配规范。该选项可以给出多次。 在这种情况下，所有给出的 @var{match-spec} 都会用空格连接起来，形成要使用的规范字符串。 请注意，只有在未给出 @t{-U} 选项时，才会使用这"
"些字符串。"

#. type: table
#: zsh.texi:19959
msgid "Specifies that matching @var{completions} are to be added to the set of matches, but are not to be listed to the user."
msgstr "指定将匹配的 @var{completions} 加入匹配集，但不向用户列出。"

#. type: table
#: zsh.texi:19965
msgid "If this flag is given, all @var{completions} are added to the set of matches and no matching will be done by the completion code. Normally this is used in functions that do the matching themselves."
msgstr "如果给出此标志，所有 @var{completions} 都会被添加到匹配集合中，补全代码将不进行匹配。通常情况下，该标志用于自行完成匹配的函数。"

#. type: item
#: zsh.texi:19966
#, no-wrap
msgid "@t{-O} @var{array}"
msgstr "@t{-O} @var{array}"

#. type: table
#: zsh.texi:19971
msgid ""
"If this option is given, the @var{completions} are @emph{not} added to the set of matches.  Instead, matching is done as usual and all of the @var{completions} that match will be stored in the array "
"parameter whose name is given as @var{array}."
msgstr "如果给定了该选项，@var{completions}  @emph{不会} 被添加到匹配集合中。 相反，匹配将像往常一样进行，所有匹配到的 @var{completions} 都将存储在数组参数中，该参数的名称为 @var{array}。"

#. type: item
#: zsh.texi:19972 zsh.texi:30443
#, no-wrap
msgid "@t{-A} @var{array}"
msgstr "@t{-A} @var{array}"

#. type: table
#: zsh.texi:19981
msgid ""
"As the @t{-O} option, except that instead of those of the @var{completions} which match being stored in @var{array}, the strings generated internally by the completion code are stored.  For example, with "
"a match specification of `@t{-M \"L:|no=\"}', a current word of `@t{nof}' and @var{completions} of `@t{foo}', this option stores the string `@t{nofoo}' in the array, whereas the @t{-O} option stores the "
"`@t{foo}' originally given."
msgstr ""
"与 @t{-O} 选项相同，只不过 @var{completions} 中的匹配字符串不存储在 @var{array} 中，而是存储补全代码内部生成的字符串。 例如，如果匹配规范为 `@t{-M \"L:|no=\"}'，当前单词为`@t{nof}'，  @var{completions} 为 "
"`@t{foo}' ，则该选项会在数组中存储字符串 `@t{nofoo}' ，而 @t{-O} 选项则存储最初给出的字符串 `@t{foo}' 。"

#. type: item
#: zsh.texi:19982
#, no-wrap
msgid "@t{-D} @var{array}"
msgstr "@t{-D} @var{array}"

#. type: table
#: zsh.texi:19989
msgid ""
"As with @t{-O}, the @var{completions} are not added to the set of matches.  Instead, whenever the @var{n}th @var{completion} does not match, the @var{n}th element of the @var{array} is removed.  Elements "
"for which the corresponding @var{completion} matches are retained.  This option can be used more than once to remove elements from multiple arrays."
msgstr ""
"与 @t{-O} 一样，@var{completions} 不会添加到匹配集合中。 相反，只要第 @var{n} 个 @var{completion} 不匹配，@var{array} 的第 @var{n} 个元素就会被移除。 相应 @var{completion} 匹配的元素会被保留。 可以多次使用"
"此选项来从多个数组中删除元素。"

#. type: table
#: zsh.texi:19998
msgid ""
"This option adds a special match which expands to all other matches when inserted into the line, even those that are added after this option is used.  Together with the @t{-d} option it is possible to "
"specify a string that should be displayed in the list for this special match.  If no string is given, it will be shown as a string containing the strings that would be inserted for the other matches, "
"truncated to the width of the screen."
msgstr ""
"该选项会添加一个特殊匹配项，在插入一行时会扩展到所有其他匹配项，即使是在使用该选项后添加的匹配项也不例外。 与 @t{-d} 选项一起使用时，可以指定在列表中显示该特殊匹配的字符串。 如果没有指定字符串，则会显示为"
"一个字符串，其中包含为其他匹配项插入的字符串，并根据屏幕宽度截断。"

#. type: item
#: zsh.texi:19999
#, no-wrap
msgid "@t{-E} @var{number}"
msgstr "@t{-E} @var{number}"

#. type: table
#: zsh.texi:20011
msgid ""
"This option adds @var{number} empty matches after matching @var{completions} have been added.  An empty match takes up space in completion listings but will never be inserted in the line and can't be "
"selected with menu completion or menu selection.  This makes empty matches only useful to format completion lists and to make explanatory string be shown in completion lists (since empty matches can be "
"given display strings with the @t{-d} option).  And because all but one empty string would otherwise be removed, this option implies the @t{-V} and @t{-2} options (even if an explicit @t{-J} option is "
"given).  This can be important to note as it affects the name space into which matches are added."
msgstr ""
"该选项会在添加了匹配的 @var{completions} 之后添加 @var{number} 个空匹配。 空匹配会占用补全列表的空间，但永远不会插入行中，也不能用菜单补全或菜单选择来选择。 这使得空匹配只在格式化补全列表和在补全列表中显示"
"解释性字符串时有用（因为可以使用 @t{-d} 选项为空匹配提供显示字符串）。 由于除了一个空字符串之外的所有字符串都会被删除，因此该选项意味着 @t{-V} 和 @t{-2} 选项（即使给出了明确的 @t{-J} 选项）。 这一点很重"
"要，因为它会影响到添加匹配的名称空间。"

#. type: item
#: zsh.texi:20013 zsh.texi:38899
#, no-wrap
msgid "@t{-}@t{-}"
msgstr "@t{-}@t{-}"

#. type: table
#: zsh.texi:20017
msgid "This flag ends the list of flags and options. All arguments after it will be taken as the @var{completions} even if they begin with hyphens."
msgstr "该标志会结束标志和选项列表。其后的所有参数都将作为 @var{completions} ，即使它们是以连字符开头的。"

#. type: table
#: zsh.texi:20023
msgid "Except for the @t{-M} flag, if any of these flags is given more than once, the first one (and its argument) will be used."
msgstr "除 @t{-M} 标志外，如果这些标志中的任何一个被多次给出，则将使用第一个标志（及其参数）。"

#. type: findex
#: zsh.texi:20024
#, no-wrap
msgid "compset"
msgstr "compset"

#. type: cindex
#: zsh.texi:20025
#, no-wrap
msgid "completion widgets, modifying special parameters"
msgstr "补全小部件, 修改特殊参数"

#. type: item
#: zsh.texi:20026
#, no-wrap
msgid "@t{compset -p} @var{number}"
msgstr "@t{compset -p} @var{number}"

#. type: itemx
#: zsh.texi:20027
#, no-wrap
msgid "@t{compset -P} [ @var{number} ] @var{pattern}"
msgstr "@t{compset -P} [ @var{number} ] @var{pattern}"

#. type: itemx
#: zsh.texi:20028
#, no-wrap
msgid "@t{compset -s} @var{number}"
msgstr "@t{compset -s} @var{number}"

#. type: itemx
#: zsh.texi:20029
#, no-wrap
msgid "@t{compset -S} [ @var{number} ] @var{pattern}"
msgstr "@t{compset -S} [ @var{number} ] @var{pattern}"

#. type: itemx
#: zsh.texi:20030
#, no-wrap
msgid "@t{compset -n} @var{begin} [ @var{end} ]"
msgstr "@t{compset -n} @var{begin} [ @var{end} ]"

#. type: itemx
#: zsh.texi:20031
#, no-wrap
msgid "@t{compset -N} @var{beg-pat} [ @var{end-pat} ]"
msgstr "@t{compset -N} @var{beg-pat} [ @var{end-pat} ]"

#. type: t{#1}
#: zsh.texi:20032
#, no-wrap
msgid "compset -q"
msgstr "compset -q"

#. type: table
#: zsh.texi:20035
msgid "This command simplifies modification of the special parameters, while its return status allows tests on them to be carried out."
msgstr "该命令简化了特殊参数的修改，其返回状态允许对特殊参数进行测试。"

#. type: table
#: zsh.texi:20038
msgid "The options are:"
msgstr "这些选项是："

#. type: item
#: zsh.texi:20041
#, no-wrap
msgid "@t{-p} @var{number}"
msgstr "@t{-p} @var{number}"

#. type: table
#: zsh.texi:20045
msgid "If the value of the @t{PREFIX} parameter is at least @var{number} characters long, the first @var{number} characters are removed from it and appended to the contents of the @t{IPREFIX} parameter."
msgstr "如果 @t{PREFIX} 参数的值至少有 @var{number} 个字符长，则会从中删除前 @var{number} 个字符，并追加到 @t{IPREFIX} 参数的内容中。"

#. type: item
#: zsh.texi:20046
#, no-wrap
msgid "@t{-P} [ @var{number} ] @var{pattern}"
msgstr "@t{-P} [ @var{number} ] @var{pattern}"

#. type: table
#: zsh.texi:20050
msgid "If the value of the @t{PREFIX} parameter begins with anything that matches the @var{pattern}, the matched portion is removed from @t{PREFIX} and appended to @t{IPREFIX}."
msgstr "如果 @t{PREFIX} 参数的值以与 @var{pattern} 匹配的内容开头，则匹配的部分会从 @t{PREFIX} 中移除，并追加到 @t{IPREFIX} 中。"

#. type: table
#: zsh.texi:20059
msgid ""
"Without the optional @var{number}, the longest match is taken, but if @var{number} is given, anything up to the @var{number}th match is moved.  If the @var{number} is negative, the @var{number}th longest "
"match is moved. For example, if @t{PREFIX} contains the string `@t{a=b=c}', then @t{compset -P '*\\='} will move the string `@t{a=b=}' into the @t{IPREFIX} parameter, but @t{compset -P 1 '*\\='} will move "
"only the string `@t{a=}'."
msgstr ""
"如果不使用可选的 @var{number}，则取最长的匹配，但如果给出 @var{number}，则移动第 @var{number} 个之前的所有匹配。 如果 @var{number} 为负数，则移动第 @var{number} 个最长的匹配项。例如，如果 @t{PREFIX} 包含字"
"符串 `@t{a=b=c}'，那么 @t{compset -P '*\\='} 将把字符串 `@t{a=b=}' 移动到 @t{IPREFIX} 参数中，但 @t{compset -P 1 '*\\='} 只移动字符串 `@t{a=}'。"

#. type: item
#: zsh.texi:20060
#, no-wrap
msgid "@t{-s} @var{number}"
msgstr "@t{-s} @var{number}"

#. type: table
#: zsh.texi:20063
msgid "As @t{-p}, but transfer the last @var{number} characters from the value of @t{SUFFIX} to the front of the value of @t{ISUFFIX}."
msgstr "与 @t{-p}相同，但会将 @t{SUFFIX} 值中的最后 @var{number} 个字符转到 @t{ISUFFIX} 值的前面。"

#. type: item
#: zsh.texi:20064
#, no-wrap
msgid "@t{-S} [ @var{number} ] @var{pattern}"
msgstr "@t{-S} [ @var{number} ] @var{pattern}"

#. type: table
#: zsh.texi:20067
msgid "As @t{-P}, but match the last portion of @t{SUFFIX} and transfer the matched portion to the front of the value of @t{ISUFFIX}."
msgstr "与 @t{-P} 相同，但匹配 @t{SUFFIX} 的最后部分，并将匹配的部分转到 @t{ISUFFIX} 值的前面。"

#. type: item
#: zsh.texi:20068
#, no-wrap
msgid "@t{-n} @var{begin} [ @var{end} ]"
msgstr "@t{-n} @var{begin} [ @var{end} ]"

#. type: table
#: zsh.texi:20073
msgid ""
"If the current word position as specified by the parameter @t{CURRENT} is greater than or equal to @var{begin}, anything up to the @var{begin}th word is removed from the @t{words} array and the value of "
"the parameter @t{CURRENT} is decremented by @var{begin}."
msgstr "如果参数 @t{CURRENT} 指定的当前字词位置大于或等于 @var{begin}，则从 @t{words} 数组中删除第 @var{begin} 个字词之前的所有内容，并按 @var{begin} 递减参数 @t{CURRENT} 的值。"

#. type: table
#: zsh.texi:20079
msgid ""
"If the optional @var{end} is given, the modification is done only if the current word position is also less than or equal to @var{end}. In this case, the words from position @var{end} onwards are also "
"removed from the @t{words} array."
msgstr "如果给出了可选的 @var{end}，则只有在当前单词位置也小于或等于 @var{end} 时，才会进行修改。在这种情况下，从 @var{end} 开始的单词也会从 @t{words} 数组中删除。"

#. type: table
#: zsh.texi:20083
msgid "Both @var{begin} and @var{end} may be negative to count backwards from the last element of the @t{words} array."
msgstr "@var{begin} 和 @var{end} 都可以是负数，以便从 @t{words} 数组的最后一个元素开始倒数。"

#. type: item
#: zsh.texi:20084
#, no-wrap
msgid "@t{-N} @var{beg-pat} [ @var{end-pat} ]"
msgstr "@t{-N} @var{beg-pat} [ @var{end-pat} ]"

#. type: table
#: zsh.texi:20090
msgid ""
"If one of the elements of the @t{words} array before the one at the index given by the value of the parameter @t{CURRENT} matches the pattern @var{beg-pat}, all elements up to and including the matching "
"one are removed from the @t{words} array and the value of @t{CURRENT} is changed to point to the same word in the changed array."
msgstr ""
"如果 @t{words} 数组中位于参数 @t{CURRENT} 值给出的索引处的元素之前的一个元素与 @var{beg-pat} 模式相匹配，则从 @t{words} 数组中删除匹配元素之前的所有元素，并更改 @t{CURRENT} 的值，使其指向已更改数组中的相同"
"单词。"

#. type: table
#: zsh.texi:20100
msgid ""
"If the optional pattern @var{end-pat} is also given, and there is an element in the @t{words} array matching this pattern, the parameters are modified only if the index of this word is higher than the one "
"given by the @t{CURRENT} parameter (so that the matching word has to be after the cursor). In this case, the words starting with the one matching @t{end-pat} are also removed from the @t{words} array. If "
"@t{words} contains no word matching @var{end-pat}, the testing and modification is performed as if it were not given."
msgstr ""
"如果同时给出了可选模式 @var{end-pat}，并且 @t{words} 数组中存在与该模式匹配的元素，那么只有当该词的索引高于 @t{CURRENT} 参数给出的索引（因此匹配词必须在游标之后）时，才会修改参数。在这种情况下，从 @t{end-"
"pat} 开始的单词也会从 @t{words} 数组中删除。如果 @t{words} 数组中没有与 @var{end-pat} 匹配的单词，则会像没有给出 @var{end-pat} 一样进行测试和修改。"

#. type: table
#: zsh.texi:20108
msgid ""
"The word currently being completed is split on spaces into separate words, respecting the usual shell quoting conventions.  The resulting words are stored in the @t{words} array, and @t{CURRENT}, "
"@t{PREFIX}, @t{SUFFIX}, @t{QIPREFIX}, and @t{QISUFFIX} are modified to reflect the word part that is completed."
msgstr ""
"当前正在补全的单词会按空格分割成不同的单词，并遵守通常的 shell 引号约定。 生成的单词存储在 @t{words} 数组中，@t{CURRENT}、@t{PREFIX}、@t{SUFFIX}、@t{QIPREFIX} 和 @t{QISUFFIX} 将被修改，以反映已补全的单词部"
"分。"

#. type: table
#: zsh.texi:20115
msgid "In all the above cases the return status is zero if the test succeeded and the parameters were modified and non-zero otherwise. This allows one to use this builtin in tests such as:"
msgstr "在上述所有情况下，如果测试成功且参数被修改，则返回状态为 0，否则为非 0。这样就可以在以下测试中使用该内置函数："

#. type: example
#: zsh.texi:20119
#, no-wrap
msgid "if compset -P '*\\='; then ...\n"
msgstr "if compset -P '*\\='; then ...\n"

#. type: table
#: zsh.texi:20124
msgid "This forces anything up to and including the last equal sign to be ignored by the completion code."
msgstr "这样，补全代码就会忽略直到并包括最后一个等号在内的所有内容。"

#. type: item
#: zsh.texi:20125
#, no-wrap
msgid "@t{compcall} [ @t{-TD} ]"
msgstr "@t{compcall} [ @t{-TD} ]"

#. type: table
#: zsh.texi:20134
msgid ""
"This allows the use of completions defined with the @t{compctl} builtin from within completion widgets.  The list of matches will be generated as if one of the non-widget completion functions (@t{complete-"
"word}, etc.)  had been called, except that only @t{compctl}s given for specific commands are used. To force the code to try completions defined with the @t{-T} option of @t{compctl} and/or the default "
"completion (whether defined by @t{compctl -D} or the builtin default) in the appropriate places, the @t{-T} and/or @t{-D} flags can be passed to @t{compcall}."
msgstr ""
"这样就可以在补全小部件中使用 @t{compctl} 内置函数定义的补全。 除了只使用为特定命令提供的 @t{compctl} 外，匹配列表的生成过程与调用非小部件的补全函数（@t{complete-word} 等）相同。要强制代码在适当的地方尝试 "
"@t{compctl} 的 @t{-T} 选项定义的补全函数和/或默认补全函数（无论是 @t{compctl -D} 还是内置默认），可以将 @t{-T} 和/或 @t{-D} 标志传递给 @t{compcall}。"

#. type: table
#: zsh.texi:20139
msgid "The return status can be used to test if a matching @t{compctl} definition was found. It is non-zero if a @t{compctl} was found and zero otherwise."
msgstr "返回状态可用于测试是否找到匹配的 @t{compctl} 定义。如果找到 @t{compctl}，返回状态为非零，否则为零。"

#. type: table
#: zsh.texi:20142
msgid "Note that this builtin is defined by the @t{zsh/compctl} module."
msgstr "请注意，该内置程序是由 @t{zsh/compctl} 模块定义的。"

#. type: node
#: zsh.texi:20146 zsh.texi:20177 zsh.texi:20179 zsh.texi:20508
#, no-wrap
msgid "Completion Matching Control"
msgstr "补全匹配控制"

#. type: cindex
#: zsh.texi:20150
#, no-wrap
msgid "completion widgets, condition codes"
msgstr "补全小部件, 条件代码"

#. type: Plain text
#: zsh.texi:20158
msgid ""
"The following additional condition codes for use within the @t{[[} @var{...} @t{]]} construct are available in completion widgets.  These work on the special parameters.  All of these tests can also be "
"performed by the @t{compset} builtin, but in the case of the condition codes the contents of the special parameters are not modified."
msgstr "在补全小部件中，可以使用以下用于 @t{[[} @var{...} @t{]]} 结构的附加条件代码。 这些代码适用于特殊参数。 所有这些测试也可由 @t{compset} 内置函数执行，但在条件代码的情况下，特殊参数的内容不会被修改。"

#. type: item
#: zsh.texi:20161
#, no-wrap
msgid "@t{-prefix} [ @var{number} ] @var{pattern}"
msgstr "@t{-prefix} [ @var{number} ] @var{pattern}"

#. type: table
#: zsh.texi:20163
msgid "true if the test for the @t{-P} option of @t{compset} would succeed."
msgstr "如果 @t{compset} 的 @t{-P} 选项测试成功，则为 true。"

#. type: item
#: zsh.texi:20164
#, no-wrap
msgid "@t{-suffix} [ @var{number} ] @var{pattern}"
msgstr "@t{-suffix} [ @var{number} ] @var{pattern}"

#. type: table
#: zsh.texi:20166
msgid "true if the test for the @t{-S} option of @t{compset} would succeed."
msgstr "如果 @t{compset} 的 @t{-S} 选项测试成功，则为 true。"

#. type: item
#: zsh.texi:20167
#, no-wrap
msgid "@t{-after} @var{beg-pat}"
msgstr "@t{-after} @var{beg-pat}"

#. type: table
#: zsh.texi:20170
msgid "true if the test of the @t{-N} option with only the @var{beg-pat} given would succeed."
msgstr "如果只带有 @var{beg-pat}的  @t{-N} 选项的测试成功，则为 true。"

#. type: item
#: zsh.texi:20171
#, no-wrap
msgid "@t{-between} @var{beg-pat end-pat}"
msgstr "@t{-between} @var{beg-pat end-pat}"

#. type: table
#: zsh.texi:20173
msgid "true if the test for the @t{-N} option with both patterns would succeed."
msgstr "如果两种模式的 @t{-N} 选项的测试都成功，则为 true。"

#. type: Plain text
#: zsh.texi:20187
msgid ""
"When the user invokes completion, the current @emph{word} on the command line (that is, the word the cursor is currently on) is used to generate a @emph{match pattern}.  Only those @emph{completions} that "
"match the pattern are offered to the user as @emph{matches}."
msgstr "当用户调用补全时，命令行上的当前 @emph{word}（即光标当前所在的单词）会被用来生成一个 @emph{匹配模式}。 只有那些与模式匹配的 @emph{completions} 才会作为 @emph{matches} 提供给用户。"

#. type: Plain text
#: zsh.texi:20190
msgid "The default match pattern is generated from the current word by either"
msgstr "默认的匹配模式是由当前单词生成的，其方法是"

#. type: itemize
#: zsh.texi:20197
msgid "appending a `@t{*}' (matching any number of characters in a completion)  @emph{or,}"
msgstr "添加 `@t{*}' （匹配补全中的任意字符数） @emph{或者,}"

#. type: itemize
#: zsh.texi:20200
msgid "if the shell option @t{COMPLETE_IN_WORD} is set, inserting a `@t{*}' at the cursor position."
msgstr "如果 shell 选项 @t{COMPLETE_IN_WORD} 已设置，则会在光标位置插入 `@t{*}' 。"

#. type: Plain text
#: zsh.texi:20210
msgid ""
"This narrow pattern can be broadened selectively by passing a @emph{match specification} to the @t{compadd} builtin command through its @t{-M} option (see @ref{Completion Builtin Commands}).  A match "
"specification consists of one or more @var{matchers} separated by whitespace.  Matchers in a match specification are applied one at a time, from left to right.  Once all matchers have been applied, "
"completions are compared to the final match pattern and non-matching ones are discarded."
msgstr ""
"通过 @t{-M} 选项将 @emph{匹配规范} 传递给 @t{compadd} 内置命令（参见 @ref{补全内置命令}），可以有选择性地扩展这种狭义模式。 匹配规范由一个或多个 @var{matchers} 组成，以空格分隔。 匹配规范中的匹配器从左到右"
"逐个应用。 一旦应用了所有匹配器，就会将补全与最终匹配模式进行比较，并丢弃不匹配的补全。"

#. type: itemize
#: zsh.texi:20220
msgid ""
"Note that the @t{-M} option is ignored if the current word contains a glob pattern and the shell option @t{GLOB_COMPLETE} is set or if the @t{pattern_match} key of the special associative array "
"@t{compstate} is set to a non-empty value (see @ref{Completion Special Parameters})."
msgstr ""
"请注意，如果当前单词包含一个 glob 模式，并且 shell 选项 @t{GLOB_COMPLETE} 已被设置，或者特殊关联数组 @t{compstate} 的 @t{pattern_match} 键被设置为非空值（参见 @ref{补全特殊参数}），则 @t{-M} 选项将被忽略。"

#. type: itemize
#: zsh.texi:20225
msgid ""
"Users of the @ref{Completion System} should generally not use the @t{-M} option directly, but rather use the @t{matcher-list} and @t{matcher} styles (see the subsection @emph{Standard Styles} in "
"@ref{Completion System Configuration})."
msgstr "@ref{补全系统} 的用户一般不应直接使用 @t{-M} 选项，而应使用 @t{matcher-list} 和 @t{matcher} 样式（参见 @ref{补全系统配置} 中的 @emph{标准样式} 小节）。"

#. type: Plain text
#: zsh.texi:20229
msgid "Each matcher consists of"
msgstr "每个匹配器由以下部分组成"

#. type: itemize
#: zsh.texi:20235
msgid "a case-sensitive letter"
msgstr "一个大小写相关的字母"

#. type: itemize
#: zsh.texi:20237
msgid "a `@t{:}',"
msgstr "一个 `@t{:}',"

#. type: itemize
#: zsh.texi:20239
msgid "one or more patterns separated by pipes (`@t{|}'),"
msgstr "一个或多个用管道 (`@t{|}')分隔的模式、"

#. type: itemize
#: zsh.texi:20241
msgid "an equals sign (`@t{=}'), and"
msgstr "等号 (`@t{=}')，以及"

#. type: itemize
#: zsh.texi:20243
msgid "another pattern."
msgstr "另一个模式。"

#. type: Plain text
#: zsh.texi:20249
msgid ""
"The patterns before the `@t{=}' are used to match substrings of the current word.  For each matched substring, the corresponding part of the match pattern is broadened with the pattern after the `@t{=}', "
"by means of a logical @t{OR}."
msgstr " `@t{=}' 之前的模式用于匹配当前单词的子串。 对于每个匹配到的子串，匹配模式的相应部分将通过逻辑 @t{OR} 与 `@t{=}' 之后的模式进行扩展。"

#. type: Plain text
#: zsh.texi:20252
msgid "Each pattern in a matcher cosists of either"
msgstr "匹配器中的每个模式包括"

#. type: itemize
#: zsh.texi:20258
msgid "the empty string or"
msgstr "空字符串或"

#. type: itemize
#: zsh.texi:20260
msgid "a sequence of"
msgstr "一序列"

#. type: itemize
#: zsh.texi:20266
msgid "literal characters (which may be quoted with a `@t{\\}'),"
msgstr "字面字符（可以用一个`@t{\\}' 加引号），"

#. type: itemize
#: zsh.texi:20268
msgid "question marks (`@t{?}'),"
msgstr "问号标记 (`@t{?}'),"

#. type: itemize
#: zsh.texi:20271
msgid "bracket expressions (`@t{[...]}'; see the subsection @emph{Glob Operators} in @ref{Filename Generation}), and/or"
msgstr "括号表达式（ `@t{[...]}' ；见 @ref{文件名生成} 中的 @emph{Glob 操作符} 小节），和/或"

#. type: itemize
#: zsh.texi:20273
msgid "brace expressions (see below)."
msgstr "括号表达示 (见下文)."

#. type: Plain text
#: zsh.texi:20279
msgid "Other shell patterns are not allowed."
msgstr "其它 shell 模式是不允许的。"

#. type: Plain text
#: zsh.texi:20282
msgid "A brace expression, like a bracket expression, consists of a list of"
msgstr "一个大括号表达式，就像一个方括号表达式一样，由下面列表组成"

#. type: itemize
#: zsh.texi:20288
msgid "literal characters,"
msgstr "字面字符，"

#. type: itemize
#: zsh.texi:20290
msgid "ranges (`@t{0-9}'), and/or"
msgstr "范围 (`@t{0-9}')，和/或"

#. type: itemize
#: zsh.texi:20292
msgid "character classes (`@t{[:}@var{name}@t{:]}')."
msgstr "字符类(`@t{[:}@var{name}@t{:]}')。"

#. type: Plain text
#: zsh.texi:20296
msgid "However, they differ from each other as follows:"
msgstr "不过，它们之间的区别如下："

#. type: itemize
#: zsh.texi:20302
msgid "A brace expression is delimited by a pair of braces (`@t{@{...@}}')."
msgstr "大括号表达式由一对括号（`@t{@{...@}}'）分隔。"

#. type: itemize
#: zsh.texi:20306
msgid "Brace expressions do not support negations.  That is, an initial `@t{!}' or `@t{^}' has no special meaning and will be interpreted as a literal character."
msgstr "括号表达式不支持否定。 也就是说，开头的 `@t{!}' 或 `@t{^}' 没有特殊含义，将被解释为字面字符。"

#. type: itemize
#: zsh.texi:20318
msgid ""
"When a character in the current word matches the @var{n}th pattern in a brace expression, the corresponding part of the match pattern is broadened only with the @var{n}th pattern of the brace expression "
"on the other side of the `@t{=}', if there is one; if there is no brace expression on the other side, then this pattern is the empty string.  However, if either brace expression has more elements than the "
"other, then the excess entries are simply ignored.  When comparing indexes, each literal character or character class counts as one element, but each range is instead expanded to the full list of literal "
"characters it represents.  Additionally, if on @emph{both} sides of the `@t{=}', the @var{n}th pattern is `@t{[:upper:]}' or `@t{[:lower:]}', then these are expanded as ranges, too."
msgstr ""
"如果当前单词中的一个字符与一个括号表达式中的第 @var{n} 个模式匹配时，仅与 `@t{=}' 另一侧的括号表达式中的第 @var{n} 个模式（如果有的话）匹配模式的相应部分会进行扩展；如果另一侧没有括号表达式，则该模式为空字"
"符串。 但是，如果任何一个括号表达式的元素多于另一个括号表达式，那么多余的条目将被忽略。 在比较索引时，每个字面字符或字符类都算作一个元素，但每个范围都会扩展为它所代表的字面字符的完整列表。 此外，如果在 "
"`@t{=}' 的 @emph{两} 边上，第 @var{n} 个模式是 `@t{[:upper:]}' 或 `@t{[:lower:]}'，那么这些模式也会扩展为范围。"

#. type: Plain text
#: zsh.texi:20325
msgid ""
"Note that, although the matching system does not yet handle multibyte characters, this is likely to be a future extension.  Hence, using `@t{[:upper:]}' and `@t{[:lower:]}' is recommended over `@t{A-Z}' "
"and `@t{a-z}'."
msgstr "请注意，尽管匹配系统尚未处理多字节字符，但这很可能是未来的扩展。 因此，建议使用 `@t{[:upper:]}' 和 `@t{[:lower:]}' ，而不是 `@t{A-Z}' 和 `@t{a-z}'。"

#. type: Plain text
#: zsh.texi:20336
msgid ""
"Below are the different forms of matchers supported.  Each @emph{uppercase} form behaves exactly like its lowercase counterpart, but adds an additional step @emph{after} the match pattern has filtered out "
"non-matching completions: Each of a match's substrings that was matched by a subpattern from an uppercase matcher is replaced with the corresponding substring of the current word.  However, patterns from "
"@emph{lowercase} matchers have higher weight: If a substring of the current word was matched by patterns from both a lowercase and an uppercase matcher, then the lowercase matcher's pattern wins and the "
"corresponding part of the match is not modified."
msgstr ""
"以下是匹配器支持的不同形式。 每种 @emph{大写} 形式的行为都与小写匹配器完全相同，但在匹配模式过滤掉非匹配补全@emph{后}，会增加一个额外步骤： 由大写匹配器的子模式匹配的每个匹配子串都会被当前单词的相应子串替"
"换。 但是，来自 @emph{小写} 匹配器的模式权重更高：如果当前单词的子串同时被小写和大写匹配器的模式匹配，则小写匹配器的模式获胜，匹配的相应部分不会被修改。"

#. type: Plain text
#: zsh.texi:20340
msgid "Unless indicated otherwise, each example listed assumes @t{COMPLETE_IN_WORD} to be unset (as it is by default)."
msgstr "除非另有说明，否则列出的每个示例都假定 @t{COMPLETE_IN_WORD} 未设置（默认情况下是这样）。"

#. type: item
#: zsh.texi:20343
#, no-wrap
msgid "@t{m:}@var{word-pat}@t{=}@var{match-pat}"
msgstr "@t{m:}@var{word-pat}@t{=}@var{match-pat}"

#. type: itemx
#: zsh.texi:20344
#, no-wrap
msgid "@t{M:}@var{word-pat}@t{=}@var{match-pat}"
msgstr "@t{M:}@var{word-pat}@t{=}@var{match-pat}"

#. type: table
#: zsh.texi:20349
msgid "For each substring of the current word that matches @var{word-pat}, broaden the corresponding part of the match pattern to additionally match @var{match-pat}."
msgstr "对于当前单词中与 @var{word-pat} 匹配的每个子串，拓宽匹配模式的相应部分，使其额外匹配 @var{match-pat}。"

#. type: table
#: zsh.texi:20352 zsh.texi:20380 zsh.texi:20409 zsh.texi:20451 zsh.texi:20479 zsh.texi:26283 zsh.texi:40178
#, no-wrap
msgid "Examples:"
msgstr "例如："

#. type: table
#: zsh.texi:20359
msgid ""
"@t{m:@{[:lower:]@}=@{[:upper:]@}} lets any lower case character in the current word be completed to itself or its uppercase counterpart.  So, the completions `@t{foo}', `@t{FOO}' and `@t{Foo}' will are be "
"considered matches for the word `@t{fo}'."
msgstr "@t{m:@{[:lower:]@}=@{[:upper:]@}} 让当前单词中的任何小写字符都能补全为自己或其对应的大写字符。因此， `@t{foo}', `@t{FOO}' 和`@t{Foo}' 将被视为与单词 `@t{fo}' 匹配。"

#. type: table
#: zsh.texi:20365
msgid ""
"@t{M:_=} inserts every underscore from the current word into each match, in the same relative position, determined by matching the substrings around it.  So, given a completion `@t{foo}', the word "
"`@t{f_o}' will be completed to the match `@t{f_oo}', even though the latter was not present as a completion."
msgstr ""
"@t{M:_=} 将当前单词中的每一个下划线插入到每个匹配中，插入的相对位置相同，由其周围的子串匹配决定。 因此，在给定补全词 `@t{foo}' 的情况下，单词 `@t{f_o}' 将被补全为匹配词 `@t{f_oo}'，即使后者并不作为补全词出"
"现。"

#. type: item
#: zsh.texi:20368
#, no-wrap
msgid "@t{b:}@var{word-pat}@t{=}@var{match-pat}"
msgstr "@t{b:}@var{word-pat}@t{=}@var{match-pat}"

#. type: itemx
#: zsh.texi:20369
#, no-wrap
msgid "@t{B:}@var{word-pat}@t{=}@var{match-pat}"
msgstr "@t{B:}@var{word-pat}@t{=}@var{match-pat}"

#. type: itemx
#: zsh.texi:20370
#, no-wrap
msgid "@t{e:}@var{word-pat}@t{=}@var{match-pat}"
msgstr "@t{e:}@var{word-pat}@t{=}@var{match-pat}"

#. type: itemx
#: zsh.texi:20371
#, no-wrap
msgid "@t{E:}@var{word-pat}@t{=}@var{match-pat}"
msgstr "@t{E:}@var{word-pat}@t{=}@var{match-pat}"

#. type: table
#: zsh.texi:20377
msgid ""
"For each consecutive substring at the @t{b:}eginning or @t{e:}nd of the current word that matches @var{word-pat}, broaden the corresponding part of the match pattern to additionally match @var{match-pat}."
msgstr "对于当前单词开始 （ @t{b:}eginning ） 或结尾 （@t{e:}nd） 处匹配 @var{word-pat} 的每个连续子串，扩大匹配模式的相应部分，使其额外匹配 @var{match-pat}。"

#. type: table
#: zsh.texi:20385
msgid "`@t{b:-=+}' lets any number of minuses at the start of the current word be completed to a minus or a plus."
msgstr "`@t{b:-=+}'  可以将当前单词开头的任意数量的减号补全为一个减号或加号。"

#. type: table
#: zsh.texi:20389
msgid "`@t{B:0=}' adds all zeroes at the beginning of the current word to the beginning of each match."
msgstr "`@t{B:0=}' 会将当前单词开头的所有 0 添加到每个匹配的开头。"

#. type: item
#: zsh.texi:20392
#, no-wrap
msgid "@t{l:}@t{|}@var{word-pat}@t{=}@var{match-pat}"
msgstr "@t{l:}@t{|}@var{word-pat}@t{=}@var{match-pat}"

#. type: itemx
#: zsh.texi:20393
#, no-wrap
msgid "@t{L:}@t{|}@var{word-pat}@t{=}@var{match-pat}"
msgstr "@t{L:}@t{|}@var{word-pat}@t{=}@var{match-pat}"

#. type: itemx
#: zsh.texi:20394
#, no-wrap
msgid "@t{R:}@var{word-pat}@t{|}@t{=}@var{match-pat}"
msgstr "@t{R:}@var{word-pat}@t{|}@t{=}@var{match-pat}"

#. type: itemx
#: zsh.texi:20395
#, no-wrap
msgid "@t{r:}@var{word-pat}@t{|}@t{=}@var{match-pat}"
msgstr "@t{r:}@var{word-pat}@t{|}@t{=}@var{match-pat}"

#. type: table
#: zsh.texi:20401
msgid ""
"If there is a substring at the @t{l:}eft or @t{r:}ight edge of the current word that matches @var{word-pat}, then broaden the corresponding part of the match pattern to additionally match @var{match-pat}."
msgstr "如果在当前单词的 @t{l:}eft  (左)或 @t{r:}ight （右)边缘有子串与 @var{word-pat} 匹配，则扩大匹配模式的相应部分，使其额外匹配 @var{match-pat}。"

#. type: table
#: zsh.texi:20406
msgid "For each @t{l:}, @t{L:}, @t{r:} and @t{R:} matcher (including the ones below), the pattern @var{match-pat} may also be a `@t{*}'.  This matches any number of characters in a completion."
msgstr "对于每个 @t{l:}、@t{L:}、@t{r:} 和 @t{R:}匹配器（包括下面的匹配器），模式 @var{match-pat} 也可以是 `@t{*}'。 它可以匹配补全中的任意数量的字符。"

#. type: table
#: zsh.texi:20415
msgid "`@t{r:|=*}' appends a `@t{*}' to the match pattern, even when @t{COMPLETE_IN_WORD} is set and the cursor is not at the end of the current word."
msgstr "即使设置了 @t{COMPLETE_IN_WORD}，且光标不在当前单词的末尾，`@t{r:|=*}' 也会在匹配模式后添加 `@t{*}' 。"

#. type: table
#: zsh.texi:20419
msgid "If the current word starts with a minus, then `@t{L:|-=}' will prepend it to each match."
msgstr "如果当前单词以减号开头， `@t{L:|-=}' 将在每次匹配前加上减号。"

#. type: item
#: zsh.texi:20422
#, no-wrap
msgid "@t{l:}@var{anchor}@t{|}@var{word-pat}@t{=}@var{match-pat}"
msgstr "@t{l:}@var{anchor}@t{|}@var{word-pat}@t{=}@var{match-pat}"

#. type: itemx
#: zsh.texi:20423
#, no-wrap
msgid "@t{L:}@var{anchor}@t{|}@var{word-pat}@t{=}@var{match-pat}"
msgstr "@t{L:}@var{anchor}@t{|}@var{word-pat}@t{=}@var{match-pat}"

#. type: itemx
#: zsh.texi:20424
#, no-wrap
msgid "@t{r:}@var{word-pat}@t{|}@var{anchor}@t{=}@var{match-pat}"
msgstr "@t{r:}@var{word-pat}@t{|}@var{anchor}@t{=}@var{match-pat}"

#. type: itemx
#: zsh.texi:20425
#, no-wrap
msgid "@t{R:}@var{word-pat}@t{|}@var{anchor}@t{=}@var{match-pat}"
msgstr "@t{R:}@var{word-pat}@t{|}@var{anchor}@t{=}@var{match-pat}"

#. type: table
#: zsh.texi:20431
msgid ""
"For each substring of the current word that matches @var{word-pat} and has on its @t{l:}eft or @t{r:}ight another substring matching @var{anchor}, broaden the corresponding part of the match pattern to "
"additionally match @var{match-pat}."
msgstr "对于当前单词中匹配 @var{word-pat} 的每个子串，如果其 @t{l:}eft 或 @t{r:}ight 上有另一个子串匹配 @var{anchor}，则扩大匹配模式的相应部分，使其额外匹配 @var{match-pat}。"

#. type: table
#: zsh.texi:20439
msgid ""
"Note that these matchers (and the ones below) modify only what is matched by @var{word-pat}; they do not change the matching behavior of what is matched by @var{anchor} (or @var{coanchor}; see the "
"matchers below).  Thus, unless its corresponding part of the match pattern has been modified, the anchor in the current word has to match literally in each completion, just like any other substring of the "
"current word."
msgstr ""
"请注意，这些匹配器（以及下面的匹配器）只修改 @var{word-pat} 所匹配的内容；它们不会改变 @var{anchor} （或 @var{coanchor}；请参阅下面的匹配器）所匹配内容的匹配行为。 因此，除非匹配模式的相应部分被修改，否则"
"当前单词中的锚点必须像当前单词的任何其他子串一样，在每次完成时都进行字面匹配。"

#. type: table
#: zsh.texi:20448
msgid ""
"If a matcher includes at least one anchor (which includes the matchers with two anchors, below), then @var{match-pat} may also be `@t{*}' or `@t{**}'.  `@t{*}' can match any part of a completion that does "
"not contain any substrings matching @var{anchor}, whereas a `@t{**}' can match any part of a completion, period.  (Note that this is different from the behavior of `@t{*}' in the anchorless forms of "
"`@t{l:}' and `@t{r:}' and and also different from `@t{*}' and `@t{**}' in glob expressions.)"
msgstr ""
"如果一个匹配器包含至少一个锚点（包括下面有两个锚点的匹配器），那么 @var{match-pat} 也可以是 `@t{*}' 或 `@t{**}'。`@t{*}' 可以匹配不包含任何匹配 @var{anchor} 的子字符串的补全的任何部分，而 `@t{**}' 可以匹配"
"补全的任何部分。 (请注意，这不同于 `@t{l:}' 和 `@t{r:}'的无锚形式中的 `@t{*}' 行为，也不同于 glob 表达式中的 `@t{*}' 和 `@t{**}'）。"

#. type: table
#: zsh.texi:20456
msgid "`@t{r:|.=*}' makes the completion `@t{comp.sources.unix}' a match for the word `@t{..u}' --- but @emph{not} for the word `@t{.u}'."
msgstr "`@t{r:|.=*}' 使补全语句  `@t{comp.sources.unix}'  与单词 `@t{..u}' 匹配 --- 但与单词 `@t{.u}'@emph{不}匹配。"

#. type: table
#: zsh.texi:20460
msgid "Given a completion `@t{-}@t{-foo}', the matcher `@t{L:--|no-=}' will complete the word `@t{-}@t{-no-}' to the match `@t{-}@t{-no-foo}'."
msgstr "给定补全词 `@t{-}@t{-foo}'，匹配器 `@t{L:--|no-=}' 将补全 `@t{-}@t{-no-}' 到匹配的 `@t{-}@t{-no-foo}'。"

#. type: item
#: zsh.texi:20463
#, no-wrap
msgid "@t{l:}@var{anchor}@t{||}@var{coanchor}@t{=}@var{match-pat}"
msgstr "@t{l:}@var{anchor}@t{||}@var{coanchor}@t{=}@var{match-pat}"

#. type: itemx
#: zsh.texi:20464
#, no-wrap
msgid "@t{L:}@var{anchor}@t{||}@var{coanchor}@t{=}@var{match-pat}"
msgstr "@t{L:}@var{anchor}@t{||}@var{coanchor}@t{=}@var{match-pat}"

#. type: itemx
#: zsh.texi:20465
#, no-wrap
msgid "@t{r:}@var{coanchor}@t{||}@var{anchor}@t{=}@var{match-pat}"
msgstr "@t{r:}@var{coanchor}@t{||}@var{anchor}@t{=}@var{match-pat}"

#. type: itemx
#: zsh.texi:20466
#, no-wrap
msgid "@t{R:}@var{coanchor}@t{||}@var{anchor}@t{=}@var{match-pat}"
msgstr "@t{R:}@var{coanchor}@t{||}@var{anchor}@t{=}@var{match-pat}"

#. type: table
#: zsh.texi:20472
msgid ""
"For any two consecutive substrings of the current word that match @var{anchor} and @var{coanchor}, in the order given, insert the pattern @var{match-pat} between their corresponding parts in the match "
"pattern."
msgstr "对于当前单词中符合 @var{anchor} 和 @var{coanchor} 的任意两个连续子串，按照给出的顺序，在匹配模式中的相应部分之间插入模式 @var{match-pat}。"

#. type: table
#: zsh.texi:20476
msgid "Note that, unlike @var{anchor}, the pattern @var{coanchor} does not change what `@t{*}' can match."
msgstr "请注意，与 @var{anchor} 不同，模式 @var{coanchor} 并不改变 `@t{*}' 可以匹配的内容。"

#. type: table
#: zsh.texi:20487
msgid ""
"`@t{r:?||[[:upper:]]=*}' will complete the current word `@t{fB}' to `@t{fooBar}', but it will not complete it to `@t{fooHooBar}' (because `@t{*}' here cannot match anything that includes a match for "
"`@t{[[:upper:]]}), nor will it complete `@t{B}' to `@t{fooBar}' (because there is no character in the current word to match @var{coanchor})."
msgstr ""
"`@t{r:?||[[:upper:]]=*}' 会将当前单词 `@t{fB}' 补全为 `@t{fooBar}'，但不会将其补全为 `@t{fooHooBar}' （因为此处的 `@t{*}' 无法匹配包含 `@t{[[:upper:]]}' 的内容），也不会将 `@t{B}' 补全为 `@t{fooBar}'（因为"
"当前单词中没有与 @var{coanchor} 匹配的字符）。"

#. type: table
#: zsh.texi:20491
msgid "Given the current word `@t{pass.n}' and a completion `@t{pass.byname}', the matcher `@t{L:.||[[:alpha:]]=by}' will produce the match `@t{pass.name}'."
msgstr "给定当前单词  `@t{pass.n}' 和补全 `@t{pass.byname}'，匹配器 `@t{L:.||[[:alpha:]]=by}' 将产生匹配结果 `@t{pass.name}'。"

#. type: t{#1}
#: zsh.texi:20494
#, no-wrap
msgid "x:"
msgstr "x:"

#. type: table
#: zsh.texi:20498
msgid "Ignore this matcher and all matchers to its right."
msgstr "忽略该匹配器及其右侧的所有匹配器。"

#. type: table
#: zsh.texi:20504
msgid ""
"This matcher is used to mark the end of a match specification.  In a single standalone list of matchers, this has no use, but where match specifications are concatenated, as is often the case when using "
"the @ref{Completion System}, it can allow one match specification to override another."
msgstr ""
"该匹配器用于标记匹配规范的结束。 在一个独立的匹配器列表中，这个匹配器没有任何作用，但在匹配规范被连接起来的情况下（如使用 @ref{补全系统} 时经常出现的情况），它可以允许一个匹配规范覆盖另一个匹配规范。"

#. type: cindex
#: zsh.texi:20512
#, no-wrap
msgid "completion widgets, example"
msgstr "补全小部件, 示例"

#. type: Plain text
#: zsh.texi:20516
msgid "The first step is to define the widget:"
msgstr "第一步是定义小部件："

#. type: example
#: zsh.texi:20520
#, no-wrap
msgid "zle -C complete complete-word complete-files\n"
msgstr "zle -C complete complete-word complete-files\n"

#. type: Plain text
#: zsh.texi:20525
msgid "Then the widget can be bound to a key using the @t{bindkey} builtin command:"
msgstr "然后，可以使用 @t{bindkey} 内置命令将小部件绑定到一个键上："

#. type: example
#: zsh.texi:20529
#, no-wrap
msgid "bindkey '^X\\t' complete\n"
msgstr "bindkey '^X\\t' complete\n"

#. type: Plain text
#: zsh.texi:20535
msgid "After that the shell function @t{complete-files} will be invoked after typing control-X and TAB. The function should then generate the matches, e.g.:"
msgstr "之后输入 control-X 和 TAB 键后，将调用 shell 函数 @t{complete-files}。该函数将生成匹配，例如"

#. type: example
#: zsh.texi:20539
#, no-wrap
msgid "complete-files () @{ compadd - * @}\n"
msgstr "complete-files () @{ compadd - * @}\n"

#. type: Plain text
#: zsh.texi:20546
msgid "This function will complete files in the current directory matching the current word."
msgstr "该函数将补全当前目录中与当前单词匹配的文件。"

#. type: cindex
#: zsh.texi:20550
#, no-wrap
msgid "completion system"
msgstr "补全系统"

#. type: Plain text
#: zsh.texi:20562
msgid ""
"This describes the shell code for the `new' completion system, referred to as @t{compsys}.  It is written in shell functions based on the features described in the previous chapter, @ref{Completion "
"Widgets}."
msgstr "本章将介绍 \"新 \"补全系统的 shell 代码，即 @t{compsys}。 它是基于前一章 @ref{补全小部件}中描述的功能， 用 shell 函数编写的。"

#. type: Plain text
#: zsh.texi:20570
msgid ""
"The features are contextual, sensitive to the point at which completion is started.  Many completions are already provided.  For this reason, a user can perform a great many tasks without knowing any "
"details beyond how to initialize the system, which is described in @ref{Initialization}."
msgstr "这些功能与上下文有关，对开始补全的时间点很敏感。 许多补全功能已经提供。 因此，除了如何初始化系统（@ref{初始化}中对此进行了描述）之外，用户无需了解任何细节，就能执行大量任务。"

#. type: Plain text
#: zsh.texi:20573
msgid "The context that decides what completion is to be performed may be"
msgstr "决定执行何种补全的上下文可能是"

#. type: itemize
#: zsh.texi:20579
msgid "an argument or option position: these describe the position on the command line at which completion is requested.  For example `first argument to rmdir, the word being completed names a directory';"
msgstr "参数或选项位置：这些参数描述了请求补全的命令行上的位置。 例如，`rmdir 的第一个参数，要补全的单词名称是一个目录'；"

#. type: itemize
#: zsh.texi:20583
msgid "a special context, denoting an element in the shell's syntax.  For example `a word in command position' or `an array subscript'."
msgstr "一个特殊的上下文，表示 shell 语法中的一个元素。 例如 `命令位置上的单词' 或 `数组下标'。"

#. type: Plain text
#: zsh.texi:20588
msgid "A full context specification contains other elements, as we shall describe."
msgstr "完整的上下文规范还包含其他要素，我们将一一介绍。"

#. type: Plain text
#: zsh.texi:20593
msgid "Besides commands names and contexts, the system employs two more concepts, @emph{styles} and @emph{tags}.  These provide ways for the user to configure the system's behaviour."
msgstr "除了命令名称和上下文，系统还采用了另外两个概念，即样式 (@emph{styles}) 和标签（ @emph{tags}）。 它们为用户提供了配置系统行为的方法。"

#. type: Plain text
#: zsh.texi:20601
msgid ""
"Tags play a dual role.  They serve as a classification system for the matches, typically indicating a class of object that the user may need to distinguish.  For example, when completing arguments of the "
"@t{ls} command the user may prefer to try @t{files} before @t{directories}, so both of these are tags.  They also appear as the rightmost element in a context specification."
msgstr ""
"标签具有双重作用。 它们是匹配的分类系统，通常表示用户可能需要区分的对象类别。 例如，在填写 @t{ls} 命令的参数时，用户可能更愿意在 @t{directories} 之前尝试 @t{files}，因此这两个都是标记。 它们也会作为最右边"
"的元素出现在上下文规范中。"

#. type: Plain text
#: zsh.texi:20608
msgid ""
"Styles modify various operations of the completion system, such as output formatting, but also what kinds of completers are used (and in what order), or which tags are examined.  Styles may accept "
"arguments and are manipulated using the @t{zstyle} command described in @ref{The zsh/zutil Module}."
msgstr "样式可以修改补全系统的各种操作，例如输出格式，还可以修改使用哪种补全程序（以及使用顺序），或检查哪些标记。 样式可以接受参数，并使用 @ref{zsh/zutil 模块} 中描述的 @t{zstyle} 命令进行操作。"

#. type: Plain text
#: zsh.texi:20617
msgid ""
"In summary, tags describe @emph{what} the completion objects are, and style @t{how} they are to be completed.  At various points of execution, the completion system checks what styles and/or tags are "
"defined for the current context, and uses that to modify its behavior.  The full description of context handling, which determines how tags and other elements of the context influence the behaviour of "
"styles, is described in @ref{Completion System Configuration}."
msgstr ""
"总之，标记描述了 @emph{什么} 是补全对象，以及 @t{如何} 补全对象的样式。 在执行的不同阶段，补全系统会检查当前上下文定义了哪些样式和/或标签，并以此修改其行为。 上下文处理决定了上下文中的标记和其他元素如何影"
"响样式的行为，有关上下文处理的完整描述请参阅 @ref{补全系统配置}。"

#. type: Plain text
#: zsh.texi:20626
msgid ""
"When a completion is requested, a dispatcher function is called; see the description of @t{_main_complete} in the list of control functions below. This dispatcher decides which function should be called "
"to produce the completions, and calls it. The result is passed to one or more @emph{completers}, functions that implement individual completion strategies: simple completion, error correction, completion "
"with error correction, menu selection, etc."
msgstr ""
"当请求补全时，会调用一个调度函数；请参阅下面控制函数列表中 @t{_main_complete} 的描述。调度程序会决定调用哪个函数来生成补全，并调用该函数。调度结果将传递给一个或多个 @emph{completters}，这些函数实现了不同的"
"补全策略：简单补全、纠错、带纠错的补全、菜单选择等。"

#. type: Plain text
#: zsh.texi:20630
msgid "More generally, the shell functions contained in the completion system are of two types:"
msgstr "一般来说，补全系统包含两种 shell 函数："

#. type: itemize
#: zsh.texi:20635
msgid "those beginning `@t{comp}' are to be called directly; there are only a few of these;"
msgstr "以 `@t{comp}' 开头的将被直接调用；这样的调用只有少数几个；"

#. type: itemize
#: zsh.texi:20641
msgid ""
"those beginning `@t{_}' are called by the completion code.  The shell functions of this set, which implement completion behaviour and may be bound to keystrokes, are referred to as `widgets'.  These "
"proliferate as new completions are required."
msgstr "以 `@t{_}' 开头的函数会被补全代码调用。 这组 shell 函数用于实现补全行为并可与按键绑定，被称为 `小部件'。 当需要新的补全功能时，这些小工具就会大量出现。"

#. type: menuentry
#: zsh.texi:20653
msgid "Completion Directories::"
msgstr "补全目录::"

#. type: node
#: zsh.texi:20653 zsh.texi:24562 zsh.texi:26735 zsh.texi:26737 zsh.texi:26776
#, no-wrap
msgid "Completion System Variables"
msgstr "补全系统变量"

#. type: node
#: zsh.texi:20656 zsh.texi:20658 zsh.texi:21171
#, no-wrap
msgid "Initialization"
msgstr "初始化"

#. type: node
#: zsh.texi:20656 zsh.texi:21171 zsh.texi:21173 zsh.texi:23839
#, no-wrap
msgid "Completion System Configuration"
msgstr "补全系统配置"

#. type: findex
#: zsh.texi:20660
#, no-wrap
msgid "compinstall"
msgstr "compinstall"

#. type: cindex
#: zsh.texi:20661
#, no-wrap
msgid "completion system, installing"
msgstr "补全系统, 安装"

#. type: Plain text
#: zsh.texi:20668
msgid ""
"If the system was installed completely, it should be enough to call the shell function @t{compinit} from your initialization file; see the next section.  However, the function @t{compinstall} can be run "
"by a user to configure various aspects of the completion system."
msgstr "如果系统已完全安装完毕，只需在初始化文件中调用 shell 函数 @t{compinit}（参见下一节）即可。 不过，用户也可以运行函数 @t{compinstall} 来配置补全系统的各个方面。"

#. type: Plain text
#: zsh.texi:20680
msgid ""
"Usually, @t{compinstall} will insert code into @t{.zshrc}, although if that is not writable it will save it in another file and tell you that file's location.  Note that it is up to you to make sure that "
"the lines added to @t{.zshrc} are actually run; you may, for example, need to move them to an earlier place in the file if @t{.zshrc} usually returns early.  So long as you keep them all together "
"(including the comment lines at the start and finish), you can rerun @t{compinstall} and it will correctly locate and modify these lines.  Note, however, that any code you add to this section by hand is "
"likely to be lost if you rerun @t{compinstall}, although lines using the command `@t{zstyle}' should be gracefully handled."
msgstr ""
"通常，@t{compinstall} 会将代码插入 @t{.zshrc}，但如果该文件不可写，它就会将代码保存到另一个文件中，并告诉你该文件的位置。 需要注意的是，您需要确保添加到 @t{.zshrc} 中的行被实际运行；例如，如果 @t{.zshrc} "
"通常提前返回，您可能需要将它们移到文件中较早的位置。 只要将它们放在一起（包括开始和结束时的注释行），就可以重新运行 @t{compinstall}，它将正确定位并修改这些行。 不过需要注意的是，如果重新运行 "
"@t{compinstall}，手动添加到这一部分的代码很可能会丢失，不过使用命令 `@t{zstyle}' 的行应该会得到妥善处理。"

#. type: Plain text
#: zsh.texi:20686
msgid ""
"The new code will take effect next time you start the shell, or run @t{.zshrc} by hand; there is also an option to make them take effect immediately.  However, if @t{compinstall} has removed definitions, "
"you will need to restart the shell to see the changes."
msgstr "新代码将在下次启动 shell 或手动运行 @t{.zshrc} 时生效；也可以选择立即生效。 不过，如果 @t{compinstall} 删除了定义，则需要重新启动 shell 才能看到更改。"

#. type: Plain text
#: zsh.texi:20696
msgid ""
"To run @t{compinstall} you will need to make sure it is in a directory mentioned in your @t{fpath} parameter, which should already be the case if zsh was properly configured as long as your startup files "
"do not remove the appropriate directories from @t{fpath}.  Then it must be autoloaded (`@t{autoload -U compinstall}' is recommended).  You can abort the installation any time you are being prompted for "
"information, and your @t{.zshrc} will not be altered at all; changes only take place right at the end, where you are specifically asked for confirmation."
msgstr ""
"要运行 @t{compinstall}，您需要确保它位于 @t{fpath} 参数中提到的目录中，如果 zsh 配置正确，只要启动文件没有从 @t{fpath} 中移除相应的目录，那么情况应该已经如此。 然后必须自动加载（建议使用 `@t{autoload -U "
"compinstall}'）。 在提示符出现时，你可以随时中止安装，你的 @t{.zshrc} 完全不会被修改；只有在最后特别要求你确认时才会发生变化。"

#. type: subsection
#: zsh.texi:20699
#, no-wrap
msgid "Use of compinit"
msgstr "compinit 的使用"

#. type: findex
#: zsh.texi:20701
#, no-wrap
msgid "compinit"
msgstr "compinit"

#. type: cindex
#: zsh.texi:20702
#, no-wrap
msgid "completion system, initializing"
msgstr "补全系统, 初始化"

#. type: Plain text
#: zsh.texi:20708
msgid ""
"This section describes the use of @t{compinit} to initialize completion for the current session when called directly; if you have run @t{compinstall} it will be called automatically from your @t{.zshrc}."
msgstr "本节将介绍 @t{compinit} 的用法，当直接调用时，它将初始化当前会话的补全；如果运行了 @t{compinstall}，它将自动从 @t{.zshrc} 中调用。"

#. type: Plain text
#: zsh.texi:20723
msgid ""
"To initialize the system, the function @t{compinit} should be in a directory mentioned in the @t{fpath} parameter, and should be autoloaded (`@t{autoload -U compinit}' is recommended), and then run simply "
"as `@t{compinit}'.  This will define a few utility functions, arrange for all the necessary shell functions to be autoloaded, and will then re-define all widgets that do completion to use the new system.  "
"If you use the @t{menu-select} widget, which is part of the @t{zsh/complist} module, you should make sure that that module is loaded before the call to @t{compinit} so that that widget is also re-"
"defined.  If completion styles (see below) are set up to perform expansion as well as completion by default, and the TAB key is bound to @t{expand-or-complete}, @t{compinit} will rebind it to @t{complete-"
"word}; this is necessary to use the correct form of expansion."
msgstr ""
"要初始化系统，函数 @t{compinit} 应位于 @t{fpath} 参数中提到的目录中，并应自动加载（建议使用 `@t{autoload -U compinit}'），然后简单的以 `@t{compinit}' 的方式运行。 这将定义一些实用程序函数，安排自动加载所有"
"必要的 shell 函数，然后重新定义所有补全的小部件，以便使用新系统。 如果使用 @t{menu-select} 小部件（它是 @t{zsh/complist} 模块的一部分），则应确保在调用 @t{compinit} 之前加载了该模块，以便重新定义该小部"
"件。 如果补全样式（见下文）被设置为默认执行扩展和补全，且 TAB 键绑定到 @t{expand-or-complete}，则 @t{compinit} 将把它重新绑定到 @t{complete-word}；这对于使用正确的扩展形式是必要的。"

#. type: Plain text
#: zsh.texi:20728
msgid "Should you need to use the original completion commands, you can still bind keys to the old widgets by putting a `@t{.}' in front of the widget name, e.g. `@t{.expand-or-complete}'."
msgstr "如果您需要使用原始的补全命令，您仍然可以在小部件名称前加上 `@t{.}' ，例如 `@t{.expand-or-complete}'，从而将按键绑定到旧的小部件。"

#. type: Plain text
#: zsh.texi:20738
msgid ""
"To speed up the running of @t{compinit}, it can be made to produce a dumped configuration that will be read in on future invocations; this is the default, but can be turned off by calling @t{compinit} "
"with the option @t{-D}.  The dumped file is @t{.zcompdump} in the same directory as the startup files (i.e. @t{$ZDOTDIR} or @t{$HOME}); alternatively, an explicit file name can be given by `@t{compinit -"
"d} @var{dumpfile}'.  The next invocation of @t{compinit} will read the dumped file instead of performing a full initialization."
msgstr ""
"为了加快 @t{compinit} 的运行速度，我们可以让它生成一个转储配置文件，并在以后的调用中读入；这是默认设置，但也可以通过调用 @t{compinit} 并加上 @t{-D} 选项来关闭。 转储文件为 @t{.zcompdump}，与启动文件位于同"
"一目录（即 @t{$ZDOTDIR} 或 @t{$HOME}）；也可以通过 `@t{compinit -d} @var{dumpfile}' 给出明确的文件名。 下一次调用 @t{compinit} 时，将读取转储文件，而不是执行完全初始化。"

#. type: Plain text
#: zsh.texi:20748
msgid ""
"If the number of completion files changes, @t{compinit} will recognise this and produce a new dump file.  However, if the name of a function or the arguments in the first line of a @t{#compdef} function "
"(as described below)  change, it is easiest to delete the dump file by hand so that @t{compinit} will re-create it the next time it is run.  The check performed to see if there are new functions can be "
"omitted by giving the option @t{-C}.  In this case the dump file will only be created if there isn't one already."
msgstr ""
"如果补全文件的数量发生变化，@t{compinit} 会识别并生成新的转储文件。 不过，如果函数名称或 @t{#compdef} 函数（如下所述）第一行的参数发生变化，最简单的办法是手工删除转储文件，以便 @t{compinit} 下次运行时重新"
"创建。 可以通过 @t{-C} 选项省略检查是否有新函数的过程。 在这种情况下，只有在没有转储文件的情况下，才会创建转储文件。"

#. type: Plain text
#: zsh.texi:20754
msgid ""
"The dumping is actually done by another function, @t{compdump}, but you will only need to run this yourself if you change the configuration (e.g. using @t{compdef}) and then want to dump the new one.  The "
"name of the old dumped file will be remembered for this purpose."
msgstr "转储实际上是由另一个函数 @t{compdump} 完成的，但只有在更改配置（例如使用 @t{compdef}）后想要转储新配置时，才需要自己运行该函数。 为此，旧转储文件的名称将被记住。"

#. type: Plain text
#: zsh.texi:20759
msgid "If the parameter @t{_compdir} is set, @t{compinit} uses it as a directory where completion functions can be found; this is only necessary if they are not already in the function search path."
msgstr "如果设置了 @t{_compdir} 参数，@t{compinit} 就会将其用作查找补全函数的目录；只有在函数搜索路径中还没有补全函数时，才有必要这样做。"

#. type: Plain text
#: zsh.texi:20770
msgid ""
"For security reasons @t{compinit} also checks if the completion system would use files not owned by root or by the current user, or files in directories that are world- or group-writable or that are not "
"owned by root or by the current user.  If such files or directories are found, @t{compinit} will ask if the completion system should really be used.  To avoid these tests and make all files found be used "
"without asking, use the option @t{-u}, and to make @t{compinit} silently ignore all insecure files and directories use the option @t{-i}.  This security check is skipped entirely when the @t{-C} option is "
"given, provided the dumpfile exists."
msgstr ""
"出于安全考虑，@t{compinit} 还会检查补全系统是否会使用非根用户或当前用户所有的文件，或者世界或组可写目录中非根用户或当前用户所有的文件。 如果发现此类文件或目录，@t{compinit} 将询问是否真的应该使用补全系"
"统。 使用 @t{-u} 选项可避免这些测试，并使找到的所有文件都无需询问即可使用；使用 @t{-i} 选项可使 @t{compinit} 静默忽略所有不安全的文件和目录。 如果使用 @t{-C} 选项，只要转储文件存在，就会完全跳过安全检查。"

#. type: findex
#: zsh.texi:20772
#, no-wrap
msgid "compaudit"
msgstr "compaudit"

#. type: Plain text
#: zsh.texi:20782
msgid ""
"The security check can be retried at any time by running the function @t{compaudit}.  This is the same check used by @t{compinit}, but when it is executed directly any changes to @t{fpath} are made local "
"to the function so they do not persist.  The directories to be checked may be passed as arguments; if none are given, @t{compaudit} uses @t{fpath} and @t{_compdir} to find completion system directories, "
"adding missing ones to @t{fpath} as necessary.  To force a check of exactly the directories currently named in @t{fpath}, set @t{_compdir} to an empty string before calling @t{compaudit} or @t{compinit}."
msgstr ""
"运行 @t{compaudit} 函数可随时重试安全检查。 这与 @t{compinit} 使用的检查方法相同，但在直接执行 @t{compaudit} 时，对 @t{fpath} 的任何更改都会在函数本地进行，因此不会持久存在。 需要检查的目录可以作为参数传"
"递；如果没有参数，@t{compaudit} 会使用 @t{fpath} 和 @t{_compdir} 查找补全系统目录，并根据需要将缺失的目录添加到 @t{fpath} 中。 要强制检查 @t{fpath} 中当前命名的目录，可在调用 @t{compaudit} 或 @t{compinit} "
"之前将 @t{_compdir} 设置为空字符串。"

#. type: findex
#: zsh.texi:20784
#, no-wrap
msgid "bashcompinit"
msgstr "bashcompinit"

#. type: Plain text
#: zsh.texi:20790
msgid ""
"The function @t{bashcompinit} provides compatibility with bash's programmable completion system.  When run it will define the functions, @t{compgen} and @t{complete} which correspond to the bash builtins "
"with the same names.  It will then be possible to use completion specifications and functions written for bash."
msgstr "函数 @t{bashcompinit} 与 bash 的可编程补全系统兼容。 运行该函数时，它将定义 @t{compgen} 和 @t{complete} 函数，这两个函数与同名的 bash 内置函数相对应。 这样就可以使用为 bash 编写的补全规范和函数。"

#. type: subsection
#: zsh.texi:20793
#, no-wrap
msgid "Autoloaded files"
msgstr "自动加载的文件"

#. type: cindex
#: zsh.texi:20795
#, no-wrap
msgid "completion system, autoloaded functions"
msgstr "补全系统, 自动加载的函数"

#. type: Plain text
#: zsh.texi:20803
msgid ""
"The convention for autoloaded functions used in completion is that they start with an underscore; as already mentioned, the @t{fpath/FPATH} parameter must contain the directory in which they are stored.  "
"If @t{zsh} was properly installed on your system, then @t{fpath/FPATH} automatically contains the required directories for the standard functions."
msgstr "补全时使用的自动加载函数的惯例是以下划线开头；如前所述，@t{fpath/FPATH} 参数必须包含存储这些函数的目录。 如果 @t{zsh} 已在系统中正确安装，那么 @t{fpath/FPATH} 就会自动包含标准函数所需的目录。"

#. type: Plain text
#: zsh.texi:20814
msgid ""
"For incomplete installations, if @t{compinit} does not find enough files beginning with an underscore (fewer than twenty) in the search path, it will try to find more by adding the directory @t{_compdir} "
"to the search path.  If that directory has a subdirectory named @t{Base}, all subdirectories will be added to the path.  Furthermore, if the subdirectory @t{Base} has a subdirectory named @t{Core}, "
"@t{compinit} will add all subdirectories of the subdirectories to the path: this allows the functions to be in the same format as in the @t{zsh} source distribution."
msgstr ""
"对于不完整的安装，如果 @t{compinit} 无法在搜索路径中找到足够的以下划线开头的文件（少于 20 个），则会尝试在搜索路径中添加 @t{_compdir} 目录，以找到更多文件。 如果该目录有一个名为 @t{Base} 的子目录，所有子目"
"录都将被添加到路径中。 此外，如果 @t{Base} 子目录下有一个名为 @t{Core} 的子目录，@t{compinit} 将把该子目录的所有子目录添加到路径中：这使得函数的格式与 @t{zsh} 源代码发布版中的格式相同。"

#. type: cindex
#: zsh.texi:20816
#, no-wrap
msgid "compdef, use of by compinit"
msgstr "compdef, use of by compinit"

#. type: Plain text
#: zsh.texi:20822
msgid ""
"When @t{compinit} is run, it searches all such files accessible via @t{fpath/FPATH} and reads the first line of each of them.  This line should contain one of the tags described below.  Files whose first "
"line does not start with one of these tags are not considered to be part of the completion system and will not be treated specially."
msgstr ""
"运行 @t{compinit} 时，它会搜索所有可通过 @t{fpath/FPATH} 访问的此类文件，并读取每个文件的第一行。 该行应包含下述标记之一。 如果文件的第一行不是以这些标记之一开头，则不会被视为补全系统的一部分，也不会受到特"
"殊处理。"

#. type: Plain text
#: zsh.texi:20825
msgid "The tags are:"
msgstr "标记是："

#. type: item
#: zsh.texi:20828
#, no-wrap
msgid "@t{#compdef} @var{name} ... [ @t{-}@{@t{p}|@t{P}@} @var{pattern} ... [ @t{-N} @var{name} ... ] ]"
msgstr "@t{#compdef} @var{name} ... [ @t{-}@{@t{p}|@t{P}@} @var{pattern} ... [ @t{-N} @var{name} ... ] ]"

#. type: table
#: zsh.texi:20834
msgid ""
"The file will be made autoloadable and the function defined in it will be called when completing @var{name}s, each of which is either the name of a command whose arguments are to be completed or one of a "
"number of special contexts in the form @t{-}@var{context}@t{-} described below."
msgstr "该文件将自动加载，在补全 @var{name}s 时将调用其中定义的函数，每个 @var{name}s 要么是要补全参数的命令名称，要么是下面描述的 @t{-}@var{context}@t{-} 形式的一系列特殊上下文之一。"

#. type: table
#: zsh.texi:20844
msgid ""
"Each @var{name} may also be of the form `@var{cmd}@t{=}@var{service}'.  When completing the command @var{cmd}, the function typically behaves as if the command (or special context) @var{service} was being "
"completed instead.  This provides a way of altering the behaviour of functions that can perform many different completions.  It is implemented by setting the parameter @t{$service} when calling the "
"function; the function may choose to interpret this how it wishes, and simpler functions will probably ignore it."
msgstr ""
"每个 @var{name} 也可以是 `@var{cmd}@t{=}@var{service}' 的形式。 在补全 @var{cmd} 命令时，函数的行为通常会被视为正在补全 @var{service} 命令（或特殊上下文）。 这提供了一种改变函数行为的方法，这些函数可以执行"
"多种不同的补全操作。 它是通过在调用函数时设置参数 @t{$service} 来实现的；函数可以自行选择如何解释，而较简单的函数可能会忽略它。"

#. type: table
#: zsh.texi:20852
msgid ""
"If the @t{#compdef} line contains one of the options @t{-p} or @t{-P}, the words following are taken to be patterns.  The function will be called when completion is attempted for a command or context that "
"matches one of the patterns.  The options @t{-p} and @t{-P} are used to specify patterns to be tried before or after other completions respectively.  Hence @t{-P} may be used to specify default actions."
msgstr ""
"如果 @t{#compdef} 行包含 @t{-p} 或 @t{-P} 选项之一，则后面的单词将被视为模式。 当试图补全与其中一个模式匹配的命令或上下文时，函数将被调用。 选项 @t{-p} 和 @t{-P} 分别用于指定在其他补全之前或之后尝试的模"
"式。 因此 @t{-P} 可用来指定默认操作。"

#. type: table
#: zsh.texi:20857
msgid ""
"The option @t{-N} is used after a list following @t{-p} or @t{-P}; it specifies that remaining words no longer define patterns.  It is possible to toggle between the three options as many times as "
"necessary."
msgstr "选项 @t{-N} 用于 @t{-p} 或 @t{-P} 之后的列表；它指定剩余的词不再定义模式。 可以根据需要在这三个选项之间多次切换。"

#. type: item
#: zsh.texi:20858
#, no-wrap
msgid "@t{#compdef -k} @var{style key-sequence} ..."
msgstr "@t{#compdef -k} @var{style key-sequence} ..."

#. type: table
#: zsh.texi:20867
msgid ""
"This option creates a widget behaving like the builtin widget @var{style} and binds it to the given @var{key-sequence}s, if any.  The @var{style} must be one of the builtin widgets that perform "
"completion, namely @t{complete-word}, @t{delete-char-or-list}, @t{expand-or-complete}, @t{expand-or-complete-prefix}, @t{list-choices}, @t{menu-complete}, @t{menu-expand-or-complete}, or @t{reverse-menu-"
"complete}.  If the @t{zsh/complist} module is loaded (see @ref{The zsh/complist Module}) the widget @t{menu-select} is also available."
msgstr ""
"该选项会创建一个与内置小部件 @var{style} 行为类似的小部件，并将其绑定到给定的 @var{key-sequence}s 上（如果有的话）。 @var{style} 必须是执行补全的内置小部件之一，即 @t{complete-word}、@t{delete-char-or-"
"list}、@t{expand-or-complete}、@t{expand-or-complete-prefix}、@t{list-choices}、@t{menu-complete}、@t{menu-expand-or-complete} 或 @t{reverse-menu-complete}。 如果已加载 @t{zsh/complist} 模块（请参阅 "
"@ref{zsh/complist 模块}），小部件 @t{menu-select} 也将可用。"

#. type: table
#: zsh.texi:20874
msgid ""
"When one of the @var{key-sequence}s is typed, the function in the file will be invoked to generate the matches.  Note that a key will not be re-bound if it already was (that is, was bound to something "
"other than @t{undefined-key}).  The widget created has the same name as the file and can be bound to any other keys using @t{bindkey} as usual."
msgstr ""
"键入 @var{key-sequence}s 之一时，文件中的函数将被调用以生成匹配。 需要注意的是，如果某个键已经绑定（即绑定到 @t{undefined-key} 以外的其他键），则不会重新绑定。 创建的小部件与文件名相同，可以像往常一样使用 "
"@t{bindkey} 绑定到任何其他键。"

#. type: item
#: zsh.texi:20875
#, no-wrap
msgid "@t{#compdef -K} @var{widget-name} @var{style} @var{key-sequence} [ @var{name} @var{style} @var{seq} ... ]"
msgstr "@t{#compdef -K} @var{widget-name} @var{style} @var{key-sequence} [ @var{name} @var{style} @var{seq} ... ]"

#. type: table
#: zsh.texi:20884
msgid ""
"This is similar to @t{-k} except that only one @var{key-sequence} argument may be given for each @var{widget-name} @var{style} pair.  However, the entire set of three arguments may be repeated with a "
"different set of arguments.  Note in particular that the @var{widget-name} must be distinct in each set.  If it does not begin with `@t{_}' this will be added.  The @var{widget-name} should not clash with "
"the name of any existing widget: names based on the name of the function are most useful.  For example,"
msgstr ""
"除了每个 @var{widget-name} @var{style} 对只能给出一个 @var{key-sequence} 参数外，该参数与 @t{-k} 类似。不过，整组三个参数可以用不同的参数重复使用。 需要特别注意的是，每组中的 @var{widget-name} 必须是不同"
"的。 如果不是以 `@t{_}' 开头，则会被添加。 @var{widget-name} 不应与任何现有小部件的名称相冲突：基于函数名称的名称最有用。 例如"

#. type: example
#: zsh.texi:20889
#, no-wrap
msgid ""
"#compdef -K _foo_complete complete-word \"^X^C\" \\ \n"
"  _foo_list list-choices \"^X^D\"\n"
msgstr ""
"#compdef -K _foo_complete complete-word \"^X^C\" \\ \n"
"  _foo_list list-choices \"^X^D\"\n"

#. type: table
#: zsh.texi:20894
msgid "(all on one line) defines a widget @t{_foo_complete} for completion, bound to `@t{^X^C}', and a widget @t{_foo_list} for listing, bound to `@t{^X^D}'."
msgstr "(在一行中）定义了一个用于完成的小部件 @t{_foo_complete}，绑定到`@t{^X^C}'，以及一个用于列出的小部件 @t{_foo_list}，绑定到`@t{^X^D}'。"

#. type: item
#: zsh.texi:20895
#, no-wrap
msgid "@t{#autoload} [ @var{options} ]"
msgstr "@t{#autoload} [ @var{options} ]"

#. type: table
#: zsh.texi:20902
msgid ""
"Functions with the @t{#autoload} tag are marked for autoloading but are not otherwise treated specially.  Typically they are to be called from within one of the completion functions.  Any @var{options} "
"supplied will be passed to the @t{autoload} builtin; a typical use is @t{+X} to force the function to be loaded immediately.  Note that the @t{-U} and @t{-z} flags are always added implicitly."
msgstr ""
"带有 @t{#autoload} 标记的函数会被标记为自动加载，但不会被特殊处理。 通常情况下，这些函数会在某个补全函数中被调用。 提供的任何 @var{options} 都将传递给 @t{autoload} 内置函数；典型用法是 @t{+X} 强制立即加载"
"函数。 请注意，@t{-U} 和 @t{-z} 标志总是隐式添加的。"

#. type: Plain text
#: zsh.texi:20909
msgid ""
"The @t{#} is part of the tag name and no white space is allowed after it.  The @t{#compdef} tags use the @t{compdef} function described below; the main difference is that the name of the function is "
"supplied implicitly."
msgstr "@t{#} 是标记名的一部分，后面不允许留白。 @t{#compdef} 标签使用下面描述的 @t{compdef} 函数；主要区别在于函数名称是隐式提供的。"

#. type: Plain text
#: zsh.texi:20912
msgid "The special contexts for which completion functions can be defined are:"
msgstr "可定义补全函数的特殊上下文有:"

#. type: kindex
#: zsh.texi:20915
#, no-wrap
msgid "-array-value-, completion context"
msgstr "-array-value-, 补全上下文"

#. type: t{#1}
#: zsh.texi:20916
#, no-wrap
msgid "-array-value-"
msgstr "-array-value-"

#. type: table
#: zsh.texi:20919
msgid "The right hand side of an array-assignment (`@var{name}@t{=(}@var{...}@t{)}')"
msgstr "数组赋值的右侧 (`@var{name}@t{=(}@var{...}@t{)}')"

#. type: kindex
#: zsh.texi:20920
#, no-wrap
msgid "-assign-parameter-, completion context"
msgstr "-assign-parameter-, 补全上下文"

#. type: t{#1}
#: zsh.texi:20921
#, no-wrap
msgid "-assign-parameter-"
msgstr "-assign-parameter-"

#. type: table
#: zsh.texi:20924
msgid "The name of a parameter in an assignment, i.e. on the left hand side of an `@t{=}'"
msgstr "赋值中参数的名称，即 `@t{=}' 的左边"

#. type: kindex
#: zsh.texi:20925
#, no-wrap
msgid "-brace-parameter-, completion context"
msgstr "-brace-parameter-, 补全上下文"

#. type: t{#1}
#: zsh.texi:20926
#, no-wrap
msgid "-brace-parameter-"
msgstr "-brace-parameter-"

#. type: table
#: zsh.texi:20928
msgid "The name of a parameter expansion within braces (`@t{$@{}@var{...}@t{@}}')"
msgstr "大括号内的参数扩展名 (`@t{$@{}@var{...}@t{@}}')"

#. type: kindex
#: zsh.texi:20929
#, no-wrap
msgid "-command-, completion context"
msgstr "-command-, 补全上下文"

#. type: t{#1}
#: zsh.texi:20930
#, no-wrap
msgid "-command-"
msgstr "-command-"

#. type: table
#: zsh.texi:20932
msgid "A word in command position"
msgstr "命令位置上的一个单词"

#. type: kindex
#: zsh.texi:20933
#, no-wrap
msgid "-condition-, completion context"
msgstr "-condition-, 补全上下文"

#. type: t{#1}
#: zsh.texi:20934
#, no-wrap
msgid "-condition-"
msgstr "-condition-"

#. type: table
#: zsh.texi:20936
msgid "A word inside a condition (`@t{[[}@var{...}@t{]]}')"
msgstr "条件中的单词 (`@t{[[}@var{...}@t{]]}')"

#. type: kindex
#: zsh.texi:20937
#, no-wrap
msgid "-default-, completion context"
msgstr "-default-, 补全上下文"

#. type: t{#1}
#: zsh.texi:20938
#, no-wrap
msgid "-default-"
msgstr "-default-"

#. type: table
#: zsh.texi:20940
msgid "Any word for which no other completion is defined"
msgstr "没有其他补全定义的任何单词"

#. type: kindex
#: zsh.texi:20941
#, no-wrap
msgid "-equal-, completion context"
msgstr "-equal-, 补全上下文"

#. type: t{#1}
#: zsh.texi:20942
#, no-wrap
msgid "-equal-"
msgstr "-equal-"

#. type: table
#: zsh.texi:20944
msgid "A word beginning with an equals sign"
msgstr "以等号开头的单词"

#. type: kindex
#: zsh.texi:20945
#, no-wrap
msgid "-first-, completion context"
msgstr "-first-, 补全上下文"

#. type: t{#1}
#: zsh.texi:20946
#, no-wrap
msgid "-first-"
msgstr "-first-"

#. type: table
#: zsh.texi:20954
msgid ""
"This is tried before any other completion function.  The function called may set the @t{_compskip} parameter to one of various values: @t{all}: no further completion is attempted; a string containing the "
"substring @t{patterns}: no pattern completion functions will be called; a string containing @t{default}: the function for the `@t{-default-}' context will not be called, but functions defined for commands "
"will be."
msgstr ""
"该函数会在任何其他补全函数之前被调用。 被调用的函数可以将 @t{_compskip} 参数设置为多种值之一： @t{all}：不再尝试其他补全函数；包含子串 @t{patterns} 的字符串：不调用模式补全函数；包含 @t{default} 的字符串："
"不调用 `@t{-default-}' 上下文的函数，但会调用为命令定义的函数。"

#. type: kindex
#: zsh.texi:20955
#, no-wrap
msgid "-math-, completion context"
msgstr "-math-, 补全上下文"

#. type: t{#1}
#: zsh.texi:20956
#, no-wrap
msgid "-math-"
msgstr "-math-"

#. type: table
#: zsh.texi:20959
msgid "Inside mathematical contexts, such as `@t{((}@var{...}@t{))}'"
msgstr "在数学语境中，如 `@t{((}@var{...}@t{))}'"

#. type: kindex
#: zsh.texi:20960
#, no-wrap
msgid "-parameter-, completion context"
msgstr "-parameter-, 补全上下文"

#. type: t{#1}
#: zsh.texi:20961
#, no-wrap
msgid "-parameter-"
msgstr "-parameter-"

#. type: table
#: zsh.texi:20963
msgid "The name of a parameter expansion (`@t{$}@var{...}')"
msgstr "参数扩展的名称(`@t{$}@var{...}')"

#. type: kindex
#: zsh.texi:20964
#, no-wrap
msgid "-redirect-, completion context"
msgstr "-redirect-, 补全上下文"

#. type: t{#1}
#: zsh.texi:20965
#, no-wrap
msgid "-redirect-"
msgstr "-redirect-"

#. type: table
#: zsh.texi:20967
msgid "The word after a redirection operator."
msgstr "重定向运算符后的单词。"

#. type: kindex
#: zsh.texi:20968
#, no-wrap
msgid "-subscript-, completion context"
msgstr "-subscript-, 补全上下文"

#. type: t{#1}
#: zsh.texi:20969
#, no-wrap
msgid "-subscript-"
msgstr "-subscript-"

#. type: table
#: zsh.texi:20971
msgid "The contents of a parameter subscript."
msgstr "参数下标内容。"

#. type: kindex
#: zsh.texi:20972
#, no-wrap
msgid "-tilde-, completion context"
msgstr "-tilde-, 补全上下文"

#. type: t{#1}
#: zsh.texi:20973
#, no-wrap
msgid "-tilde-"
msgstr "-tilde-"

#. type: table
#: zsh.texi:20976
msgid "After an initial tilde (`@t{~}'), but before the first slash in the word."
msgstr "在开头的波浪线之后（`@t{~}'），单词的第一个斜线之前。"

#. type: kindex
#: zsh.texi:20977
#, no-wrap
msgid "-value-, completion context"
msgstr "-value-, 补全上下文"

#. type: t{#1}
#: zsh.texi:20978
#, no-wrap
msgid "-value-"
msgstr "-value-"

#. type: table
#: zsh.texi:20980
msgid "On the right hand side of an assignment."
msgstr " 在赋值的右边。"

#. type: Plain text
#: zsh.texi:20988
msgid ""
"Default implementations are supplied for each of these contexts.  In most cases the context @t{-}@var{context}@t{-} is implemented by a corresponding function @t{_}@var{context}, for example the context "
"`@t{-tilde-}' and the function `@t{_tilde}')."
msgstr "这些上下文每个都有默认实现。 在大多数情况下，上下文 @t{-}@var{context}@t{-} 由相应的函数 @t{_}@var{context} 实现，例如上下文 `@t{-tilde-}' 和函数 `@t{_tilde}'）。"

#. type: Plain text
#: zsh.texi:20994
msgid ""
"The contexts @t{-redirect-} and @t{-value-} allow extra context-specific information.  (Internally, this is handled by the functions for each context calling the function @t{_dispatch}.)  The extra "
"information is added separated by commas."
msgstr "上下文 @t{-redirect-} 和 @t{-value-} 允许使用额外的特定上下文信息。 (在内部，这些信息由调用 @t{_dispatch} 的每个上下文的函数处理）。 额外信息用逗号分隔。"

#. type: Plain text
#: zsh.texi:21001
msgid ""
"For the @t{-redirect-} context, the extra information is in the form `@t{-redirect-,}@var{op}@t{,}@var{command}', where @var{op} is the redirection operator and @var{command} is the name of the command on "
"the line.  If there is no command on the line yet, the @var{command} field will be empty."
msgstr ""
"对于 @t{-redirect-} 上下文，额外信息的格式为 `@t{-redirect-,}@var{op}@t{,}@var{command}'，其中 @var{op} 是重定向操作符，@var{command} 是该行上的命令名称。 如果行中还没有命令，@var{command} 字段将为空。"

#. type: Plain text
#: zsh.texi:21011
msgid ""
"For the @t{-value-} context, the form is `@t{-value-,}@var{name}@t{,}@var{command}', where @var{name} is the name of the parameter on the left hand side of the assignment.  In the case of elements of an "
"associative array, for example `@t{assoc=(key <TAB>}', @var{name} is expanded to `@var{name}@t{-}@var{key}'.  In certain special contexts, such as completing after `@t{make CFLAGS=}', the @var{command} "
"part gives the name of the command, here @t{make}; otherwise it is empty."
msgstr ""
"对于 @t{-value-} 上下文，其形式为 `@t{-value-,}@var{name}@t{,}@var{command}'，其中 @var{name} 是赋值左侧的参数名称。 对于关联数组中的元素，例如 `@t{assoc=(key <TAB>}'，@var{name} 会扩展为 `@var{name}@t{-}"
"@var{key}'。 在某些特殊情况下，例如在 `@t{make CFLAGS=}' 之后补全，@var{command} 部分会给出命令名称，此处为 @t{make}；否则为空。"

#. type: Plain text
#: zsh.texi:21020
msgid ""
"It is not necessary to define fully specific completions as the functions provided will try to generate completions by progressively replacing the elements with `@t{-default-}'.  For example, when "
"completing after `@t{foo=<TAB>}', @t{_value} will try the names `@t{-value-,foo,}' (note the empty @var{command} part), `@t{-value-,foo,-default-}' and`@t{-value-,-default-,-default-}', in that order, "
"until it finds a function to handle the context."
msgstr ""
"没有必要定义完全特定的补全，因为所提供的函数会尝试通过逐步替换 `@t{-default-}' 元素来生成补全。 例如，当在 `@t{foo=<TAB>}' 后补全时，@t{_value} 将依次尝试 `@t{-value-,foo,}' （注意 @var{command} 部分为"
"空）、`@t{-value-,foo,-default-}' 和`@t{-value-,-default-,-default-}'，直到找到可以处理上下文的函数。"

#. type: Plain text
#: zsh.texi:21023
msgid "As an example:"
msgstr "作为一个例子："

#. type: example
#: zsh.texi:21027
#, no-wrap
msgid "compdef '_files -g \"*.log\"' '-redirect-,2>,-default-'\n"
msgstr "compdef '_files -g \"*.log\"' '-redirect-,2>,-default-'\n"

#. type: Plain text
#: zsh.texi:21032
msgid "completes files matching `@t{*.log}' after `@t{2> <TAB>}' for any command with no more specific handler defined."
msgstr "补全在 `@t{2> <TAB>}' 之后与 `@t{*.log}' 匹配的文件，适用于任何未定义更多特定处理程序的命令。"

#. type: Plain text
#: zsh.texi:21035
msgid "Also:"
msgstr "还有："

#. type: example
#: zsh.texi:21039
#, no-wrap
msgid "compdef _foo -value-,-default-,-default-\n"
msgstr "compdef _foo -value-,-default-,-default-\n"

#. type: Plain text
#: zsh.texi:21045
msgid "specifies that @t{_foo} provides completions for the values of parameters for which no special function has been defined.  This is usually handled by the function @t{_value} itself."
msgstr "指定 @t{_foo} 为未定义特殊函数的参数值提供补全。 这通常由函数 @t{_value} 本身处理。"

#. type: Plain text
#: zsh.texi:21049
msgid "The same lookup rules are used when looking up styles (as described below); for example"
msgstr "查找样式时也使用相同的查找规则（如下所述），例如"

#. type: example
#: zsh.texi:21053
#, no-wrap
msgid "zstyle ':completion:*:*:-redirect-,2>,*:*' file-patterns '*.log'\n"
msgstr "zstyle ':completion:*:*:-redirect-,2>,*:*' file-patterns '*.log'\n"

#. type: Plain text
#: zsh.texi:21058
msgid "is another way to make completion after `@t{2> <TAB>}' complete files matching `@t{*.log}'."
msgstr "是另一种方法，可让 `@t{2> <TAB>}' 后的补全操作补全与 `@t{*.log}' 匹配的文件。"

#. type: Plain text
#: zsh.texi:21067
msgid "The following function is defined by @t{compinit} and may be called directly."
msgstr "以下函数由 @t{compinit} 定义，可直接调用。"

#. type: findex
#: zsh.texi:21069
#, no-wrap
msgid "compdef"
msgstr "compdef"

#. type: cindex
#: zsh.texi:21070
#, no-wrap
msgid "completion system, adding definitions"
msgstr "补全系统, 增加定义"

#. type: item
#: zsh.texi:21073
#, no-wrap
msgid "@t{compdef} [ @t{-ane} ] @var{function name} ... [ @t{-}@{@t{p}|@t{P}@} @var{pattern} ... [ @t{-N} @var{name} ...]]"
msgstr "@t{compdef} [ @t{-ane} ] @var{function name} ... [ @t{-}@{@t{p}|@t{P}@} @var{pattern} ... [ @t{-N} @var{name} ...]]"

#. type: itemx
#: zsh.texi:21074
#, no-wrap
msgid "@t{compdef -d} @var{name} ..."
msgstr "@t{compdef -d} @var{name} ..."

#. type: itemx
#: zsh.texi:21075
#, no-wrap
msgid "@t{compdef -k} [ @t{-an} ] @var{function style key-sequence} [ @var{key-sequence} ... ]"
msgstr "@t{compdef -k} [ @t{-an} ] @var{function style key-sequence} [ @var{key-sequence} ... ]"

#. type: itemx
#: zsh.texi:21076
#, no-wrap
msgid "@t{compdef -K} [ @t{-an} ] @var{function name style key-seq} [ @var{name style seq} ... ]"
msgstr "@t{compdef -K} [ @t{-an} ] @var{function name style key-seq} [ @var{name style seq} ... ]"

#. type: table
#: zsh.texi:21079
msgid "The first form defines the @var{function} to call for completion in the given contexts as described for the @t{#compdef} tag above."
msgstr "第一种形式定义了在给定上下文中调用 @var{function} 来补全的 @t{#compdef} 标记。"

#. type: table
#: zsh.texi:21086
msgid ""
"Alternatively, all the arguments may have the form `@var{cmd}@t{=}@var{service}'.  Here @var{service} should already have been defined by `@var{cmd1}@t{=}@var{service}' lines in @t{#compdef} files, as "
"described above.  The argument for @var{cmd} will be completed in the same way as @var{service}."
msgstr ""
"或者，所有参数的形式可以是 `@var{cmd}@t{=}@var{service}'。 此处的 @var{service} 应已由 @t{#compdef} 文件中的 `@var{cmd1}@t{=}@var{service}' 行定义，如上所述。 @var{cmd} 的参数将以与 @var{service} 相同的方"
"式完成。"

#. type: table
#: zsh.texi:21096
msgid ""
"The @var{function} argument may alternatively be a string containing almost any shell code.  If the string contains an equal sign, the above will take precedence.  The option @t{-e} may be used to specify "
"the first argument is to be evaluated as shell code even if it contains an equal sign.  The string will be executed using the @t{eval} builtin command to generate completions.  This provides a way of "
"avoiding having to define a new completion function.  For example, to complete files ending in `@t{.h}' as arguments to the command @t{foo}:"
msgstr ""
"@var{function} 参数也可以是包含几乎所有 shell 代码的字符串。 如果字符串中包含等号，则上述参数优先。 可以使用选项 @t{-e}，将第一个参数指定为 shell 代码，即使其中包含等号。 该字符串将使用 @t{eval} 内置命令来"
"生成补全。 这样就可以避免定义新的补全函数。 例如，将以 `@t{.h}' 结尾的文件作为 @t{foo} 命令的参数来补全："

#. type: example
#: zsh.texi:21100
#, no-wrap
msgid "compdef '_files -g \"*.h\"' foo\n"
msgstr "compdef '_files -g \"*.h\"' foo\n"

#. type: table
#: zsh.texi:21105
msgid "The option @t{-n} prevents any completions already defined for the command or context from being overwritten."
msgstr "选项 @t{-n} 可防止已为命令或上下文定义的补全被覆盖。"

#. type: table
#: zsh.texi:21109
msgid "The option @t{-d} deletes any completion defined for the command or contexts listed."
msgstr "选项 @t{-d} 会删除为所列命令或上下文定义的任何补全。"

#. type: table
#: zsh.texi:21115
msgid ""
"The @var{name}s may also contain @t{-p}, @t{-P} and @t{-N} options as described for the @t{#compdef} tag.  The effect on the argument list is identical, switching between definitions of patterns tried "
"initially, patterns tried finally, and normal commands and contexts."
msgstr "@var{name}s 也可以包含 @t{-p}、@t{-P} 和 @t{-N} 选项，如 @t{#compdef} 标记所述。 对参数列表的影响是相同的，即在最初尝试的模式定义、最后尝试的模式定义以及正常命令和上下文之间切换。"

#. type: table
#: zsh.texi:21126
msgid ""
"The parameter @t{$_compskip} may be set by any function defined for a pattern context.  If it is set to a value containing the substring `@t{patterns}' none of the pattern-functions will be called; if it "
"is set to a value containing the substring `@t{all}', no other function will be called.  Setting @t{$_compskip} in this manner is of particular utility when using the @t{-p} option, as otherwise the "
"dispatcher will move on to additional functions (likely the default one) after calling the pattern-context one, which can mangle the display of completion possibilities if not handled properly."
msgstr ""
"参数 @t{$_compskip} 可由任何为模式上下文定义的函数设置。 如果将其设置为包含子串 `@t{patterns}' 的值，则不会调用任何模式函数；如果将其设置为包含子串 `@t{all}' 的值，则不会调用任何其他函数。 在使用 @t{-p} 选"
"项时，以这种方式设置 @t{$_compskip} 特别有用，否则调度程序会在调用模式上下文函数后继续调用其他函数（可能是默认函数），如果处理不当，可能会导致显示的补全可能混乱。"

#. type: table
#: zsh.texi:21139
msgid ""
"The form with @t{-k} defines a widget with the same name as the @var{function} that will be called for each of the @var{key-sequence}s; this is like the @t{#compdef -k} tag.  The function should generate "
"the completions needed and will otherwise behave like the builtin widget whose name is given as the @var{style} argument.  The widgets usable for this are: @t{complete-word}, @t{delete-char-or-list}, "
"@t{expand-or-complete}, @t{expand-or-complete-prefix}, @t{list-choices}, @t{menu-complete}, @t{menu-expand-or-complete}, and @t{reverse-menu-complete}, as well as @t{menu-select} if the @t{zsh/complist} "
"module is loaded.  The option @t{-n} prevents the key being bound if it is already to bound to something other than @t{undefined-key}."
msgstr ""
"带有 @t{-k} 的形式定义了一个与 @var{function} 同名的小部件，它将为每个 @var{key-sequence}s 调用；这就像 @t{#compdef -k} 标记一样。 该函数应生成所需的补全，否则其行为将与名称作为 @var{style} 参数给出的内置"
"小部件相同。 可用的小部件有 @t{complete-word}, @t{delete-char-or-list}, @t{expand-or-complete}, @t{expand-or-complete-prefix}, @t{list-choices}, @t{menu-complete}, @t{menu-expand-or-complete}  和 "
"@t{reverse-menu-complete}, 以及 @t{menu-select} （如果已加载 @t{zsh/complist} 模块）。 如果键已绑定到 @t{undefined-key} 以外的其他键，则选项 @t{-n} 将阻止键被绑定。"

#. type: table
#: zsh.texi:21146
msgid ""
"The form with @t{-K} is similar and defines multiple widgets based on the same @var{function}, each of which requires the set of three arguments @var{name}, @var{style} and @var{key-seq}uence, where the "
"latter two are as for @t{-k} and the first must be a unique widget name beginning with an underscore."
msgstr ""
"带有 @t{-K} 的形式与此类似，它基于同一个 @var{function} 定义多个小部件，每个小部件都需要 @var{name}、@var{style} 和 @var{key-seq}序列三个参数，其中后两个参数与 @t{-k} 相同，第一个参数必须是以下划线开头的唯"
"一小部件名称。"

#. type: table
#: zsh.texi:21150
msgid "Wherever applicable, the @t{-a} option makes the @var{function} autoloadable, equivalent to @t{autoload -U }@var{function}."
msgstr "在适用的情况下，@t{-a} 选项使 @var{function} 可自动加载，相当于 @t{autoload -U }@var{function}。"

#. type: Plain text
#: zsh.texi:21156
msgid "The function @t{compdef} can be used to associate existing completion functions with new commands.  For example,"
msgstr "函数 @t{compdef} 可用于将现有的补全函数与新命令关联起来。 例如"

#. type: example
#: zsh.texi:21160
#, no-wrap
msgid "compdef _pids foo\n"
msgstr "compdef _pids foo\n"

#. type: Plain text
#: zsh.texi:21164
msgid "uses the function @t{_pids} to complete process IDs for the command @t{foo}."
msgstr "使用函数 @t{_pids} 补全命令 @t{foo} 的进程 ID。"

#. type: Plain text
#: zsh.texi:21169
msgid "Note also the @t{_gnu_generic} function described below, which can be used to complete options for commands that understand the `@t{-}@t{-help}' option."
msgstr "还请注意下面介绍的 @t{_gnu_generic} 函数，该函数可用于能理解 `@t{-}@t{-help}' 选项的命令补全选项。"

#. type: node
#: zsh.texi:21171 zsh.texi:23839 zsh.texi:23841 zsh.texi:24336
#, no-wrap
msgid "Control Functions"
msgstr "控制函数"

#. type: cindex
#: zsh.texi:21175
#, no-wrap
msgid "completion system, configuration"
msgstr "补全系统, 配置"

#. type: Plain text
#: zsh.texi:21181
msgid "This section gives a short overview of how the completion system works, and then more detail on how users can configure how and when matches are generated."
msgstr "本节简要概述了补全系统的工作原理，然后详细介绍了用户如何配置匹配的生成方式和时间。"

#. type: Plain text
#: zsh.texi:21196
msgid ""
"When completion is attempted somewhere on the command line the completion system begins building the context.  The context represents everything that the shell knows about the meaning of the command line "
"and the significance of the cursor position.  This takes account of a number of things including the command word (such as `@t{grep}' or `@t{zsh}') and options to which the current word may be an argument "
"(such as the `@t{-o}' option to @t{zsh} which takes a shell option as an argument)."
msgstr ""
"当在命令行的某处尝试补全时，补全系统就会开始构建上下文。 上下文代表了 shell 所知道的命令行含义和光标位置的意义。 其中包括命令字（如\"@t{grep}\"或\"@t{zsh}\"）和当前命令字作为参数的选项（如 @t{zsh} 的 `@t{-"
"o}' 选项，它将 shell 选项作为参数）。"

#. type: Plain text
#: zsh.texi:21203
msgid ""
"The context starts out very generic (\"we are beginning a completion\")  and becomes more specific as more is learned (\"the current word is in a position that is usually a command name\" or \"the current "
"word might be a variable name\" and so on).  Therefore the context will vary during the same call to the completion system."
msgstr ""
"上下文开始时非常通用（\"我们正在开始补全\"），随着学习的深入，上下文会变得越来越具体（\"当前单词所在的位置通常是命令名 \"或 \"当前单词可能是变量名 \"等等）。 因此，在调用同一个补全系统时，上下文会有所不"
"同。"

#. type: Plain text
#: zsh.texi:21213
msgid ""
"This context information is condensed into a string consisting of multiple fields separated by colons, referred to simply as `the context' in the remainder of the documentation.  Note that a user of the "
"completion system rarely needs to compose a context string, unless for example a new function is being written to perform completion for a new command.  What a user may need to do is compose a "
"@emph{style} pattern, which is matched against a context when needed to look up context-sensitive options that configure the completion system."
msgstr ""
"这些上下文信息被浓缩成一个字符串，由多个字段组成，中间用冒号隔开，在本文的其余部分中简称为 `上下文'。 请注意，补全系统的用户很少需要编写上下文字符串，除非编写一个新函数来执行新命令的补全。 用户可能需要做的"
"是编写一个 @emph{style} 模式，在需要查找配置补全系统的上下文敏感选项时与上下文进行匹配。"

#. type: Plain text
#: zsh.texi:21220
msgid ""
"The next few paragraphs explain how a context is composed within the completion function suite.  Following that is discussion of how @emph{styles} are defined.  Styles determine such things as how the "
"matches are generated, similarly to shell options but with much more control.  They are defined with the @t{zstyle} builtin command (@ref{The zsh/zutil Module})."
msgstr ""
"接下来的几段将解释补全函数套件中的上下文是如何构成的。 接下来将讨论如何定义 @emph{styles}。 样式决定匹配结果的生成方式，与 shell 选项类似，但控制能力更强。 它们由 @t{zstyle} 内置命令定义（@ref{zsh/zutil 模"
"块}）。"

#. type: Plain text
#: zsh.texi:21227
msgid ""
"The context string always consists of a fixed set of fields, separated by colons and with a leading colon before the first.  Fields which are not yet known are left empty, but the surrounding colons "
"appear anyway.  The fields are always in the order @t{:completion:}@var{function}@t{:}@var{completer}@t{:}@var{command}@t{:}@var{argument}@t{:}@var{tag}.  These have the following meaning:"
msgstr ""
"上下文字符串总是由一组固定的字段组成，字段之间用冒号隔开，第一个字段前有一个前导冒号。 未知字段留空，但周围的冒号还是会出现。 字段的顺序总是 @t{:completion:}@var{function}@t{:}@var{completer}@t{:}"
"@var{command}@t{:}@var{argument}@t{:}@var{tag}。 其含义如下："

#. type: itemize
#: zsh.texi:21235
msgid "The literal string @t{completion}, saying that this style is used by the completion system.  This distinguishes the context from those used by, for example, zle widgets and ZFTP functions."
msgstr "字面字符串 @t{completion}，表示该样式由补全系统使用。 这将该上下文与 zle 小部件和 ZFTP 函数等使用的上下文区分开来。"

#. type: itemize
#: zsh.texi:21242
msgid ""
"The @var{function}, if completion is called from a named widget rather than through the normal completion system.  Typically this is blank, but it is set by special widgets such as @t{predict-on} and the "
"various functions in the @t{Widget} directory of the distribution to the name of that function, often in an abbreviated form."
msgstr ""
"@var{function}，如果补全是通过一个已命名的小部件而不是通过正常的补全系统调用的。 通常情况下，它是空白的，但特殊部件（如 @t{predict-on}）和发行版 @t{Widget} 目录中的各种函数会将其设置为该函数的名称，通常是"
"缩写形式。"

#. type: itemize
#: zsh.texi:21252
msgid ""
"The @var{completer} currently active, the name of the function without the leading underscore and with other underscores converted to hyphens.  A `completer' is in overall control of how completion is to "
"be performed; `@t{complete}' is the simplest, but other completers exist to perform related tasks such as correction, or to modify the behaviour of a later completer.  See @ref{Control Functions} for more "
"information."
msgstr ""
"当前激活的 @var{complete}，即函数名称，去掉前导下划线，并将其他下划线转换为连字符。 一个`completer'  可以全面控制补全程序的执行方式； `@t{complete}'  是最简单的补全程序，但也存在其他补全程序来执行相关任"
"务，如更正，或修改后一个补全程序的行为。 更多信息，请参阅 @ref{控制函数}。"

#. type: itemize
#: zsh.texi:21261
msgid ""
"The @var{command} or a special @t{-}@var{context}@t{-}, just at it appears following the @t{#compdef} tag or the @t{compdef} function.  Completion functions for commands that have sub-commands usually "
"modify this field to contain the name of the command followed by a minus sign and the sub-command.  For example, the completion function for the @t{cvs} command sets this field to @t{cvs-add} when "
"completing arguments to the @t{add} subcommand."
msgstr ""
"@var{command} 或特殊的 @t{-}@var{context}@t{-}，就在 @t{#compdef} 标记或 @t{compdef} 函数之后出现。 针对具有子命令的命令的补全函数通常会修改该字段，使其包含命令名称、减号和子命令。 例如，@t{cvs} 命令的补全"
"函数在补全 @t{add} 子命令的参数时，会将该字段设置为 @t{cvs-add}。"

#. type: itemize
#: zsh.texi:21270
msgid ""
"The @var{argument}; this indicates which command line or option argument we are completing.  For command arguments this generally takes the form @t{argument-}@var{n}, where @var{n} is the number of the "
"argument, and for arguments to options the form @t{option-}@var{opt}@t{-}@var{n} where @var{n} is the number of the argument to option @var{opt}.  However, this is only the case if the command line is "
"parsed with standard UNIX-style options and arguments, so many completions do not set this."
msgstr ""
"@var{argument}；这表示我们正在补全哪个命令行或选项参数。 对于命令参数，一般采用 @t{argument-}@var{n} 的形式，其中 @var{n} 是参数的编号；对于选项参数，则采用 @t{option-}@var{opt}@t{-}@var{n} 的形式，其中 "
"@var{n} 是选项 @var{opt} 的参数编号。 不过，只有在使用标准 UNIX 样式的选项和参数对命令行进行解析时才会出现这种情况，因此许多补全程序并不设置它。"

#. type: itemize
#: zsh.texi:21276
msgid ""
"The @var{tag}.  As described previously, tags are used to discriminate between the types of matches a completion function can generate in a certain context.  Any completion function may use any tag name "
"it likes, but a list of the more common ones is given below."
msgstr "@var{tag}.  如前所述，标记用于区分补全函数在特定上下文中可以生成的匹配类型。 任何补全函数都可以使用自己喜欢的标记名，下面列出了一些比较常用的标记名。"

#. type: Plain text
#: zsh.texi:21286
msgid ""
"The context is gradually put together as the functions are executed, starting with the main entry point, which adds @t{:completion:} and the @var{function} element if necessary.  The completer then adds "
"the @var{completer} element.  The contextual completion adds the @var{command} and @var{argument} options.  Finally, the @var{tag} is added when the types of completion are known.  For example, the "
"context name"
msgstr ""
"随着函数的执行，上下文逐渐组合在一起，从主入口点开始，必要时添加 @t{:completion:} 和 @var{function} 元素。 然后，补全器添加 @var{completer} 元素。 上下文补全器添加 @var{command} 和 @var{argument} 选项。 最"
"后，在知道补全类型时，会添加 @var{tag}。 例如，上下文名称"

#. type: example
#: zsh.texi:21290
#, no-wrap
msgid "@t{:completion::complete:dvips:option-o-1:files}\n"
msgstr "@t{:completion::complete:dvips:option-o-1:files}\n"

#. type: Plain text
#: zsh.texi:21295
msgid "says that normal completion was attempted as the first argument to the option @t{-o} of the command @t{dvips}:"
msgstr "表示正常补全作为 @t{dvips} 命令的 @t{-o} 选项的第一个参数进行了尝试："

#. type: example
#: zsh.texi:21299
#, no-wrap
msgid "@t{dvips -o ...}\n"
msgstr "@t{dvips -o ...}\n"

#. type: Plain text
#: zsh.texi:21303
msgid "and the completion function will generate filenames."
msgstr "而补全函数将生成文件名。"

#. type: Plain text
#: zsh.texi:21309
msgid ""
"Usually completion will be tried for all possible tags in an order given by the completion function.  However, this can be altered by using the @t{tag-order} style.  Completion is then restricted to the "
"list of given tags in the given order."
msgstr "通常，补全将按照补全函数给出的顺序对所有可能的标记进行尝试。 不过，可以通过使用 @t{tag-order} 样式来改变顺序。 这样，补全就会被限制在按给定顺序排列的给定标记列表中。"

#. type: Plain text
#: zsh.texi:21316
msgid ""
"The @t{_complete_help} bindable command shows all the contexts and tags available for completion at a particular point.  This provides an easy way of finding information for @t{tag-order} and other "
"styles.  It is described in @ref{Bindable Commands}."
msgstr "@t{_complete_help} 可绑定命令显示了在某一点上可用于补全的所有上下文和标记。 这为查找 @t{tag-order} 和其他样式的信息提供了一种简便的方法。 该命令在 @ref{可绑定命令} 中有所描述。"

#. type: Plain text
#: zsh.texi:21325
msgid ""
"When looking up styles the completion system uses full context names, including the tag.  Looking up the value of a style therefore consists of two things: the context, which is matched to the most "
"specific (best fitting) pattern, and the name of the style itself, which must be matched exactly.  The following examples demonstrate that patterns may be loosely defined for styles that apply broadly, or "
"as tightly defined as desired for styles that apply in narrower circumstances."
msgstr ""
"在查找样式时，补全系统使用完整的上下文名称，包括标记。 因此，查找样式的值由两部分组成：上下文（与最具体（最适合）的模式匹配）和样式本身的名称（必须完全匹配）。 下面的示例说明，对于适用范围较广的样式，可以"
"松散地定义模式，而对于适用范围较窄的样式，则可以根据需要严格定义模式。"

#. type: Plain text
#: zsh.texi:21331
msgid ""
"For example, many completion functions can generate matches in a simple and a verbose form and use the @t{verbose} style to decide which form should be used.  To make all such functions use the verbose "
"form, put"
msgstr "例如，许多补全函数可以以简单和详细两种形式生成匹配，并使用 @t{verbose} 样式来决定使用哪种形式。 要使所有此类函数都使用详细形式，请将"

#. type: example
#: zsh.texi:21335
#, no-wrap
msgid "zstyle ':completion:*' verbose yes\n"
msgstr "zstyle ':completion:*' verbose yes\n"

#. type: Plain text
#: zsh.texi:21343
msgid ""
"in a startup file (probably @t{.zshrc}).  This gives the @t{verbose} style the value @t{yes} in every context inside the completion system, unless that context has a more specific definition.  It is best "
"to avoid giving the pattern as `@t{*}' in case the style has some meaning outside the completion system."
msgstr ""
"放在启动文件（可能是 @t{.zshrc}）中。 这使得 @t{verbose} 样式在补全系统中的每种上下文中都具有 @t{yes} 的值，除非该上下文有更具体的定义。 最好避免将样式定义为 `@t{*}' ，以防该样式在补全系统之外有其他含义。"

#. type: Plain text
#: zsh.texi:21347
msgid "Many such general purpose styles can be configured simply by using the @t{compinstall} function."
msgstr "只需使用 @t{compinstall} 函数，就可以配置许多此类通用样式。"

#. type: Plain text
#: zsh.texi:21353
msgid ""
"A more specific example of the use of the @t{verbose} style is by the completion for the @t{kill} builtin.  If the style is set, the builtin lists full job texts and process command lines; otherwise it "
"shows the bare job numbers and PIDs.  To turn the style off for this use only:"
msgstr "使用 @t{verbose} 样式的一个更具体的例子是 @t{kill} 内置程序的补全。 如果设置了该样式，内置程序就会列出完整的作业文本和进程命令行；否则，就会只显示作业编号和 PID。 要关闭该样式，请执行以下操作:"

#. type: example
#: zsh.texi:21357
#, no-wrap
msgid "zstyle ':completion:*:*:kill:*:*' verbose no\n"
msgstr "zstyle ':completion:*:*:kill:*:*' verbose no\n"

#. type: Plain text
#: zsh.texi:21362
msgid "For even more control, the style can use one of the tags `@t{jobs}' or `@t{processes}'.  To turn off verbose display only for jobs:"
msgstr "为了获得更多控制权，样式可以使用标记 `@t{jobs}' 或 `@t{processes}'。 要关闭仅针对作业的冗长显示，请执行以下操作:"

#. type: example
#: zsh.texi:21366
#, no-wrap
msgid "zstyle ':completion:*:*:kill:*:jobs' verbose no\n"
msgstr "zstyle ':completion:*:*:kill:*:jobs' verbose no\n"

#. type: Plain text
#: zsh.texi:21373
msgid ""
"The @t{-e} option to @t{zstyle} even allows completion function code to appear as the argument to a style; this requires some understanding of the internals of completion functions (see @ref{Completion "
"Widgets})).  For example,"
msgstr "@t{zstyle} 的 @t{-e} 选项甚至允许将补全函数代码作为样式的参数；这需要对补全函数的内部结构有一定的了解（参见 @ref{补全小部件}）。 例如"

#. type: example
#: zsh.texi:21377
#, no-wrap
msgid "@t{zstyle -e ':completion:*' hosts 'reply=($myhosts)'}\n"
msgstr "@t{zstyle -e ':completion:*' hosts 'reply=($myhosts)'}\n"

#. type: Plain text
#: zsh.texi:21387
msgid ""
"This forces the value of the @t{hosts} style to be read from the variable @t{myhosts} each time a host name is needed; this is useful if the value of @t{myhosts} can change dynamically.  For another "
"useful example, see the example in the description of the @t{file-list} style below.  This form can be slow and should be avoided for commonly examined styles such as @t{menu} and @t{list-rows-first}."
msgstr ""
"这就会强制每次需要主机名时从变量 @t{myhosts} 中读取 @t{hosts} 样式的值。如果 @t{myhosts} 的值是动态变化的，这是有用的。 另一个有用的例子，请参阅下面 @t{file-list} 样式描述中的示例。 这种形式可能会比较慢，"
"对于 @t{menu} 和 @t{list-rows-first} 等常用样式，应避免使用。"

#. type: Plain text
#: zsh.texi:21397
msgid ""
"Note that the order in which styles are @emph{defined} does not matter; the style mechanism uses the most specific possible match for a particular style to determine the set of values.  Strings are "
"preferred over patterns (for example, `@t{:completion::complete:::foo}' is more specific than `@t{:completion::complete:::*'}), and longer patterns are preferred over the pattern `@t{*}'. See @ref{The zsh/"
"zutil Module} for details."
msgstr ""
"请注意，样式的 @emph{定义} 顺序并不重要；样式机制使用特定样式的最具体匹配来确定值集。 字符串优先于模式（例如， `@t{:completion::complete:::foo}' 比 `@t{:completion::complete:::*'} 更具体），较长的模式优先"
"于模式 `@t{*}'。详情请参见 @ref{zsh/zutil 模块}。"

#. type: Plain text
#: zsh.texi:21407
msgid ""
"Context patterns that use something other than a wildcard (@t{*}) to match the middle parts of the context --- the @var{completer}, @var{command}, and @var{argument} in @t{:completion:}@var{function}@t{:}"
"@var{completer}@t{:}@var{command}@t{:}@var{argument}@t{:}@var{tag} --- should include all six colons (@t{:}) explicitly. Without this, a pattern such as @t{:completion:*:foo:*} could match @t{foo} against "
"a component other than the intended one (for example, against @var{completer} when a match against @var{command} was intended)."
msgstr ""
"使用通配符 (@t{*}) 以外的其他内容来匹配上下文中间部分的上下文模式 --- 即 @t{:completion:}@var{function}@t{:}@var{completer}@t{:}@var{command}@t{:}@var{argument}@t{:}@var{tag} 中的@var{completer}, "
"@var{command} 和 @var{argument} 。应明确包含所有六个冒号 (@t{:})。如果不这样做，像 @t{:completion:*:foo:*} 这样的模式就可能匹配到 @t{foo} 以外的其他组件（例如，当要匹配 @var{command} 时，却匹配到 "
"@var{completer} ）。"

#. type: Plain text
#: zsh.texi:21412
msgid "Style names like those of tags are arbitrary and depend on the completion function.  However, the following two sections list some of the most common tags and styles."
msgstr "样式名称与标记名称一样是任意命名的，取决于补全函数。 不过，下面两节列出了一些最常用的标记和样式。"

#. type: subsection
#: zsh.texi:21415
#, no-wrap
msgid "Standard Tags"
msgstr "标准标记"

#. type: cindex
#: zsh.texi:21417
#, no-wrap
msgid "completion system, tags"
msgstr "补全系统, 标记"

#. type: Plain text
#: zsh.texi:21422
msgid "Some of the following are only used when looking up particular styles and do not refer to a type of match."
msgstr "以下部分内容仅用于查找特定样式，并不代表某种匹配类型。"

#. type: kindex
#: zsh.texi:21425
#, no-wrap
msgid "accounts, completion tag"
msgstr "帐户, 补全标记"

#. type: t{#1}
#: zsh.texi:21426
#, no-wrap
msgid "accounts"
msgstr "帐户"

#. type: table
#: zsh.texi:21428 zsh.texi:21637 zsh.texi:21666
msgid "used to look up the @t{users-hosts} style"
msgstr "用于查询 @t{users-hosts} 样式"

#. type: kindex
#: zsh.texi:21429
#, no-wrap
msgid "all-expansions, completion tag"
msgstr "all-expansions, 补全标记"

#. type: t{#1}
#: zsh.texi:21430
#, no-wrap
msgid "all-expansions"
msgstr "all-expansions"

#. type: table
#: zsh.texi:21433
msgid "used by the @t{_expand} completer when adding the single string containing all possible expansions"
msgstr "在添加包含所有可能扩展的单个字符串时被 @t{_expand} 补全器使用"

#. type: kindex
#: zsh.texi:21434
#, no-wrap
msgid "all-files, completion tag"
msgstr "all-files, 补全标记"

#. type: t{#1}
#: zsh.texi:21435
#, no-wrap
msgid "all-files"
msgstr "all-files"

#. type: table
#: zsh.texi:21438
msgid "for the names of all files (as distinct from a particular subset, see the @t{globbed-files} tag)."
msgstr "用于所有文件的名称(有别于特定子集，参见 @t{globbed-files} 标记）。"

#. type: kindex
#: zsh.texi:21439
#, no-wrap
msgid "arguments, completion tag"
msgstr "arguments, 补全标记"

#. type: t{#1}
#: zsh.texi:21440
#, no-wrap
msgid "arguments"
msgstr "arguments"

#. type: table
#: zsh.texi:21442
msgid "for arguments to a command"
msgstr "用于命令的参数"

#. type: kindex
#: zsh.texi:21443
#, no-wrap
msgid "arrays, completion tag"
msgstr "arrays, 补全标记"

#. type: t{#1}
#: zsh.texi:21444
#, no-wrap
msgid "arrays"
msgstr "arrays"

#. type: table
#: zsh.texi:21446
msgid "for names of array parameters"
msgstr "用于数组参数名"

#. type: kindex
#: zsh.texi:21447
#, no-wrap
msgid "association-keys, completion tag"
msgstr "association-keys, 补全标记"

#. type: t{#1}
#: zsh.texi:21448
#, no-wrap
msgid "association-keys"
msgstr "association-keys"

#. type: table
#: zsh.texi:21451
msgid "for keys of associative arrays; used when completing inside a subscript to a parameter of this type"
msgstr "用于关联数组的键；在补全该类型参数的下标时使用"

#. type: kindex
#: zsh.texi:21452
#, no-wrap
msgid "bookmarks, completion tag"
msgstr "bookmarks, 补全标记"

#. type: t{#1}
#: zsh.texi:21453
#, no-wrap
msgid "bookmarks"
msgstr "bookmarks"

#. type: table
#: zsh.texi:21455
msgid "when completing bookmarks (e.g. for URLs and the @t{zftp} function suite)"
msgstr "补全书签时（如 URL 和 @t{zftp} 函数套件）"

#. type: kindex
#: zsh.texi:21456
#, no-wrap
msgid "builtins, completion tag"
msgstr "builtins, 补全标记"

#. type: t{#1}
#: zsh.texi:21457 zsh.texi:29671 zsh.texi:29672
#, no-wrap
msgid "builtins"
msgstr "builtins"

#. type: table
#: zsh.texi:21459
msgid "for names of builtin commands"
msgstr "用于内置命令的名称"

#. type: kindex
#: zsh.texi:21460
#, no-wrap
msgid "characters, completion tag"
msgstr "characters, 补全标记"

#. type: t{#1}
#: zsh.texi:21461
#, no-wrap
msgid "characters"
msgstr "characters"

#. type: table
#: zsh.texi:21464
msgid "for single characters in arguments of commands such as @t{stty}.  Also used when completing character classes after an opening bracket"
msgstr "用于命令参数中的单字符，如 @t{stty}。 也用于在开头括号后补全字符分类"

#. type: kindex
#: zsh.texi:21465
#, no-wrap
msgid "colormapids, completion tag"
msgstr "colormapids, 补全标记"

#. type: t{#1}
#: zsh.texi:21466
#, no-wrap
msgid "colormapids"
msgstr "colormapids"

#. type: table
#: zsh.texi:21468
msgid "for X colormap ids"
msgstr "用于 X colormap ids"

#. type: kindex
#: zsh.texi:21469
#, no-wrap
msgid "colors, completion tag"
msgstr "colors, 补全标记"

#. type: t{#1}
#: zsh.texi:21470 zsh.texi:40690 zsh.texi:40691
#, no-wrap
msgid "colors"
msgstr "colors"

#. type: table
#: zsh.texi:21472
msgid "for color names"
msgstr "用于颜色名称"

#. type: kindex
#: zsh.texi:21473
#, no-wrap
msgid "commands, completion tag"
msgstr "commands, 补全标记"

#. type: t{#1}
#: zsh.texi:21474 zsh.texi:21987 zsh.texi:29623 zsh.texi:29624
#, no-wrap
msgid "commands"
msgstr "commands"

#. type: table
#: zsh.texi:21477
msgid "for names of external commands.  Also used by complex commands such as @t{cvs} when completing names subcommands."
msgstr "用于外部命令的名称。 复杂命令（如 @t{cvs}）在补全子命令名称时也会用到。"

#. type: kindex
#: zsh.texi:21478
#, no-wrap
msgid "contexts, completion tag"
msgstr "contexts, 补全标记"

#. type: t{#1}
#: zsh.texi:21479
#, no-wrap
msgid "contexts"
msgstr "contexts"

#. type: table
#: zsh.texi:21481
msgid "for contexts in arguments to the @t{zstyle} builtin command"
msgstr "用于 @t{zstyle} 内置命令参数中的上下文"

#. type: kindex
#: zsh.texi:21482
#, no-wrap
msgid "corrections, completion tag"
msgstr "corrections, 补全标记"

#. type: t{#1}
#: zsh.texi:21483
#, no-wrap
msgid "corrections"
msgstr "corrections"

#. type: table
#: zsh.texi:21486
msgid "used by the @t{_approximate} and @t{_correct} completers for possible corrections"
msgstr "用于 @t{_approximate} 和 @t{_correct} 补全器使用，以进行可能的修正"

#. type: kindex
#: zsh.texi:21487
#, no-wrap
msgid "cursors, completion tag"
msgstr "cursors, 补全标记"

#. type: t{#1}
#: zsh.texi:21488
#, no-wrap
msgid "cursors"
msgstr "cursors"

#. type: table
#: zsh.texi:21490
msgid "for cursor names used by X programs"
msgstr "用于 X 程序使用的光标名称"

#. type: kindex
#: zsh.texi:21491
#, no-wrap
msgid "default, completion tag"
msgstr "default, 补全标记"

#. type: table
#: zsh.texi:21496
msgid "used in some contexts to provide a way of supplying a default when more specific tags are also valid.  Note that this tag is used when only the @var{function} field of the context name is set"
msgstr "在某些上下文中使用，以便在更具体的标记也有效时提供默认值。 请注意，该标记仅在上下文名称的 @var{function} 字段被设置时使用"

#. type: kindex
#: zsh.texi:21497
#, no-wrap
msgid "descriptions, completion tag"
msgstr "说明, 补全标记"

#. type: t{#1}
#: zsh.texi:21498
#, no-wrap
msgid "descriptions"
msgstr "说明"

#. type: table
#: zsh.texi:21501
msgid "used when looking up the value of the @t{format} style to generate descriptions for types of matches"
msgstr "用于查找 @t{format} 样式的值，以生成匹配类型的说明"

#. type: kindex
#: zsh.texi:21502
#, no-wrap
msgid "devices, completion tag"
msgstr "设备, 补全标记"

#. type: t{#1}
#: zsh.texi:21503
#, no-wrap
msgid "devices"
msgstr "设备"

#. type: table
#: zsh.texi:21505
msgid "for names of device special files"
msgstr "设备特殊文件的名字"

#. type: kindex
#: zsh.texi:21506
#, no-wrap
msgid "directories, completion tag"
msgstr "目录, 补全标记"

#. type: table
#: zsh.texi:21511
msgid "for names of directories --- @t{local-directories} is used instead when completing arguments of @t{cd} and related builtin commands when the @t{cdpath} array is set"
msgstr "目录名 --- 当补全 @t{cd} 和相关内置命令的参数时，如果 @t{cdpath} 数组已设置，将使用 @t{local-directories} 代替"

#. type: kindex
#: zsh.texi:21512
#, no-wrap
msgid "directory-stack, completion tag"
msgstr "目录栈, 补全标记"

#. type: t{#1}
#: zsh.texi:21513
#, no-wrap
msgid "directory-stack"
msgstr "目录栈"

#. type: table
#: zsh.texi:21515
msgid "for entries in the directory stack"
msgstr "目录栈中的条目"

#. type: kindex
#: zsh.texi:21516
#, no-wrap
msgid "displays, completion tag"
msgstr "显示器, 补全标记"

#. type: t{#1}
#: zsh.texi:21517
#, no-wrap
msgid "displays"
msgstr "显示器"

#. type: table
#: zsh.texi:21519
msgid "for X display names"
msgstr "X 显示器名字"

#. type: kindex
#: zsh.texi:21520
#, no-wrap
msgid "domains, completion tag"
msgstr "domains, 补全标记"

#. type: t{#1}
#: zsh.texi:21521 zsh.texi:22073
#, no-wrap
msgid "domains"
msgstr "domains"

#. type: table
#: zsh.texi:21523
msgid "for network domains"
msgstr "用于网络域"

#. type: kindex
#: zsh.texi:21524
#, no-wrap
msgid "email-*, completion tag"
msgstr "email-*, 补全标记"

#. type: item
#: zsh.texi:21525
#, no-wrap
msgid "@t{email-}@var{plugin}"
msgstr "@t{email-}@var{plugin}"

#. type: table
#: zsh.texi:21527
msgid "for email addresses from the `@t{_email-}@var{plugin}' backend of @t{_email_addresses}"
msgstr "从 @t{_email_addresses} 的 `@t{_email-}@var{plugin}' 后端获取电子邮件地址"

#. type: kindex
#: zsh.texi:21528
#, no-wrap
msgid "expansions, completion tag"
msgstr "expansions, 补全标记"

#. type: t{#1}
#: zsh.texi:21529
#, no-wrap
msgid "expansions"
msgstr "扩展"

#. type: table
#: zsh.texi:21533
msgid "used by the @t{_expand} completer for individual words (as opposed to the complete set of expansions) resulting from the expansion of a word on the command line"
msgstr "用于 @t{_expand} 补全器，以补全命令行单词扩展后产生的单个单词（而不是完整的扩展集）。"

#. type: kindex
#: zsh.texi:21534
#, no-wrap
msgid "extensions, completion tag"
msgstr "extensions, 补全标记"

#. type: t{#1}
#: zsh.texi:21535
#, no-wrap
msgid "extensions"
msgstr "extensions"

#. type: table
#: zsh.texi:21537
msgid "for X server extensions"
msgstr "用于 X 服务扩展"

#. type: kindex
#: zsh.texi:21538
#, no-wrap
msgid "file-descriptors, completion tag"
msgstr "file-descriptors, 补全标记"

#. type: t{#1}
#: zsh.texi:21539
#, no-wrap
msgid "file-descriptors"
msgstr "file-descriptors"

#. type: table
#: zsh.texi:21541
msgid "for numbers of open file descriptors"
msgstr "表示打开的文件描述符的数量"

#. type: kindex
#: zsh.texi:21542
#, no-wrap
msgid "files, completion tag"
msgstr "files, 补全标记"

#. type: t{#1}
#: zsh.texi:21543 zsh.texi:40121
#, no-wrap
msgid "files"
msgstr "files"

#. type: table
#: zsh.texi:21545
msgid "the generic file-matching tag used by functions completing filenames"
msgstr "补全文件名的函数使用的通用文件匹配标记"

#. type: kindex
#: zsh.texi:21546
#, no-wrap
msgid "fonts, completion tag"
msgstr "fonts, 补全标记"

#. type: t{#1}
#: zsh.texi:21547
#, no-wrap
msgid "fonts"
msgstr "fonts"

#. type: table
#: zsh.texi:21549
msgid "for X font names"
msgstr "用于 X 字体名"

#. type: kindex
#: zsh.texi:21550
#, no-wrap
msgid "fstypes, completion tag"
msgstr "fstypes, 补全标记"

#. type: t{#1}
#: zsh.texi:21551
#, no-wrap
msgid "fstypes"
msgstr "fstypes"

#. type: table
#: zsh.texi:21553
msgid "for file system types (e.g. for the @t{mount} command)"
msgstr "用于文件系统类型（例如用于 @t{mount} 命令）"

#. type: kindex
#: zsh.texi:21554
#, no-wrap
msgid "functions, completion tag"
msgstr "functions, 补全标记"

#. type: table
#: zsh.texi:21558
msgid "names of functions --- normally shell functions, although certain commands may understand other kinds of function"
msgstr "函数名称 --- 通常是 shell 函数，但某些命令可能理解其他类型的函数"

#. type: kindex
#: zsh.texi:21559
#, no-wrap
msgid "globbed-files, completion tag"
msgstr "globbed-files, 补全标记"

#. type: t{#1}
#: zsh.texi:21560
#, no-wrap
msgid "globbed-files"
msgstr "globbed-files"

#. type: table
#: zsh.texi:21562
msgid "for filenames when the name has been generated by pattern matching"
msgstr "用于文件名是通过模式匹配生成时"

#. type: kindex
#: zsh.texi:21563
#, no-wrap
msgid "groups, completion tag"
msgstr "groups, 补全标记"

#. type: t{#1}
#: zsh.texi:21564 zsh.texi:22494
#, no-wrap
msgid "groups"
msgstr "groups"

#. type: table
#: zsh.texi:21566
msgid "for names of user groups"
msgstr "用于用户组的名字"

#. type: kindex
#: zsh.texi:21567
#, no-wrap
msgid "history-words, completion tag"
msgstr "history-words, 补全标记"

#. type: t{#1}
#: zsh.texi:21568
#, no-wrap
msgid "history-words"
msgstr "history-words"

#. type: table
#: zsh.texi:21570
msgid "for words from the history"
msgstr "用于历史中的单词"

#. type: kindex
#: zsh.texi:21571
#, no-wrap
msgid "hosts, completion tag"
msgstr "hosts, 补全标记"

#. type: t{#1}
#: zsh.texi:21572 zsh.texi:22513
#, no-wrap
msgid "hosts"
msgstr "hosts"

#. type: table
#: zsh.texi:21574
msgid "for hostnames"
msgstr "用于主机名"

#. type: kindex
#: zsh.texi:21575
#, no-wrap
msgid "indexes, completion tag"
msgstr "indexes, 补全标记"

#. type: t{#1}
#: zsh.texi:21576
#, no-wrap
msgid "indexes"
msgstr "indexes"

#. type: table
#: zsh.texi:21578
msgid "for array indexes"
msgstr "用于数组索引"

#. type: kindex
#: zsh.texi:21579
#, no-wrap
msgid "interfaces, completion tag"
msgstr "interfaces, 补全标记"

#. type: t{#1}
#: zsh.texi:21580
#, no-wrap
msgid "interfaces"
msgstr "interfaces"

#. type: table
#: zsh.texi:21582
msgid "for network interfaces"
msgstr "用于网络接口"

#. type: kindex
#: zsh.texi:21583
#, no-wrap
msgid "jobs, completion tag"
msgstr "jobs, 补全标记"

#. type: table
#: zsh.texi:21586
msgid "for jobs (as listed by the `@t{jobs}' builtin)"
msgstr "用于作业 ( `@t{jobs}' 内置程序列出的)"

#. type: kindex
#: zsh.texi:21587
#, no-wrap
msgid "keymaps, completion tag"
msgstr "keymaps, 补全标记"

#. type: table
#: zsh.texi:21590
msgid "for names of zsh keymaps"
msgstr "用于 zsh 键映射的名字"

#. type: kindex
#: zsh.texi:21591
#, no-wrap
msgid "keysyms, completion tag"
msgstr "keysyms, 补全标记"

#. type: t{#1}
#: zsh.texi:21592
#, no-wrap
msgid "keysyms"
msgstr "keysyms"

#. type: table
#: zsh.texi:21594
msgid "for names of X keysyms"
msgstr "用于 X keysyms 的名字"

#. type: kindex
#: zsh.texi:21595
#, no-wrap
msgid "libraries, completion tag"
msgstr "libraries, 补全标记"

#. type: t{#1}
#: zsh.texi:21596
#, no-wrap
msgid "libraries"
msgstr "libraries"

#. type: table
#: zsh.texi:21598
msgid "for names of system libraries"
msgstr "用于系统库的名字"

#. type: kindex
#: zsh.texi:21599
#, no-wrap
msgid "limits, completion tag"
msgstr "limits, 补全标记"

#. type: t{#1}
#: zsh.texi:21600 zsh.texi:35800
#, no-wrap
msgid "limits"
msgstr "limits"

#. type: table
#: zsh.texi:21602
msgid "for system limits"
msgstr "用于系统限制"

#. type: kindex
#: zsh.texi:21603
#, no-wrap
msgid "local-directories, completion tag"
msgstr "local-directories, 补全标记"

#. type: t{#1}
#: zsh.texi:21604
#, no-wrap
msgid "local-directories"
msgstr "local-directories"

#. type: table
#: zsh.texi:21609
msgid ""
"for names of directories that are subdirectories of the current working directory when completing arguments of @t{cd} and related builtin commands (compare @t{path-directories}) --- when the @t{cdpath} "
"array is unset, @t{directories} is used instead"
msgstr "在补全 @t{cd} 和相关内置命令（比较 @t{path-directories}）的参数时，用于查找当前工作目录的子目录名称 --- 当 @t{cdpath} 数组未设置时，将使用 @t{directories} 代替"

#. type: kindex
#: zsh.texi:21610
#, no-wrap
msgid "mailboxes, completion tag"
msgstr "mailboxes, 补全标记"

#. type: t{#1}
#: zsh.texi:21611
#, no-wrap
msgid "mailboxes"
msgstr "mailboxes"

#. type: table
#: zsh.texi:21613
msgid "for e-mail folders"
msgstr "用于电子邮件目录"

#. type: kindex
#: zsh.texi:21614
#, no-wrap
msgid "manuals, completion tag"
msgstr "manuals, 补全标记"

#. type: t{#1}
#: zsh.texi:21615
#, no-wrap
msgid "manuals"
msgstr "manuals"

#. type: table
#: zsh.texi:21617
msgid "for names of manual pages"
msgstr "用于手册页的名字"

#. type: kindex
#: zsh.texi:21618
#, no-wrap
msgid "maps, completion tag"
msgstr "maps, 补全标记"

#. type: t{#1}
#: zsh.texi:21619
#, no-wrap
msgid "maps"
msgstr "maps"

#. type: table
#: zsh.texi:21621
msgid "for map names (e.g. NIS maps)"
msgstr "用于映射名（例如 NIS 映射）"

#. type: kindex
#: zsh.texi:21622
#, no-wrap
msgid "messages, completion tag"
msgstr "messages, 补全标记"

#. type: t{#1}
#: zsh.texi:21623
#, no-wrap
msgid "messages"
msgstr "messages"

#. type: table
#: zsh.texi:21625
msgid "used to look up the @t{format} style for messages"
msgstr "用于查找 @t{format} 样式的信息"

#. type: kindex
#: zsh.texi:21626
#, no-wrap
msgid "modifiers, completion tag"
msgstr "修饰符, 补全标记"

#. type: table
#: zsh.texi:21629
msgid "for names of X modifiers"
msgstr "用于 X 修饰符的名字（X modifiers）"

#. type: kindex
#: zsh.texi:21630
#, no-wrap
msgid "modules, completion tag"
msgstr "modules, 补全标记"

#. type: t{#1}
#: zsh.texi:21631 zsh.texi:27607 zsh.texi:29733 zsh.texi:29734
#, no-wrap
msgid "modules"
msgstr "modules"

#. type: table
#: zsh.texi:21633
msgid "for modules (e.g. @t{zsh} modules)"
msgstr "用于模块（如 @t{zsh} 模块）"

#. type: kindex
#: zsh.texi:21634
#, no-wrap
msgid "my-accounts, completion tag"
msgstr "my-accounts, 补全标记"

#. type: t{#1}
#: zsh.texi:21635
#, no-wrap
msgid "my-accounts"
msgstr "my-accounts"

#. type: kindex
#: zsh.texi:21638
#, no-wrap
msgid "named-directories, completion tag"
msgstr "named-directories, 补全标记"

#. type: t{#1}
#: zsh.texi:21639
#, no-wrap
msgid "named-directories"
msgstr "named-directories"

#. type: table
#: zsh.texi:21641
msgid "for named directories (you wouldn't have guessed that, would you?)"
msgstr "用于命名的目录（你不会猜到吧？）"

#. type: kindex
#: zsh.texi:21642
#, no-wrap
msgid "names, completion tag"
msgstr "names, 补全标记"

#. type: t{#1}
#: zsh.texi:21643
#, no-wrap
msgid "names"
msgstr "names"

#. type: table
#: zsh.texi:21645
msgid "for all kinds of names"
msgstr "用于所有类型的名称"

#. type: kindex
#: zsh.texi:21646
#, no-wrap
msgid "newsgroups, completion tag"
msgstr "newsgroups, 补全标记"

#. type: t{#1}
#: zsh.texi:21647
#, no-wrap
msgid "newsgroups"
msgstr "newsgroups"

#. type: table
#: zsh.texi:21649
msgid "for USENET groups"
msgstr "用于 USENET 组"

#. type: kindex
#: zsh.texi:21650
#, no-wrap
msgid "nicknames, completion tag"
msgstr "nicknames, 补全标记"

#. type: t{#1}
#: zsh.texi:21651
#, no-wrap
msgid "nicknames"
msgstr "nicknames"

#. type: table
#: zsh.texi:21653
msgid "for nicknames of NIS maps"
msgstr "用于 NIS 映射的昵称"

#. type: kindex
#: zsh.texi:21654
#, no-wrap
msgid "options, completion tag"
msgstr "options, 补全标记"

#. type: table
#: zsh.texi:21657
msgid "for command options"
msgstr "用于命令选项"

#. type: kindex
#: zsh.texi:21658
#, no-wrap
msgid "original, completion tag"
msgstr "original, 补全标记"

#. type: t{#1}
#: zsh.texi:21659 zsh.texi:23181
#, no-wrap
msgid "original"
msgstr "original"

#. type: table
#: zsh.texi:21662
msgid "used by the @t{_approximate}, @t{_correct} and @t{_expand} completers when offering the original string as a match"
msgstr "在提供原始字符串作为匹配时,被 @t{_approximate}、@t{_correct} 和 @t{_expand} 补全器使用。"

#. type: kindex
#: zsh.texi:21663
#, no-wrap
msgid "other-accounts, completion tag"
msgstr "other-accounts, 补全标记"

#. type: t{#1}
#: zsh.texi:21664
#, no-wrap
msgid "other-accounts"
msgstr "other-accounts"

#. type: kindex
#: zsh.texi:21667
#, no-wrap
msgid "packages, completion tag"
msgstr "packages, 补全标记"

#. type: t{#1}
#: zsh.texi:21668
#, no-wrap
msgid "packages"
msgstr "packages"

#. type: table
#: zsh.texi:21670
msgid "for packages (e.g. @t{rpm} or installed @t{Debian} packages)"
msgstr "用于软件包（例如 @t{rpm} 或已安装的 @t{Debian} 软件包）"

#. type: kindex
#: zsh.texi:21671
#, no-wrap
msgid "parameters, completion tag"
msgstr "parameters, 补全标记"

#. type: table
#: zsh.texi:21674
msgid "for names of parameters"
msgstr "用于参数名称"

#. type: kindex
#: zsh.texi:21675
#, no-wrap
msgid "path-directories, completion tag"
msgstr "path-directories, 补全标记"

#. type: t{#1}
#: zsh.texi:21676
#, no-wrap
msgid "path-directories"
msgstr "path-directories"

#. type: table
#: zsh.texi:21680
msgid "for names of directories found by searching the @t{cdpath} array when completing arguments of @t{cd} and related builtin commands (compare @t{local-directories})"
msgstr "当补全 @t{cd} 的参数和相关内置命令的参数时，用于通过搜索 @t{cdpath} 数组找到的目录名称（比较 @t{local-directories}。"

#. type: kindex
#: zsh.texi:21681
#, no-wrap
msgid "paths, completion tag"
msgstr "paths, 补全标记"

#. type: t{#1}
#: zsh.texi:21682
#, no-wrap
msgid "paths"
msgstr "paths"

#. type: table
#: zsh.texi:21685
msgid "used to look up the values of the @t{expand}, @t{ambiguous} and @t{special-dirs} styles"
msgstr "用于查找 @t{expand}、@t{ambiguous} 和 @t{special-dirs} 样式的值"

#. type: kindex
#: zsh.texi:21686
#, no-wrap
msgid "pods, completion tag"
msgstr "pods, 补全标记"

#. type: t{#1}
#: zsh.texi:21687
#, no-wrap
msgid "pods"
msgstr "pods"

#. type: table
#: zsh.texi:21689
msgid "for perl pods (documentation files)"
msgstr "用于 perl pods (文档文件）"

#. type: kindex
#: zsh.texi:21690
#, no-wrap
msgid "ports, completion tag"
msgstr "ports, 补全标记"

#. type: t{#1}
#: zsh.texi:21691 zsh.texi:23238
#, no-wrap
msgid "ports"
msgstr "ports"

#. type: table
#: zsh.texi:21693
msgid "for communication ports"
msgstr "用于通讯端口"

#. type: kindex
#: zsh.texi:21694
#, no-wrap
msgid "prefixes, completion tag"
msgstr "prefixes, 补全标记"

#. type: t{#1}
#: zsh.texi:21695
#, no-wrap
msgid "prefixes"
msgstr "prefixes"

#. type: table
#: zsh.texi:21697
msgid "for prefixes (like those of a URL)"
msgstr "用于前缀（如 URL 的前缀）"

#. type: kindex
#: zsh.texi:21698
#, no-wrap
msgid "printers, completion tag"
msgstr "printers, 补全标记"

#. type: t{#1}
#: zsh.texi:21699
#, no-wrap
msgid "printers"
msgstr "printers"

#. type: table
#: zsh.texi:21701
msgid "for print queue names"
msgstr "用于打印队列名称"

#. type: kindex
#: zsh.texi:21702
#, no-wrap
msgid "processes, completion tag"
msgstr "processes, 补全标记"

#. type: t{#1}
#: zsh.texi:21703
#, no-wrap
msgid "processes"
msgstr "processes"

#. type: table
#: zsh.texi:21705
msgid "for process identifiers"
msgstr "用于进程标识符"

#. type: kindex
#: zsh.texi:21706
#, no-wrap
msgid "processes-names, completion tag"
msgstr "processes-names, 补全标记"

#. type: t{#1}
#: zsh.texi:21707
#, no-wrap
msgid "processes-names"
msgstr "processes-names"

#. type: table
#: zsh.texi:21710
msgid "used to look up the @t{command} style when generating the names of processes for @t{killall}"
msgstr "用于为 @t{killall} 生成进程名称时查找 @t{command} 样式"

#. type: kindex
#: zsh.texi:21711
#, no-wrap
msgid "sequences, completion tag"
msgstr "sequences, 补全标记"

#. type: t{#1}
#: zsh.texi:21712
#, no-wrap
msgid "sequences"
msgstr "sequences"

#. type: table
#: zsh.texi:21714
msgid "for sequences (e.g. @t{mh} sequences)"
msgstr "用于序列（如 @t{mh} 序列）"

#. type: kindex
#: zsh.texi:21715
#, no-wrap
msgid "sessions, completion tag"
msgstr "会话, 补全标记"

#. type: t{#1}
#: zsh.texi:21716
#, no-wrap
msgid "sessions"
msgstr "会话"

#. type: table
#: zsh.texi:21718
msgid "for sessions in the @t{zftp} function suite"
msgstr "@t{zftp} 函数套件中的会话"

#. type: kindex
#: zsh.texi:21719
#, no-wrap
msgid "signals, completion tag"
msgstr "信号, 补全标记"

#. type: table
#: zsh.texi:21722
msgid "for signal names"
msgstr "用于信号名"

#. type: kindex
#: zsh.texi:21723
#, no-wrap
msgid "strings, completion tag"
msgstr "字符串, 补全标记"

#. type: t{#1}
#: zsh.texi:21724
#, no-wrap
msgid "strings"
msgstr "字符串"

#. type: table
#: zsh.texi:21727
msgid "for strings (e.g. the replacement strings for the @t{cd} builtin command)"
msgstr "用于字符串（例如 @t{cd} 内置命令的替换字符串）"

#. type: kindex
#: zsh.texi:21728
#, no-wrap
msgid "styles, completion tag"
msgstr "样式, 补全标记"

#. type: t{#1}
#: zsh.texi:21729 zsh.texi:35804
#, no-wrap
msgid "styles"
msgstr "样式"

#. type: table
#: zsh.texi:21731
msgid "for styles used by the zstyle builtin command"
msgstr "zstyle 内置命令使用的样式"

#. type: kindex
#: zsh.texi:21732
#, no-wrap
msgid "suffixes, completion tag"
msgstr "后缀, 补全标记"

#. type: t{#1}
#: zsh.texi:21733
#, no-wrap
msgid "suffixes"
msgstr "后缀"

#. type: table
#: zsh.texi:21735
msgid "for filename extensions"
msgstr "用于文件扩展名"

#. type: kindex
#: zsh.texi:21736
#, no-wrap
msgid "tags, completion tag"
msgstr "标记, 补全标记"

#. type: t{#1}
#: zsh.texi:21737
#, no-wrap
msgid "tags"
msgstr "标记"

#. type: table
#: zsh.texi:21739
msgid "for tags (e.g. @t{rpm} tags)"
msgstr "用于标记（如 @t{rpm} 标记）"

#. type: kindex
#: zsh.texi:21740
#, no-wrap
msgid "targets, completion tag"
msgstr "目标, 补全标记"

#. type: t{#1}
#: zsh.texi:21741
#, no-wrap
msgid "targets"
msgstr "目标"

#. type: table
#: zsh.texi:21743
msgid "for makefile targets"
msgstr "用于 makefile 目标"

#. type: kindex
#: zsh.texi:21744
#, no-wrap
msgid "time-zones, completion tag"
msgstr "时区, 补全标记"

#. type: t{#1}
#: zsh.texi:21745
#, no-wrap
msgid "time-zones"
msgstr "时区"

#. type: table
#: zsh.texi:21747
msgid "for time zones (e.g. when setting the @t{TZ} parameter)"
msgstr "用于时区(例如，在设置 @t{TZ} 参数时）"

#. type: kindex
#: zsh.texi:21748
#, no-wrap
msgid "types, completion tag"
msgstr "类型, 补全标记"

#. type: t{#1}
#: zsh.texi:21749
#, no-wrap
msgid "types"
msgstr "类型"

#. type: table
#: zsh.texi:21751
msgid "for types of whatever (e.g. address types for the @t{xhost} command)"
msgstr "关于各种类型的内容（例如 @t{xhost} 命令的地址类型）。"

#. type: kindex
#: zsh.texi:21752
#, no-wrap
msgid "urls, completion tag"
msgstr "urls, 补全标记"

#. type: t{#1}
#: zsh.texi:21753 zsh.texi:23707
#, no-wrap
msgid "urls"
msgstr "urls"

#. type: table
#: zsh.texi:21755
msgid "used to look up the @t{urls} and @t{local} styles when completing URLs"
msgstr "用于在补全 URL 时查找 @t{urls} 和 @t{local} 样式"

#. type: kindex
#: zsh.texi:21756
#, no-wrap
msgid "users, completion tag"
msgstr "users, 补全标记"

#. type: t{#1}
#: zsh.texi:21757 zsh.texi:23791
#, no-wrap
msgid "users"
msgstr "users"

#. type: table
#: zsh.texi:21759
msgid "for usernames"
msgstr "用于用户名"

#. type: kindex
#: zsh.texi:21760
#, no-wrap
msgid "values, completion tag"
msgstr "values, 补全标记"

#. type: t{#1}
#: zsh.texi:21761
#, no-wrap
msgid "values"
msgstr "values"

#. type: table
#: zsh.texi:21763
msgid "for one of a set of values in certain lists"
msgstr "用于某些列表中的一组数值之一"

#. type: kindex
#: zsh.texi:21764
#, no-wrap
msgid "variant, completion tag"
msgstr "variant, 补全标记"

#. type: t{#1}
#: zsh.texi:21765
#, no-wrap
msgid "variant"
msgstr "variant"

#. type: table
#: zsh.texi:21768
msgid "used by @t{_pick_variant} to look up the command to run when determining what program is installed for a particular command name."
msgstr "用于 @t{_pick_variant} 在确定特定命令名安装了什么程序时查找要运行的命令。"

#. type: kindex
#: zsh.texi:21769
#, no-wrap
msgid "visuals, completion tag"
msgstr "visuals, 补全标记"

#. type: t{#1}
#: zsh.texi:21770
#, no-wrap
msgid "visuals"
msgstr "visuals"

#. type: table
#: zsh.texi:21772
msgid "for X visuals"
msgstr "用于 X 视觉效果"

#. type: kindex
#: zsh.texi:21773
#, no-wrap
msgid "warnings, completion tag"
msgstr "warnings, 补全标记"

#. type: t{#1}
#: zsh.texi:21774
#, no-wrap
msgid "warnings"
msgstr "warnings"

#. type: table
#: zsh.texi:21776
msgid "used to look up the @t{format} style for warnings"
msgstr "用于为警告查找 @t{format} 样式"

#. type: kindex
#: zsh.texi:21777
#, no-wrap
msgid "widgets, completion tag"
msgstr "widgets, 补全标记"

#. type: table
#: zsh.texi:21780
msgid "for zsh widget names"
msgstr "用于 zsh 小部件名称"

#. type: kindex
#: zsh.texi:21781
#, no-wrap
msgid "windows, completion tag"
msgstr "windows, 补全标记"

#. type: t{#1}
#: zsh.texi:21782
#, no-wrap
msgid "windows"
msgstr "windows"

#. type: table
#: zsh.texi:21784
msgid "for IDs of X windows"
msgstr "用于 X 窗口的 ID"

#. type: kindex
#: zsh.texi:21785
#, no-wrap
msgid "zsh-options, completion tag"
msgstr "zsh-options, 补全标记"

#. type: t{#1}
#: zsh.texi:21786
#, no-wrap
msgid "zsh-options"
msgstr "zsh-options"

#. type: table
#: zsh.texi:21788
msgid "for shell options"
msgstr "用于 shell 选项"

#. type: subsection
#: zsh.texi:21793
#, no-wrap
msgid "Standard Styles"
msgstr "标准样式"

#. type: cindex
#: zsh.texi:21795
#, no-wrap
msgid "completion system, styles"
msgstr "补全系统, 样式"

#. type: Plain text
#: zsh.texi:21805
msgid ""
"Note that the values of several of these styles represent boolean values.  Any of the strings `@t{true}', `@t{on}', `@t{yes}', and `@t{1}' can be used for the value `true' and any of the strings "
"`@t{false}', `@t{off}', `@t{no}', and `@t{0}' for the value `false'.  The behavior for any other value is undefined except where explicitly mentioned.  The default value may be either `true' or `false' if "
"the style is not set."
msgstr ""
"请注意，其中几个样式的值代表布尔值。 任何字符串 `@t{true}', `@t{on}', `@t{yes}' 和 `@t{1}' 都可用于表示值 `true' ，任何字符串 `@t{false}', `@t{off}', `@t{no}' 和 `@t{0}' 都可用于表示值 `false' 。 除非明确"
"提及，否则任何其他值的行为都是未定义的。 如果未设置样式，默认值可能是 `true' 或 `false' 。"

#. type: Plain text
#: zsh.texi:21814
msgid ""
"Some of these styles are tested first for every possible tag corresponding to a type of match, and if no style was found, for the @t{default} tag.  The most notable styles of this type are @t{menu}, "
"@t{list-colors} and styles controlling completion listing such as @t{list-packed} and @t{last-prompt}.  When tested for the @t{default} tag, only the @var{function} field of the context will be set so "
"that a style using the @t{default} tag will normally be defined along the lines of:"
msgstr ""
"其中一些样式会首先针对与匹配类型相对应的所有可能标记进行测试，如果未找到样式，则针对 @t{default} 标签进行测试。 这类样式中最著名的是 @t{menu}、@t{list-colors} 和控制补全列表的样式，如 @t{list-packed} 和 "
"@t{last-prompt}。 在对 @t{default} 标记进行测试时，只有上下文的 @var{function} 字段会被设置，因此使用 @t{default} 标记的样式通常会按以下方式定义："

#. type: example
#: zsh.texi:21818
#, no-wrap
msgid "zstyle ':completion:*:default' menu ...\n"
msgstr "zstyle ':completion:*:default' menu ...\n"

#. type: kindex
#: zsh.texi:21822
#, no-wrap
msgid "accept-exact, completion style"
msgstr "accept-exact, 补全样式"

#. type: t{#1}
#: zsh.texi:21823
#, no-wrap
msgid "accept-exact"
msgstr "accept-exact"

#. type: table
#: zsh.texi:21829
msgid ""
"This is tested for the @t{default} tag in addition to the tags valid for the current context.  If it is set to `true' and any of the trial matches is the same as the string on the command line, this match "
"will immediately be accepted (even if it would otherwise be considered ambiguous)."
msgstr "除了对当前上下文有效的标记外，还对 @t{default} 标记进行测试。 如果将其设置为 `true' ，且任何一个试验匹配都与命令行中的字符串相同，则该匹配将立即被接受（即使在其他情况下它会被认为是模棱两可的）。"

#. type: table
#: zsh.texi:21837
msgid ""
"When completing pathnames (where the tag used is `@t{paths}')  this style accepts any number of patterns as the value in addition to the boolean values.  Pathnames matching one of these patterns will be "
"accepted immediately even if the command line contains some more partially typed pathname components and these match no file under the directory accepted."
msgstr ""
"在补全路径名时（使用的标记为 `@t{paths}' ），除布尔值外，该样式还接受任意数量的模式作为值。 即使命令行中包含更多部分键入的路径名组件，且这些组件与所接受目录下的文件不匹配，也会立即接受与这些模式之一匹配的"
"路径名。"

#. type: table
#: zsh.texi:21847
msgid ""
"This style is also used by the @t{_expand} completer to decide if words beginning with a tilde or parameter expansion should be expanded.  For example, if there are parameters @t{foo} and @t{foobar}, the "
"string `@t{$foo}' will only be expanded if @t{accept-exact} is set to `true'; otherwise the completion system will be allowed to complete @t{$foo} to @t{$foobar}. If the style is set to `@t{continue}', "
"@t{_expand} will add the expansion as a match and the completion system will also be allowed to continue."
msgstr ""
"@t{_expand} 补全器也使用这种样式来决定是否扩展以斜线（tilde）开头的单词或参数扩展。 例如，如果有参数 @t{foo} 和 @t{foobar}，只有当 @t{accept-exact} 设置为 `true' 时，字符串 `@t{$foo}' 才会被展开；否则，将"
"允许补全系统将 @t{$foo} 补全为 @t{$foobar}。如果样式被设置为`@t{continue}'，@t{_expand} 将添加扩展作为匹配，补全系统也将被允许继续。"

#. type: kindex
#: zsh.texi:21848
#, no-wrap
msgid "accept-exact-dirs, completion style"
msgstr "accept-exact-dirs, 补全样式"

#. type: t{#1}
#: zsh.texi:21849
#, no-wrap
msgid "accept-exact-dirs"
msgstr "accept-exact-dirs"

#. type: table
#: zsh.texi:21856
msgid ""
"This is used by filename completion.  Unlike @t{accept-exact} it is a boolean.  By default, filename completion examines all components of a path to see if there are completions of that component, even if "
"the component matches an existing directory.  For example, when completion after @t{/usr/bin/}, the function examines possible completions to @t{/usr}."
msgstr ""
"用于文件名补全。 与 @t{accept-exact} 不同，它是一个布尔值。 默认情况下，文件名补全会检查路径的所有组件，以查看是否存在该组件的补全，即使该组件与现有目录相匹配。 例如，当补全在 @t{/usr/bin/} 之后时，函数会"
"检查 @t{/usr} 的可能补全。"

#. type: table
#: zsh.texi:21862
msgid ""
"When this style is `true', any prefix of a path that matches an existing directory is accepted without any attempt to complete it further.  Hence, in the given example, the path @t{/usr/bin/} is accepted "
"immediately and completion tried in that directory."
msgstr "当该样式为 `true' 时，任何与现有目录匹配的路径前缀都会被接受，而不会尝试进一步补全。 因此，在给出的示例中，路径 @t{/usr/bin/} 被立即接受，并尝试在该目录中补全。"

#. type: table
#: zsh.texi:21869
msgid ""
"This style is also useful when completing after directories that magically appear when referenced, such as ZFS @t{.zfs} directories or NetApp @t{.snapshot} directories.  When the style is set the shell "
"does not check for the existence of the directory within the parent directory."
msgstr "这种样式在处理引用后自动出现的目录时也很有用，比如 ZFS 的 @t{.zfs} 目录或 NetApp 的 @t{.snapshot} 目录。当设置了这种样式时，shell 不会检查父目录中的目录是否存在。"

#. type: table
#: zsh.texi:21873
msgid "If you wish to inhibit this behaviour entirely, set the @t{path-completion} style (see below) to `false'."
msgstr "如果希望完全禁止这种行为，请将 @t{path-completion} 样式（见下文）设置为 `false'。"

#. type: kindex
#: zsh.texi:21874
#, no-wrap
msgid "add-space, completion style"
msgstr "add-space, 补全样式"

#. type: t{#1}
#: zsh.texi:21875
#, no-wrap
msgid "add-space"
msgstr "add-space"

#. type: table
#: zsh.texi:21884
msgid ""
"This style is used by the @t{_expand} completer.  If it is `true' (the default), a space will be inserted after all words resulting from the expansion, or a slash in the case of directory names.  If the "
"value is `@t{file}', the completer will only add a space to names of existing files.  Either a boolean `true' or the value `@t{file}' may be combined with `@t{subst}', in which case the completer will not "
"add a space to words generated from the expansion of a substitution of the form `@t{$(}@var{...}@t{)}' or `@t{$@{}@var{...}@t{@}}'."
msgstr ""
"该样式由 @t{_expand} 补全器使用。 如果值为 `true'（默认值），则会在扩展后的所有单词后插入空格，如果是目录名，则会插入斜线。 如果该值为 `@t{file}'，则补全器只会在现有文件名后添加空格。 布尔值 `true' 或值 "
"`@t{file}' 都可以与 `@t{subst}' 结合使用，在这种情况下，补全器不会在形式为 `@t{$(}@var{...}@t{)}' 或 `@t{$@{}@var{...}@t{@}}' 的替换扩展产生的单词后添加空格。"

#. type: table
#: zsh.texi:21888
msgid "The @t{_prefix} completer uses this style as a simple boolean value to decide if a space should be inserted before the suffix."
msgstr "@t{_prefix} 补全器使用这种样式作为一个简单的布尔值，来决定是否在后缀前插入空格。"

#. type: kindex
#: zsh.texi:21889
#, no-wrap
msgid "ambiguous, completion style"
msgstr "ambiguous, 补全样式"

#. type: t{#1}
#: zsh.texi:21890
#, no-wrap
msgid "ambiguous"
msgstr "ambiguous"

#. type: table
#: zsh.texi:21895
msgid ""
"This applies when completing non-final components of filename paths, in other words those with a trailing slash.  If it is set, the cursor is left after the first ambiguous component, even if menu "
"completion is in use.  The style is always tested with the @t{paths} tag."
msgstr "这适用于补全文件名路径中的非最终组件，换句话说，就是那些带有尾部斜线的组件。 如果设置了该样式，即使正在使用菜单补全，光标也会留在第一个含混的组件之后。 该样式始终使用 @t{paths} 标记进行测试。"

#. type: kindex
#: zsh.texi:21896
#, no-wrap
msgid "assign-list, completion style"
msgstr "assign-list, 补全样式"

#. type: t{#1}
#: zsh.texi:21897
#, no-wrap
msgid "assign-list"
msgstr "assign-list"

#. type: table
#: zsh.texi:21903
msgid ""
"When completing after an equals sign that is being treated as an assignment, the completion system normally completes only one filename.  In some cases the value may be a list of filenames separated by "
"colons, as with @t{PATH} and similar parameters.  This style can be set to a list of patterns matching the names of such parameters."
msgstr "在等号后补全赋值时，补全系统通常只补全一个文件名。 在某些情况下，该值可能是由冒号分隔的文件名列表，如 @t{PATH} 和类似参数。 这种样式可以设置为与此类参数名称相匹配的模式列表。"

#. type: table
#: zsh.texi:21907
msgid "The default is to complete lists when the word on the line already contains a colon."
msgstr "默认情况下，当一行中的单词已经包含冒号时，列表会补全。"

#. type: kindex
#: zsh.texi:21908
#, no-wrap
msgid "auto-description, completion style"
msgstr "auto-description, 补全样式"

#. type: t{#1}
#: zsh.texi:21909
#, no-wrap
msgid "auto-description"
msgstr "auto-description"

#. type: table
#: zsh.texi:21916
msgid ""
"If set, this style's value will be used as the description for options that are not described by the completion functions, but that have exactly one argument.  The sequence `@t{%d}' in the value will be "
"replaced by the description for this argument.  Depending on personal preferences, it may be useful to set this style to something like `@t{specify: %d}'.  Note that this may not work for some commands."
msgstr ""
"如果设置了该样式，则该样式的值将用作未被补全函数描述但有一个参数的选项的描述。 值中的序列 `@t{%d}' 将被该参数的描述所取代。 根据个人喜好，将该样式设置为类似于 `@t{specify: %d}'。  请注意，这对某些命令可能"
"不起作用。"

#. type: kindex
#: zsh.texi:21917
#, no-wrap
msgid "avoid-completer, completion style"
msgstr "avoid-completer, 补全样式"

#. type: t{#1}
#: zsh.texi:21918
#, no-wrap
msgid "avoid-completer"
msgstr "avoid-completer"

#. type: table
#: zsh.texi:21924
msgid ""
"This is used by the @t{_all_matches} completer to decide if the string consisting of all matches should be added to the list currently being generated.  Its value is a list of names of completers.  If any "
"of these is the name of the completer that generated the matches in this completion, the string will not be added."
msgstr "@t{_all_matches} 补全器使用它来决定是否将所有匹配字符串添加到当前生成的列表中。 它的值是一个补全器名称列表。 如果其中任何一个是在此补全中生成匹配结果的补全器名称，则不会添加该字符串。"

#. type: table
#: zsh.texi:21929
msgid "The default value for this style is `@t{_expand _old_list _correct _approximate}', i.e. it contains the completers for which a string with all matches will almost never be wanted."
msgstr "该样式的默认值为 `@t{_expand _old_list _correct _approximate}'，也就是说，该样式包含的补全器几乎永远不会有匹配的字符串。"

#. type: kindex
#: zsh.texi:21930
#, no-wrap
msgid "cache-path, completion style"
msgstr "cache-path, 补全样式"

#. type: t{#1}
#: zsh.texi:21931
#, no-wrap
msgid "cache-path"
msgstr "cache-path"

#. type: table
#: zsh.texi:21936
msgid ""
"This style defines the path where any cache files containing dumped completion data are stored.  It defaults to `@t{$ZDOTDIR/.zcompcache}', or `@t{$HOME/.zcompcache}' if @t{$ZDOTDIR} is not defined.  The "
"completion cache will not be used unless the @t{use-cache} style is set."
msgstr ""
"该样式定义了包含转储补全数据的缓存文件的存储路径。 默认路径为 `@t{$ZDOTDIR/.zcompcache}'，如果未定义 @t{$ZDOTDIR}，则默认路径为 `@t{$HOME/.zcompcache}' 。 除非设置了 @t{use-cache} 样式，否则不会使用补全缓"
"存。"

#. type: kindex
#: zsh.texi:21937
#, no-wrap
msgid "cache-policy, completion style"
msgstr "cache-policy, 补全样式"

#. type: t{#1}
#: zsh.texi:21938
#, no-wrap
msgid "cache-policy"
msgstr "cache-policy"

#. type: table
#: zsh.texi:21942
msgid "This style defines the function that will be used to determine whether a cache needs rebuilding.  See the section on the @t{_cache_invalid} function below."
msgstr "该样式定义了用于确定缓存是否需要重建的函数。 请参阅下面有关 @t{_cache_invalid} 函数的部分。"

#. type: kindex
#: zsh.texi:21943
#, no-wrap
msgid "call-command, completion style"
msgstr "call-command, 补全样式"

#. type: t{#1}
#: zsh.texi:21944
#, no-wrap
msgid "call-command"
msgstr "call-command"

#. type: table
#: zsh.texi:21951
msgid ""
"This style is used in the function for commands such as @t{make} and @t{ant} where calling the command directly to generate matches suffers problems such as being slow or, as in the case of @t{make} can "
"potentially cause actions in the makefile to be executed. If it is set to `true' the command is called to generate matches. The default value of this style is `false'."
msgstr ""
"这种风格用于函数中的命令，如@t{make}和@t{ant}，在这些情况下，直接调用命令来生成匹配项会遇到一些问题，例如速度慢，或者像在@t{make}的情况下，可能会导致 makefile 中的操作被执行。如果它被设置为 `true'，则会调"
"用命令来生成匹配项。这种风格的默认值是false。"

#. type: kindex
#: zsh.texi:21952
#, no-wrap
msgid "command, completion style"
msgstr "command, 补全样式"

#. type: table
#: zsh.texi:21963
msgid ""
"In many places, completion functions need to call external commands to generate the list of completions.  This style can be used to override the command that is called in some such cases.  The elements of "
"the value are joined with spaces to form a command line to execute.  The value can also start with a hyphen, in which case the usual command will be added to the end; this is most useful for putting "
"`@t{builtin}' or `@t{command}' in front to make sure the appropriate version of a command is called, for example to avoid calling a shell function with the same name as an external command."
msgstr ""
"在许多地方，补全函数需要调用外部命令来生成补全列表。 在这种情况下，可以使用这种样式来覆盖调用的命令。 值中的元素用空格连接，形成要执行的命令行。 该值也可以以连字符开头，在这种情况下，通常的命令会被添加到最"
"后；这对于在前面加上 `@t{builtin}' 或 `@t{command}'，以确保调用的是命令的适当版本（例如，避免调用与外部命令同名的 shell 函数）最为有用。"

#. type: table
#: zsh.texi:21974
msgid ""
"As an example, the completion function for process IDs uses this style with the @t{processes} tag to generate the IDs to complete and the list of processes to display (if the @t{verbose} style is "
"`true').  The list produced by the command should look like the output of the @t{ps} command.  The first line is not displayed, but is searched for the string `@t{PID}' (or `@t{pid}') to find the position "
"of the process IDs in the following lines.  If the line does not contain `@t{PID}', the first numbers in each of the other lines are taken as the process IDs to complete."
msgstr ""
"举例来说，进程 ID 的补全函数使用这种样式和 @t{processes} 标记来生成要补全的 ID 和要显示的进程列表（如果 @t{verbose} 样式为 `true'）。 该命令生成的列表应与 @t{ps} 命令的输出相似。 第一行不会显示，但会搜索字"
"符串 `@t{PID}' （或 `@t{pid}'），以确定进程 ID 在下面各行中的位置。 如果该行不包含 `@t{PID}'，则其他各行中的第一个数字将作为进程 ID 用来补全。"

#. type: table
#: zsh.texi:21980
msgid ""
"Note that the completion function generally has to call the specified command for each attempt to generate the completion list.  Hence care should be taken to specify only commands that take a short time "
"to run, and in particular to avoid any that may never terminate."
msgstr "需要注意的是，每次尝试生成补全列表时，补全函数一般都要调用指定的命令。 因此，应注意只指定运行时间较短的命令，尤其要避免任何可能永远不会终止的命令。"

#. type: kindex
#: zsh.texi:21981
#, no-wrap
msgid "command-path, completion style"
msgstr "command-path, 补全样式"

#. type: t{#1}
#: zsh.texi:21982
#, no-wrap
msgid "command-path"
msgstr "command-path"

#. type: table
#: zsh.texi:21985
msgid "This is a list of directories to search for commands to complete.  The default for this style is the value of the special parameter @t{path}."
msgstr "这是要搜索补全命令的目录列表。 该样式的默认值是特殊参数 @t{path} 的值。"

#. type: kindex
#: zsh.texi:21986
#, no-wrap
msgid "commands, completion style"
msgstr "commands, 补全样式"

#. type: table
#: zsh.texi:21994
msgid ""
"This is used by the function completing sub-commands for the system initialisation scripts (residing in @t{/etc/init.d} or somewhere not too far away from that).  Its values give the default commands to "
"complete for those commands for which the completion function isn't able to find them out automatically.  The default for this style are the two strings `@t{start}' and `@t{stop}'."
msgstr "用于补全系统初始化脚本的子命令的函数（位于 @t{/etc/init.d} 或其他位置）。 对于补全函数无法自动找出的命令，它的值给出了要补全的默认命令。 该样式的默认值是两个字符串 `@t{start}' 和 `@t{stop}'。"

#. type: kindex
#: zsh.texi:21995
#, no-wrap
msgid "complete, completion style"
msgstr "complete, 补全样式"

#. type: t{#1}
#: zsh.texi:21996 zsh.texi:39661
#, no-wrap
msgid "complete"
msgstr "complete"

#. type: table
#: zsh.texi:22001
msgid ""
"This is used by the @t{_expand_alias} function when invoked as a bindable command.  If set to `true' and the word on the command line is not the name of an alias, matching alias names will be completed."
msgstr "当作为可绑定命令调用时，@t{_expand_alias} 函数将使用此值。 如果设置为 `true' ，且命令行中的单词不是别名的名字，则将补全与别名匹配的名字。"

#. type: kindex
#: zsh.texi:22002
#, no-wrap
msgid "complete-options, completion style"
msgstr "complete-options, 补全样式"

#. type: t{#1}
#: zsh.texi:22003
#, no-wrap
msgid "complete-options"
msgstr "complete-options"

#. type: table
#: zsh.texi:22011
msgid ""
"This is used by the completer for @t{cd}, @t{chdir} and @t{pushd}.  For these commands a @t{-} is used to introduce a directory stack entry and completion of these is far more common than completing "
"options.  Hence unless the value of this style is `true' options will not be completed, even after an initial @t{-}.  If it is `true', options will be completed after an initial @t{-} unless there is a "
"preceding @t{-}@t{-} on the command line."
msgstr ""
"这是 @t{cd}、@t{chdir} 和 @t{pushd} 的补全器使用的。 对于这些命令，@t{-} 用于引入目录堆栈条目，补全这些命令远比补全选项更常见。 因此，除非该样式的值为 `true'，否则即使在初始化 @t{-} 后，也不会补全选项。 如"
"果该样式的值为 `true'，选项将在初始化 @t{-} 之后补全，除非命令行中有@t{-}@t{-}。"

#. type: kindex
#: zsh.texi:22012 zsh.texi:39625
#, no-wrap
msgid "completer, completion style"
msgstr "completer, 补全样式"

#. type: t{#1}
#: zsh.texi:22013 zsh.texi:39626
#, no-wrap
msgid "completer"
msgstr "completer"

#. type: table
#: zsh.texi:22018
msgid "The strings given as the value of this style provide the names of the completer functions to use. The available completer functions are described in @ref{Control Functions}."
msgstr "作为该样式值的字符串提供了要使用的补全函数名称。@ref{控制函数} 中描述了可用的补全函数。"

#. type: table
#: zsh.texi:22030
msgid ""
"Each string may be either the name of a completer function or a string of the form `@var{function}@t{:}@var{name}'.  In the first case the @var{completer} field of the context will contain the name of the "
"completer without the leading underscore and with all other underscores replaced by hyphens.  In the second case the @var{function} is the name of the completer to call, but the context will contain the "
"user-defined @var{name} in the @var{completer} field of the context.  If the @var{name} starts with a hyphen, the string for the context will be build from the name of the completer function as in the "
"first case with the @var{name} appended to it.  For example:"
msgstr ""
"每个字符串既可以是补全函数的名称，也可以是形式为 `@var{function}@t{:}@var{name}' 的字符串。 在第一种情况下，上下文的 @var{completer} 字段将包含补全器的名称，但不包括前导下划线，其他下划线均由连字符代替。 "
"在第二种情况下，@var{function} 是要调用的完成器的名称，但上下文的 @var{completer} 字段中将包含用户定义的 @var{name} 。 如果 @var{name} 以连字号开头，则上下文字符串将与第一种情况一样，由包含 @var{name} 的补"
"全函数名称追加构建而成。 例如："

#. type: example
#: zsh.texi:22034
#, no-wrap
msgid "zstyle ':completion:*' completer _complete _complete:-foo\n"
msgstr "zstyle ':completion:*' completer _complete _complete:-foo\n"

#. type: table
#: zsh.texi:22045
msgid ""
"Here, completion will call the @t{_complete} completer twice, once using `@t{complete}' and once using `@t{complete-foo}' in the @var{completer} field of the context.  Normally, using the same completer "
"more than once only makes sense when used with the `@var{functions}@t{:}@var{name}' form, because otherwise the context name will be the same in all calls to the completer; possible exceptions to this "
"rule are the @t{_ignored} and @t{_prefix} completers."
msgstr ""
"在这里，补全将调用 @t{_complete} 补全函数两次，一次是使用 `@t{complete}' ，另一次是在上下文的 @var{completer} 字段中使用 `@t{complete-foo}' 。 通常，只有在与 `@var{functions}@t{:}@var{name}' 形式一起使用"
"时，多次使用同一补全器才有意义，否则在所有对补全器的调用中，上下文名称都将相同；@t{_ignored} 和 @t{_prefix} 补全器可能是这一规则的例外。"

#. type: table
#: zsh.texi:22050
msgid "The default value for this style is `@t{_complete _ignored}': only completion will be done, first using the @t{ignored-patterns} style and the @t{$fignore} array and then without ignoring matches."
msgstr "该样式的默认值为 `@t{_complete _ignored}'：只完成补全，首先使用 @t{ignored-patterns} 样式和 @t{$fignore} 数组，然后在不忽略匹配的情况下进行。"

#. type: kindex
#: zsh.texi:22051
#, no-wrap
msgid "condition, completion style"
msgstr "condition, 补全样式"

#. type: table
#: zsh.texi:22056
msgid "This style is used by the @t{_list} completer function to decide if insertion of matches should be delayed unconditionally. The default is `true'."
msgstr "该样式被 @t{_list} 补全器函数用于决定是否应无条件延迟插入匹配项。默认为 `true'。"

#. type: kindex
#: zsh.texi:22057
#, no-wrap
msgid "delimiters, completion style"
msgstr "delimiters, 补全样式"

#. type: t{#1}
#: zsh.texi:22058
#, no-wrap
msgid "delimiters"
msgstr "delimiters"

#. type: table
#: zsh.texi:22065
msgid ""
"This style is used when adding a delimiter for use with history modifiers or glob qualifiers that have delimited arguments.  It is an array of preferred delimiters to add.  Non-special characters are "
"preferred as the completion system may otherwise become confused.  The default list is @t{:}, @t{+}, @t{/}, @t{-}, @t{%}.  The list may be empty to force a delimiter to be typed."
msgstr ""
"该样式用于添加分隔符，以便与历史修饰符或 glob 限定符一起使用(具有分隔的参数)。 它是一个要添加的首选分隔符数组。 首选非特殊字符，否则补全系统可能会混淆。 默认列表为 @t{:}、@t{+}、@t{/}、@t{-}、@t{%}。 该列"
"表可以为空，以强制输入分隔符。"

#. type: kindex
#: zsh.texi:22066
#, no-wrap
msgid "disabled, completion style"
msgstr "disabled, 补全样式"

#. type: t{#1}
#: zsh.texi:22067
#, no-wrap
msgid "disabled"
msgstr "disabled"

#. type: table
#: zsh.texi:22071
msgid "If this is set to `true', the @t{_expand_alias} completer and bindable command will try to expand disabled aliases, too.  The default is `false'."
msgstr "如果设置为 `true'，@t{_expand_alias} 补全器和可绑定命令也将尝试扩展禁用的别名。 默认值为 `false'。"

#. type: kindex
#: zsh.texi:22072
#, no-wrap
msgid "domains, completion style"
msgstr "domains, 补全样式"

#. type: table
#: zsh.texi:22077
msgid "A list of names of network domains for completion.  If this is not set, domain names will be taken from the file @t{/etc/resolv.conf}."
msgstr "用于补全的网络域名列表。 如果未设置，域名将取自 @t{/etc/resolv.conf} 文件。"

#. type: kindex
#: zsh.texi:22078
#, no-wrap
msgid "environ, completion style"
msgstr "environ, 补全样式"

#. type: t{#1}
#: zsh.texi:22079
#, no-wrap
msgid "environ"
msgstr "environ"

#. type: table
#: zsh.texi:22083
msgid ""
"The environ style is used when completing for `@t{sudo}'.  It is set to an array of `@var{VAR}@t{=}@var{value}' assignments to be exported into the local environment before the completion for the target "
"command is invoked."
msgstr "environ 样式用于补全 `@t{sudo}'。 在调用目标命令的补全之前，它将被设置为 `@var{VAR}@t{=}@var{value}' 赋值的数组，并导出到本地环境中。"

#. type: example
#: zsh.texi:22086
#, no-wrap
msgid ""
"zstyle ':completion:*:sudo::' environ \\ \n"
"  PATH=\"/sbin:/usr/sbin:$PATH\" HOME=\"/root\"\n"
msgstr ""
"zstyle ':completion:*:sudo::' environ \\ \n"
"  PATH=\"/sbin:/usr/sbin:$PATH\" HOME=\"/root\"\n"

#. type: kindex
#: zsh.texi:22088
#, no-wrap
msgid "expand, completion style"
msgstr "expand, 补全样式"

#. type: t{#1}
#: zsh.texi:22089
#, no-wrap
msgid "expand"
msgstr "expand"

#. type: table
#: zsh.texi:22092
msgid "This style is used when completing strings consisting of multiple parts, such as path names."
msgstr "这种样式用于补全由多个部分（如路径名）组成的字符串。"

#. type: table
#: zsh.texi:22097
msgid "If one of its values is the string `@t{prefix}', the partially typed word from the line will be expanded as far as possible even if trailing parts cannot be completed."
msgstr "如果其值之一是字符串 `@t{prefix}'，则即使尾部无法完成，也会尽可能扩展该行的部分输入字。"

#. type: table
#: zsh.texi:22103
msgid ""
"If one of its values is the string `@t{suffix}', matching names for components after the first ambiguous one will also be added.  This means that the resulting string is the longest unambiguous string "
"possible.  However, menu completion can be used to cycle through all matches."
msgstr "如果其值之一是字符串 `@t{suffix}'，则在第一个模棱两可的名称之后也会添加匹配的组件名称。 这意味着生成的字符串可能是最长的无歧义字符串。 不过，可以使用菜单补全来循环查看所有匹配结果。"

#. type: kindex
#: zsh.texi:22104
#, no-wrap
msgid "extra-verbose, completion style"
msgstr "extra-verbose, 补全样式"

#. type: t{#1}
#: zsh.texi:22105
#, no-wrap
msgid "extra-verbose"
msgstr "extra-verbose"

#. type: table
#: zsh.texi:22109
msgid "If set, the completion listing is more verbose at the cost of a probable decrease in completion speed.  Completion performance will suffer if this style is set to `true'."
msgstr "如果设置，则补全列表会更加冗长，但可能会降低补全速度。 如果将此样式设置为 `true'，补全性能将受到影响。"

#. type: kindex
#: zsh.texi:22110
#, no-wrap
msgid "fake, completion style"
msgstr "fake, 补全样式"

#. type: t{#1}
#: zsh.texi:22111
#, no-wrap
msgid "fake"
msgstr "fake"

#. type: table
#: zsh.texi:22118
msgid ""
"This style may be set for any completion context.  It specifies additional strings that will always be completed in that context.  The form of each string is `@var{value}@t{:}@var{description}'; the colon "
"and description may be omitted, but any literal colons in @var{value} must be quoted with a backslash.  Any @var{description} provided is shown alongside the value in completion listings."
msgstr ""
"可为任何补全上下文设置该样式。 它指定了在该上下文中将始终补全的附加字符串。 每个字符串的形式为 `@var{value}@t{:}@var{description}'；冒号和描述可以省略，但 @var{value} 中的任何字面冒号必须用反斜杠引出。 提"
"供的任何 @var{description} 都会与值一起显示在补全列表中。"

#. type: table
#: zsh.texi:22123
msgid ""
"It is important to use a sufficiently restrictive context when specifying fake strings.  Note that the styles @t{fake-files} and @t{fake-parameters} provide additional features when completing files or "
"parameters."
msgstr "在指定虚假字符串时，必须使用足够严格的上下文。 请注意，@t{fake-files} 和 @t{fake-parameters} 样式可在补全文件或参数时提供额外功能。"

#. type: kindex
#: zsh.texi:22124
#, no-wrap
msgid "fake-always, completion style"
msgstr "fake-always, 补全样式"

#. type: t{#1}
#: zsh.texi:22125
#, no-wrap
msgid "fake-always"
msgstr "fake-always"

#. type: table
#: zsh.texi:22130
msgid ""
"This works identically to the @t{fake} style except that the @t{ignored-patterns} style is not applied to it.  This makes it possible to override a set of matches completely by setting the ignored "
"patterns to `@t{*}'."
msgstr "除了不使用 @t{ignored-patterns} 样式外，该样式的作用与 @t{fake} 样式相同。 这样，通过将忽略模式设置为 `@t{*}'，就可以完全覆盖一组匹配。"

#. type: table
#: zsh.texi:22141
msgid ""
"The following shows a way of supplementing any tag with arbitrary data, but having it behave for display purposes like a separate tag.  In this example we use the features of the @t{tag-order} style to "
"divide the @t{named-directories} tag into two when performing completion with the standard completer @t{complete} for arguments of @t{cd}.  The tag @t{named-directories-normal} behaves as normal, but the "
"tag @t{named-directories-mine} contains a fixed set of directories.  This has the effect of adding the match group `@t{extra directories}' with the given completions."
msgstr ""
"下面的示例展示了一种用任意数据补充任何标记的方法，但在显示时，这些数据的表现与单独的标记无异。 在本例中，我们使用 @t{tag-order} 样式的功能，在使用标准补全器 @t{complete} 对 @t{cd} 的参数进行补全时，将 "
"@t{named-directories} 标签分为两个。 标签 @t{named-directories-normal} 的行为与正常一样，但标签 @t{named-directories-mine} 包含一组固定的目录。 这样做的效果是，使用给定的补全添加匹配组 `@t{extra "
"directories}'。"

#. type: example
#: zsh.texi:22151
#, no-wrap
msgid ""
"zstyle ':completion::complete:cd:*' tag-order \\ \n"
"  'named-directories:-mine:extra\\ directories\n"
"  named-directories:-normal:named\\ directories *'\n"
"zstyle ':completion::complete:cd:*:named-directories-mine' \\ \n"
"  fake-always mydir1 mydir2\n"
"zstyle ':completion::complete:cd:*:named-directories-mine' \\ \n"
"  ignored-patterns '*'\n"
msgstr ""
"zstyle ':completion::complete:cd:*' tag-order \\ \n"
"  'named-directories:-mine:extra\\ directories\n"
"  named-directories:-normal:named\\ directories *'\n"
"zstyle ':completion::complete:cd:*:named-directories-mine' \\ \n"
"  fake-always mydir1 mydir2\n"
"zstyle ':completion::complete:cd:*:named-directories-mine' \\ \n"
"  ignored-patterns '*'\n"

#. type: kindex
#: zsh.texi:22153
#, no-wrap
msgid "fake-files, completion style"
msgstr "fake-files, 补全样式"

#. type: t{#1}
#: zsh.texi:22154
#, no-wrap
msgid "fake-files"
msgstr "fake-files"

#. type: table
#: zsh.texi:22163
msgid ""
"This style is used when completing files and looked up without a tag.  Its values are of the form `@var{dir}@t{:}@var{names...}'.  This will add the @var{names} (strings separated by spaces) as possible "
"matches when completing in the directory @var{dir}, even if no such files really exist.  The dir may be a pattern; pattern characters or colons in @var{dir} should be quoted with a backslash to be treated "
"literally."
msgstr ""
"该样式用于补全文件和查找无标记的文件。 其值的形式为 `@var{dir}@t{:}@var{names...}'。 这将在目录 @var{dir} 中补全时添加 @var{names}（用空格分隔的字符串）作为可能的匹配项，即使确实不存在这样的文件。 dir 可以"
"是一个模式；@var{dir} 中的模式字符或冒号应使用反斜杠引出，以便按字面意思处理。"

#. type: table
#: zsh.texi:22170
msgid ""
"This can be useful on systems that support special file systems whose top-level pathnames can not be listed or generated with glob patterns (but see @t{accept-exact-dirs} for a more general way of dealing "
"with this problem).  It can also be used for directories for which one does not have read permission."
msgstr "这在支持特殊文件系统的系统中非常有用，这些系统的顶层路径名无法用 glob 模式列出或生成（但请参阅 @t{accept-exact-dirs}，了解处理这一问题的更普遍方法）。 它还可用于没有读取权限的目录。"

#. type: table
#: zsh.texi:22174
msgid "The pattern form can be used to add a certain `magic' entry to all directories on a particular file system."
msgstr "模式形式可用于在特定文件系统的所有目录中添加某个 `魔法' 条目。"

#. type: kindex
#: zsh.texi:22175
#, no-wrap
msgid "fake-parameters, completion style"
msgstr "fake-parameters, 补全样式"

#. type: t{#1}
#: zsh.texi:22176
#, no-wrap
msgid "fake-parameters"
msgstr "fake-parameters"

#. type: table
#: zsh.texi:22185
msgid ""
"This is used by the completion function for parameter names.  Its values are names of parameters that might not yet be set but should be completed nonetheless.  Each name may also be followed by a colon "
"and a string specifying the type of the parameter (like `@t{scalar}', `@t{array}' or `@t{integer}').  If the type is given, the name will only be completed if parameters of that type are required in the "
"particular context.  Names for which no type is specified will always be completed."
msgstr ""
"补全函数将其用于参数名称。 其值是可能尚未设置但仍应补全的参数名称。 每个名称后面还可以跟一个冒号和一个字符串，该字符串指定了参数的类型（如 `@t{scalar}', `@t{array}' 或 `@t{integer}'）。 如果给出了类型，只"
"有在特定上下文中需要该类型的参数时，才会补全名称。 未指定类型的名称将始终补全。"

#. type: kindex
#: zsh.texi:22186
#, no-wrap
msgid "file-list, completion style"
msgstr "file-list, 补全样式"

#. type: t{#1}
#: zsh.texi:22187
#, no-wrap
msgid "file-list"
msgstr "file-list"

#. type: table
#: zsh.texi:22194
msgid ""
"This style controls whether files completed using the standard builtin mechanism are to be listed with a long list similar to @t{ls -l}.  Note that this feature uses the shell module @t{zsh/stat} for file "
"information; this loads the builtin @t{stat} which will replace any external @t{stat} executable.  To avoid this the following code can be included in an initialization file:"
msgstr ""
"该样式控制使用标准内置机制补全的文件是否以类似 @t{ls -l} 的长列表形式列出。 需要注意的是，该功能使用 shell 模块 @t{zsh/stat} 来获取文件信息；这将加载内置的 @t{stat}，从而取代任何外部 @t{stat} 可执行文件。 "
"为避免这种情况，可在初始化文件中加入以下代码："

#. type: example
#: zsh.texi:22199
#, no-wrap
msgid ""
"zmodload -i zsh/stat\n"
"disable stat\n"
msgstr ""
"zmodload -i zsh/stat\n"
"disable stat\n"

#. type: table
#: zsh.texi:22207
msgid ""
"The style may either be set to a `true' value (or `@t{all}'), or one of the values `@t{insert}' or `@t{list}', indicating that files are to be listed in long format in all circumstances, or when "
"attempting to insert a file name, or when listing file names without attempting to insert one."
msgstr "样式既可以设置为 `true' 值（或 `@t{all}'），也可以设置为 `@t{insert}' 或`@t{list}' 值之一，表示在任何情况下都将以长格式列出文件，或在尝试插入文件名时，或在列出文件名但不尝试插入文件名时。"

#. type: table
#: zsh.texi:22213
msgid ""
"More generally, the value may be an array of any of the above values, optionally followed by @t{=}@var{num}.  If @var{num} is present it gives the maximum number of matches for which long listing style "
"will be used.  For example,"
msgstr "一般来说，该值可以是由上述任意值组成的数组，可选择在其后加上 @t{=}@var{num}。 如果存在 @var{num}，则表示将使用长列表样式的最大匹配次数。 例如"

#. type: example
#: zsh.texi:22217
#, no-wrap
msgid "zstyle ':completion:*' file-list list=20 insert=10\n"
msgstr "zstyle ':completion:*' file-list list=20 insert=10\n"

#. type: table
#: zsh.texi:22224
msgid ""
"specifies that long format will be used when listing up to 20 files or inserting a file with up to 10 matches (assuming a listing is to be shown at all, for example on an ambiguous completion), else short "
"format will be used."
msgstr "指定在列出多达 20 个文件或插入多达 10 个匹配文件时使用长格式（假设要显示列表，例如在模棱两可的补全时），否则将使用短格式。"

#. type: example
#: zsh.texi:22229
#, no-wrap
msgid ""
"zstyle -e ':completion:*' file-list \\ \n"
"       '(( $@{+NUMERIC@} )) && reply=(true)'\n"
msgstr ""
"zstyle -e ':completion:*' file-list \\ \n"
"       '(( $@{+NUMERIC@} )) && reply=(true)'\n"

#. type: table
#: zsh.texi:22234
msgid "specifies that long format will be used any time a numeric argument is supplied, else short format."
msgstr "指定在提供数字参数时使用长格式，否则使用短格式。"

#. type: kindex
#: zsh.texi:22235
#, no-wrap
msgid "file-patterns, completion style"
msgstr "file-patterns, 补全样式"

#. type: t{#1}
#: zsh.texi:22236
#, no-wrap
msgid "file-patterns"
msgstr "file-patterns"

#. type: table
#: zsh.texi:22243
msgid ""
"This is used by the standard function for completing filenames, @t{_files}.  If the style is unset up to three tags are offered, `@t{globbed-files}',`@t{directories}' and `@t{all-files}', depending on the "
"types of files expected by the caller of @t{_files}.  The first two (`@t{globbed-files}' and `@t{directories}') are normally offered together to make it easier to complete files in sub-directories."
msgstr ""
"用于补全文件名的标准函数 @t{_files}。 如果未设置样式，则会根据 @t{_files} 的调用者所期望的文件类型，提供三种标记：`@t{globbed-files}',`@t{directories}' 和 `@t{all-files}'。 前两种（`@t{globbed-files}' 和 "
"`@t{directories}'）通常一起提供，以方便补全子目录中的文件。"

#. type: table
#: zsh.texi:22249
msgid ""
"The @t{file-patterns} style provides alternatives to the default tags, which are not used.  Its value consists of elements of the form `@var{pattern}@t{:}@var{tag}'; each string may contain any number of "
"such specifications separated by spaces."
msgstr "@t{file-patterns} 样式提供了默认标记的替代方案，默认标记不会被使用。 其值由形式为 `@var{pattern}@t{:}@var{tag}' 的元素组成；每个字符串可包含任意数量的此类规范，并用空格分隔。"

#. type: table
#: zsh.texi:22258
msgid ""
"The @var{pattern} is a pattern that is to be used to generate filenames.  Any occurrence of the sequence `@t{%p}' is replaced by any pattern(s)  passed by the function calling @t{_files}.  Colons in the "
"pattern must be preceded by a backslash to make them distinguishable from the colon before the @var{tag}.  If more than one pattern is needed, the patterns can be given inside braces, separated by commas."
msgstr ""
"@var{pattern} 是用于生成文件名的模式。 任何出现的序列 `@t{%p}' 都会被调用 @t{_files} 的函数所传递的任何模式所替换。 模式中的冒号必须在前面加上反斜杠，以便与 @var{tag} 前面的冒号区分开来。 如果需要多个模"
"式，可以将模式放在大括号内，中间用逗号隔开。"

#. type: table
#: zsh.texi:22264
msgid ""
"The @var{tag}s of all strings in the value will be offered by @t{_files} and used when looking up other styles.  Any @var{tag}s in the same word will be offered at the same time and before later words.  "
"If no `@t{:}@var{tag}' is given the `@t{files}' tag will be used."
msgstr ""
"值中所有字符串的 @var{tag}s 将由 @t{_files} 提供，并在查找其他样式时使用。 同一单词中的任何 @var{tag}s 都将同时提供，并在后面的单词之前提供。 如果没有给出 `@t{:}@var{tag}' ，则将使用 `@t{files}' 标记。"

#. type: table
#: zsh.texi:22273
msgid ""
"The @var{tag} may also be followed by an optional second colon and a description, which will be used for the `@t{%d}' in the value of the @t{format} style (if that is set) instead of the default "
"description supplied by the completion function.  The inclusion of a description also gives precedence to associated options such as for completion grouping so it can be used where files should be "
"separated."
msgstr ""
"在 @var{tag} 后面还可以可选择的跟着第二个冒号和描述，描述将用于 @t{format} 样式值中的 `@t{%d}' （如果已设置），而不是补全函数提供的默认描述。 包含描述也会优先于相关选项，如补全分组，因此它可以用于需要分隔"
"文件的地方。"

#. type: table
#: zsh.texi:22278
msgid "For example, to make the @t{rm} command first complete only names of object files and then the names of all files if there is no matching object file:"
msgstr "例如，要使 @t{rm} 命令首先只补全对象文件的名称，然后在没有匹配的对象文件时补全所有文件的名称："

#. type: example
#: zsh.texi:22283
#, no-wrap
msgid ""
"zstyle ':completion:*:*:rm:*:*' file-patterns \\ \n"
"    '*.o:object-files' '%p:all-files'\n"
msgstr ""
"zstyle ':completion:*:*:rm:*:*' file-patterns \\ \n"
"    '*.o:object-files' '%p:all-files'\n"

#. type: table
#: zsh.texi:22290
msgid ""
"To alter the default behaviour of file completion --- offer files matching a pattern and directories on the first attempt, then all files --- to offer only matching files on the first attempt, then "
"directories, and finally all files:"
msgstr "改变文件补全的默认行为 --- 第一次尝试时，提供与模式和目录匹配的文件，然后提供所有文件 --- 改为第一次尝试时，只提供匹配的文件，然后提供目录，最后提供所有文件："

#. type: example
#: zsh.texi:22295
#, no-wrap
msgid ""
"zstyle ':completion:*' file-patterns \\ \n"
"    '%p:globbed-files' '*(-/):directories' '*:all-files'\n"
msgstr ""
"zstyle ':completion:*' file-patterns \\ \n"
"    '%p:globbed-files' '*(-/):directories' '*:all-files'\n"

#. type: table
#: zsh.texi:22302
msgid ""
"This works even where there is no special pattern: @t{_files} matches all files using the pattern `@t{*}' at the first step and stops when it sees this pattern.  Note also it will never try a pattern more "
"than once for a single completion attempt."
msgstr "即使在没有特殊模式的情况下，也能正常工作： @t{_files} 第一步会匹配所有使用 `@t{*}' 模式的文件，并在看到该模式时停止。 还要注意的是，它不会在一次补全尝试中多次尝试一个模式。"

#. type: table
#: zsh.texi:22309
msgid ""
"To separate directories into a separate group from the files but still complete them at the first attempt, a description needs to be given.  Note that directories need to be explicitly excluded from the "
"globbed-files because `@t{*}' will match directories. For grouping, it is also necessary to set the @t{group-name} style."
msgstr "若要将目录与文件分隔成一组，但仍能在第一次尝试时补全，则需要给出说明。 请注意，目录需要明确地从 globbed-files 中排除，因为 `@t{*}' 将匹配目录。对于分组，还需要设置 @t{group-name} 样式。"

#. type: example
#: zsh.texi:22314
#, no-wrap
msgid ""
"zstyle ':completion:*' file-patterns \\ \n"
"    '%p(^-/):globbed-files *(-/):directories:location'\n"
msgstr ""
"zstyle ':completion:*' file-patterns \\ \n"
"    '%p(^-/):globbed-files *(-/):directories:location'\n"

#. type: table
#: zsh.texi:22320
msgid "During the execution of completion functions, the @t{EXTENDED_GLOB} option is in effect, so the characters `@t{#}', `@t{~}' and `@t{^}' have special meanings in the patterns."
msgstr "在执行补全函数期间，@t{EXTENDED_GLOB} 选项有效，因此字符 `@t{#}', `@t{~}' 和 `@t{^}' 在模式中具有特殊含义。"

#. type: kindex
#: zsh.texi:22321
#, no-wrap
msgid "file-sort, completion style"
msgstr "file-sort, 补全样式"

#. type: t{#1}
#: zsh.texi:22322
#, no-wrap
msgid "file-sort"
msgstr "file-sort"

#. type: table
#: zsh.texi:22337
msgid ""
"The standard filename completion function uses this style without a tag to determine in which order the names should be listed; menu completion will cycle through them in the same order.  The possible "
"values are: `@t{size}' to sort by the size of the file; `@t{links}' to sort by the number of links to the file; `@t{modification}' (or `@t{time}' or `@t{date}') to sort by the last modification time; "
"`@t{access}' to sort by the last access time; and `@t{inode}' (or `@t{change}') to sort by the last inode change time.  If the style is set to any other value, or is unset, files will be sorted "
"alphabetically by name.  If the value contains the string `@t{reverse}', sorting is done in the opposite order.  If the value contains the string `@t{follow}', timestamps are associated with the targets "
"of symbolic links; the default is to use the timestamps of the links themselves."
msgstr ""
"标准文件名补全函数使用这种不带标记的样式来确定名称的排列顺序；菜单补全将以相同的顺序循环显示这些名称。 可能的值有: `@t{size}',按文件大小排序；`@t{links}' , 按文件链接数排序；`@t{modification}'（或 "
"`@t{time}' 或 `@t{date}'）,按最后修改时间排序；`@t{access}' ,按最后访问时间排序；`@t{inode}'（或 `@t{change}'）,按最后 inode 更改时间排序。 如果样式被设置为其他值或未设置，文件将按名称的字母顺序排序。 如果"
"值包含字符串 `@t{reverse}'，则按相反顺序排序。 如果值包含字符串 `@t{follow}'，时间戳将与符号链接的目标相关联；默认情况下使用链接本身的时间戳。"

#. type: kindex
#: zsh.texi:22338
#, no-wrap
msgid "file-split-chars, completion style"
msgstr "file-split-chars, 补全样式"

#. type: t{#1}
#: zsh.texi:22339
#, no-wrap
msgid "file-split-chars"
msgstr "file-split-chars"

#. type: table
#: zsh.texi:22347
msgid ""
"A set of characters that will cause @emph{all} file completions for the given context to be split at the point where any of the characters occurs.  A typical use is to set the style to @t{:}; then "
"everything up to and including the last @t{:} in the string so far is ignored when completing files.  As this is quite heavy-handed, it is usually preferable to update completion functions for contexts "
"where this behaviour is useful."
msgstr ""
"一组字符，会导致 @emph{所有} 文件补全在出现其中任何一个字符时被分割。 典型的用法是将样式设置为 @t{:}；这样，在补全文件时，字符串中直到最后一个 @t{:} 在内的所有内容都将被忽略。 由于这种做法比较粗暴，通常最"
"好是更新补全函数，以适应这种有用的行为。"

#. type: kindex
#: zsh.texi:22348
#, no-wrap
msgid "filter, completion style"
msgstr "filter, 补全样式"

#. type: t{#1}
#: zsh.texi:22349
#, no-wrap
msgid "filter"
msgstr "filter"

#. type: table
#: zsh.texi:22357
msgid ""
"The @t{ldap} plugin of email address completion (see @t{_email_addresses}) uses this style to specify the attributes to match against when filtering entries.  So for example, if the style is set to "
"`@t{sn}', matching is done against surnames.  Standard LDAP filtering is used so normal completion matching is bypassed.  If this style is not set, the LDAP plugin is skipped.  You may also need to set "
"the @t{command} style to specify how to connect to your LDAP server."
msgstr ""
"电子邮件地址补全的 @t{ldap} 插件（请参阅 @t{_email_addresses}）在过滤条目时使用该样式指定匹配的属性。 例如，如果样式设置为 `@t{sn}'，则会根据姓氏进行匹配。 将使用标准 LDAP 过滤，因此绕过了正常的补全匹配。 "
"如果未设置此样式，则会跳过 LDAP 插件。 您可能还需要设置 @t{command} 样式，以指定如何连接到 LDAP 服务器。"

#. type: kindex
#: zsh.texi:22358
#, no-wrap
msgid "force-list, completion style"
msgstr "force-list, 补全样式"

#. type: t{#1}
#: zsh.texi:22359
#, no-wrap
msgid "force-list"
msgstr "force-list"

#. type: table
#: zsh.texi:22369
msgid ""
"This forces a list of completions to be shown at any point where listing is done, even in cases where the list would usually be suppressed.  For example, normally the list is only shown if there are at "
"least two different matches.  By setting this style to `@t{always}', the list will always be shown, even if there is only a single match that will immediately be accepted.  The style may also be set to a "
"number.  In this case the list will be shown if there are at least that many matches, even if they would all insert the same string."
msgstr ""
"这将强制在进行列表时显示补全列表，即使在通常不显示补全列表的情况下也是如此。 例如，通常只有在至少有两个不同的匹配项时才会显示列表。 将该样式设置为 `@t{always}' 后，列表将始终显示，即使只有一个匹配项会立即"
"被接受。 样式也可以设置为数字。 在这种情况下，如果至少有这么多匹配项，即使所有匹配项都插入相同的字符串，列表也会显示。"

#. type: table
#: zsh.texi:22374
msgid "This style is tested for the default tag as well as for each tag valid for the current completion.  Hence the listing can be forced only for certain types of match."
msgstr "该样式针对默认标记以及当前补全时有效的每个标签进行测试。 因此，可以只对某些类型的匹配强制应用列表。"

#. type: kindex
#: zsh.texi:22375
#, no-wrap
msgid "format, completion style"
msgstr "format, 补全样式"

#. type: t{#1}
#: zsh.texi:22376
#, no-wrap
msgid "format"
msgstr "format"

#. type: table
#: zsh.texi:22384
msgid ""
"If this is set for the @t{descriptions} tag, its value is used as a string to display above matches in completion lists.  The sequence `@t{%d}' in this string will be replaced with a short description of "
"what these matches are.  This string may also contain the output attribute sequences understood by @t{compadd -X} (see @ref{Completion Widgets})."
msgstr ""
"如果为 @t{descriptions} 标记设置了此项，其值将作为字符串在补全列表中显示以上匹配项。 该字符串中的 `@t{%d}' 序列将被替换为这些匹配项的简短描述。 该字符串还可能包含 @t{compadd -X} 所理解的输出属性序列（参见 "
"@ref{补全小部件}）。"

#. type: table
#: zsh.texi:22389
msgid "The style is tested with each tag valid for the current completion before it is tested for the @t{descriptions} tag.  Hence different format strings can be defined for different types of match."
msgstr "在对 @t{descriptions} 标记进行测试之前，会对当前补全时有效的每个标记进行样式测试。 因此，可以为不同类型的匹配定义不同的格式字符串。"

#. type: table
#: zsh.texi:22394
msgid "Note also that some completer functions define additional `@t{%}'-sequences.  These are described for the completer functions that make use of them."
msgstr "还要注意的是，某些补全函数定义了额外的 `@t{%}' 序列。 我们将对使用这些序列的补全函数进行说明。"

#. type: table
#: zsh.texi:22399
msgid "Some completion functions display messages that may be customised by setting this style for the @t{messages} tag.  Here, the `@t{%d}' is replaced with a message given by the completion function."
msgstr "某些补全函数显示的信息可以通过为 @t{messages} 标记设置这种样式来定制。 在这里，`@t{%d}' 会被替换为补全函数给出的信息。"

#. type: table
#: zsh.texi:22406
msgid ""
"Finally, the format string is looked up with the @t{warnings} tag, for use when no matches could be generated at all.  In this case the `@t{%d}' is replaced with the descriptions for the matches that were "
"expected separated by spaces.  The sequence `@t{%D}' is replaced with the same descriptions separated by newlines."
msgstr "最后，使用 @t{warnings} 标记查找格式字符串，以便在完全无法生成匹配结果时使用。 在这种情况下，`@t{%d}' 会被替换为预期匹配的描述，并用空格分隔。 序列 `@t{%D}' 会被替换为同样的描述，并用换行符隔开。"

#. type: table
#: zsh.texi:22412
msgid ""
"It is possible to use printf-style field width specifiers with `@t{%d}' and similar escape sequences.  This is handled by the @t{zformat} builtin command from the @t{zsh/zutil} module, see @ref{The zsh/"
"zutil Module}."
msgstr "可以使用printf 风格的字段宽度指定符 `@t{%d}' 和类似的转义序列。 这由 @t{zsh/zutil} 模块中的 @t{zformat} 内置命令处理，参见 @ref{zsh/zutil 模块}。"

#. type: kindex
#: zsh.texi:22413
#, no-wrap
msgid "gain-privileges, completion style"
msgstr "gain-privileges, 补全样式"

#. type: t{#1}
#: zsh.texi:22414
#, no-wrap
msgid "gain-privileges"
msgstr "gain-privileges"

#. type: table
#: zsh.texi:22421
msgid ""
"If set to @t{true}, this style enables the use of commands like @t{sudo} or @t{doas} to gain extra privileges when retrieving information for completion. This is only done when a command such as @t{sudo} "
"appears on the command-line. To force the use of, e.g. @t{sudo} or to override any prefix that might be added due to @t{gain-privileges}, the @t{command} style can be used with a value that begins with a "
"hyphen."
msgstr ""
"如果设置为 @t{true}，该样式将允许使用 @t{sudo} 或 @t{doas} 等命令来获取额外权限，以检索补全信息。只有当 @t{sudo} 等命令出现在命令行中时，才会这样做。要强制使用 @t{sudo} 等命令，或覆盖因 @t{gain-"
"privileges} 而可能添加的任何前缀，可以使用 @t{command} 样式和以连字符开头的值。"

#. type: kindex
#: zsh.texi:22422
#, no-wrap
msgid "glob, completion style"
msgstr "glob, 补全样式"

#. type: t{#1}
#: zsh.texi:22423
#, no-wrap
msgid "glob"
msgstr "glob"

#. type: table
#: zsh.texi:22428
msgid ""
"This is used by the @t{_expand} completer.  If it is set to `true' (the default), globbing will be attempted on the words resulting from a previous substitution (see the @t{substitute} style) or else the "
"original string from the line."
msgstr "由 @t{_expand} 补全器使用。 如果将其设置为 `true' （默认值），则将尝试对之前替换（参见 @t{substitute} 样式）后的字词进行 globbing，否则将使用该行的原始字符串。"

#. type: kindex
#: zsh.texi:22429
#, no-wrap
msgid "global, completion style"
msgstr "global, 补全样式"

#. type: t{#1}
#: zsh.texi:22430
#, no-wrap
msgid "global"
msgstr "global"

#. type: table
#: zsh.texi:22433
msgid "If this is set to `true' (the default), the @t{_expand_alias} completer and bindable command will try to expand global aliases."
msgstr "如果设置为 `true' （默认），@t{_expand_alias} 补全器和可绑定命令将尝试扩展全局别名。"

#. type: kindex
#: zsh.texi:22434
#, no-wrap
msgid "group-name, completion style"
msgstr "group-name, 补全样式"

#. type: t{#1}
#: zsh.texi:22435
#, no-wrap
msgid "group-name"
msgstr "group-name"

#. type: table
#: zsh.texi:22443
msgid ""
"The completion system can group different types of matches, which appear in separate lists.  This style can be used to give the names of groups for particular tags.  For example, in command position the "
"completion system generates names of builtin and external commands, names of aliases, shell functions and parameters and reserved words as possible completions.  To have the external commands and shell "
"functions listed separately:"
msgstr ""
"补全系统可以将不同类型的匹配分组，分别出现在不同的列表中。 这种样式可用于为特定标记提供分组名称。 例如，在命令位置，补全系统会生成内置和外部命令名称、别名、shell 函数和参数以及保留字作为可能的补全。 若要单"
"独列出外部命令和 shell 函数，可使用以下方法："

#. type: example
#: zsh.texi:22450
#, no-wrap
msgid ""
"zstyle ':completion:*:*:-command-:*:commands' \\ \n"
"       group-name commands\n"
"zstyle ':completion:*:*:-command-:*:functions' \\ \n"
"       group-name functions\n"
msgstr ""
"zstyle ':completion:*:*:-command-:*:commands' \\ \n"
"       group-name commands\n"
"zstyle ':completion:*:*:-command-:*:functions' \\ \n"
"       group-name functions\n"

#. type: table
#: zsh.texi:22455
msgid "As a consequence, any match with the same tag will be displayed in the same group."
msgstr "因此，任何具有相同标记的匹配都会显示在同一组中。"

#. type: table
#: zsh.texi:22460
msgid "If the name given is the empty string the name of the tag for the matches will be used as the name of the group.  So, to have all different types of matches displayed separately, one can just set:"
msgstr "如果给定的名称是空字符串，匹配标记的名称将被用作组的名称。 因此，要分别显示所有不同类型的匹配信息，只需设置"

#. type: example
#: zsh.texi:22464
#, no-wrap
msgid "zstyle ':completion:*' group-name @value{dsq}\n"
msgstr "zstyle ':completion:*' group-name @value{dsq}\n"

#. type: table
#: zsh.texi:22469
msgid "All matches for which no group name is defined will be put in a group named @t{-default-}."
msgstr "所有未定义组名的匹配结果都将被归入名为 @t{-default-} 的组中。"

#. type: table
#: zsh.texi:22473
msgid "To display the group name in the output, see the @t{format} style (q.v.)  under the @t{descriptions} tag."
msgstr "要在输出中显示组名，请参阅 @t{descriptions} 标记下的 @t{format} 样式（q.v. ）。"

#. type: kindex
#: zsh.texi:22474
#, no-wrap
msgid "group-order, completion style"
msgstr "group-order, 补全样式"

#. type: t{#1}
#: zsh.texi:22475
#, no-wrap
msgid "group-order"
msgstr "group-order"

#. type: table
#: zsh.texi:22481
msgid ""
"This style is additional to the @t{group-name} style to specify the order for display of the groups defined by that style (compare @t{tag-order}, which determines which completions appear at all).  The "
"groups named are shown in the given order; any other groups are shown in the order defined by the completion function."
msgstr "该样式是 @t{group-name} 样式的附加样式，用于指定该样式所定义的组的显示顺序（比较 @t{tag-order}，它决定显示哪些补全）。 已命名的组按指定顺序显示；其他任何组则按补全函数定义的顺序显示。"

#. type: table
#: zsh.texi:22486
msgid "For example, to have names of builtin commands, shell functions and external commands appear in that order when completing in command position:"
msgstr "例如，让内置命令、shell 函数和外部命令的名称在命令位置补全时按顺序显示："

#. type: example
#: zsh.texi:22491
#, no-wrap
msgid ""
"zstyle ':completion:*:*:-command-:*:*' group-order \\ \n"
"       builtins functions commands\n"
msgstr ""
"zstyle ':completion:*:*:-command-:*:*' group-order \\ \n"
"       builtins functions commands\n"

#. type: kindex
#: zsh.texi:22493
#, no-wrap
msgid "groups, completion style"
msgstr "groups, 补全样式"

#. type: table
#: zsh.texi:22497
msgid "A list of names of UNIX groups.  If this is not set, group names are taken from the YP database or the file `@t{/etc/group}'."
msgstr "UNIX 组名称列表。 如果未设置，则组名取自 YP 数据库或文件 `@t{/etc/group}'。"

#. type: kindex
#: zsh.texi:22498
#, no-wrap
msgid "hidden, completion style"
msgstr "hidden, 补全样式"

#. type: t{#1}
#: zsh.texi:22499
#, no-wrap
msgid "hidden"
msgstr "hidden"

#. type: table
#: zsh.texi:22505
msgid ""
"If this is set to `true', matches for the given context will not be listed, although any description for the matches set with the @t{format} style will be shown.  If it is set to `@t{all}', not even the "
"description will be displayed."
msgstr "如果设置为 `true'，则不会列出给定上下文的匹配项，但会显示使用 @t{format} 样式设置的匹配项的描述。 如果设置为 `@t{all}'，则连描述也不会显示。"

#. type: table
#: zsh.texi:22511
msgid ""
"Note that the matches will still be completed; they are just not shown in the list.  To avoid having matches considered as possible completions at all, the @t{tag-order} style can be modified as described "
"below."
msgstr "请注意，这些匹配项仍然会被补全，只是不会显示在列表中。 为了避免将匹配项视为可能的补全项，可以按下文所述修改 @t{tag-order} 样式。"

#. type: kindex
#: zsh.texi:22512
#, no-wrap
msgid "hosts, completion style"
msgstr "hosts, 补全样式"

#. type: table
#: zsh.texi:22516
msgid "A list of names of hosts that should be completed.  If this is not set, hostnames are taken from the file `@t{/etc/hosts}'."
msgstr "应补全的主机名列表。 如果未设置，主机名将取自文件 `@t{/etc/hosts}'。"

#. type: kindex
#: zsh.texi:22517
#, no-wrap
msgid "hosts-ports, completion style"
msgstr "hosts-ports, 补全样式"

#. type: t{#1}
#: zsh.texi:22518
#, no-wrap
msgid "hosts-ports"
msgstr "hosts-ports"

#. type: table
#: zsh.texi:22523
msgid ""
"This style is used by commands that need or accept hostnames and network ports.  The strings in the value should be of the form `@var{host}@t{:}@var{port}'.  Valid ports are determined by the presence of "
"hostnames; multiple ports for the same host may appear."
msgstr "这种样式适用于需要或接受主机名和网络端口的命令。 值中的字符串格式应为 `@var{host}@t{:}@var{port}'。 有效端口由主机名决定；同一主机可能有多个端口。"

#. type: kindex
#: zsh.texi:22524
#, no-wrap
msgid "ignore-line, completion style"
msgstr "ignore-line, 补全样式"

#. type: t{#1}
#: zsh.texi:22525
#, no-wrap
msgid "ignore-line"
msgstr "ignore-line"

#. type: table
#: zsh.texi:22534
msgid ""
"This is tested for each tag valid for the current completion.  If it is set to `true', none of the words that are already on the line will be considered as possible completions.  If it is set to "
"`@t{current}', the word the cursor is on will not be considered as a possible completion.  The value `@t{current-shown}' is similar but only applies if the list of completions is currently shown on the "
"screen.  Finally, if the style is set to `@t{other}', all words on the line except for the current one will be excluded from the possible completions."
msgstr ""
"这将为当前补全有效的每个标记进行测试。 如果设置为 `true'，则该行中已经存在的单词都不会被视为可能的补全。 如果设置为 `@t{current}'，光标所在的单词将不被视为可能的补全。 值 `@t{current-shown}' 与之类似，但只"
"适用于当前屏幕上显示补全列表的情况。 最后，如果样式设置为 `@t{other}'，则该行中除当前单词外的所有单词都将被排除在可能的补全之外。"

#. type: table
#: zsh.texi:22539
msgid "The values `@t{current}' and `@t{current-shown}' are a bit like the opposite of the @t{accept-exact} style: only strings with missing characters will be completed."
msgstr " `@t{current}' 和 `@t{current-shown}' 有点像 @t{accept-exact} 样式的反义词：只有字符缺失的字符串才会被补全。"

#. type: table
#: zsh.texi:22546
msgid ""
"Note that you almost certainly don't want to set this to `true' or `@t{other}' for a general context such as `@t{:completion:*}'.  This is because it would disallow completion of, for example, options "
"multiple times even if the command in question accepts the option more than once."
msgstr "需要注意的是，在一般情况下，比如 `@t{:completion:*}' ，你几乎肯定不想将其设置为 `true' 或 `@t{other}' 。 这是因为，即使相关命令不止一次接受选项，它也会禁止多次补全选项。"

#. type: kindex
#: zsh.texi:22547
#, no-wrap
msgid "ignore-parents, completion style"
msgstr "ignore-parents, 补全样式"

#. type: t{#1}
#: zsh.texi:22548
#, no-wrap
msgid "ignore-parents"
msgstr "ignore-parents"

#. type: table
#: zsh.texi:22554
msgid ""
"The style is tested without a tag by the function completing pathnames in order to determine whether to ignore the names of directories already mentioned in the current word, or the name of the current "
"working directory.  The value must include one or both of the following strings:"
msgstr "补全路径名的函数会在没有标记的情况下对样式进行测试，以确定是忽略当前单词中已提及的目录名，还是忽略当前工作目录名。 该值必须包括以下字符串中的一个或两个："

#. type: t{#1}
#: zsh.texi:22557 zsh.texi:36195
#, no-wrap
msgid "parent"
msgstr "parent"

#. type: table
#: zsh.texi:22561
msgid ""
"The name of any directory whose path is already contained in the word on the line is ignored.  For example, when completing after @t{foo/../}, the directory @t{foo} will not be considered a valid "
"completion."
msgstr "如果该行中的单词已包含任何目录的路径，则该目录的名称将被忽略。 例如，在 @t{foo/../} 之后补全时，目录 @t{foo} 将不被视为有效的补全。"

#. type: table
#: zsh.texi:22566
msgid "The name of the current working directory will not be completed; hence, for example, completion after @t{../} will not use the name of the current directory."
msgstr "当前工作目录的名称不会被补全；因此，例如，在 @t{../} 之后补全将不会使用当前目录的名称。"

#. type: table
#: zsh.texi:22571
msgid "In addition, the value may include one or both of:"
msgstr "此外，该值还可包括以下一项或两项："

#. type: t{#1}
#: zsh.texi:22574
#, no-wrap
msgid ".."
msgstr ".."

#. type: table
#: zsh.texi:22577
msgid "Ignore the specified directories only when the word on the line contains the substring `@t{../}'."
msgstr "仅当一行中的单词包含子字符串 `@t{../}' 时，才忽略指定目录。"

#. type: t{#1}
#: zsh.texi:22578
#, no-wrap
msgid "directory"
msgstr "directory"

#. type: table
#: zsh.texi:22581
msgid "Ignore the specified directories only when names of directories are completed, not when completing names of files."
msgstr "仅在补全目录名时忽略指定目录，而不在补全文件名时忽略指定目录。"

#. type: table
#: zsh.texi:22588
msgid "Excluded values act in a similar fashion to values of the @t{ignored-patterns} style, so they can be restored to consideration by the @t{_ignored} completer."
msgstr "排除值的作用方式与 @t{ignored-patterns} 样式的值类似，因此可以通过 @t{_ignored} 补全器恢复对它们的考虑。"

#. type: kindex
#: zsh.texi:22589
#, no-wrap
msgid "ignored-patterns, completion style"
msgstr "ignored-patterns, 补全样式"

#. type: t{#1}
#: zsh.texi:22590
#, no-wrap
msgid "ignored-patterns"
msgstr "ignored-patterns"

#. type: table
#: zsh.texi:22596
msgid ""
"A list of patterns; any trial completion matching one of the patterns will be excluded from consideration.  The @t{_ignored} completer can appear in the list of completers to restore the ignored matches.  "
"This is a more configurable version of the shell parameter @t{$fignore}."
msgstr "模式列表；任何与其中一个模式匹配的试验补全都将被排除在外。 @t{_ignored} 补全器可以出现在补全器列表中，以恢复被忽略的匹配。 这是 shell 参数 @t{$fignore} 的可配置版本。"

#. type: table
#: zsh.texi:22602
msgid "Note that the @t{EXTENDED_GLOB} option is set during the execution of completion functions, so the characters `@t{#}', `@t{~}' and `@t{^}' have special meanings in the patterns."
msgstr "请注意，@t{EXTENDED_GLOB} 选项是在执行补全函数期间设置的，因此字符 `@t{#}', `@t{~}' 和 `@t{^}' 在模式中具有特殊含义。"

#. type: kindex
#: zsh.texi:22603
#, no-wrap
msgid "insert, completion style"
msgstr "insert, 补全样式"

#. type: table
#: zsh.texi:22608
msgid "This style is used by the @t{_all_matches} completer to decide whether to insert the list of all matches unconditionally instead of adding the list as another match."
msgstr "@t{_all_matches} 补全器使用这种样式来决定是否无条件插入所有匹配项的列表，而不是将列表作为另一个匹配项添加。"

#. type: kindex
#: zsh.texi:22609
#, no-wrap
msgid "insert-ids, completion style"
msgstr "insert-ids, 补全样式"

#. type: t{#1}
#: zsh.texi:22610
#, no-wrap
msgid "insert-ids"
msgstr "insert-ids"

#. type: table
#: zsh.texi:22618
msgid ""
"When completing process IDs, for example as arguments to the @t{kill} and @t{wait} builtins the name of a command may be converted to the appropriate process ID.  A problem arises when the process name "
"typed is not unique.  By default (or if this style is set explicitly to `@t{menu}') the name will be converted immediately to a set of possible IDs, and menu completion will be started to cycle through "
"them."
msgstr ""
"在填写进程 ID 时，例如作为 @t{kill} 和 @t{wait} 内置程序的参数，命令名称可能会被转换为相应的进程 ID。 如果键入的进程名称不是唯一的，就会出现问题。 默认情况下（或将此样式显式设置为 `@t{menu}'），名称会立即"
"转换为一组可能的 ID，并启动菜单补全以循环浏览这些 ID。"

#. type: table
#: zsh.texi:22626
msgid ""
"If the value of the style is `@t{single}', the shell will wait until the user has typed enough to make the command unique before converting the name to an ID; attempts at completion will be unsuccessful "
"until that point.  If the value is any other string, menu completion will be started when the string typed by the user is longer than the common prefix to the corresponding IDs."
msgstr ""
"如果样式的值为`@t{single}'，shell 将等待用户键入足够多的字符，使命令具有唯一性后才将名称转换为 ID；在此之前，补全尝试将不会成功。 如果值是任何其他字符串，当用户键入的字符串长于相应 ID 的通用前缀时，将启动"
"菜单补全。"

#. type: kindex
#: zsh.texi:22627
#, no-wrap
msgid "insert-sections, completion style"
msgstr "insert-sections, 补全样式"

#. type: t{#1}
#: zsh.texi:22628
#, no-wrap
msgid "insert-sections"
msgstr "insert-sections"

#. type: table
#: zsh.texi:22633
msgid ""
"This style is used with tags of the form `@t{manuals.}@var{X}' when completing names of manual pages. If set and the @var{X} in the tag name matches the section number of the page being completed, the "
"section number is inserted along with the page name. For example, given"
msgstr "在补全手册页面名称时，该样式与格式为 `@t{manuals.}@var{X}' 的标记一起使用。如果设置了该样式，且标签名称中的 @var{X} 与所补全页面的章节编号一致，则章节编号将与页面名称一起插入。例如，"

#. type: example
#: zsh.texi:22637
#, no-wrap
msgid "zstyle ':completion:*:manuals.*' insert-sections true\n"
msgstr "zstyle ':completion:*:manuals.*' insert-sections true\n"

#. type: table
#: zsh.texi:22641
msgid "@t{man ssh_<TAB>} may be completed to @t{man 5 ssh_config}."
msgstr "@t{man ssh_<TAB>} 可被补全为 @t{man 5 ssh_config}。"

#. type: table
#: zsh.texi:22646
msgid ""
"The value may also be set to one of `@t{prepend}', or `@t{suffix}'.  `@t{prepend}' behaves the same as `true' as in the above example, while `@t{suffix}' would complete @t{man ssh_<TAB>} as @t{man "
"ssh_config.5}."
msgstr "该值也可以设置为 `@t{prepend}' 或 `@t{suffix}' 之一。 在上例中，`@t{prepend}' 的行为与 `true' 相同，而 `@t{suffix}' 则会将 @t{man ssh_<TAB>} 补全为 @t{man ssh_config.5}。"

#. type: table
#: zsh.texi:22652
msgid ""
"This is especially useful in conjunction with @t{separate-sections}, as it ensures that the page requested of @t{man} corresponds to the one displayed in the completion listing when there are multiple "
"pages with the same name (e.g., @t{printf(1)} and @t{printf(3)})."
msgstr "这一点与 @t{separate-sections} 配合使用尤其有用，因为它可以确保在有多个同名页面时（例如 @t{printf(1)} 和 @t{printf(3)}），@t{man} 请求的页面与补全列表中显示的页面一致。"

#. type: table
#: zsh.texi:22655 zsh.texi:23405 zsh.texi:23508
msgid "The default for this style is `false'."
msgstr "该样式的默认值为 `false'。"

#. type: kindex
#: zsh.texi:22656 zsh.texi:41241
#, no-wrap
msgid "insert-tab, completion style"
msgstr "insert-tab, 补全样式"

#. type: t{#1}
#: zsh.texi:22657 zsh.texi:41242
#, no-wrap
msgid "insert-tab"
msgstr "insert-tab"

#. type: table
#: zsh.texi:22662
msgid ""
"If this is set to `true', the completion system will insert a TAB character (assuming that was used to start completion) instead of performing completion when there is no non-blank character to the left "
"of the cursor.  If it is set to `false', completion will be done even there."
msgstr "如果设置为 `true'，当光标左侧没有非空白字符时，补全系统将插入一个 TAB 字符（假设该字符用于开始补全），而不是执行补全。 如果设置为 `false'，即使在这种情况下也会执行补全。"

#. type: table
#: zsh.texi:22673
msgid ""
"The value may also contain the substrings `@t{pending}' or `@t{pending=}@var{val}'.  In this case, the typed character will be inserted instead of starting completion when there is unprocessed input "
"pending.  If a @var{val} is given, completion will not be done if there are at least that many characters of unprocessed input.  This is often useful when pasting characters into a terminal.  Note "
"however, that it relies on the @t{$PENDING} special parameter from the @t{zsh/zle} module being set properly which is not guaranteed on all platforms."
msgstr ""
"值也可能包含子串 `@t{pending}' 或 `@t{pending=}@var{val}'。 在这种情况下，当有未处理的输入待处理时，将插入键入的字符，而不是开始补全。 如果给定了 @var{val}，那么如果至少有这么多字符的未处理输入，就不会补"
"全。 这在向终端粘贴字符时非常有用。 但需要注意的是，它依赖于 @t{zsh/zle} 模块中的 @t{$PENDING} 特殊参数的正确设置，而这并非在所有平台上都能保证。"

#. type: table
#: zsh.texi:22677
msgid "The default value of this style is `true' except for completion within @t{vared} builtin command where it is `false'."
msgstr "该样式的默认值为 `true' ，但在 @t{vared} 内置命令中补全时为 `false'。"

#. type: kindex
#: zsh.texi:22678
#, no-wrap
msgid "insert-unambiguous, completion style"
msgstr "insert-unambiguous, 补全样式"

#. type: t{#1}
#: zsh.texi:22679
#, no-wrap
msgid "insert-unambiguous"
msgstr "insert-unambiguous"

#. type: table
#: zsh.texi:22686
msgid ""
"This is used by the @t{_match} and @t{_approximate} completers.  These completers are often used with menu completion since the word typed may bear little resemblance to the final completion.  However, if "
"this style is `true', the completer will start menu completion only if it could find no unambiguous initial string at least as long as the original string typed by the user."
msgstr ""
"这被 @t{_match} 和 @t{_approximate} 补全器使用。 这些补全器通常与菜单补全一起使用，因为键入的单词可能与最终的补全几乎没有相似之处。 但是，如果该样式为 `true'，则补全器只有在找不到至少与用户键入的原始字符串"
"一样长的明确初始字符串时，才会启动菜单补全。"

#. type: table
#: zsh.texi:22692
msgid ""
"In the case of the @t{_approximate} completer, the completer field in the context will already have been set to one of @t{correct-}@var{num} or @t{approximate-}@var{num}, where @var{num} is the number of "
"errors that were accepted."
msgstr "如果使用 @t{_approximate} 补全器，上下文中的补全器字段将被设置为 @t{correct-}@var{num} 或 @t{approximate-}@var{num}，其中 @var{num} 是已接受的错误数。"

#. type: table
#: zsh.texi:22697
msgid "In the case of the @t{_match} completer, the style may also be set to the string `@t{pattern}'.  Then the pattern on the line is left unchanged if it does not match unambiguously."
msgstr "对于 @t{_match} 补全器，样式也可以设置为字符串 `@t{pattern}'。 如果该行上的模式不能明确匹配，则保持不变。"

#. type: kindex
#: zsh.texi:22698
#, no-wrap
msgid "keep-prefix, completion style"
msgstr "keep-prefix, 补全样式"

#. type: t{#1}
#: zsh.texi:22699
#, no-wrap
msgid "keep-prefix"
msgstr "keep-prefix"

#. type: table
#: zsh.texi:22708
msgid ""
"This style is used by the @t{_expand} completer.  If it is `true', the completer will try to keep a prefix containing a tilde or parameter expansion.  Hence, for example, the string `@t{~/f*}' would be "
"expanded to `@t{~/foo}' instead of `@t{/home/user/foo}'.  If the style is set to `@t{changed}' (the default), the prefix will only be left unchanged if there were other changes between the expanded words "
"and the original word from the command line.  Any other value forces the prefix to be expanded unconditionally."
msgstr ""
"该样式由 @t{_expand} 补全器使用。 如果为 `true'，补全器将尝试保留包含转折号(tilde)或参数扩展的前缀。 例如，字符串 `@t{~/f*}' 将扩展为  `@t{~/foo}' ，而不是 `@t{/home/user/foo}'。 如果样式设置为 "
"`@t{changed}' （默认），只有在扩展后的单词与命令行中的原始单词之间有其他变化时，前缀才会保持不变。 任何其他值都会强制无条件扩展前缀。"

#. type: table
#: zsh.texi:22713
msgid ""
"The behaviour of @t{_expand} when this style is `true' is to cause @t{_expand} to give up when a single expansion with the restored prefix is the same as the original; hence any remaining completers may "
"be called."
msgstr "这个样式为 `true' 时，@t{_expand} 的行为是，当恢复的前缀的单个扩展与原始扩展相同时，@t{_expand} 会放弃；因此，可以调用任何剩余的补全器。"

#. type: t{#1}
#: zsh.texi:22714 zsh.texi:22715
#, no-wrap
msgid "known-hosts-files"
msgstr "known-hosts-files"

#. type: table
#: zsh.texi:22720
msgid ""
"This style should contain a list of files to search for host names and (if the @t{use-ip} style is set) IP addresses in a format compatible with ssh @t{known_hosts} files.  If it is not set, the files @t{/"
"etc/ssh/ssh_known_hosts} and @t{~/.ssh/known_hosts} are used."
msgstr ""
"该样式应包含一个文件列表，用于搜索与 ssh @t{known_hosts} 文件格式兼容的主机名和 IP 地址（如果设置了 @t{use-ip} 样式）。 如果未设置，则使用 @t{/etc/ssh/ssh_known_hosts} 和 @t{~/.ssh/known_hosts} 文件。"

#. type: kindex
#: zsh.texi:22721
#, no-wrap
msgid "last-prompt, completion style"
msgstr "last-prompt, 补全样式"

#. type: t{#1}
#: zsh.texi:22722
#, no-wrap
msgid "last-prompt"
msgstr "last-prompt"

#. type: table
#: zsh.texi:22731
msgid ""
"This is a more flexible form of the @t{ALWAYS_LAST_PROMPT} option.  If it is `true', the completion system will try to return the cursor to the previous command line after displaying a completion list.  "
"It is tested for all tags valid for the current completion, then the @t{default} tag.  The cursor will be moved back to the previous line if this style is `true' for all types of match.  Note that unlike "
"the @t{ALWAYS_LAST_PROMPT} option this is independent of the numeric argument."
msgstr ""
"这是 @t{ALWAYS_LAST_PROMPT} 选项的一种更灵活的形式。 如果该选项为 `true'，补全系统将尝试在显示补全列表后将光标返回到前一个命令行。 它会对当前补全有效的所有标记进行测试，然后是 @t{default} 标记。 如果该样式"
"对所有类型的匹配都是 `true' ，光标将被移回上一行。 需要注意的是，与 @t{ALWAYS_LAST_PROMPT} 选项不同，此样式与数字参数无关。"

#. type: kindex
#: zsh.texi:22732
#, no-wrap
msgid "list, completion style"
msgstr "list, 补全样式"

#. type: table
#: zsh.texi:22739
msgid ""
"This style is used by the @t{_history_complete_word} bindable command.  If it is set to `true' it has no effect.  If it is set to `false' matches will not be listed.  This overrides the setting of the "
"options controlling listing behaviour, in particular @t{AUTO_LIST}.  The context always starts with `@t{:completion:history-words}'."
msgstr ""
"该样式由 @t{_history_complete_word} 可绑定命令使用。 如果设置为 `true' ，则没有任何效果。 如果设置为 `false'，则不会列出匹配结果。 这将覆盖控制列表行为的选项设置，尤其是 @t{AUTO_LIST}。 上下文总是以 `@t{:"
"completion:history-words}' 开头。"

#. type: kindex
#: zsh.texi:22740
#, no-wrap
msgid "list-colors, completion style"
msgstr "list-colors, 补全样式"

#. type: t{#1}
#: zsh.texi:22741
#, no-wrap
msgid "list-colors"
msgstr "list-colors"

#. type: table
#: zsh.texi:22746
msgid ""
"If the @t{zsh/complist} module is loaded, this style can be used to set color specifications.  This mechanism replaces the use of the @t{ZLS_COLORS} and @t{ZLS_COLOURS} parameters described in @ref{The "
"zsh/complist Module}, but the syntax is the same."
msgstr "如果已加载 @t{zsh/complist} 模块，则可使用此样式来设置颜色规格。 这种机制取代了 @ref{zsh/complist 模块}中 @t{ZLS_COLORS} 和 @t{ZLS_COLOURS} 参数的使用，但语法相同。"

#. type: table
#: zsh.texi:22753
msgid ""
"If this style is set for the @t{default} tag, the strings in the value are taken as specifications that are to be used everywhere.  If it is set for other tags, the specifications are used only for "
"matches of the type described by the tag.  For this to work best, the @t{group-name} style must be set to an empty string."
msgstr ""
"如果为 @t{default} 标记设置了这种样式，那么值中的字符串将被视为在任何地方都要使用的规范。 如果为其他标记设置了该样式，则仅在该标记描述的匹配类型中使用规范。 为达到最佳效果，必须将 @t{group-name} 样式设置为"
"空字符串。"

#. type: table
#: zsh.texi:22759
msgid ""
"In addition to setting styles for specific tags, it is also possible to use group names specified explicitly by the @t{group-name} tag together with the `@t{(group)}' syntax allowed by the @t{ZLS_COLORS} "
"and @t{ZLS_COLOURS} parameters and simply using the @t{default} tag."
msgstr "除了为特定标记设置样式外，还可以使用 @t{group-name} 标记明确指定的组名，以及 @t{ZLS_COLORS} 和 @t{ZLS_COLOURS} 参数允许的 `@t{(group)}' 语法，并简单地使用 @t{default} 标记。"

#. type: table
#: zsh.texi:22763
msgid "It is possible to use any color specifications already set up for the GNU version of the @t{ls} command:"
msgstr "可以使用已为 GNU 版本 @t{ls} 命令设置的任何颜色规格："

#. type: example
#: zsh.texi:22768
#, no-wrap
msgid ""
"zstyle ':completion:*:default' list-colors \\ \n"
"       $@{(s.:.)LS_COLORS@}\n"
msgstr ""
"zstyle ':completion:*:default' list-colors \\ \n"
"       $@{(s.:.)LS_COLORS@}\n"

#. type: table
#: zsh.texi:22773
msgid "The default colors are the same as for the GNU @t{ls} command and can be obtained by setting the style to an empty string (i.e. @t{@value{dsq}})."
msgstr "默认颜色与 GNU @t{ls} 命令相同，可以通过将样式设置为空字符串（即 @t{@value{dsq}}）来获得。"

#. type: kindex
#: zsh.texi:22774
#, no-wrap
msgid "list-dirs-first, completion style"
msgstr "list-dirs-first, 补全样式"

#. type: t{#1}
#: zsh.texi:22775
#, no-wrap
msgid "list-dirs-first"
msgstr "list-dirs-first"

#. type: table
#: zsh.texi:22780
msgid ""
"This is used by file completion and corresponds to a particular setting of the @t{file-patterns} style.  If set, the default directories to be completed are listed separately from and before completion "
"for other files."
msgstr "文件补全时使用，与 @t{file-patterns} 样式的特定设置相对应。 如果设置了该样式，则要补全的默认目录将与其他文件分开列出，并先于其他文件补全。"

#. type: kindex
#: zsh.texi:22781
#, no-wrap
msgid "list-grouped, completion style"
msgstr "list-grouped, 补全样式"

#. type: t{#1}
#: zsh.texi:22782
#, no-wrap
msgid "list-grouped"
msgstr "list-grouped"

#. type: table
#: zsh.texi:22789
msgid ""
"If this style is `true' (the default), the completion system will try to make certain completion listings more compact by grouping matches.  For example, options for commands that have the same "
"description (shown when the @t{verbose} style is set to `true') will appear as a single entry.  However, menu selection can be used to cycle through all the matches."
msgstr ""
"如果该样式为 `true' （默认），补全系统将尝试通过分组匹配使某些补全列表更紧凑。 例如，具有相同描述的命令选项（在 @t{verbose} 样式设置为 `true' 时显示）将显示为一个条目。 不过，可以使用菜单选择来循环浏览所有"
"匹配项。"

#. type: kindex
#: zsh.texi:22790
#, no-wrap
msgid "list-packed, completion style"
msgstr "list-packed, 补全样式"

#. type: t{#1}
#: zsh.texi:22791
#, no-wrap
msgid "list-packed"
msgstr "list-packed"

#. type: table
#: zsh.texi:22796
msgid ""
"This is tested for each tag valid in the current context as well as the @t{default} tag.  If it is set to `true', the corresponding matches appear in listings as if the @t{LIST_PACKED} option were set.  "
"If it is set to `false', they are listed normally."
msgstr "这将针对当前上下文中有效的每个标记以及 @t{default} 标记进行测试。 如果设置为 `true'，则相应的匹配项会出现在列表中，就像设置了 @t{LIST_PACKED} 选项一样。 如果设置为 `false'，则会正常列出。"

#. type: kindex
#: zsh.texi:22797
#, no-wrap
msgid "list-prompt, completion style"
msgstr "list-prompt, 补全样式"

#. type: t{#1}
#: zsh.texi:22798
#, no-wrap
msgid "list-prompt"
msgstr "list-prompt"

#. type: table
#: zsh.texi:22805
msgid ""
"If this style is set for the @t{default} tag, completion lists that don't fit on the screen can be scrolled (see @ref{The zsh/complist Module}).  The value, if not the empty string, will be displayed "
"after every screenful and the shell will prompt for a key press; if the style is set to the empty string, a default prompt will be used."
msgstr ""
"如果为 @t{default} 标记设置了该样式，则无法在屏幕上显示的补全列表可以滚动显示（参见 @ref{zsh/complist 模块}）。 如果该值不是空字符串，则会在每次刷屏后显示，并且 shell 会提示按键；如果样式设置为空字符串，则"
"会使用默认提示符。"

#. type: table
#: zsh.texi:22823
msgid ""
"The value may contain the escape sequences: `@t{%l}' or `@t{%L}', which will be replaced by the number of the last line displayed and the total number of lines; `@t{%m}' or `@t{%M}', the number of the "
"last match shown and the total number of matches; and `@t{%p}' and `@t{%P}', `@t{Top}' when at the beginning of the list, `@t{Bottom}' when at the end and the position shown as a percentage of the total "
"length otherwise.  In each case the form with the uppercase letter will be replaced by a string of fixed width, padded to the right with spaces, while the lowercase form will be replaced by a variable "
"width string.  As in other prompt strings, the escape sequences `@t{%S}', `@t{%s}', `@t{%B}', `@t{%b}', `@t{%U}', `@t{%u}' for entering and leaving the display modes standout, bold and underline, and "
"`@t{%F}', `@t{%f}', `@t{%K}', `@t{%k}' for changing the foreground background colour, are also available, as is the form `@t{%@{}...@t{%@}}' for enclosing escape sequences which display with zero (or, "
"with a numeric argument, some other) width."
msgstr ""
"该值可能包含转义序列：`@t{%l}' 或 `@t{%L}'，它将被最后显示的行数和总行数取代；`@t{%m}' 或 `@t{%M}'，它将被最后显示的匹配数和总匹配数取代；以及 `@t{%p}' 和 `@t{%P}'，当位于列表开头时为 `@t{Top}' ，位于列表"
"结尾时为 `@t{Bottom}' ，否则将以总长度的百分比显示位置。 在每种情况下，大写字母形式将被固定宽度的字符串替换，并在右侧填充空格，而小写字母形式将被宽度可变的字符串替换。 与其他提示符字符串一样，用于进入和离"
"开显示模式的转义序列 `@t{%S}', `@t{%s}', `@t{%B}', `@t{%b}', `@t{%U}', `@t{%u}' (突出,粗体，下划线)，此外，还有用于改变前景背景颜色的 `@t{%F}', `@t{%f}', `@t{%K}', `@t{%k}' ,和\"@t{%@{}\"形式。用于括起来"
"的 `@t{%@{}...@t{%@}}' 转义序列，其显示宽度为零（或用数字参数表示为其他宽度）。"

#. type: table
#: zsh.texi:22827
msgid "After deleting this prompt the variable @t{LISTPROMPT} should be unset for the removal to take effect."
msgstr "删除此提示符后，应取消设置变量 @t{LISTPROMPT} ,才能生效。"

#. type: kindex
#: zsh.texi:22828
#, no-wrap
msgid "list-rows-first, completion style"
msgstr "list-rows-first, 补全样式"

#. type: t{#1}
#: zsh.texi:22829
#, no-wrap
msgid "list-rows-first"
msgstr "list-rows-first"

#. type: table
#: zsh.texi:22833
msgid "This style is tested in the same way as the @t{list-packed} style and determines whether matches are to be listed in a rows-first fashion as if the @t{LIST_ROWS_FIRST} option were set."
msgstr "该样式的测试方法与 @t{list-packed} 样式相同，并决定是否以行优先的方式列出匹配结果，就像设置了 @t{LIST_ROWS_FIRST} 选项一样。"

#. type: kindex
#: zsh.texi:22834
#, no-wrap
msgid "list-separator, completion style"
msgstr "list-separator, 补全样式"

#. type: t{#1}
#: zsh.texi:22835
#, no-wrap
msgid "list-separator"
msgstr "list-separator"

#. type: table
#: zsh.texi:22839
msgid "The value of this style is used in completion listing to separate the string to complete from a description when possible (e.g. when completing options).  It defaults to `@t{-}@t{-}' (two hyphens)."
msgstr "该样式的值在补全列表中用于在可能的情况下（如补全选项时）分隔要补全的字符串和描述。 默认值为 `@t{-}@t{-}' （两个连字符）。"

#. type: kindex
#: zsh.texi:22840
#, no-wrap
msgid "list-suffixes, completion style"
msgstr "list-suffixes, 补全样式"

#. type: t{#1}
#: zsh.texi:22841
#, no-wrap
msgid "list-suffixes"
msgstr "list-suffixes"

#. type: table
#: zsh.texi:22846
msgid ""
"This style is used by the function that completes filenames.  If it is `true', and completion is attempted on a string containing multiple partially typed pathname components, all ambiguous components "
"will be shown.  Otherwise, completion stops at the first ambiguous component."
msgstr "该样式由补全文件名的函数使用。 如果该样式为 `true'，并且在尝试补全键入的包含多个部分路径名组件的字符串时，将显示所有不明确的组件。 否则，补全将在第一个含糊的部分停止。"

#. type: kindex
#: zsh.texi:22847
#, no-wrap
msgid "local, completion style"
msgstr "local, 补全样式"

#. type: table
#: zsh.texi:22855
msgid ""
"This is for use with functions that complete URLs for which the corresponding files are available directly from the file system.  Its value should consist of three strings: a hostname, the path to the "
"default web pages for the server, and the directory name used by a user placing web pages within their home area."
msgstr "用于补全 URL 的函数，这些 URL 的相应文件可直接从文件系统中获取。 其值应由三个字符串组成：主机名、服务器默认网页的路径，以及用户在其主页区域放置网页时使用的目录名。"

#. type: example
#: zsh.texi:22863
#, no-wrap
msgid ""
"zstyle ':completion:*' local toast \\ \n"
"    /var/http/public/toast public_html\n"
msgstr ""
"zstyle ':completion:*' local toast \\ \n"
"    /var/http/public/toast public_html\n"

#. type: table
#: zsh.texi:22870
msgid ""
"Completion after `@t{http://toast/stuff/}' will look for files in the directory @t{/var/http/public/toast/stuff}, while completion after `@t{http://toast/~yousir/}' will look for files in the directory "
"@t{~yousir/public_html}."
msgstr "在 `@t{http://toast/stuff/}' 后补全将查找 @t{/var/http/public/toast/stuff} 目录中的文件，而在 `@t{http://toast/~yousir/}' 后补全将查找 @t{~yousir/public_html} 目录中的文件。"

#. type: kindex
#: zsh.texi:22871
#, no-wrap
msgid "mail-directory, completion style"
msgstr "mail-directory, 补全样式"

#. type: t{#1}
#: zsh.texi:22872
#, no-wrap
msgid "mail-directory"
msgstr "mail-directory"

#. type: table
#: zsh.texi:22875
msgid "If set, zsh will assume that mailbox files can be found in the directory specified.  It defaults to `@t{~/Mail}'."
msgstr "如果设置了该选项，zsh 会假定邮箱文件在指定的目录中。 默认值为 `@t{~/Mail}'。"

#. type: kindex
#: zsh.texi:22876
#, no-wrap
msgid "match-original, completion style"
msgstr "match-original, 补全样式"

#. type: t{#1}
#: zsh.texi:22877
#, no-wrap
msgid "match-original"
msgstr "match-original"

#. type: table
#: zsh.texi:22885
msgid ""
"This is used by the @t{_match} completer.  If it is set to @t{only}, @t{_match} will try to generate matches without inserting a `@t{*}' at the cursor position.  If set to any other non-empty value, it "
"will first try to generate matches without inserting the `@t{*}' and if that yields no matches, it will try again with the `@t{*}' inserted.  If it is unset or set to the empty string, matching will only "
"be performed with the `@t{*}' inserted."
msgstr ""
"这是 @t{_match} 补全器使用的。 如果设置为 @t{only}，@t{_match} 将尝试生成匹配,但不在光标位置插入 `@t{*}' 。 如果设置为任何其他非空值，它将首先在不插入 `@t{*}' 的情况下尝试生成匹配结果，如果没有匹配结果，它"
"将在插入 `@t{*}' 的情况下再次尝试。 如果未设置或设置为空字符串，则只在插入 `@t{*}' 时执行匹配。"

#. type: kindex
#: zsh.texi:22886
#, no-wrap
msgid "matcher, completion style"
msgstr "匹配器，补全样式"

#. type: t{#1}
#: zsh.texi:22887
#, no-wrap
msgid "matcher"
msgstr "匹配器"

#. type: table
#: zsh.texi:22893
msgid ""
"This style is tested separately for each tag valid in the current context.  Its value is placed before any match specifications given by the @t{matcher-list} style so can override them via the use of an "
"@t{x:} specification.  The value should be in the form described in @ref{Completion Matching Control}.  For examples of this, see the description of the @t{tag-order} style."
msgstr ""
"该样式对当前上下文中有效的每个标记分别进行测试。 它的值被置于 @t{matcher-list} 样式给出的任何匹配规范之前，因此可以通过使用 @t{x:} 规范来覆盖这些规范。 该值应采用 @ref{补全匹配控制} 中描述的形式。 有关示"
"例，请参阅 @t{tag-order} 样式的说明。"

#. type: table
#: zsh.texi:22897
msgid "For notes comparing the use of this and the @t{matcher-list} style, see under the description of the @t{tag-order} style."
msgstr "关于该样式注意与 @t{matcher-list} 样式的使用进行比较，请参阅 @t{tag-order} 样式的说明。"

#. type: kindex
#: zsh.texi:22898
#, no-wrap
msgid "matcher-list, completion style"
msgstr "matcher-list, 补全样式"

#. type: t{#1}
#: zsh.texi:22899
#, no-wrap
msgid "matcher-list"
msgstr "matcher-list"

#. type: table
#: zsh.texi:22906
msgid ""
"This style can be set to a list of match specifications that are to be applied everywhere. Match specifications are described in @ref{Completion Matching Control}.  The completion system will try them one "
"after another for each completer selected.  For example, to try first simple completion and, if that generates no matches, case-insensitive completion:"
msgstr ""
"该样式可设置为匹配规范的列表，这些匹配规范将应用于所有地方。@ref{补全匹配控制} 中描述了匹配规范。 补全系统将针对所选的每个补全器逐一尝试匹配规范。 例如，首先尝试简单补全，如果没有匹配结果，则尝试不区分大小"
"写的补全："

#. type: example
#: zsh.texi:22910
#, no-wrap
msgid "zstyle ':completion:*' matcher-list @value{dsq} 'm:@{a-zA-Z@}=@{A-Za-z@}'\n"
msgstr "zstyle ':completion:*' matcher-list @value{dsq} 'm:@{a-zA-Z@}=@{A-Za-z@}'\n"

#. type: table
#: zsh.texi:22917
msgid ""
"By default each specification replaces the previous one; however, if a specification is prefixed with @t{+}, it is added to the existing list.  Hence it is possible to create increasingly general "
"specifications without repetition:"
msgstr "默认情况下，每一条规范都会取代前一条规范；但是，如果一条规范的前缀是 @t{+}，它就会被添加到现有的列表中。 因此，可以在不重复的情况下创建越来越多的通用规范："

#. type: example
#: zsh.texi:22922
#, no-wrap
msgid ""
"zstyle ':completion:*' matcher-list \\ \n"
"       @value{dsq} '+m:@{a-z@}=@{A-Z@}' '+m:@{A-Z@}=@{a-z@}'\n"
msgstr ""
"zstyle ':completion:*' matcher-list \\ \n"
"       @value{dsq} '+m:@{a-z@}=@{A-Z@}' '+m:@{A-Z@}=@{a-z@}'\n"

#. type: table
#: zsh.texi:22931
msgid ""
"It is possible to create match specifications valid for particular completers by using the third field of the context.  This applies only to completers that override the global matcher-list, which as of "
"this writing includes only @t{_prefix} and @t{_ignored}.  For example, to use the completers @t{_complete} and @t{_prefix} but allow case-insensitive completion only with @t{_complete}:"
msgstr ""
"通过使用上下文的第三个字段，可以创建对特定补全程序有效的匹配规范。 这仅适用于覆盖全局匹配器列表的补全程序，截至本文撰写时，全局匹配器列表仅包括 @t{_prefix} 和 @t{_ignored}。 例如，要使用 @t{_complete} 和 "
"@t{_prefix}，但只允许使用 @t{_complete} 进行大小写不敏感的补全："

#. type: example
#: zsh.texi:22937
#, no-wrap
msgid ""
"zstyle ':completion:*' completer _complete _prefix\n"
"zstyle ':completion:*:complete:*:*:*' matcher-list \\ \n"
"       @value{dsq} 'm:@{a-zA-Z@}=@{A-Za-z@}'\n"
msgstr ""
"zstyle ':completion:*' completer _complete _prefix\n"
"zstyle ':completion:*:complete:*:*:*' matcher-list \\ \n"
"       @value{dsq} 'm:@{a-zA-Z@}=@{A-Za-z@}'\n"

#. type: table
#: zsh.texi:22946
msgid ""
"User-defined names, as explained for the @t{completer} style, are available.  This makes it possible to try the same completer more than once with different match specifications each time.  For example, "
"to try normal completion without a match specification, then normal completion with case-insensitive matching, then correction, and finally partial-word completion:"
msgstr ""
"用户可自定义名称，如 @t{completer} 样式所解释的那样。 这样就可以多次使用同一个补全器，每次使用不同的匹配规范。 例如，先尝试不带匹配规范的正常补全，再尝试带大小写不敏感匹配的正常补全，然后是纠错，最后是部分"
"词补全："

#. type: example
#: zsh.texi:22955
#, no-wrap
msgid ""
"zstyle ':completion:*' completer \\ \n"
"    _complete _correct _complete:foo\n"
"zstyle ':completion:*:complete:*:*:*' matcher-list \\ \n"
"    @value{dsq} 'm:@{a-zA-Z@}=@{A-Za-z@}'\n"
"zstyle ':completion:*:foo:*:*:*' matcher-list \\ \n"
"    'm:@{a-zA-Z@}=@{A-Za-z@} r:|[-_./]=* r:|=*'\n"
msgstr ""
"zstyle ':completion:*' completer \\ \n"
"    _complete _correct _complete:foo\n"
"zstyle ':completion:*:complete:*:*:*' matcher-list \\ \n"
"    @value{dsq} 'm:@{a-zA-Z@}=@{A-Za-z@}'\n"
"zstyle ':completion:*:foo:*:*:*' matcher-list \\ \n"
"    'm:@{a-zA-Z@}=@{A-Za-z@} r:|[-_./]=* r:|=*'\n"

#. type: table
#: zsh.texi:22963
msgid ""
"If the style is unset in any context no match specification is applied.  Note also that some completers such as @t{_correct} and @t{_approximate} do not use the match specifications at all, though these "
"completers will only ever be called once even if the @t{matcher-list} contains more than one element."
msgstr ""
"如果在任何上下文中未设置样式，则不会应用匹配规范。 还需注意的是，某些补全器（如 @t{_correct} 和 @t{_approximate}）根本不使用匹配规范，不过即使 @t{matcher-list} 包含多个元素，这些补全器也只会被调用一次。"

#. type: table
#: zsh.texi:22971
msgid ""
"Where multiple specifications are useful, note that the @emph{entire} completion is done for each element of @t{matcher-list}, which can quickly reduce the shell's performance.  As a rough rule of thumb, "
"one to three strings will give acceptable performance.  On the other hand, putting multiple space-separated values into the same string does not have an appreciable impact on performance."
msgstr ""
"在使用多个规范时，请注意 @emph{整个} 补全过程是针对 @t{matcher-list} 的每个元素进行的，这会迅速降低 shell 的性能。 根据粗略的经验，一到三个字符串就能提供可接受的性能。 另一方面，将多个以空格分隔的值放入同"
"一字符串不会对性能产生明显影响。"

#. type: table
#: zsh.texi:22977
msgid ""
"If there is no current matcher or it is empty, and the option @t{NO_CASE_GLOB} is in effect, the matching for files is performed case-insensitively in any case.  However, any matcher must explicitly "
"specify case-insensitive matching if that is required."
msgstr "如果当前没有匹配器或匹配器为空，且选项 @t{NO_CASE_GLOB} 有效，则在任何情况下都将执行不区分大小写的文件匹配。 不过，如果需要，任何匹配器都必须明确指定大小写不敏感匹配。"

#. type: table
#: zsh.texi:22981
msgid "For notes comparing the use of this and the @t{matcher} style, see under the description of the @t{tag-order} style."
msgstr "关于该样式与 @t{matcher} 样式的使用比较，请参阅 @t{tag-order} 样式的说明。"

#. type: kindex
#: zsh.texi:22982
#, no-wrap
msgid "max-errors, completion style"
msgstr "max-errors, 补全样式"

#. type: t{#1}
#: zsh.texi:22983
#, no-wrap
msgid "max-errors"
msgstr "max-errors"

#. type: table
#: zsh.texi:22989
msgid ""
"This is used by the @t{_approximate} and @t{_correct} completer functions to determine the maximum number of errors to allow.  The completer will try to generate completions by first allowing one error, "
"then two errors, and so on, until either a match or matches were found or the maximum number of errors given by this style has been reached."
msgstr "@t{_approximate} 和 @t{_correct} 补全函数使用它来确定允许的最大错误数。 补全器在生成补全时，会先允许一个错误，然后是两个错误，以此类推，直到找到一个或多个匹配项，或者达到该样式给出的最大错误数。"

#. type: table
#: zsh.texi:22994
msgid "If the value for this style contains the string `@t{numeric}', the completer function will take any numeric argument as the maximum number of errors allowed. For example, with"
msgstr "如果该样式的值包含字符串 `@t{numeric}'，则补全函数会将任何数字参数作为允许的最大错误数。例如"

#. type: example
#: zsh.texi:22998
#, no-wrap
msgid "zstyle ':completion:*:approximate:::' max-errors 2 numeric\n"
msgstr "zstyle ':completion:*:approximate:::' max-errors 2 numeric\n"

#. type: table
#: zsh.texi:23005
msgid ""
"two errors are allowed if no numeric argument is given, but with a numeric argument of six (as in `@t{ESC-6 TAB}'), up to six errors are accepted.  Hence with a value of `@t{0 numeric}', no correcting "
"completion will be attempted unless a numeric argument is given."
msgstr "如果没有给出数值参数，则允许出现两个错误，但如果数值参数为 6（如 `@t{ESC-6 TAB}'），则最多可接受六个错误。 因此，如果值为`@t{0 numeric}'，除非给出一个数字参数，否则不会尝试纠正补全。"

#. type: table
#: zsh.texi:23014
msgid ""
"If the value contains the string `@t{not-numeric}', the completer will @emph{not} try to generate corrected completions when given a numeric argument, so in this case the number given should be greater "
"than zero.  For example, `@t{2 not-numeric}' specifies that correcting completion with two errors will usually be performed, but if a numeric argument is given, correcting completion will not be performed."
msgstr ""
"如果值包含字符串 `@t{not-numeric}'，则在给定数字参数时，补全程序将 @emph{不会} 尝试生成更正补全，因此在这种情况下，给定的数字应大于零。 例如， `@t{2 not-numeric}' 表示通常会对两个错误进行纠正补全，但如果给"
"出的是数字参数，则不会进行纠正补全。"

#. type: table
#: zsh.texi:23017
msgid "The default value for this style is `@t{2 numeric}'."
msgstr "这个样式的默认值是 `@t{2 numeric}'."

#. type: kindex
#: zsh.texi:23018
#, no-wrap
msgid "max-matches-width, completion style"
msgstr "max-matches-width, 补全样式"

#. type: t{#1}
#: zsh.texi:23019
#, no-wrap
msgid "max-matches-width"
msgstr "max-matches-width"

#. type: table
#: zsh.texi:23025
msgid ""
"This style is used to determine the trade off between the width of the display used for matches and the width used for their descriptions when the @t{verbose} style is in effect.  The value gives the "
"number of display columns to reserve for the matches.  The default is half the width of the screen."
msgstr "当 @t{verbose} 样式生效时，该样式用于确定匹配内容显示宽度与匹配内容描述宽度之间的权衡。 该值给出了为匹配预留的显示列数。 默认值为屏幕宽度的一半。"

#. type: table
#: zsh.texi:23031
msgid ""
"This has the most impact when several matches have the same description and so will be grouped together.  Increasing the style will allow more matches to be grouped together; decreasing it will allow more "
"of the description to be visible."
msgstr "当多个匹配具有相同的描述，会被分组在一起，这一点影响最大。 增大样式可以将更多的匹配归为一组；减小样式可以显示更多的描述。"

#. type: kindex
#: zsh.texi:23032
#, no-wrap
msgid "menu, completion style"
msgstr "menu, 补全样式"

#. type: t{#1}
#: zsh.texi:23033
#, no-wrap
msgid "menu"
msgstr "menu"

#. type: table
#: zsh.texi:23037
msgid ""
"If this is `true' in the context of any of the tags defined for the current completion menu completion will be used.  The value for a specific tag will take precedence over that for the `@t{default}' tag."
msgstr "如果此值为 `true' ，则将在当前补全定义的任何标记上下文中使用菜单补全。 特定标记的值优先于 `@t{default}' 标记的值。"

#. type: table
#: zsh.texi:23042
msgid "If none of the values found in this way is `true' but at least one is set to `@t{auto}', the shell behaves as if the @t{AUTO_MENU} option is set."
msgstr "如果通过这种方法找到的值都不是 `true' ，但至少有一个值被设置为 `@t{auto}'，那么 shell 的行为就如同设置了 @t{AUTO_MENU} 选项。"

#. type: table
#: zsh.texi:23047
msgid "If one of the values is explicitly set to `false', menu completion will be explicitly turned off, overriding the @t{MENU_COMPLETE} option and other settings."
msgstr "如果其中一个值被明确设置为 `false'，则菜单补全将被明确关闭，并覆盖 @t{MENU_COMPLETE} 选项和其他设置。"

#. type: table
#: zsh.texi:23058
msgid ""
"In the form `@t{yes=}@var{num}', where `@t{yes}' may be any of the `true' values (`@t{yes}', `@t{true}', `@t{on}' and `@t{1}'), menu completion will be turned on if there are at least @var{num} matches.  "
"In the form `@t{yes=long}', menu completion will be turned on if the list does not fit on the screen.  This does not activate menu completion if the widget normally only lists completions, but menu "
"completion can be activated in that case with the value `@t{yes=long-list}' (Typically, the value `@t{select=long-list}' described later is more useful as it provides control over scrolling.)"
msgstr ""
"在 `@t{yes=}@var{num}' 形式中， `@t{yes}' 可以是任何一个 `true' 值（`@t{yes}', `@t{true}', `@t{on}' 和 `@t{1}'），如果至少有 @var{num} 个匹配项，则将打开菜单补全功能。 在 `@t{yes=long}' 形式中，如果列表无"
"法显示在屏幕上，则将打开菜单补全功能。 如果小部件通常只列出补全信息，则不会激活菜单补全，但在这种情况下，可以使用值 `@t{yes=long-list}' 激活菜单补全（通常情况下，后面介绍的值  `@t{select=long-list}' 更有"
"用，因为它提供了对滚动的控制）。"

#. type: table
#: zsh.texi:23062
msgid "Similarly, with any of the `false' values (as in `@t{no=10}'), menu completion will @emph{not} be used if there are @var{num} or more matches."
msgstr "同样，如果使用任何 `false' 值（如 `@t{no=10}'），如果有 @var{num} 或更多个匹配项，将 @emph{不会} 使用完成菜单。"

#. type: table
#: zsh.texi:23067
msgid "The value of this widget also controls menu selection, as implemented by the @t{zsh/complist} module.  The following values may appear either alongside or instead of the values above."
msgstr "该小部件的值还可以控制菜单选择，由 @t{zsh/complist} 模块实现。 以下值可以与上述值同时出现，也可以代替上述值。"

#. type: table
#: zsh.texi:23071
msgid "If the value contains the string `@t{select}', menu selection will be started unconditionally."
msgstr "如果值包含字符串 `@t{select}'，则将无条件启动菜单选择。"

#. type: table
#: zsh.texi:23076
msgid "In the form `@t{select=}@var{num}', menu selection will only be started if there are at least @var{num} matches.  If the values for more than one tag provide a number, the smallest number is taken."
msgstr "在 `@t{select=}@var{num}' 形式中，只有至少有 @var{num} 个匹配时，才会启动菜单选择。 如果不止一个标记的值提供了一个数字，则取最小的数字。"

#. type: table
#: zsh.texi:23080
msgid "Menu selection can be turned off explicitly by defining a value containing the string`@t{no-select}'."
msgstr "通过定义包含字符串 `@t{no-select}' 的值，可以明确关闭菜单选择功能。"

#. type: table
#: zsh.texi:23086
msgid ""
"It is also possible to start menu selection only if the list of matches does not fit on the screen by using the value `@t{select=long}'.  To start menu selection even if the current widget only performs "
"listing, use the value `@t{select=long-list}'."
msgstr "还可以使用值 `@t{select=long}'，仅在匹配列表无法在屏幕上显示时启动菜单选择。 要在当前小部件只执行列表功能的情况下启动菜单选择，可使用值 `@t{select=long-list}'。"

#. type: table
#: zsh.texi:23092
msgid ""
"To turn on menu completion or menu selection when there are a certain number of matches @emph{or} the list of matches does not fit on the screen, both of `@t{yes=}' and `@t{select=}' may be given twice, "
"once with a number and once with `@t{long}' or `@t{long-list}'."
msgstr "当有一定数量的匹配项 @emph{或} 匹配项列表无法在屏幕上显示时，打开菜单补全或菜单选择功能，则可以同时给出两次 `@t{yes=}' 和 `@t{select=}' ，一次是数字，另一次是 `@t{long}' 或 `@t{long-list}'。"

#. type: table
#: zsh.texi:23101
msgid ""
"Finally, it is possible to activate two special modes of menu selection.  The word `@t{interactive}' in the value causes interactive mode to be entered immediately when menu selection is started; see "
"@ref{The zsh/complist Module} for a description of interactive mode.  Including the string `@t{search}' does the same for incremental search mode.  To select backward incremental search, include the "
"string `@t{search-backward}'."
msgstr ""
"最后，还可以激活两种特殊的菜单选择模式。 值中包含 `@t{interactive}' 会导致在开始选择菜单时立即进入交互模式；有关交互模式的描述，请参阅 @ref{zsh/complist 模块}。 包含字符串 `@t{search}' 增量搜索模式中行为相"
"同。 要选择后向增量搜索，请加入字符串 `@t{search-backward}'。"

#. type: kindex
#: zsh.texi:23102
#, no-wrap
msgid "muttrc, completion style"
msgstr "muttrc, 补全样式"

#. type: t{#1}
#: zsh.texi:23103
#, no-wrap
msgid "muttrc"
msgstr "muttrc"

#. type: table
#: zsh.texi:23106
msgid "If set, gives the location of the mutt configuration file.  It defaults to `@t{~/.muttrc}'."
msgstr "如果设置，则给出 mutt 配置文件的位置。 默认为 `@t{~/.muttrc}'。"

#. type: kindex
#: zsh.texi:23107
#, no-wrap
msgid "numbers, completion style"
msgstr "numbers, 补全样式"

#. type: t{#1}
#: zsh.texi:23108
#, no-wrap
msgid "numbers"
msgstr "numbers"

#. type: table
#: zsh.texi:23115
msgid ""
"This is used with the @t{jobs} tag.  If it is `true', the shell will complete job numbers instead of the shortest unambiguous prefix of the job command text.  If the value is a number, job numbers will "
"only be used if that many words from the job descriptions are required to resolve ambiguities.  For example, if the value is `@t{1}', strings will only be used if all jobs differ in the first word on "
"their command lines."
msgstr ""
"与 @t{jobs} 标记一起使用。 如果值为 `true'，shell 将补全作业编号，而不是作业命令文本中最短的无歧义前缀。 如果值为数字，则只有在需要从作业描述中找出这么多字来解决歧义时，才会使用作业编号。 例如，如果值为 "
"`@t{1}'，则只有在所有作业命令行的第一个单词不同时，才会使用字符串。"

#. type: kindex
#: zsh.texi:23116
#, no-wrap
msgid "old-list, completion style"
msgstr "old-list, 补全样式"

#. type: t{#1}
#: zsh.texi:23117
#, no-wrap
msgid "old-list"
msgstr "old-list"

#. type: table
#: zsh.texi:23129
msgid ""
"This is used by the @t{_oldlist} completer.  If it is set to `@t{always}', then standard widgets which perform listing will retain the current list of matches, however they were generated; this can be "
"turned off explicitly with the value `@t{never}', giving the behaviour without the @t{_oldlist} completer.  If the style is unset, or any other value, then the existing list of completions is displayed if "
"it is not already; otherwise, the standard completion list is generated; this is the default behaviour of @t{_oldlist}.  However, if there is an old list and this style contains the name of the completer "
"function that generated the list, then the old list will be used even if it was generated by a widget which does not do listing."
msgstr ""
"该值由 @t{_oldlist} 补全器使用。 如果将其设置为 `@t{always}'，那么执行列表的标准小部件将保留当前的匹配列表，无论它们是如何生成的；可以使用值 `@t{never}' 显式地关闭此功能，从而在不使用 @t{_oldlist} 补全器的"
"情况下提供相应的行为。 如果未设置样式或其他值，则会显示现有的补全列表（如果还没有）；否则，将生成标准的补全列表；这是 @t{_oldlist} 的默认行为。 不过，如果存在旧列表，且该样式包含生成该列表的补全函数名称，"
"则将使用旧列表，即使该列表是由不做列表的小部件生成的。"

#. type: table
#: zsh.texi:23137
msgid ""
"For example, suppose you type @t{^Xc} to use the @t{_correct_word} widget, which generates a list of corrections for the word under the cursor.  Usually, typing @t{^D} would generate a standard list of "
"completions for the word on the command line, and show that.  With @t{_oldlist}, it will instead show the list of corrections already generated."
msgstr ""
"例如，假设键入 @t{^Xc} 来使用 @t{_correct_word} 小部件，它会生成光标下单词的更正列表。 通常情况下，键入 @t{^D} 会在命令行中生成该单词的标准补全列表并显示出来。 如果使用 @t{_oldlist}，则会显示已生成的更正列"
"表。"

#. type: table
#: zsh.texi:23146
msgid ""
"As another example consider the @t{_match} completer: with the @t{insert-unambiguous} style set to `true' it inserts only a common prefix string, if there is any.  However, this may remove parts of the "
"original pattern, so that further completion could produce more matches than on the first attempt.  By using the @t{_oldlist} completer and setting this style to @t{_match}, the list of matches generated "
"on the first attempt will be used again."
msgstr ""
"再以 @t{_match} 补全器为例：当 @t{insert-unambiguous} 样式设置为 `true' 时，如果有公共前缀字符串，它只会插入该字符串。 不过，这可能会删除原始模式的部分内容，因此进一步补全可能会产生比第一次更多的匹配结"
"果。 通过使用 @t{_oldlist} 补全器并将此样式设置为 @t{_match}，将再次使用第一次尝试时生成的匹配列表。"

#. type: kindex
#: zsh.texi:23147
#, no-wrap
msgid "old-matches, completion style"
msgstr "old-matches, 补全样式"

#. type: t{#1}
#: zsh.texi:23148
#, no-wrap
msgid "old-matches"
msgstr "old-matches"

#. type: table
#: zsh.texi:23155
msgid ""
"This is used by the @t{_all_matches} completer to decide if an old list of matches should be used if one exists.  This is selected by one of the `true' values or by the string `@t{only}'.  If the value is "
"`@t{only}', @t{_all_matches} will only use an old list and won't have any effect on the list of matches currently being generated."
msgstr ""
"@t{_all_matches} 补全器使用该值来决定是否在存在匹配列表的情况下使用旧的匹配列表。 这可以通过 `true' 值或字符串 `@t{only}' 来选择。 如果值为 `@t{only}'，@t{_all_matches} 将只使用旧的匹配列表，而不会对当前生"
"成的匹配列表产生任何影响。"

#. type: table
#: zsh.texi:23161
msgid ""
"If this style is set it is generally unwise to call the @t{_all_matches} completer unconditionally.  One possible use is for either this style or the @t{completer} style to be defined with the @t{-e} "
"option to @t{zstyle} to make the style conditional."
msgstr "如果设置了这种样式，无条件调用 @t{_all_matches} 补全器通常是不明智的。 一种可能的用法是，使用这个样式 或使用 @t{zstyle} 的 @t{-e} 选项来定义的 @t{completer} 样式，从而使样式具有条件性。"

#. type: kindex
#: zsh.texi:23162
#, no-wrap
msgid "old-menu, completion style"
msgstr "old-menu, 补全样式"

#. type: t{#1}
#: zsh.texi:23163
#, no-wrap
msgid "old-menu"
msgstr "old-menu"

#. type: table
#: zsh.texi:23172
msgid ""
"This is used by the @t{_oldlist} completer.  It controls how menu completion behaves when a completion has already been inserted and the user types a standard completion key such as @t{TAB}.  The default "
"behaviour of @t{_oldlist} is that menu completion always continues with the existing list of completions.  If this style is set to `false', however, a new completion is started if the old list was "
"generated by a different completion command; this is the behaviour without the @t{_oldlist} completer."
msgstr ""
"由 @t{_oldlist} 补全器使用。 它可以控制菜单补全在已插入补全且用户键入标准补全键（如 @t{TAB}）时的行为。 @t{_oldlist} 的默认行为是，菜单补全总是继续使用现有的补全列表。 但如果将此样式设置为 `false'，则如果"
"旧的补全列表是由不同的补全命令生成的，则会启动新的补全；这是没有 @t{_oldlist} 补全器时的行为。"

#. type: table
#: zsh.texi:23179
msgid ""
"For example, suppose you type @t{^Xc} to generate a list of corrections, and menu completion is started in one of the usual ways.  Usually, or with this style set to `false', typing @t{TAB} at this point "
"would start trying to complete the line as it now appears.  With @t{_oldlist}, it instead continues to cycle through the list of corrections."
msgstr ""
"例如，假设您键入 @t{^Xc} 来生成一个更正列表，然后菜单补全以常规方式之一启动。 通常情况下，或在此样式设置为`false' 的情况下，此时键入 @t{TAB} 将开始尝试补全现在显示的行。 如果使用 @t{_oldlist}，则会继续在更"
"正列表中循环。"

#. type: kindex
#: zsh.texi:23180
#, no-wrap
msgid "original, completion style"
msgstr "original, 补全样式"

#. type: table
#: zsh.texi:23190
msgid ""
"This is used by the @t{_approximate} and @t{_correct} completers to decide if the original string should be added as a possible completion.  Normally, this is done only if there are at least two possible "
"corrections, but if this style is set to `true', it is always added.  Note that the style will be examined with the completer field in the context name set to @t{correct-}@var{num} or @t{approximate-}"
"@var{num}, where @var{num} is the number of errors that were accepted."
msgstr ""
"这被 @t{_approximate} 和 @t{_correct} 补全器用来决定是否应将原始字符串添加为可能的补全。 通常，只有在至少有两个可能的纠正时，才会添加补全，但如果此样式设置为 `true'，则总是会添加补全。 请注意，在检查该样式"
"时，将把上下文名称中的补全器字段设置为 @t{correct-}@var{num} 或 @t{approximate-}@var{num}，其中 @var{num} 是接受的错误数。"

#. type: kindex
#: zsh.texi:23191
#, no-wrap
msgid "packageset, completion style"
msgstr "packageset, 补全样式"

#. type: t{#1}
#: zsh.texi:23192
#, no-wrap
msgid "packageset"
msgstr "packageset"

#. type: table
#: zsh.texi:23196
msgid "This style is used when completing arguments of the Debian `@t{dpkg}' program.  It contains an override for the default package set for a given context.  For example,"
msgstr "该样式用于完成 Debian 的 `@t{dpkg}' 程序的参数。 它包含对给定上下文的默认软件包集的覆盖。 例如，"

#. type: example
#: zsh.texi:23201
#, no-wrap
msgid ""
"zstyle ':completion:*:complete:dpkg:option--status-1:*' \\ \n"
"               packageset avail\n"
msgstr ""
"zstyle ':completion:*:complete:dpkg:option--status-1:*' \\ \n"
"               packageset avail\n"

#. type: table
#: zsh.texi:23206
msgid "causes available packages, rather than only installed packages, to be completed for `@t{dpkg -}@t{-status}'."
msgstr "会导致 `@t{dpkg -}@t{-status}' 补全可用的软件包，而不仅仅是已安装的软件包。"

#. type: kindex
#: zsh.texi:23207
#, no-wrap
msgid "path, completion style"
msgstr "path, 补全样式"

#. type: table
#: zsh.texi:23214
msgid ""
"The function that completes color names uses this style with the @t{colors} tag.  The value should be the pathname of a file containing color names in the format of an X11 @t{rgb.txt} file.  If the style "
"is not set but this file is found in one of various standard locations it will be used as the default."
msgstr "补全颜色名称的函数使用这种带有 @t{colors} 标记的样式。 该值应是包含颜色名称的文件的路径名，格式为 X11 @t{rgb.txt} 文件。 如果未设置样式，但在各种标准位置中找到了该文件，则默认使用该文件。"

#. type: kindex
#: zsh.texi:23215
#, no-wrap
msgid "path-completion, completion style"
msgstr "path-completion, 补全样式"

#. type: t{#1}
#: zsh.texi:23216
#, no-wrap
msgid "path-completion"
msgstr "path-completion"

#. type: table
#: zsh.texi:23223
msgid ""
"This is used by filename completion.  By default, filename completion examines all components of a path to see if there are completions of that component.  For example, @t{/u/b/z} can be completed to @t{/"
"usr/bin/zsh}.  Explicitly setting this style to `false' inhibits this behaviour for path components up to the @t{/} before the cursor; this overrides the setting of @t{accept-exact-dirs}."
msgstr ""
"文件名补全时使用。 默认情况下，文件名补全会检查路径的所有组件，查看是否存在该组件的补全。 例如，@t{/u/b/z} 可以补全为 @t{/usr/bin/zsh}。 如果将此样式明确设置为 `false' ，则光标前的 @t{/} 之前的路径组件将无"
"法执行此行为；这将覆盖 @t{accept-exact-dirs} 的设置。"

#. type: table
#: zsh.texi:23230
msgid ""
"Even with the style set to `false', it is still possible to complete multiple paths by setting the option @t{COMPLETE_IN_WORD} and moving the cursor back to the first component in the path to be "
"completed.  For example, @t{/u/b/z} can be completed to @t{/usr/bin/zsh} if the cursor is after the @t{/u}."
msgstr ""
"即使将样式设置为  `false'，通过设置选项 @t{COMPLETE_IN_WORD}，并将光标移回到要补全的路径中的第一个组件，仍然可以补全多个路径。 例如，如果光标位于 @t{/u} 之后，则 @t{/u/b/z} 可以补全为 @t{/usr/bin/zsh}。"

#. type: kindex
#: zsh.texi:23231
#, no-wrap
msgid "pine-directory, completion style"
msgstr "pine-directory, 补全样式"

#. type: t{#1}
#: zsh.texi:23232
#, no-wrap
msgid "pine-directory"
msgstr "pine-directory"

#. type: table
#: zsh.texi:23236
msgid "If set, specifies the directory containing PINE mailbox files.  There is no default, since recursively searching this directory is inconvenient for anyone who doesn't use PINE."
msgstr "如果设置，则指定包含 PINE 邮箱文件的目录。 没有默认设置，因为递归搜索该目录对不使用 PINE 的人来说很不方便。"

#. type: kindex
#: zsh.texi:23237
#, no-wrap
msgid "ports, completion style"
msgstr "ports, 补全样式"

#. type: table
#: zsh.texi:23241
msgid "A list of Internet service names (network ports) to complete.  If this is not set, service names are taken from the file `@t{/etc/services}'."
msgstr "要补全的互联网服务名称（网络端口）列表。 如果未设置，服务名称将取自文件 `@t{/etc/services}'。"

#. type: kindex
#: zsh.texi:23242
#, no-wrap
msgid "prefix-hidden, completion style"
msgstr "prefix-hidden, 补全样式"

#. type: t{#1}
#: zsh.texi:23243
#, no-wrap
msgid "prefix-hidden"
msgstr "prefix-hidden"

#. type: table
#: zsh.texi:23247
msgid "This is used for certain completions which share a common prefix, for example command options beginning with dashes.  If it is `true', the prefix will not be shown in the list of matches."
msgstr "用于某些有共同前缀的补全，例如以破折号开头的命令选项。 如果设置为 `true'，前缀将不会显示在匹配列表中。"

#. type: table
#: zsh.texi:23250
msgid "The default value for this style is `false'."
msgstr "这个样式的默认值是 `false'."

#. type: kindex
#: zsh.texi:23251
#, no-wrap
msgid "prefix-needed, completion style"
msgstr "prefix-needed, 补全样式"

#. type: t{#1}
#: zsh.texi:23252
#, no-wrap
msgid "prefix-needed"
msgstr "prefix-needed"

#. type: table
#: zsh.texi:23256
msgid "This style is also relevant for matches with a common prefix.  If it is set to `true' this common prefix must be typed by the user to generate the matches."
msgstr "这种样式也适用于有共同前缀的匹配。 如果设置为 `true' ，则必须由用户输入共同前缀才能生成匹配。"

#. type: table
#: zsh.texi:23260
msgid "The style is applicable to the @t{options}, @t{signals}, @t{jobs}, @t{functions}, and @t{parameters} completion tags."
msgstr "该样式适用于 @t{options}, @t{signals}, @t{jobs}, @t{functions} 和 @t{parameters} 等补全标记。"

#. type: table
#: zsh.texi:23265
msgid "For command options, this means that the initial `@t{-}', `@t{+}', or `@t{-}@t{-}' must be typed explicitly before option names will be completed."
msgstr "对于命令选项而言，这意味着在补全选项名称之前，必须明确键入前导的 `@t{-}', `@t{+}' 或 `@t{-}@t{-}'。"

#. type: table
#: zsh.texi:23269
msgid "For signals, an initial `@t{-}' is required before signal names will be completed."
msgstr "对于信号，在补全信号名称之前，需要一个前导的 `@t{-}' 。"

#. type: table
#: zsh.texi:23273
msgid "For jobs, an initial `@t{%}' is required before job names will be completed."
msgstr "对于作业，在补全作业名称之前，需要输入前导的 `@t{%}'。"

#. type: table
#: zsh.texi:23278
msgid "For function and parameter names, an initial `@t{_}' or `@t{.}' is required before function or parameter names starting with those characters will be completed."
msgstr "对于函数名和参数名，在补全以 `@t{_}' 或 `@t{.}' 字符开头的函数名或参数名之前，需要先输入前导的 `@t{_}' 或 `@t{.}' 。"

#. type: table
#: zsh.texi:23282
msgid "The default value for this style is `false' for @t{function} and @t{parameter} completions, and `true' otherwise."
msgstr "对于 @t{function} 和 @t{parameter} 补全，该样式的默认值为 `false' ，否则为 `true' 。"

#. type: kindex
#: zsh.texi:23283
#, no-wrap
msgid "preserve-prefix, completion style"
msgstr "preserve-prefix, 补全样式"

#. type: t{#1}
#: zsh.texi:23284
#, no-wrap
msgid "preserve-prefix"
msgstr "preserve-prefix"

#. type: table
#: zsh.texi:23292
msgid ""
"This style is used when completing path names.  Its value should be a pattern matching an initial prefix of the word to complete that should be left unchanged under all circumstances.  For example, on "
"some Unices an initial `@t{//}' (double slash) has a special meaning; setting this style to the string `@t{//}' will preserve it.  As another example, setting this style to `@t{?:/}' under Cygwin would "
"allow completion after `@t{a:/...}' and so on."
msgstr ""
"该样式用于补全路径名。 它的值应该是一个与要补全的单词的首字母前缀相匹配的模式，在任何情况下都不应改变。 例如，在某些 Unices 中(指 UNIX 的多种变体)，开头的 `@t{//}'（双斜线）具有特殊含义；将该样式设置为字符"
"串 `@t{//}' 将保留该含义。 再比如，在 Cygwin 下将该样式设置为 `@t{?:/}' 将允许在 `@t{a:/...}' 后补全，等等。"

#. type: kindex
#: zsh.texi:23293
#, no-wrap
msgid "range, completion style"
msgstr "range, 补全样式"

#. type: t{#1}
#: zsh.texi:23294
#, no-wrap
msgid "range"
msgstr "range"

#. type: table
#: zsh.texi:23298
msgid "This is used by the @t{_history} completer and the @t{_history_complete_word} bindable command to decide which words should be completed."
msgstr "@t{_history} 补全器和 @t{_history_complete_word} 可绑定命令会使用该命令来决定哪些词应该被补全。"

#. type: table
#: zsh.texi:23302
msgid "If it is a single number, only the last @var{N} words from the history will be completed."
msgstr "如果是单个数字，则只补全历史记录中最后 @var{N} 个字。"

#. type: table
#: zsh.texi:23309
msgid ""
"If it is a range of the form `@var{max}@t{:}@var{slice}', the last @var{slice} words will be completed; then if that yields no matches, the @var{slice} words before those will be tried and so on.  This "
"process stops either when at least one match has been found, or @var{max} words have been tried."
msgstr ""
"如果它是一个形式为 `@var{max}@t{:}@var{slice}' 的范围，则将补全最后一个 @var{slice} 词；如果没有匹配结果，则将尝试之前的 @var{slice} 词，依此类推。 这个过程会在找到至少一个匹配词或 @var{max} 个词已被尝试后"
"停止。"

#. type: table
#: zsh.texi:23312
msgid "The default is to complete all words from the history at once."
msgstr "默认设置是一次性补全历史记录中的所有单词。"

#. type: kindex
#: zsh.texi:23313
#, no-wrap
msgid "recursive-files, completion style"
msgstr "recursive-files, 补全样式"

#. type: t{#1}
#: zsh.texi:23314
#, no-wrap
msgid "recursive-files"
msgstr "recursive-files"

#. type: table
#: zsh.texi:23327
msgid ""
"If this style is set, its value is an array of patterns to be tested against `@t{$PWD/}': note the trailing slash, which allows directories in the pattern to be delimited unambiguously by including "
"slashes on both sides.  If an ordinary file completion fails and the word on the command line does not yet have a directory part to its name, the style is retrieved using the same tag as for the "
"completion just attempted, then the elements tested against @t{$PWD/} in turn.  If one matches, then the shell reattempts completion by prepending the word on the command line with each directory in the "
"expansion of @t{**/*(/)} in turn.  Typically the elements of the style will be set to restrict the number of directories beneath the current one to a manageable number, for example `@t{*/.git/*}'."
msgstr ""
"如果设置了该样式，其值将是针对 `@t{$PWD/}' 进行测试的模式数组：请注意尾部的斜线，它允许通过在两侧包含斜线来明确划分模式中的目录。 如果普通文件补全失败，而命令行中的单词名称中还没有目录部分，那么将使用与刚"
"才尝试的补全相同的标记来检索样式，然后依次根据 @t{$PWD/} 对元素进行测试。 如果有一个匹配，shell 会重新尝试补全，方法是依次将命令行上的单词用 @t{**/*(/)} 扩展中的每个目录作为前缀。 通常情况下，样式元素的设"
"置会将当前目录下的目录数量限制在可控范围内，例如 `@t{*/.git/*}' 。"

#. type: example
#: zsh.texi:23334
#, no-wrap
msgid "zstyle ':completion:*' recursive-files '*/zsh/*'\n"
msgstr "zstyle ':completion:*' recursive-files '*/zsh/*'\n"

#. type: table
#: zsh.texi:23339
msgid "If the current directory is @t{/home/pws/zsh/Src}, then @t{zle_tr<TAB>} can be completed to @t{Zle/zle_tricky.c}."
msgstr "如果当前目录是 @t{/home/pws/zsh/Src}，则 @t{zle_tr<TAB>} 可以补全为 @t{Zle/zle_tricky.c}。"

#. type: kindex
#: zsh.texi:23340
#, no-wrap
msgid "regular, completion style"
msgstr "regular, 补全样式"

#. type: t{#1}
#: zsh.texi:23341
#, no-wrap
msgid "regular"
msgstr "regular"

#. type: table
#: zsh.texi:23347
msgid ""
"This style is used by the @t{_expand_alias} completer and bindable command.  If set to `true' (the default), regular aliases will be expanded but only in command position.  If it is set to `false', "
"regular aliases will never be expanded.  If it is set to `@t{always}', regular aliases will be expanded even if not in command position."
msgstr ""
"该样式由 @t{_expand_alias} 补全器和可绑定命令使用。 如果设置为 `true' （默认），正则别名将被展开，但仅限于命令位置。 如果设置为  `false'，则不会扩展常规别名。 如果设置为 `@t{always}'，即使不在命令位置，也"
"会展开常规别名。"

#. type: kindex
#: zsh.texi:23348
#, no-wrap
msgid "rehash, completion style"
msgstr "rehash, 补全样式"

#. type: table
#: zsh.texi:23355
msgid ""
"If this is set when completing external commands, the internal list (hash) of commands will be updated for each search by issuing the @t{rehash} command.  There is a speed penalty for this which is only "
"likely to be noticeable when directories in the path have slow file access."
msgstr "如果在补全外部命令时设置了该选项，则每次搜索时都会通过 @t{rehash} 命令更新内部命令列表（哈希）。 这样做会降低速度，只有在路径中的目录文件访问速度较慢时才会明显感觉到。"

#. type: kindex
#: zsh.texi:23356
#, no-wrap
msgid "remote-access, completion style"
msgstr "remote-access, 补全样式"

#. type: t{#1}
#: zsh.texi:23357
#, no-wrap
msgid "remote-access"
msgstr "remote-access"

#. type: table
#: zsh.texi:23361
msgid "If set to `false', certain commands will be prevented from making Internet connections to retrieve remote information.  This includes the completion for the @t{CVS} command."
msgstr "如果设置为 `false'，某些命令将无法通过互联网连接获取远程信息。 这包括 @t{CVS} 命令的补全。"

#. type: table
#: zsh.texi:23365
msgid "It is not always possible to know if connections are in fact to a remote site, so some may be prevented unnecessarily."
msgstr "我们并不总能知道连接是否确实指向远程站点，因此有些连接可能会被不必要地阻止。"

#. type: kindex
#: zsh.texi:23366
#, no-wrap
msgid "remove-all-dups, completion style"
msgstr "remove-all-dups, 补全样式"

#. type: t{#1}
#: zsh.texi:23367
#, no-wrap
msgid "remove-all-dups"
msgstr "remove-all-dups"

#. type: table
#: zsh.texi:23371
msgid "The @t{_history_complete_word} bindable command and the @t{_history} completer use this to decide if all duplicate matches should be removed, rather than just consecutive duplicates."
msgstr "@t{_history_complete_word} 可绑定命令和 @t{_history} 补全器利用这一点来决定是否要删除所有重复匹配，而不是只删除连续的重复匹配。"

#. type: kindex
#: zsh.texi:23372
#, no-wrap
msgid "select-prompt, completion style"
msgstr "select-prompt, 补全样式"

#. type: t{#1}
#: zsh.texi:23373
#, no-wrap
msgid "select-prompt"
msgstr "select-prompt"

#. type: table
#: zsh.texi:23380
msgid ""
"If this is set for the @t{default} tag, its value will be displayed during menu selection (see the @t{menu} style above) when the completion list does not fit on the screen as a whole.  The same escapes "
"as for the @t{list-prompt} style are understood, except that the numbers refer to the match or line the mark is on.  A default prompt is used when the value is the empty string."
msgstr ""
"如果为 @t{default} 标记设置了该值，则当补全列表无法作为一个整体显示在屏幕上时，其值将在菜单选择时显示（参见上文的 @t{menu} 样式）。 与 @t{list-prompt} 样式相同的转义符都可以被识别，只是数字指的是标记所在的"
"匹配或行。 当值为空字符串时，将使用默认提示符。"

#. type: kindex
#: zsh.texi:23381
#, no-wrap
msgid "select-scroll, completion style"
msgstr "select-scroll, 补全样式"

#. type: t{#1}
#: zsh.texi:23382
#, no-wrap
msgid "select-scroll"
msgstr "select-scroll"

#. type: table
#: zsh.texi:23391
msgid ""
"This style is tested for the @t{default} tag and determines how a completion list is scrolled during a menu selection (see the @t{menu} style above) when the completion list does not fit on the screen as "
"a whole.  If the value is `@t{0}' (zero), the list is scrolled by half-screenfuls; if it is a positive integer, the list is scrolled by the given number of lines; if it is a negative number, the list is "
"scrolled by a screenful minus the absolute value of the given number of lines.  The default is to scroll by single lines."
msgstr ""
"该样式针对 @t{default} 标记进行测试，并决定在菜单选择（见上文 @t{menu} 样式）时，如果补全列表无法在整个屏幕上显示时，如何滚动补全列表。 如果该值为 `@t{0}' （零），则按半屏滚动；如果该值为正整数，则按给定的"
"行数滚动；如果该值为负数，则按给定行数的绝对值减去一屏滚动。 默认滚动行数为单行。"

#. type: kindex
#: zsh.texi:23392
#, no-wrap
msgid "separate-sections, completion style"
msgstr "separate-sections, 补全样式"

#. type: t{#1}
#: zsh.texi:23393
#, no-wrap
msgid "separate-sections"
msgstr "separate-sections"

#. type: table
#: zsh.texi:23402
msgid ""
"This style is used with the @t{manuals} tag when completing names of manual pages.  If it is `true', entries for different sections are added separately using tag names of the form `@t{manuals.}@var{X}', "
"where @var{X} is the section number.  When the @t{group-name} style is also in effect, pages from different sections will appear separately.  This style is also used similarly with the @t{words} style "
"when completing words for the dict command. It allows words from different dictionary databases to be added separately. See also @t{insert-sections}."
msgstr ""
"在补全手册页面名称时，该样式与 @t{manuals} 标记一起使用。 如果该样式为 `true'，不同章节的条目将使用 `@t{manuals.}@var{X}' 形式的标签名分别添加，其中 @var{X} 是章节编号。 当 @t{group-name} 样式也有效时，不"
"同章节的页面将分别显示。 在为 dict 命令补全单词时，该样式也与 @t{words} 样式类似。它允许分别添加来自不同词典数据库的单词。另请参阅 @t{insert-sections}。"

#. type: kindex
#: zsh.texi:23406
#, no-wrap
msgid "show-ambiguity, completion style"
msgstr "show-ambiguity, 补全样式"

#. type: t{#1}
#: zsh.texi:23407
#, no-wrap
msgid "show-ambiguity"
msgstr "show-ambiguity"

#. type: table
#: zsh.texi:23414
msgid ""
"If the @t{zsh/complist} module is loaded, this style can be used to highlight the first ambiguous character in completion lists. The value is either a color indication such as those supported by the "
"@t{list-colors} style or, with a value of `true', a default of underlining is selected. The highlighting is only applied if the completion display strings correspond to the actual matches."
msgstr ""
"如果加载了 @t{zsh/complist} 模块，该样式可用于高亮显示补全列表中的第一个模糊字符。其值可以是颜色指示，如 @t{list-colors} 样式所支持的颜色；或者，如果值为 `true'，则默认选择下划线。只有在补全显示字符串与实"
"际匹配对应时，才会应用高亮显示。"

#. type: kindex
#: zsh.texi:23415
#, no-wrap
msgid "show-completer, completion style"
msgstr "show-completer, 补全样式"

#. type: t{#1}
#: zsh.texi:23416
#, no-wrap
msgid "show-completer"
msgstr "show-completer"

#. type: table
#: zsh.texi:23421
msgid ""
"Tested whenever a new completer is tried.  If it is `true', the completion system outputs a progress message in the listing area showing what completer is being tried.  The message will be overwritten by "
"any output when completions are found and is removed after completion is finished."
msgstr "每当尝试一个新的补全器时都会进行测试。 如果为 `true'，补全系统会在列表区输出一条进度信息，显示正在尝试的补全器。 当找到补全器时，该信息会被输出覆盖，并在补全完成后删除。"

#. type: kindex
#: zsh.texi:23422
#, no-wrap
msgid "single-ignored, completion style"
msgstr "single-ignored, 补全样式"

#. type: t{#1}
#: zsh.texi:23423
#, no-wrap
msgid "single-ignored"
msgstr "single-ignored"

#. type: table
#: zsh.texi:23429
msgid ""
"This is used by the @t{_ignored} completer when there is only one match.  If its value is `@t{show}', the single match will be displayed but not inserted.  If the value is `@t{menu}', then the single "
"match and the original string are both added as matches and menu completion is started, making it easy to select either of them."
msgstr ""
"当只有一个匹配时，@t{_ignored} 补全器会使用该值。 如果其值为 `@t{show}'，则将显示但不插入单个匹配字符串。 如果其值为 `@t{menu}'，则单个匹配字符串和原始字符串都会被添加为匹配字符串，并启动菜单补全，从而方便"
"选择其中任何一个。"

#. type: kindex
#: zsh.texi:23430
#, no-wrap
msgid "sort, completion style"
msgstr "sort, 补全样式"

#. type: t{#1}
#: zsh.texi:23431
#, no-wrap
msgid "sort"
msgstr "sort"

#. type: table
#: zsh.texi:23433
msgid "This allows the standard ordering of matches to be overridden."
msgstr "这样就可以覆盖匹配的标准排序。"

#. type: table
#: zsh.texi:23439
msgid ""
"If its value is `@t{true}' or `@t{false}', sorting is enabled or disabled.  Additionally the values associated with the `@t{-o}' option to @t{compadd} can also be listed: @t{match}, @t{nosort}, "
"@t{numeric}, @t{reverse}.  If it is not set for the context, the standard behaviour of the calling widget is used."
msgstr ""
"如果其值为 `@t{true}' 或 `@t{false}'，则表示启用或禁用排序。 此外，还可以列出与 @t{compadd} 的 `@t{-o}' 选项相关的值： @t{match}, @t{nosort}, @t{numeric}, @t{reverse}。 如果上下文未设置该选项，则使用调用小"
"部件的标准行为。"

#. type: table
#: zsh.texi:23443
msgid "The style is tested first against the full context including the tag, and if that fails to produce a value against the context without the tag."
msgstr "首先针对包含标记的完整上下文测试这个样式，如果测试失败，则针对不包含标记的上下文测试这个样式。"

#. type: table
#: zsh.texi:23449
msgid ""
"In many cases where a calling widget explicitly selects a particular ordering in lieu of the default, a value of `@t{true}' is not honoured.  An example of where this is not the case is for command "
"history where the default of sorting matches chronologically may be overridden by setting the style to `true'."
msgstr ""
"在许多情况下，如果调用小部件明确选择了特定的排序方式，而不是默认的排序方式，`@t{true}' 的值就不会被兑现。不是这种情况的例子是，在命令历史中，可以通过将样式设置为 `true' 来覆盖按时间顺序排列匹配的默认值。"

#. type: table
#: zsh.texi:23456
msgid ""
"In the @t{_expand} completer, if it is set to `true', the expansions generated will always be sorted.  If it is set to `@t{menu}', then the expansions are only sorted when they are offered as single "
"strings but not in the string containing all possible expansions."
msgstr "在 @t{_expand} 补全器中，如果将其设置为 `true'，生成的扩展将始终排序。 如果将其设置为 `@t{menu}'，则只有当扩展作为单个字符串提供时，才会对扩展进行排序，而不是在包含所有可能扩展的字符串中进行排序。"

#. type: kindex
#: zsh.texi:23457
#, no-wrap
msgid "special-dirs, completion style"
msgstr "special-dirs, 补全样式"

#. type: t{#1}
#: zsh.texi:23458
#, no-wrap
msgid "special-dirs"
msgstr "special-dirs"

#. type: table
#: zsh.texi:23463
msgid ""
"Normally, the completion code will not produce the directory names `@t{.}' and `@t{..}' as possible completions.  If this style is set to `true', it will add both `@t{.}' and `@t{..}' as possible "
"completions; if it is set to `@t{..}', only `@t{..}' will be added."
msgstr "通常情况下，补全代码不会将目录名 `@t{.}' 和 `@t{..}' 作为可能的补全。 如果将该样式设置为 `true'，则会同时添加 `@t{.}' 和 `@t{..}' 作为可能的补全；如果设置为 `@t{..}'，则只会添加 `@t{..}'。"

#. type: table
#: zsh.texi:23468
msgid "The following example sets @t{special-dirs} to `@t{..}' when the current prefix is empty, is a single `@t{.}', or consists only of a path beginning with `@t{../}'.  Otherwise the value is `false'."
msgstr "下面的示例将 @t{special-dirs} 设置为 `@t{..}' ，前提是当前前缀为空，是单一的 `@t{.}' 或仅由以 `@t{../}' 开头的路径组成。 否则，该值为 `false'。"

#. type: example
#: zsh.texi:23473
#, no-wrap
msgid ""
"zstyle -e ':completion:*' special-dirs \\ \n"
"   '[[ $PREFIX = (../)#(|.|..) ]] && reply=(..)'\n"
msgstr ""
"zstyle -e ':completion:*' special-dirs \\ \n"
"   '[[ $PREFIX = (../)#(|.|..) ]] && reply=(..)'\n"

#. type: kindex
#: zsh.texi:23475
#, no-wrap
msgid "squeeze-slashes, completion style"
msgstr "squeeze-slashes, 补全样式"

#. type: t{#1}
#: zsh.texi:23476
#, no-wrap
msgid "squeeze-slashes"
msgstr "squeeze-slashes"

#. type: table
#: zsh.texi:23481
msgid ""
"If set to `true', sequences of slashes in filename paths (for example in `@t{foo//bar}') will be treated as a single slash.  This is the usual behaviour of UNIX paths.  However, by default the file "
"completion function behaves as if there were a `@t{*}' between the slashes."
msgstr "如果设置为 `true'，文件名路径中的斜线序列（例如在 `@t{foo//bar}' 中）将被视为单个斜线。 这是 UNIX 路径的通常行为。 不过，默认情况下，文件补全函数会认为斜线之间有一个 `@t{*}' 。"

#. type: kindex
#: zsh.texi:23482
#, no-wrap
msgid "stop, completion style"
msgstr "stop, 补全样式"

#. type: t{#1}
#: zsh.texi:23483
#, no-wrap
msgid "stop"
msgstr "stop"

#. type: table
#: zsh.texi:23490
msgid ""
"If set to `true', the @t{_history_complete_word} bindable command will stop once when reaching the beginning or end of the history.  Invoking @t{_history_complete_word} will then wrap around to the "
"opposite end of the history.  If this style is set to `false' (the default), @t{_history_complete_word} will loop immediately as in a menu completion."
msgstr ""
"如果设置为 `true'，@t{_history_complete_word} 可绑定命令将在到达历史记录的开始或结束时停止一次。 然后，调用 @t{_history_complete_word} 将回绕到历史的另一端。 如果将此样式设置为 `false'（默认），"
"@t{_history_complete_word} 将像菜单补全一样立即循环。"

#. type: kindex
#: zsh.texi:23491
#, no-wrap
msgid "strip-comments, completion style"
msgstr "strip-comments, 补全样式"

#. type: t{#1}
#: zsh.texi:23492
#, no-wrap
msgid "strip-comments"
msgstr "strip-comments"

#. type: table
#: zsh.texi:23497
msgid ""
"If set to `true', this style causes non-essential comment text to be removed from completion matches.  Currently it is only used when completing e-mail addresses where it removes any display name from the "
"addresses, cutting them down to plain @var{user@@host} form."
msgstr "如果设置为 `true'，该样式会删除补全匹配中的非必要注释文本。 目前，它只用于补全电子邮件地址，在这种情况下，它会删除地址中的任何显示名称，将其缩减为简单的 @var{user@@host} 格式。"

#. type: kindex
#: zsh.texi:23498
#, no-wrap
msgid "subst-globs-only, completion style"
msgstr "subst-globs-only, 补全样式"

#. type: t{#1}
#: zsh.texi:23499
#, no-wrap
msgid "subst-globs-only"
msgstr "subst-globs-only"

#. type: table
#: zsh.texi:23505
msgid ""
"This is used by the @t{_expand} completer.  If it is set to `true', the expansion will only be used if it resulted from globbing; hence, if expansions resulted from the use of the @t{substitute} style "
"described below, but these were not further changed by globbing, the expansions will be rejected."
msgstr ""
"这将被 @t{_expand} 补全器使用。 如果将其设置为 `true'，则只有通过 globbing 产生的扩展才会被使用；因此，如果扩展是通过使用下面描述的 @t{substitute} 样式产生的，但这些扩展并没有通过 globbing 进一步改变，则这"
"些扩展将被拒绝。"

#. type: kindex
#: zsh.texi:23509
#, no-wrap
msgid "substitute, completion style"
msgstr "替换, 补全样式"

#. type: t{#1}
#: zsh.texi:23510
#, no-wrap
msgid "substitute"
msgstr "替换"

#. type: table
#: zsh.texi:23514
msgid "This boolean style controls whether the @t{_expand} completer will first try to expand all substitutions in the string (such as `@t{$(}@var{...}@t{)}' and `@t{$@{}@var{...}@t{@}}')."
msgstr "该布尔样式控制 @t{_expand}  补全器是否首先尝试扩展字符串中的所有替换（如 `@t{$(}@var{...}@t{)}'  和 `@t{$@{}@var{...}@t{@}}' ）。"

#. type: table
#: zsh.texi:23517
msgid "The default is `true'."
msgstr "默认是 `true'."

#. type: kindex
#: zsh.texi:23518
#, no-wrap
msgid "suffix, completion style"
msgstr "后缀, 补全样式"

#. type: table
#: zsh.texi:23526
msgid ""
"This is used by the @t{_expand} completer if the word starts with a tilde or contains a parameter expansion.  If it is set to `true', the word will only be expanded if it doesn't have a suffix, i.e. if it "
"is something like `@t{~foo}' or `@t{$foo}' rather than `@t{~foo/}' or `@t{$foo/bar}', unless that suffix itself contains characters eligible for expansion.  The default for this style is `true'."
msgstr ""
"如果单词以转折号(tilde)开头或包含参数扩展，@t{_expand} 补全器就会使用它。 如果将其设置为 `true'，则只有在单词没有后缀的情况下才会进行扩展，也就是说，如果单词的后缀是类似 `@t{~foo}' 或 `@t{$foo}' ，而不是 "
"`@t{~foo/}' 或 `@t{$foo/bar}'，才会进行扩展，除非该后缀本身包含符合扩展条件的字符。 该样式的默认值为 `true'。"

#. type: kindex
#: zsh.texi:23527
#, no-wrap
msgid "tag-order, completion style"
msgstr "tag-order, 补全样式"

#. type: t{#1}
#: zsh.texi:23528
#, no-wrap
msgid "tag-order"
msgstr "tag-order"

#. type: table
#: zsh.texi:23531
msgid "This provides a mechanism for sorting how the tags available in a particular context will be used."
msgstr "这就提供了一种机制，用于对特定上下文中可用标记的使用方式进行排序。"

#. type: table
#: zsh.texi:23537
msgid ""
"The values for the style are sets of space-separated lists of tags.  The tags in each value will be tried at the same time; if no match is found, the next value is used.  (See the @t{file-patterns} style "
"for an exception to this behavior.)"
msgstr "样式的值是一组以空格分隔的标记列表。 每个值中的标签将同时被尝试；如果没有找到匹配，则使用下一个值。 (请参阅 @t{file-patterns} 样式，了解此行为的例外情况）。"

#. type: example
#: zsh.texi:23545
#, no-wrap
msgid ""
"zstyle ':completion:*:complete:-command-:*:*' tag-order \\ \n"
"    'commands functions'\n"
msgstr ""
"zstyle ':completion:*:complete:-command-:*:*' tag-order \\ \n"
"    'commands functions'\n"

#. type: table
#: zsh.texi:23551
msgid "specifies that completion in command position first offers external commands and shell functions.  Remaining tags will be tried if no completions are found."
msgstr "指定命令位置的补全首先提供外部命令和 shell 函数。 如果找不到补全，将尝试其余标记。"

#. type: table
#: zsh.texi:23555
msgid "In addition to tag names, each string in the value may take one of the following forms:"
msgstr "除标记名称外，值中的每个字符串还可以是以下形式之一："

#. type: table
#: zsh.texi:23565
msgid ""
"If any value consists of only a hyphen, then @emph{only} the tags specified in the other values are generated.  Normally all tags not explicitly selected are tried last if the specified tags fail to "
"generate any matches.  This means that a single value consisting only of a single hyphen turns off completion."
msgstr ""
"如果任何值只包含一个连字符，那么将 @emph{只} 生成其他值中指定的标记。 通常情况下，如果指定的标记无法生成任何匹配结果，则最后尝试所有未明确选择的标记。 这意味着，仅由一个连字符组成的单个值将关闭补全功能。"

#. type: item
#: zsh.texi:23566
#, no-wrap
msgid "@t{!} @var{tags}..."
msgstr "@t{!} @var{tags}..."

#. type: table
#: zsh.texi:23571
msgid "A string starting with an exclamation mark specifies names of tags that are @emph{not} to be used.  The effect is the same as if all other possible tags for the context had been listed."
msgstr "以感叹号开头的字符串用于指定 @emph{不会使用的} 标记的名称。 其效果与列出上下文中所有其他可能的标签相同。"

#. type: item
#: zsh.texi:23572
#, no-wrap
msgid "@var{tag}@t{:}@var{label} ..."
msgstr "@var{tag}@t{:}@var{label} ..."

#. type: table
#: zsh.texi:23577
msgid ""
"Here, @var{tag} is one of the standard tags and @var{label} is an arbitrary name.  Matches are generated as normal but the name @var{label} is used in contexts instead of @var{tag}.  This is not useful in "
"words starting with @t{!}."
msgstr "这里，@var{tag} 是标准标签之一，@var{label} 是任意名称。 匹配结果的生成与正常情况相同，但在上下文中使用 @var{label} 而不是 @var{tag}。 这在以 @t{!} 开头的词语中没有用处。"

#. type: table
#: zsh.texi:23584
msgid ""
"If the @var{label} starts with a hyphen, the @var{tag} is prepended to the @var{label} to form the name used for lookup.  This can be used to make the completion system try a certain tag more than once, "
"supplying different style settings for each attempt; see below for an example."
msgstr "如果 @var{label} 以连字符开头，则 @var{tag} 将作为 @var{label} 的前缀，以形成用于查找的名称。 这可以用来让补全系统多次尝试某个标签，并为每次尝试提供不同的样式设置；请参阅下面的示例。"

#. type: item
#: zsh.texi:23585
#, no-wrap
msgid "@var{tag}@t{:}@var{label}@t{:}@var{description}"
msgstr "@var{tag}@t{:}@var{label}@t{:}@var{description}"

#. type: table
#: zsh.texi:23592
msgid ""
"As before, but @t{description} will replace the `@t{%d}' in the value of the @t{format} style instead of the default description supplied by the completion function.  Spaces in the description must be "
"quoted with a backslash.  A `@t{%d}' appearing in @var{description} is replaced with the description given by the completion function."
msgstr ""
"与之前一样，但 @t{description} 将替换 @t{format} 样式值中的 `@t{%d}' ，而不是补全函数提供的默认描述。 描述中的空格必须用反斜线引出。 出现在 @var{description} 中的 `@t{%d}' 会被补全函数给出的描述所替换。"

#. type: table
#: zsh.texi:23600
msgid ""
"In any of the forms above the tag may be a pattern or several patterns in the form `@t{@{}@var{pat1}@t{,}@var{pat2...}@t{@}}'.  In this case all matching tags will be used except for any given explicitly "
"in the same string."
msgstr "在上述任何一种形式中，标记可以是一个模式或多个模式，其形式为 `@t{@{}@var{pat1}@t{,}@var{pat2...}@t{@}}'。 在这种情况下，除了同一字符串中任何明确给出的标记外，所有匹配标签都将被使用。"

#. type: table
#: zsh.texi:23608
msgid ""
"One use of these features is to try one tag more than once, setting other styles differently on each attempt, but still to use all the other tags without having to repeat them all.  For example, to make "
"completion of function names in command position ignore all the completion functions starting with an underscore the first time completion is tried:"
msgstr ""
"这些功能的一个用途是多次尝试一个标记，每次尝试都以不同的方式设置其他样式，但仍可使用所有其他标记，而不必重复所有标记。 例如，在第一次尝试补全时，让命令位置的函数名补全忽略所有以下划线开头的补全函数："

#. type: example
#: zsh.texi:23615
#, no-wrap
msgid ""
"zstyle ':completion:*:*:-command-:*:*' tag-order \\ \n"
"    'functions:-non-comp *' functions\n"
"zstyle ':completion:*:functions-non-comp' \\ \n"
"    ignored-patterns '_*'\n"
msgstr ""
"zstyle ':completion:*:*:-command-:*:*' tag-order \\ \n"
"    'functions:-non-comp *' functions\n"
"zstyle ':completion:*:functions-non-comp' \\ \n"
"    ignored-patterns '_*'\n"

#. type: table
#: zsh.texi:23624
msgid ""
"On the first attempt, all tags will be offered but the @t{functions} tag will be replaced by @t{functions-non-comp}.  The @t{ignored-patterns} style is set for this tag to exclude functions starting with "
"an underscore.  If there are no matches, the second value of the @t{tag-order} style is used which completes functions using the default tag, this time presumably including all function names."
msgstr ""
"第一次尝试时，将提供所有标记，但 @t{functions} 标记将被 @t{functions-non-comp} 替换。 为该标记设置的 @t{ignored-patterns} 样式将排除以下划线开头的函数。 如果没有匹配项，则使用 @t{tag-order} 样式的第二个"
"值，以使用默认标记补全函数，这次可能包括所有函数名。"

#. type: table
#: zsh.texi:23627
msgid "The matches for one tag can be split into different groups.  For example:"
msgstr "一个标记的匹配可以分成不同的组。 例如"

#. type: example
#: zsh.texi:23640
#, no-wrap
msgid ""
"zstyle ':completion:*' tag-order \\ \n"
"    'options:-long:long\\ options\n"
"     options:-short:short\\ options\n"
"     options:-single-letter:single\\ letter\\ options'\n"
"zstyle ':completion:*:options-long' \\ \n"
"     ignored-patterns '[-+](|-|[^-]*)'\n"
"zstyle ':completion:*:options-short' \\ \n"
"     ignored-patterns '--*' '[-+]?'\n"
"zstyle ':completion:*:options-single-letter' \\ \n"
"     ignored-patterns '???*'\n"
msgstr ""
"zstyle ':completion:*' tag-order \\ \n"
"    'options:-long:long\\ options\n"
"     options:-short:short\\ options\n"
"     options:-single-letter:single\\ letter\\ options'\n"
"zstyle ':completion:*:options-long' \\ \n"
"     ignored-patterns '[-+](|-|[^-]*)'\n"
"zstyle ':completion:*:options-short' \\ \n"
"     ignored-patterns '--*' '[-+]?'\n"
"zstyle ':completion:*:options-single-letter' \\ \n"
"     ignored-patterns '???*'\n"

#. type: table
#: zsh.texi:23647
msgid ""
"With the @t{group-names} style set, options beginning with `@t{-}@t{-}', options beginning with a single `@t{-}' or `@t{+}' but containing multiple characters, and single-letter options will be displayed "
"in separate groups with different descriptions."
msgstr "如果设置了 @t{group-names} 样式，以 `@t{-}@t{-}' 开头的选项、以单个 `@t{-}' 或 `@t{+}' 开头但包含多个字符的选项，以及单字母选项，都将以不同的描述分组显示。"

#. type: table
#: zsh.texi:23657
msgid ""
"Another use of patterns is to try multiple match specifications one after another.  The @t{matcher-list} style offers something similar, but it is tested very early in the completion system and hence "
"can't be set for single commands nor for more specific contexts.  Here is how to try normal completion without any match specification and, if that generates no matches, try again with case-insensitive "
"matching, restricting the effect to arguments of the command @t{foo}:"
msgstr ""
"模式的另一个用途是连续尝试多个匹配规范。 @t{matcher-list} 样式提供了类似的功能，但它在补全系统中很早就进行了测试，因此不能为单个命令或更具体的上下文设置。 下面是如何在没有任何匹配规范的情况下尝试正常补全，"
"如果没有匹配结果，则再次尝试大小写不敏感匹配，将效果限制在命令 @t{foo} 的参数上："

#. type: example
#: zsh.texi:23662
#, no-wrap
msgid ""
"zstyle ':completion:*:*:foo:*:*' tag-order '*' '*:-case'\n"
"zstyle ':completion:*-case' matcher 'm:@{a-z@}=@{A-Z@}'\n"
msgstr ""
"zstyle ':completion:*:*:foo:*:*' tag-order '*' '*:-case'\n"
"zstyle ':completion:*-case' matcher 'm:@{a-z@}=@{A-Z@}'\n"

#. type: table
#: zsh.texi:23671
msgid ""
"First, all the tags offered when completing after @t{foo} are tried using the normal tag name.  If that generates no matches, the second value of @t{tag-order} is used, which tries all tags again except "
"that this time each has @t{-case} appended to its name for lookup of styles.  Hence this time the value for the @t{matcher} style from the second call to @t{zstyle} in the example is used to make "
"completion case-insensitive."
msgstr ""
"首先，在 @t{foo} 之后补全时提供的所有标记都会使用正常的标记名称进行尝试。 如果没有匹配结果，则使用 @t{tag-order} 的第二个值，再次尝试所有标记，但这次每个标记的名称后都附加了 @t{-case}，以便查找样式。 因"
"此，这次将使用示例中第二次调用 @t{zstyle} 时的 @t{matcher} 样式值来完成补全，而不区分大小写。"

#. type: table
#: zsh.texi:23676
msgid "It is possible to use the @t{-e} option of the @t{zstyle} builtin command to specify conditions for the use of particular tags.  For example:"
msgstr "可以使用 @t{zstyle} 内置命令的 @t{-e} 选项来指定使用特定标记的条件。 例如:"

#. type: example
#: zsh.texi:23685
#, no-wrap
msgid ""
"zstyle -e '*:-command-:*' tag-order '\n"
"    if [[ -n $PREFIX$SUFFIX ]]; then\n"
"      reply=( )\n"
"    else\n"
"      reply=( - )\n"
"    fi'\n"
msgstr ""
"zstyle -e '*:-command-:*' tag-order '\n"
"    if [[ -n $PREFIX$SUFFIX ]]; then\n"
"      reply=( )\n"
"    else\n"
"      reply=( - )\n"
"    fi'\n"

#. type: table
#: zsh.texi:23697
msgid ""
"Completion in command position will be attempted only if the string typed so far is not empty.  This is tested using the @t{PREFIX} special parameter; see @ref{Completion Widgets} for a description of "
"parameters which are special inside completion widgets.  Setting @t{reply} to an empty array provides the default behaviour of trying all tags at once; setting it to an array containing only a hyphen "
"disables the use of all tags and hence of all completions."
msgstr ""
"只有当输入的字符串不为空时，才会尝试在命令位置补全。 这将通过 @t{PREFIX} 特殊参数进行测试；有关补全小部件内部特殊参数的描述，请参阅 @ref{补全小部件}。 将 @t{reply} 设置为空数组时，默认情况下会一次性尝试所"
"有标记；将其设置为仅包含连字符的数组时，则禁止使用所有标记，因此也无法使用所有补全。"

#. type: table
#: zsh.texi:23705
msgid ""
"If no @t{tag-order} style has been defined for a context, the strings `@t{(|*-)argument-* (|*-)option-* values}' and `@t{options}' plus all tags offered by the completion function will be used to provide "
"a sensible default behavior that causes arguments (whether normal command arguments or arguments of options) to be completed before option names for most commands."
msgstr ""
"如果没有为上下文定义 @t{tag-order} 样式，则将使用字符串 `@t{(|*-)argument-* (|*-)option-* values}' 和 `@t{options}' 以及补全函数提供的所有标记来提供合理的默认行为，在大多数命令中，参数（无论是普通命令参数"
"还是选项参数）将在选项名称之前补全。"

#. type: kindex
#: zsh.texi:23706
#, no-wrap
msgid "urls, completion style"
msgstr "urls, 补全样式"

#. type: table
#: zsh.texi:23710
msgid "This is used together with the @t{urls} tag by functions completing URLs."
msgstr "该标记与 @t{urls} 标记一起用于补全 URL 的函数。"

#. type: table
#: zsh.texi:23715
msgid "If the value consists of more than one string, or if the only string does not name a file or directory, the strings are used as the URLs to complete."
msgstr "如果值由多个字符串组成，或者唯一的字符串没有命名文件或目录，则这些字符串作为 URL 来补全。"

#. type: table
#: zsh.texi:23720
msgid "If the value contains only one string which is the name of a normal file the URLs are taken from that file (where the URLs may be separated by white space or newlines)."
msgstr "如果值中只包含一个字符串，即一个普通文件的名称，URL 将取自该文件（URL 之间可以用空格或换行分隔）。"

#. type: table
#: zsh.texi:23728
msgid ""
"Finally, if the only string in the value names a directory, the directory hierarchy rooted at this directory gives the completions.  The top level directory should be the file access method, such as "
"`@t{http}', `@t{ftp}', `@t{bookmark}' and so on.  In many cases the next level of directories will be a filename.  The directory hierarchy can descend as deep as necessary."
msgstr ""
"最后，如果值中唯一的字符串命名了一个目录，则根植于该目录的目录层次结构会给出补全。 顶层目录应是文件访问方式，如 `@t{http}', `@t{ftp}', `@t{bookmark}' 等。 在许多情况下，下一级目录将是文件名。 目录层次结构"
"可以根据需要尽可能深入。"

#. type: example
#: zsh.texi:23736
#, no-wrap
msgid ""
"zstyle ':completion:*' urls ~/.urls\n"
"mkdir -p ~/.urls/ftp/ftp.zsh.org/pub\n"
"\n"
msgstr ""
"zstyle ':completion:*' urls ~/.urls\n"
"mkdir -p ~/.urls/ftp/ftp.zsh.org/pub\n"
"\n"

#. type: table
#: zsh.texi:23745
msgid ""
"allows completion of all the components of the URL @t{ftp://ftp.zsh.org/pub} after suitable commands such as `@t{netscape}' or `@t{lynx}'.  Note, however, that access methods and files are completed "
"separately, so if the @t{hosts} style is set hosts can be completed without reference to the @t{urls} style."
msgstr ""
"允许在执行适当的命令（如 `@t{netscape}' 或`@t{lynx}'）后补全 URL @t{ftp://ftp.zsh.org/pub} 的所有组件。 但需要注意的是，访问方法和文件是分开补全的，因此如果设置了 @t{hosts} 样式，则可以在不参考 @t{urls} 样"
"式的情况下补全主机。"

#. type: table
#: zsh.texi:23749
msgid "See the description in the function @t{_urls} itself for more information (e.g. `@t{more $^fpath/_urls(N)}')."
msgstr "更多信息请参阅函数 @t{_urls} 本身的描述（例如 `@t{more $^fpath/_urls(N)}'）。"

#. type: kindex
#: zsh.texi:23750
#, no-wrap
msgid "use-cache, completion style"
msgstr "use-cache, 补全样式"

#. type: t{#1}
#: zsh.texi:23751
#, no-wrap
msgid "use-cache"
msgstr "use-cache"

#. type: table
#: zsh.texi:23756
msgid ""
"If this is set, the completion caching layer is activated for any completions which use it (via the @t{_store_cache}, @t{_retrieve_cache}, and @t{_cache_invalid} functions).  The directory containing the "
"cache files can be changed with the @t{cache-path} style."
msgstr "如果设置了该值，则会为任何使用该值的补全激活补全缓存层（通过 @t{_store_cache}、@t{_retrieve_cache} 和 @t{_cache_invalid} 函数）。 可以使用 @t{cache-path} 样式更改包含缓存文件的目录。"

#. type: kindex
#: zsh.texi:23757
#, no-wrap
msgid "use-compctl, completion style"
msgstr "use-compctl, 补全样式"

#. type: t{#1}
#: zsh.texi:23758
#, no-wrap
msgid "use-compctl"
msgstr "use-compctl"

#. type: table
#: zsh.texi:23766
msgid ""
"If this style is set to a string @emph{not} equal to @t{false}, @t{0}, @t{no}, and @t{off}, the completion system may use any completion specifications defined with the @t{compctl} builtin command.  If "
"the style is unset, this is done only if the @t{zsh/compctl} module is loaded.  The string may also contain the substring `@t{first}' to use completions defined with `@t{compctl -T}', and the substring "
"`@t{default}' to use the completion defined with `@t{compctl -D}'."
msgstr ""
"如果将此样式设置为 @emph{不} 等于 @t{false}、@t{0}、@t{no} 和 @t{off} 的字符串，补全系统可以使用 @t{compctl} 内置命令定义的任何补全规范。 如果未设置该样式，则只有在加载了 @t{zsh/compctl} 模块时才会这样"
"做。 该字符串还可以包含子字符串`@t{first}' ，以使用用 `@t{compctl -T}' 定义的补全，以及子字符串 `@t{default}'，以使用用 `@t{compctl -D}' 定义的补全。"

#. type: table
#: zsh.texi:23771
msgid "Note that this is only intended to smooth the transition from @t{compctl} to the new completion system and may disappear in the future."
msgstr "请注意，这只是为了从 @t{compctl} 向新的补全系统平稳过渡，将来可能会消失。"

#. type: table
#: zsh.texi:23779
msgid ""
"Note also that the definitions from @t{compctl} will only be used if there is no specific completion function for the command in question.  For example, if there is a function @t{_foo} to complete "
"arguments to the command @t{foo}, @t{compctl} will never be invoked for @t{foo}.  However, the @t{compctl} version will be tried if @t{foo} only uses default completion."
msgstr ""
"还请注意，只有在相关命令没有特定的补全函数时，才会使用 @t{compctl} 定义的。 例如，如果有一个函数 @t{_foo} 来补全命令 @t{foo} 的参数，那么 @t{compctl} 将不会被调用。 但是，如果 @t{foo} 只使用默认补全，则会"
"尝试 @t{compctl} 版本。"

#. type: kindex
#: zsh.texi:23780
#, no-wrap
msgid "use-ip, completion style"
msgstr "use-ip, 补全样式"

#. type: t{#1}
#: zsh.texi:23781
#, no-wrap
msgid "use-ip"
msgstr "use-ip"

#. type: table
#: zsh.texi:23789
msgid ""
"By default, the function @t{_hosts} that completes host names strips IP addresses from entries read from host databases such as NIS and ssh files.  If this style is `true', the corresponding IP addresses "
"can be completed as well.  This style is not use in any context where the @t{hosts} style is set; note also it must be set before the cache of host names is generated (typically the first completion "
"attempt)."
msgstr ""
"默认情况下，补全主机名的函数 @t{_hosts} 会从 NIS 和 ssh 文件等主机数据库读取的条目中剥离 IP 地址。 如果该样式为 `true'，则相应的 IP 地址也可以补全。 在任何设置了 @t{hosts} 样式的情况下，都不能使用该样式；"
"还需注意的是，必须在生成主机名缓存（通常是第一次补全尝试）之前设置该样式。"

#. type: kindex
#: zsh.texi:23790
#, no-wrap
msgid "users, completion style"
msgstr "users, 补全样式"

#. type: table
#: zsh.texi:23797
msgid ""
"This may be set to a list of usernames to be completed.  If it is not set all usernames will be completed.  Note that if it is set only that list of users will be completed; this is because on some "
"systems querying all users can take a prohibitive amount of time."
msgstr "可将其设置为待补全的用户名列表。 如果不设置，则将补全所有用户名。 请注意，如果设置了该选项，则只能补全该用户列表；这是因为在某些系统中，查询所有用户会耗费大量时间。"

#. type: kindex
#: zsh.texi:23798
#, no-wrap
msgid "users-hosts, completion style"
msgstr "users-hosts, 补全样式"

#. type: t{#1}
#: zsh.texi:23799
#, no-wrap
msgid "users-hosts"
msgstr "users-hosts"

#. type: table
#: zsh.texi:23806
msgid ""
"The values of this style should be of the form `@var{user}@t{@@}@var{host}' or `@var{user}@t{:}@var{host}'. It is used for commands that need pairs of user- and hostnames.  These commands will complete "
"usernames from this style (only), and will restrict subsequent hostname completion to hosts paired with that user in one of the values of the style."
msgstr ""
"该样式的值应为 `@var{user}@t{@@}@var{host}' 或 `@var{user}@t{:}@var{host}'。它用于需要成对用户名和主机名的命令。 这些命令将补全（仅）该样式中的用户名，并将限制后续主机名的补全，只能补全与该样式值之一中的用"
"户配对的主机。"

#. type: table
#: zsh.texi:23814
msgid ""
"It is possible to group values for sets of commands which allow a remote login, such as @t{rlogin} and @t{ssh}, by using the @t{my-accounts} tag.  Similarly, values for sets of commands which usually "
"refer to the accounts of other people, such as @t{talk} and @t{finger}, can be grouped by using the @t{other-accounts} tag.  More ambivalent commands may use the @t{accounts} tag."
msgstr ""
"可以使用 @t{my-accounts} 标记对允许远程登录的命令集的值进行分组，如 @t{rlogin} 和 @t{ssh}。 同样，对于通常指向他人账户的命令集（如 @t{talk} 和 @t{finger}），也可以使用 @t{other-accounts} 标记进行分组。 比"
"较矛盾的命令可以使用 @t{accounts} 标记。"

#. type: kindex
#: zsh.texi:23815
#, no-wrap
msgid "users-hosts-ports, completion style"
msgstr "users-hosts-ports, 补全样式"

#. type: t{#1}
#: zsh.texi:23816
#, no-wrap
msgid "users-hosts-ports"
msgstr "users-hosts-ports"

#. type: table
#: zsh.texi:23819
msgid "Like @t{users-hosts} but used for commands like @t{telnet} and containing strings of the form `@var{user}@t{@@}@var{host}@t{:}@var{port}'."
msgstr "与 @t{users-hosts} 类似，但用于执行 @t{telnet} 等命令，并包含格式为 `@var{user}@t{@@}@var{host}@t{:}@var{port}' 的字符串。"

#. type: kindex
#: zsh.texi:23820
#, no-wrap
msgid "verbose, completion style"
msgstr "verbose, 补全样式"

#. type: t{#1}
#: zsh.texi:23821 zsh.texi:39781
#, no-wrap
msgid "verbose"
msgstr "verbose"

#. type: table
#: zsh.texi:23825
msgid "If set, as it is by default, the completion listing is more verbose.  In particular many commands show descriptions for options if this style is `true'."
msgstr "如果设置(默认)，则补全列表会更加详细。 特别是，如果该样式为 `true'，许多命令都会显示选项说明。"

#. type: kindex
#: zsh.texi:23826
#, no-wrap
msgid "word, completion style"
msgstr "word, 补全样式"

#. type: t{#1}
#: zsh.texi:23827
#, no-wrap
msgid "word"
msgstr "word"

#. type: table
#: zsh.texi:23835
msgid ""
"This is used by the @t{_list} completer, which prevents the insertion of completions until a second completion attempt when the line has not changed.  The normal way of finding out if the line has changed "
"is to compare its entire contents between the two occasions.  If this style is `true', the comparison is instead performed only on the current word.  Hence if completion is performed on another word with "
"the same contents, completion will not be delayed."
msgstr ""
"@t{_list} 补全器使用了这一功能，它可以防止插入补全，直到第二次补全尝试时行内容未发生变化。 正常情况下，要确定该行是否已更改，需要在两次尝试中比较其全部内容。 如果该样式为 `true'，则只对当前单词进行比较。 "
"因此，如果在内容相同的另一个字上执行补全，补全将不会延迟。"

#. type: node
#: zsh.texi:23839 zsh.texi:24336 zsh.texi:24338 zsh.texi:24562
#, no-wrap
msgid "Bindable Commands"
msgstr "可绑定命令"

#. type: cindex
#: zsh.texi:23843
#, no-wrap
msgid "completion system, choosing completers"
msgstr "补全系统, 选择补全器"

#. type: Plain text
#: zsh.texi:23855
msgid ""
"The initialization script @t{compinit} redefines all the widgets which perform completion to call the supplied widget function @t{_main_complete}.  This function acts as a wrapper calling the so-called "
"`completer' functions that generate matches.  If @t{_main_complete} is called with arguments, these are taken as the names of completer functions to be called in the order given.  If no arguments are "
"given, the set of functions to try is taken from the @t{completer} style.  For example, to use normal completion and correction if that doesn't generate any matches:"
msgstr ""
"初始化脚本 @t{compinit} 会重新定义所有执行补全的小部件，以调用提供的小部件函数 @t{_main_complete}。 该函数作为一个包装器，调用生成匹配的所谓 `completer' 函数。 如果 @t{_main_complete} 是带参数调用的，那么"
"这些参数将作为按给定顺序调用的补全函数名称。 如果没有给定参数，则从 @t{completer} 样式中获取要尝试的函数集。 例如，使用正常补全，如果不能生成任何匹配，则进行修正："

#. type: example
#: zsh.texi:23859
#, no-wrap
msgid "zstyle ':completion:*' completer _complete _correct\n"
msgstr "zstyle ':completion:*' completer _complete _correct\n"

#. type: Plain text
#: zsh.texi:23869
msgid ""
"after calling @t{compinit}. The default value for this style is `@t{_complete _ignored}', i.e. normally only ordinary completion is tried, first with the effect of the @t{ignored-patterns} style and then "
"without it.  The @t{_main_complete} function uses the return status of the completer functions to decide if other completers should be called.  If the return status is zero, no other completers are tried "
"and the @t{_main_complete} function returns."
msgstr ""
"在调用 @t{compinit} 之后。该样式的默认值为 `@t{_complete _ignored}'，即通常只尝试普通补全，先使用 @t{ignored-patterns} 样式的效果，然后不使用。 @t{_main_complete} 函数使用补全函数的返回状态来决定是否调用其"
"他补全器。 如果返回状态为零，则不尝试其他补全器，并返回 @t{_main_complete} 函数。"

#. type: Plain text
#: zsh.texi:23876
msgid ""
"If the first argument to @t{_main_complete} is a single hyphen, the arguments will not be taken as names of completers.  Instead, the second argument gives a name to use in the @var{completer} field of "
"the context and the other arguments give a command name and arguments to call to generate the matches."
msgstr ""
"如果 @t{_main_complete} 的第一个参数是单个连字符，则不会将参数作为补全器的名称。 相反，第二个参数会给出一个名称，用于上下文的 @var{completer} 字段，其他参数会给出一个命令名称和参数s，用于调用生成匹配。"

#. type: Plain text
#: zsh.texi:23882
msgid ""
"The following completer functions are contained in the distribution, although users may write their own.  Note that in contexts the leading underscore is stripped, for example basic completion is "
"performed in the context `@t{:completion::complete:}@var{...}'."
msgstr "尽管用户可以编写自己的补全函数，但发行版中包含以下补全函数。 请注意，在上下文中，前导下划线会被去掉，例如，基本补全是在上下文 `@t{:completion::complete:}@var{...}' 中执行的。"

#. type: cindex
#: zsh.texi:23884
#, no-wrap
msgid "completion system, completers"
msgstr "补全系统, 补全器"

#. type: t{#1}
#: zsh.texi:23886 zsh.texi:23887
#, no-wrap
msgid "_all_matches"
msgstr "_all_matches"

#. type: table
#: zsh.texi:23892
msgid ""
"This completer can be used to add a string consisting of all other matches.  As it influences later completers it must appear as the first completer in the list.  The list of all matches is affected by "
"the @t{avoid-completer} and @t{old-matches} styles described above."
msgstr "该补全器可用于添加一个由所有其他匹配项组成的字符串。 由于它会影响后面的补全器，因此必须作为列表中的第一个补全器出现。 所有匹配列表都会受到上述 @t{avoid-completer} 和 @t{old-matches} 样式的影响。"

#. type: table
#: zsh.texi:23896
msgid "It may be useful to use the @t{_generic} function described below to bind @t{_all_matches} to its own keystroke, for example:"
msgstr "例如，使用下面描述的 @t{_generic} 函数将 @t{_all_matches} 与自己的按键绑定，可能会很有用："

#. type: example
#: zsh.texi:23903
#, no-wrap
msgid ""
"zle -C all-matches complete-word _generic\n"
"bindkey '^Xa' all-matches\n"
"zstyle ':completion:all-matches:*' old-matches only\n"
"zstyle ':completion:all-matches::::' completer _all_matches\n"
msgstr ""
"zle -C all-matches complete-word _generic\n"
"bindkey '^Xa' all-matches\n"
"zstyle ':completion:all-matches:*' old-matches only\n"
"zstyle ':completion:all-matches::::' completer _all_matches\n"

#. type: table
#: zsh.texi:23911
msgid ""
"Note that this does not generate completions by itself: first use any of the standard ways of generating a list of completions, then use @t{^Xa} to show all matches.  It is possible instead to add a "
"standard completer to the list and request that the list of all matches should be directly inserted:"
msgstr "请注意，这本身并不会生成补全：首先使用任何标准方法生成补全列表，然后使用 @t{^Xa} 显示所有匹配。 您可以在列表中添加一个标准补全器，并要求直接插入所有匹配列表："

#. type: example
#: zsh.texi:23917
#, no-wrap
msgid ""
"zstyle ':completion:all-matches::::' completer \\ \n"
"       _all_matches _complete\n"
"zstyle ':completion:all-matches:*' insert true\n"
msgstr ""
"zstyle ':completion:all-matches::::' completer \\ \n"
"       _all_matches _complete\n"
"zstyle ':completion:all-matches:*' insert true\n"

#. type: table
#: zsh.texi:23921
msgid "In this case the @t{old-matches} style should not be set."
msgstr "在这种情况下，不应设置 @t{old-matches} 样式。"

#. type: t{#1}
#: zsh.texi:23922 zsh.texi:23923
#, no-wrap
msgid "_approximate"
msgstr "_approximate"

#. type: table
#: zsh.texi:23931
msgid ""
"This is similar to the basic @t{_complete} completer but allows the completions to undergo corrections.  The maximum number of errors can be specified by the @t{max-errors} style; see the description of "
"approximate matching in @ref{Filename Generation} for how errors are counted.  Normally this completer will only be tried after the normal @t{_complete} completer:"
msgstr ""
"这与基本的 @t{_complete} 补全器类似，但允许对补全内容进行修正。 错误的最大数量可以通过 @t{max-errors} 样式指定；关于如何计算错误，请参阅 @ref{文件名生成} 中关于近似匹配的描述。 通常情况下，该补全器只会在正"
"常的 @t{_complete} 补全器之后尝试："

#. type: example
#: zsh.texi:23935
#, no-wrap
msgid "zstyle ':completion:*' completer _complete _approximate\n"
msgstr "zstyle ':completion:*' completer _complete _approximate\n"

#. type: table
#: zsh.texi:23942
msgid ""
"This will give correcting completion if and only if normal completion yields no possible completions.  When corrected completions are found, the completer will normally start menu completion allowing you "
"to cycle through these strings."
msgstr "只有在正常补全没有结果的情况下，才会给出修正补全。 当找到修正补全时，补全器通常会启动菜单补全，允许您循环查看这些字符串。"

#. type: table
#: zsh.texi:23950
msgid ""
"This completer uses the tags @t{corrections} and @t{original} when generating the possible corrections and the original string.  The @t{format} style for the former may contain the additional sequences "
"`@t{%e}' and `@t{%o}' which will be replaced by the number of errors accepted to generate the corrections and the original string, respectively."
msgstr ""
"该补全器在生成可能的更正和原始字符串时使用 @t{corrections} 和 @t{original} 标记。 前者的 @t{format} 样式可能包含额外的序列 `@t{%e}' 和 `@t{%o}' ，它们将分别被生成更正和原始字符串时接受的错误数所取代。"

#. type: table
#: zsh.texi:23958
msgid ""
"The completer progressively increases the number of errors allowed up to the limit by the @t{max-errors} style, hence if a completion is found with one error, no completions with two errors will be shown, "
"and so on.  It modifies the completer name in the context to indicate the number of errors being tried: on the first try the completer field contains `@t{approximate-1}', on the second try "
"`@t{approximate-2}', and so on."
msgstr ""
"补全器会逐步增加允许的错误数，直至达到 @t{max-errors} 样式的限制，因此如果发现一个补全有一个错误，就不会显示有两个错误的补全，以此类推。 它会修改上下文中的补全器名称，以显示正在尝试的错误数：第一次尝试时，"
"补全器字段包含 `@t{approximate-1}'，第二次尝试时包含 `@t{approximate-2}'，以此类推。"

#. type: table
#: zsh.texi:23963
msgid ""
"When @t{_approximate} is called from another function, the number of errors to accept may be passed with the @t{-a} option.  The argument is in the same format as the @t{max-errors} style, all in one "
"string."
msgstr "当 @t{_approximate} 从其他函数调用时，可以通过 @t{-a} 选项传递接受的错误数。 参数的格式与 @t{max-errors} 样式相同，都在一个字符串中。"

#. type: table
#: zsh.texi:23971
msgid ""
"Note that this completer (and the @t{_correct} completer mentioned below) can be quite expensive to call, especially when a large number of errors are allowed.  One way to avoid this is to set up the "
"@t{completer} style using the @t{-e} option to zstyle so that some completers are only used when completion is attempted a second time on the same string, e.g.:"
msgstr ""
"需要注意的是，这个补全器（以及下面提到的 @t{_correct} 补全器）的调用代价可能会相当高昂，尤其是在允许出现大量错误的情况下。 避免这种情况的方法之一是使用 zstyle 的 @t{-e} 选项来设置 @t{completer} 样式，这样"
"只有在对同一字符串进行第二次补全尝试时才会使用某些补全器，例如："

#. type: example
#: zsh.texi:23981
#, no-wrap
msgid ""
"zstyle -e ':completion:*' completer '\n"
"  if [[ $_last_try != \"$HISTNO$BUFFER$CURSOR\" ]]; then\n"
"    _last_try=\"$HISTNO$BUFFER$CURSOR\"\n"
"    reply=(_complete _match _prefix)\n"
"  else\n"
"    reply=(_ignored _correct _approximate)\n"
"  fi'\n"
msgstr ""
"zstyle -e ':completion:*' completer '\n"
"  if [[ $_last_try != \"$HISTNO$BUFFER$CURSOR\" ]]; then\n"
"    _last_try=\"$HISTNO$BUFFER$CURSOR\"\n"
"    reply=(_complete _match _prefix)\n"
"  else\n"
"    reply=(_ignored _correct _approximate)\n"
"  fi'\n"

#. type: table
#: zsh.texi:23989
msgid ""
"This uses the @t{HISTNO} parameter and the @t{BUFFER} and @t{CURSOR} special parameters that are available inside zle and completion widgets to find out if the command line hasn't changed since the last "
"time completion was tried.  Only then are the @t{_ignored}, @t{_correct} and @t{_approximate} completers called."
msgstr ""
"它会使用 @t{HISTNO} 参数和 @t{BUFFER} 及 @t{CURSOR} 特殊参数（这些参数在 zle 和补全小部件中可用）来查找命令行自上次尝试补全后是否未发生变化。 只有这样，才会调用 @t{_ignored}、@t{_correct} 和 "
"@t{_approximate} 补全函数。"

#. type: findex
#: zsh.texi:23990
#, no-wrap
msgid "_canonical_paths"
msgstr "_canonical_paths"

#. type: item
#: zsh.texi:23991
#, no-wrap
msgid "@t{_canonical_paths} [ @t{-A} @var{var} ] [ @t{-N} ] [ @t{-MJV12nfX} ] @var{tag} @var{descr} [ @var{paths} ... ]"
msgstr "@t{_canonical_paths} [ @t{-A} @var{var} ] [ @t{-N} ] [ @t{-MJV12nfX} ] @var{tag} @var{descr} [ @var{paths} ... ]"

#. type: table
#: zsh.texi:23996
msgid ""
"This completion function completes all paths given to it, and also tries to offer completions which point to the same file as one of the paths given (relative path when an absolute path is given, and vice "
"versa; when @t{..}'s are present in the word to be completed; and some paths got from symlinks)."
msgstr "该补全函数会补全所有给定的路径，并尝试提供与给定路径指向相同文件的补全（当给定绝对路径时为相对路径，反之亦然；当待补全的单词中存在 @t{..} 时；以及从符号链接中获得的某些路径）。"

#. type: table
#: zsh.texi:24003
msgid ""
"@t{-A}, if specified, takes the paths from the array variable specified. Paths can also be specified on the command line as shown above.  @t{-N}, if specified, prevents canonicalizing the paths given "
"before using them for completion, in case they are already so. The options @t{-M}, @t{-J}, @t{-V}, @t{-1}, @t{-2}, @t{-n}, @t{-F}, @t{-X} are passed to @t{compadd}."
msgstr ""
"如果指定了 @t{-A}，则会从指定的数组变量中获取路径。路径也可以如上所示在命令行中指定。 如果指定了 @t{-N}，则可以防止在使用所给路径进行补全之前将其规范化，假设它们已经这样规范化。选项 @t{-M}、@t{-J}、@t{-"
"V}、@t{-1}、@t{-2}、@t{-n}、@t{-F}、@t{-X} 会传递给 @t{compadd}。"

#. type: table
#: zsh.texi:24006
msgid "See @t{_description} for a description of @var{tag} and @var{descr}."
msgstr "有关 @var{tag} 和 @var{descr} 的说明，请参见 @t{_description}。"

#. type: t{#1}
#: zsh.texi:24007 zsh.texi:24008
#, no-wrap
msgid "_cmdambivalent"
msgstr "_cmdambivalent"

#. type: table
#: zsh.texi:24015
msgid ""
"Completes the remaining positional arguments as an external command.  The external command and its arguments are completed as separate arguments (in a manner appropriate for completing @t{/usr/bin/env})  "
"if there are two or more remaining positional arguments on the command line, and as a quoted command string (in the manner of @t{system(...)}) otherwise.  See also @t{_cmdstring} and @t{_precommand}."
msgstr ""
"将剩余的位置参数作为外部命令补全。 如果命令行上有两个或两个以上的剩余位置参数，外部命令及其参数将作为单独的参数（以补全 @t{/usr/bin/env} 的适当方式）补全，否则将作为带引号的命令字符串（以 @t{system(...)} "
"的方式）补全。 另请参见 @t{_cmdstring} 和 @t{_precommand}。"

#. type: table
#: zsh.texi:24018
msgid "This function takes no arguments."
msgstr "该函数不带参数。"

#. type: t{#1}
#: zsh.texi:24019 zsh.texi:24020
#, no-wrap
msgid "_cmdstring"
msgstr "_cmdstring"

#. type: table
#: zsh.texi:24023
msgid "Completes an external command as a single argument, as for @t{system(...)}."
msgstr "以单个参数形式补全外部命令，如 @t{system(...)}。"

#. type: t{#1}
#: zsh.texi:24024 zsh.texi:24025
#, no-wrap
msgid "_complete"
msgstr "_complete"

#. type: table
#: zsh.texi:24030
msgid ""
"This completer generates all possible completions in a context-sensitive manner, i.e. using the settings defined with the @t{compdef} function explained above and the current settings of all special "
"parameters.  This gives the normal completion behaviour."
msgstr "该补全器以上下文相关的方式生成所有可能的补全，即使用上文解释的 @t{compdef} 函数定义的设置以及所有特殊参数的当前设置。 这就给出了正常的补全行为。"

#. type: table
#: zsh.texi:24037
msgid ""
"To complete arguments of commands, @t{_complete} uses the utility function @t{_normal}, which is in turn responsible for finding the particular function; it is described below.  Various contexts of the "
"form @t{-}@var{context}@t{-} are handled specifically. These are all mentioned above as possible arguments to the @t{#compdef} tag."
msgstr ""
"为了补全命令的参数，@t{_complete} 使用了实用函数 @t{_normal}，该函数又负责查找特定的函数；下文将对其进行介绍。 @t{-}@var{context}@t{-} 形式的各种上下文会特殊处理。上面提到的这些都是 @t{#compdef} 标记的可能"
"参数。"

#. type: table
#: zsh.texi:24053
msgid ""
"Before trying to find a function for a specific context, @t{_complete} checks if the parameter `@t{compcontext}' is set. Setting `@t{compcontext}' allows the usual completion dispatching to be overridden "
"which is useful in places such as a function that uses @t{vared} for input. If it is set to an array, the elements are taken to be the possible matches which will be completed using the tag `@t{values}' "
"and the description `@t{value}'. If it is set to an associative array, the keys are used as the possible completions and the values (if non-empty) are used as descriptions for the matches.  If "
"`@t{compcontext}' is set to a string containing colons, it should be of the form `@var{tag}@t{:}@var{descr}@t{:}@var{action}'.  In this case the @var{tag} and @var{descr} give the tag and description to "
"use and the @var{action} indicates what should be completed in one of the forms accepted by the @t{_arguments} utility function described below."
msgstr ""
"在尝试为特定上下文查找函数之前，@t{_complete} 会检查参数`@t{compcontext}' 是否已设置。设置 `@t{compcontext}' 可以覆盖通常的补全调度，这在使用 @t{vared} 作为输入的函数等地方非常有用。如果将其设置为数组，则"
"元素将被视为可能的匹配项，这些匹配项将使用标记`@t{values}' 和描述 `@t{value}' 来补全。如果设置为关联数组，则键被用作可能的补全，值（如果非空）被用作匹配的描述。 如果将`@t{compcontext}' 设置为包含冒号的字符"
"串，则其形式应为 `@var{tag}@t{:}@var{descr}@t{:}@var{action}'。 在这种情况下，@var{tag} 和 @var{descr} 给出了要使用的标记和描述，@var{action} 则表示应以下面描述的 @t{_arguments} 实用程序函数所接受的形式之"
"一来补全。"

#. type: table
#: zsh.texi:24061
msgid ""
"Finally, if `@t{compcontext}' is set to a string without colons, the value is taken as the name of the context to use and the function defined for that context will be called.  For this purpose, there is "
"a special context named @t{-command-line-} that completes whole command lines (commands and their arguments).  This is not used by the completion system itself but is nonetheless handled when explicitly "
"called."
msgstr ""
"最后，如果将 `@t{compcontext}' 设置为不带冒号的字符串，则该值将作为要使用的上下文名称，并调用为该上下文定义的函数。 为此，有一种名为 @t{-command-line-}的特殊上下文可以补全整条命令行（命令及其参数）。 补全"
"系统本身并不使用该上下文，但在明确调用时会对其进行处理。"

#. type: t{#1}
#: zsh.texi:24062 zsh.texi:24063
#, no-wrap
msgid "_correct"
msgstr "_correct"

#. type: table
#: zsh.texi:24069
msgid ""
"Generate corrections, but not completions, for the current word; this is similar to @t{_approximate} but will not allow any number of extra characters at the cursor as that completer does.  The effect is "
"similar to spell-checking.  It is based on @t{_approximate}, but the completer field in the context name is @t{correct}."
msgstr ""
"为当前单词生成更正，但不生成补全；这与 @t{_approximate} 类似，但不会像该补全器那样允许光标处出现任何数量的额外字符。 其效果类似于拼写检查。 它基于 @t{_approximate}，但上下文名称中的补全器字段是 "
"@t{correct}。"

#. type: table
#: zsh.texi:24072
msgid "For example, with:"
msgstr "例如："

#. type: example
#: zsh.texi:24079
#, no-wrap
msgid ""
"zstyle ':completion:::::' completer \\ \n"
"       _complete _correct _approximate\n"
"zstyle ':completion:*:correct:::' max-errors 2 not-numeric\n"
"zstyle ':completion:*:approximate:::' max-errors 3 numeric\n"
msgstr ""
"zstyle ':completion:::::' completer \\ \n"
"       _complete _correct _approximate\n"
"zstyle ':completion:*:correct:::' max-errors 2 not-numeric\n"
"zstyle ':completion:*:approximate:::' max-errors 3 numeric\n"

#. type: table
#: zsh.texi:24088
msgid ""
"correction will accept up to two errors.  If a numeric argument is given, correction will not be performed, but correcting completion will be, and will accept as many errors as given by the numeric "
"argument.  Without a numeric argument, first correction and then correcting completion will be tried, with the first one accepting two errors and the second one accepting three errors."
msgstr ""
"更正最多接受两个错误。 如果给出了数字参数，则不会执行修正，但会执行更正补全，并接受与数字参数相同数量的错误。 在没有数字参数的情况下，将先尝试修正，然后再尝试更正补全，前者接受两个错误，后者接受三个错误。"

#. type: table
#: zsh.texi:24093
msgid ""
"When @t{_correct} is called as a function, the number of errors to accept may be given following the @t{-a} option.  The argument is in the same form a values to the @t{accept} style, all in one string."
msgstr "当 @t{_correct} 作为函数调用时，可以在 @t{-a} 选项后给出要接受的错误数量。 参数的形式与 @t{accept} 样式的值相同，都在一个字符串中。"

#. type: table
#: zsh.texi:24100
msgid ""
"This completer function is intended to be used without the @t{_approximate} completer or, as in the example, just before it.  Using it after the @t{_approximate} completer is useless since "
"@t{_approximate} will at least generate the corrected strings generated by the @t{_correct} completer --- and probably more."
msgstr ""
"该补全函数可以在不使用 @t{_approximate} 补全函数的情况下使用，或者像示例中那样，在 @t{_approximate} 补全函数之前使用。 在 @t{_approximate} 补全函数之后使用该函数是没有用的，因为 @t{_approximate} 至少会生"
"成 @t{_correct} 补全函数生成的修正字符串 --- 可能还会更多。"

#. type: t{#1}
#: zsh.texi:24101 zsh.texi:24102
#, no-wrap
msgid "_expand"
msgstr "_expand"

#. type: table
#: zsh.texi:24112
msgid ""
"This completer function does not really perform completion, but instead checks if the word on the command line is eligible for expansion and, if it is, gives detailed control over how this expansion is "
"done.  For this to happen, the completion system needs to be invoked with @t{complete-word}, not @t{expand-or-complete} (the default binding for @t{TAB}), as otherwise the string will be expanded by the "
"shell's internal mechanism before the completion system is started.  Note also this completer should be called before the @t{_complete} completer function."
msgstr ""
"该补全函数并不真正执行补全，而是检查命令行中的单词是否符合扩展条件，如果符合，则详细控制如何进行扩展。 为此，需要使用 @t{complete-word} 而不是 @t{expand-or-complete}（@t{TAB} 的默认绑定）来调用补全系统，否"
"则字符串将在补全系统启动之前被 shell 的内部机制展开。 还请注意，此补全函数应在 @t{_complete} 补全函数之前调用。"

#. type: table
#: zsh.texi:24120
msgid ""
"The tags used when generating expansions are @t{all-expansions} for the string containing all possible expansions, @t{expansions} when adding the possible expansions as single matches and @t{original} "
"when adding the original string from the line.  The order in which these strings are generated, if at all, can be controlled by the @t{group-order} and @t{tag-order} styles, as usual."
msgstr ""
"生成扩展时使用的标记有：@t{all-expansions}，用于包含所有可能扩展的字符串；@t{expansions}，用于将可能的扩展作为单个匹配项添加；@t{original}，用于添加该行的原始字符串。 这些字符串的生成顺序（如果有的话）可以"
"像往常一样由 @t{group-order} 和 @t{tag-order} 样式控制。"

#. type: table
#: zsh.texi:24125
msgid "The format string for @t{all-expansions} and for @t{expansions} may contain the sequence `@t{%o}' which will be replaced by the original string from the line."
msgstr "@t{all-expansions} 和 @t{expansions} 的格式字符串可能包含 `@t{%o}' 序列，该序列将被该行的原始字符串替换。"

#. type: table
#: zsh.texi:24129
msgid "The kind of expansion to be tried is controlled by the @t{substitute}, @t{glob} and @t{subst-globs-only} styles."
msgstr "要尝试的扩展类型由 @t{substitute}、@t{glob} 和 @t{subst-globs-only} 样式控制。"

#. type: table
#: zsh.texi:24134
msgid ""
"It is also possible to call @t{_expand} as a function, in which case the different modes may be selected with options: @t{-s} for @t{substitute}, @t{-g} for @t{glob} and @t{-o} for @t{subst-globs-only}."
msgstr "也可以将 @t{_expand} 作为函数调用，在这种情况下，可以通过选项选择不同的模式： @t{-s} 表示 @t{substitute}，@t{-g} 表示 @t{glob} ，@t{-o} 表示 @t{subst-globs-only}。"

#. type: t{#1}
#: zsh.texi:24135 zsh.texi:24136
#, no-wrap
msgid "_expand_alias"
msgstr "_expand_alias"

#. type: table
#: zsh.texi:24140
msgid ""
"If the word the cursor is on is an alias, it is expanded and no other completers are called.  The types of aliases which are to be expanded can be controlled with the styles @t{regular}, @t{global} and "
"@t{disabled}."
msgstr "如果光标所在的单词是别名，则会展开该别名，而不会调用其他补全器。 可以使用 @t{regular}、@t{global} 和 @t{disabled} 样式来控制要展开的别名类型。"

#. type: table
#: zsh.texi:24144
msgid "This function is also a bindable command, see @ref{Bindable Commands}."
msgstr "该函数也是一个可绑定命令，请参阅 @ref{可绑定命令}。"

#. type: t{#1}
#: zsh.texi:24145 zsh.texi:24146
#, no-wrap
msgid "_extensions"
msgstr "_extensions"

#. type: table
#: zsh.texi:24153
msgid ""
"If the cursor follows the string `@t{*.}', filename extensions are completed. The extensions are taken from files in current directory or a directory specified at the beginning of the current word. For "
"exact matches, completion continues to allow other completers such as @t{_expand} to expand the pattern. The standard @t{add-space} and @t{prefix-hidden} styles are observed."
msgstr ""
"如果光标跟随字符串 `@t{*.}'，则补全文件扩展名。扩展名取自当前目录下的文件或指定以当前单词开头的目录。对于完全匹配，补全继续允许 @t{_expand} 等其他补全器扩展模式。标准的 @t{add-space} 和 @t{prefix-hidden} "
"样式会被遵守。"

#. type: t{#1}
#: zsh.texi:24154 zsh.texi:24155
#, no-wrap
msgid "_external_pwds"
msgstr "_external_pwds"

#. type: table
#: zsh.texi:24158
msgid "Completes current directories of other zsh processes belonging to the current user."
msgstr "补全属于当前用户的其他 zsh 进程的当前目录。"

#. type: table
#: zsh.texi:24163
msgid "This is intended to be used via @t{_generic}, bound to a custom key combination. Note that pattern matching is enabled so matching is performed similar to how it works with the @t{_match} completer."
msgstr "它通过 @t{_generic} 与自定义组合键绑定使用。请注意，模式匹配已启用，因此匹配的执行方式与 @t{_match} 补全器类似。"

#. type: t{#1}
#: zsh.texi:24164 zsh.texi:24165
#, no-wrap
msgid "_history"
msgstr "_history"

#. type: table
#: zsh.texi:24172
msgid ""
"Complete words from the shell's command history.  This completer can be controlled by the @t{remove-all-dups}, and @t{sort} styles as for the @t{_history_complete_word} bindable command, see @ref{Bindable "
"Commands} and @ref{Completion System Configuration}."
msgstr "补全 shell 历史命令中的单词。 该补全器可由 @t{remove-all-dups} 和 @t{sort} 样式控制，正如 @t{_history_complete_word} 可绑定命令一样，请参阅 @ref{可绑定命令} 和 @ref{补全系统配置}。"

#. type: t{#1}
#: zsh.texi:24173 zsh.texi:24174
#, no-wrap
msgid "_ignored"
msgstr "_ignored"

#. type: table
#: zsh.texi:24182
msgid ""
"The @t{ignored-patterns} style can be set to a list of patterns which are compared against possible completions; matching ones are removed.  With this completer those matches can be reinstated, as if no "
"@t{ignored-patterns} style were set.  The completer actually generates its own list of matches; which completers are invoked is determined in the same way as for the @t{_prefix} completer.  The @t{single-"
"ignored} style is also available as described above."
msgstr ""
"可以将 @t{ignored-patterns} 样式设置为一个模式列表，并将其与可能的补全进行比较；匹配的模式将被删除。 有了这个补全器，就可以恢复这些匹配，就像没有设置 @t{ignored-patterns} 样式一样。 补全器实际上会生成自己"
"的匹配列表；调用哪些补全器的决定方与 @t{_prefix} 补全器相同。 如上所述，还可以使用 @t{single-ignored} 样式。"

#. type: t{#1}
#: zsh.texi:24183 zsh.texi:24184
#, no-wrap
msgid "_list"
msgstr "_list"

#. type: table
#: zsh.texi:24190
msgid ""
"This completer allows the insertion of matches to be delayed until completion is attempted a second time without the word on the line being changed.  On the first attempt, only the list of matches will be "
"shown.  It is affected by the styles @t{condition} and @t{word}, see @ref{Completion System Configuration}."
msgstr "该补全器允许延迟插入匹配内容，直到第二次尝试补全时，行上的单词才会被更改。 第一次尝试时，只显示匹配列表。 它受 @t{condition} 和 @t{word} 样式的影响，参见 @ref{补全系统配置}。"

#. type: t{#1}
#: zsh.texi:24191 zsh.texi:24192
#, no-wrap
msgid "_match"
msgstr "_match"

#. type: table
#: zsh.texi:24197
msgid ""
"This completer is intended to be used after the @t{_complete} completer.  It behaves similarly but the string on the command line may be a pattern to match against trial completions.  This gives the "
"effect of the @t{GLOB_COMPLETE} option."
msgstr "该补全器用于 @t{_complete} 补全器之后。 它的行为类似，但命令行上的字符串可以是与试用补全匹配的模式。 它具有 @t{GLOB_COMPLETE} 选项的效果。"

#. type: table
#: zsh.texi:24203
msgid ""
"Normally completion will be performed by taking the pattern from the line, inserting a `@t{*}' at the cursor position and comparing the resulting pattern with the possible completions generated.  This can "
"be modified with the @t{match-original} style described above."
msgstr "通常情况下，补全是通过从行中提取模式，在光标位置插入 `@t{*}' ，然后将生成的模式与可能的补全进行比较。 这可以通过上述 @t{match-original} 样式进行修改。"

#. type: table
#: zsh.texi:24208
msgid "The generated matches will be offered in a menu completion unless the @t{insert-unambiguous} style is set to `true'; see the description above for other options for this style."
msgstr "除非 @t{insert-unambiguous} 样式设置为 `true'，否则生成的匹配结果将在菜单补全中提供；有关该样式的其他选项，请参阅上文的说明。"

#. type: table
#: zsh.texi:24213
msgid "Note that matcher specifications defined globally or used by the completion functions (the styles @t{matcher-list} and @t{matcher}) will not be used."
msgstr "请注意，全局定义的或补全函数使用的匹配器规范（样式 @t{matcher-list} 和 @t{matcher}），不会被使用。"

#. type: t{#1}
#: zsh.texi:24214 zsh.texi:24215
#, no-wrap
msgid "_menu"
msgstr "_menu"

#. type: table
#: zsh.texi:24224
msgid ""
"This completer was written as simple example function to show how menu completion can be enabled in shell code. However, it has the notable effect of disabling menu selection which can be useful with "
"@t{_generic} based widgets. It should be used as the first completer in the list.  Note that this is independent of the setting of the @t{MENU_COMPLETE} option and does not work with the other menu "
"completion widgets such as @t{reverse-menu-complete}, or @t{accept-and-menu-complete}."
msgstr ""
"该补全器是作为一个简单的示例函数编写的，用于展示如何在 shell 代码中启用菜单补全功能。不过，它也有一个显著的效果，就是禁用了菜单选择功能，这对基于 @t{_generic} 的小部件很有用。它应作为列表中的第一个补全器使"
"用。 请注意，这与 @t{MENU_COMPLETE} 选项的设置无关，并且不能与 @t{reverse-menu-complete} 或 @t{accept-and-menu-complete} 等其他菜单补全小部件一起使用。"

#. type: t{#1}
#: zsh.texi:24225 zsh.texi:24226
#, no-wrap
msgid "_oldlist"
msgstr "_oldlist"

#. type: table
#: zsh.texi:24237
msgid ""
"This completer controls how the standard completion widgets behave when there is an existing list of completions which may have been generated by a special completion (i.e. a separately-bound completion "
"command).  It allows the ordinary completion keys to continue to use the list of completions thus generated, instead of producing a new list of ordinary contextual completions.  It should appear in the "
"list of completers before any of the widgets which generate matches.  It uses two styles: @t{old-list} and @t{old-menu}, see @ref{Completion System Configuration}."
msgstr ""
"在存在由特殊补全（即单独绑定的补全命令）生成的现有补全列表时，该补全器可控制标准补全部件的行为。 它允许普通补全键继续使用由此生成的补全列表，而不是生成一个新的普通上下文补全列表。 它应该在任何生成匹配的小"
"部件之前，出现在补全器列表中，。 它使用两种样式： @t{old-list} 和 @t{old-menu}，请参阅 @ref{补全系统配置}。"

#. type: t{#1}
#: zsh.texi:24238 zsh.texi:24239
#, no-wrap
msgid "_precommand"
msgstr "_precommand"

#. type: table
#: zsh.texi:24242
msgid "Complete an external command in word-separated arguments, as for @t{exec} and @t{/usr/bin/env}."
msgstr "用分隔参数（word-separated）补全外部命令，如 @t{exec} 和 @t{/usr/bin/env}。"

#. type: t{#1}
#: zsh.texi:24243 zsh.texi:24244
#, no-wrap
msgid "_prefix"
msgstr "_prefix"

#. type: table
#: zsh.texi:24249
msgid ""
"This completer can be used to try completion with the suffix (everything after the cursor) ignored.  In other words, the suffix will not be considered to be part of the word to complete.  The effect is "
"similar to the @t{expand-or-complete-prefix} command."
msgstr "该补全器可用于在忽略后缀（光标后的所有内容）的情况下尝试补全。 换句话说，后缀不会被视为要补全的单词的一部分。 其效果类似于 @t{expand-or-complete-prefix} 命令。"

#. type: table
#: zsh.texi:24257
msgid ""
"The @t{completer} style is used to decide which other completers are to be called to generate matches.  If this style is unset, the list of completers set for the current context is used --- except, of "
"course, the @t{_prefix} completer itself.  Furthermore, if this completer appears more than once in the list of completers only those completers not already tried by the last invocation of @t{_prefix} "
"will be called."
msgstr ""
"@t{completer} 样式用于决定调用哪些其他补全程序来生成匹配。 如果未设置此样式，则使用为当前上下文设置的补全程序列表 --- 当然，@t{_prefix} 补全器本身除外。 此外，如果该补全器在补全器列表中出现不止一次，则只会"
"调用上次调用 @t{_prefix} 时尚未尝试过的补全器。"

#. type: table
#: zsh.texi:24260
msgid "For example, consider this global @t{completer} style:"
msgstr "例如，请看这个全局 @t{completer} 样式："

#. type: example
#: zsh.texi:24265
#, no-wrap
msgid ""
"zstyle ':completion:*' completer \\ \n"
"    _complete _prefix _correct _prefix:foo\n"
msgstr ""
"zstyle ':completion:*' completer \\ \n"
"    _complete _prefix _correct _prefix:foo\n"

#. type: table
#: zsh.texi:24274
msgid ""
"Here, the @t{_prefix} completer tries normal completion but ignoring the suffix.  If that doesn't generate any matches, and neither does the call to the @t{_correct} completer after it, @t{_prefix} will "
"be called a second time and, now only trying correction with the suffix ignored.  On the second invocation the completer part of the context appears as `@t{foo}'."
msgstr ""
"在这里，@t{_prefix} 补全器会尝试正常补全，但忽略后缀。 如果没有匹配结果，之后调用 @t{_correct} 补全器也没有匹配结果，那么 @t{_prefix} 将被第二次调用，现在只尝试修正而忽略后缀。 在第二次调用时，上下文的补全"
"部分显示为 `@t{foo}'。"

#. type: table
#: zsh.texi:24278
msgid "To use @t{_prefix} as the last resort and try only normal completion when it is invoked:"
msgstr "将 @t{_prefix} 作为最后手段使用，并在调用时只尝试正常补全："

#. type: example
#: zsh.texi:24283
#, no-wrap
msgid ""
"zstyle ':completion:*' completer _complete ... _prefix\n"
"zstyle ':completion::prefix:*' completer _complete\n"
msgstr ""
"zstyle ':completion:*' completer _complete ... _prefix\n"
"zstyle ':completion::prefix:*' completer _complete\n"

#. type: table
#: zsh.texi:24289
msgid "The @t{add-space} style is also respected.  If it is set to `true' then @t{_prefix} will insert a space between the matches generated (if any)  and the suffix."
msgstr "同时，@t{add-space} 样式也会受到尊守。 如果设置为 `true' ，@t{_prefix} 将在生成的匹配项（如果有）和后缀之间插入空格。"

#. type: table
#: zsh.texi:24295
msgid ""
"Note that this completer is only useful if the @t{COMPLETE_IN_WORD} option is set; otherwise, the cursor will be moved to the end of the current word before the completion code is called and hence there "
"will be no suffix."
msgstr "请注意，只有设置了 @t{COMPLETE_IN_WORD} 选项，这个补全器才会有用；否则，在调用补全代码之前，光标会被移到当前单词的末尾，因此不会有后缀。"

#. type: t{#1}
#: zsh.texi:24296 zsh.texi:24297
#, no-wrap
msgid "_user_expand"
msgstr "_user_expand"

#. type: table
#: zsh.texi:24303
msgid ""
"This completer behaves similarly to the @t{_expand} completer but instead performs expansions defined by users.  The styles @t{add-space} and @t{sort} styles specific to the @t{_expand} completer are "
"usable with @t{_user_expand} in addition to other styles handled more generally by the completion system.  The tag @t{all-expansions} is also available."
msgstr ""
"该补全器的行为与 @t{_expand} 补全器类似，但它执行的是由用户定义的扩展。 除了补全系统一般处理的其他样式外，@t{_user_expand} 还可以使用指定给 @t{_expand} 的 @t{_add-space} 和 @t{sort} 样式。 此外，还可以使"
"用 @t{all-expansions} 标记。"

#. type: table
#: zsh.texi:24310
msgid ""
"The expansion depends on the array style @t{user-expand} being defined for the current context; remember that the context for completers is less specific than that for contextual completion as the full "
"context has not yet been determined.  Elements of the array may have one of the following forms:"
msgstr "扩展取决于为当前上下文定义的数组样式 @t{user-expand}；请记住，补全器的上下文没有上下文补全程序那么具体，因为完整的上下文尚未确定。 数组的元素可以是以下形式之一："

#. type: item
#: zsh.texi:24313
#, no-wrap
msgid "@t{$}@var{hash}"
msgstr "@t{$}@var{hash}"

#. type: table
#: zsh.texi:24320
msgid ""
"@var{hash} is the name of an associative array.  Note this is not a full parameter expression, merely a @t{$}, suitably quoted to prevent immediate expansion, followed by the name of an associative "
"array.  If the trial expansion word matches a key in @var{hash}, the resulting expansion is the corresponding value."
msgstr ""
"@var{hash} 是关联数组的名称。 请注意，这并不是一个完整的参数表达式，而只是一个 @t{$}，为防止立即展开，该表达式后跟了一个关联数组的名称。 如果试验扩展词与 @var{hash} 中的键匹配，则扩展结果就是相应的值。"

#. type: var{#1}
#: zsh.texi:24321
#, no-wrap
msgid "_func"
msgstr "_func"

#. type: table
#: zsh.texi:24330
msgid ""
"@var{_func} is the name of a shell function whose name must begin with @t{_} but is not otherwise special to the completion system.  The function is called with the trial word as an argument.  If the word "
"is to be expanded, the function should set the array @t{reply} to a list of expansions.  Optionally, it can set @t{REPLY} to a word that will be used as a description for the set of expansions.  The "
"return status of the function is irrelevant."
msgstr ""
"@var{_func} 是 shell 函数的名称，其名称必须以 @t{_} 开头，但对补全系统没有其他特殊要求。 调用该函数时，试用词作为参数。 如果要对单词进行扩展，函数应将数组 @t{reply} 设置为扩展列表。 可选的，函数还可以将 "
"@t{REPLY} 设置为一个单词，该单词将用作扩展集的描述。 函数的返回状态与此无关。"

#. type: node
#: zsh.texi:24336 zsh.texi:24562 zsh.texi:26735
#, no-wrap
msgid "Completion Functions"
msgstr "补全函数"

#. type: cindex
#: zsh.texi:24340
#, no-wrap
msgid "completion system, bindable commands"
msgstr "补全系统, 可绑定命令"

#. type: Plain text
#: zsh.texi:24347
msgid ""
"In addition to the context-dependent completions provided, which are expected to work in an intuitively obvious way, there are a few widgets implementing special behaviour which can be bound separately to "
"keys.  The following is a list of these and their default bindings."
msgstr "除了所提供的与上下文相关的补全（这些补全有望以直观明显的方式运行）外，还有一些实现特殊行为的小部件可以单独绑定到按键上。 下面列出了这些部件及其默认绑定。"

#. type: t{#1}
#: zsh.texi:24350 zsh.texi:24351
#, no-wrap
msgid "_bash_completions"
msgstr "_bash_completions"

#. type: table
#: zsh.texi:24362
msgid ""
"This function is used by two widgets, @t{_bash_complete-word} and @t{_bash_list-choices}.  It exists to provide compatibility with completion bindings in bash.  The last character of the binding "
"determines what is completed: `@t{!}', command names; `@t{$}', environment variables; `@t{@@}', host names; `@t{/}', file names; `@t{~}' user names.  In bash, the binding preceded by `@t{\\e}' gives "
"completion, and preceded by `@t{^X}' lists options.  As some of these bindings clash with standard zsh bindings, only `@t{\\e~}' and `@t{^X~}' are bound by default.  To add the rest, the following should "
"be added to @t{.zshrc} after @t{compinit} has been run:"
msgstr ""
"@t{_bash_complete-word} 和 @t{_bash_list-choices} 这两个小部件使用了该函数。 它的存在是为了与 bash 中的补全绑定兼容。 绑定的最后一个字符决定补全的内容： `@t{!}'，命令名；`@t{$}'，环境变量； `@t{@@}'，主机"
"名； `@t{/}'，文件名；`@t{~}' ，用户名。 在 bash 中，以 `@t{\\e}' 开头的绑定给出补全，`@t{^X}' 开头的绑定列出选项。 由于其中一些绑定与标准的 zsh 绑定冲突，因此默认只绑定了 `@t{\\e~}' 和 `@t{^X~}'。 要添加"
"其余选项，应在 @t{compinit} 运行后将以下内容添加到 @t{.zshrc} 中："

#. type: example
#: zsh.texi:24369
#, no-wrap
msgid ""
"for key in '!' '$' '@@' '/' '~'; do\n"
"  bindkey \"\\e$key\" _bash_complete-word\n"
"  bindkey \"^X$key\" _bash_list-choices\n"
"done\n"
msgstr ""
"for key in '!' '$' '@@' '/' '~'; do\n"
"  bindkey \"\\e$key\" _bash_complete-word\n"
"  bindkey \"^X$key\" _bash_list-choices\n"
"done\n"

#. type: table
#: zsh.texi:24374
msgid "This includes the bindings for `@t{~}' in case they were already bound to something else; the completion code does not override user bindings."
msgstr "这包括 `@t{~}' 的绑定，以防它们已经绑定到其他东西上；补全代码不会覆盖用户绑定。"

#. type: findex
#: zsh.texi:24375
#, no-wrap
msgid "_correct_filename (^XC)"
msgstr "_correct_filename (^XC)"

#. type: item
#: zsh.texi:24376
#, no-wrap
msgid "@t{_correct_filename} (@t{^XC})"
msgstr "@t{_correct_filename} (@t{^XC})"

#. type: table
#: zsh.texi:24381
msgid ""
"Correct the filename path at the cursor position.  Allows up to six errors in the name.  Can also be called with an argument to correct a filename path, independently of zle; the correction is printed on "
"standard output."
msgstr "更正光标位置的文件名路径。 最多允许在名称中出现六个错误。 也可以调用带参数的命令来修正文件名路径，独立于 zle ；修正结果将打印在标准输出上。"

#. type: findex
#: zsh.texi:24382
#, no-wrap
msgid "_correct_word (^Xc)"
msgstr "_correct_word (^Xc)"

#. type: item
#: zsh.texi:24383
#, no-wrap
msgid "@t{_correct_word} (@t{^Xc})"
msgstr "@t{_correct_word} (@t{^Xc})"

#. type: table
#: zsh.texi:24388
msgid ""
"Performs correction of the current argument using the usual contextual completions as possible choices. This stores the string `@t{correct-word}' in the @var{function} field of the context name and then "
"calls the @t{_correct} completer."
msgstr "使用通常的上下文补全词作为可能的选择，对当前参数执行校正。这会在上下文名称的 @var{function} 字段中存储字符串 `@t{correct-word}' ，然后调用 @t{_correct} 补全器。"

#. type: findex
#: zsh.texi:24389
#, no-wrap
msgid "_expand_alias (^Xa)"
msgstr "_expand_alias (^Xa)"

#. type: item
#: zsh.texi:24390
#, no-wrap
msgid "@t{_expand_alias} (@t{^Xa})"
msgstr "@t{_expand_alias} (@t{^Xa})"

#. type: table
#: zsh.texi:24395
msgid ""
"This function can be used as a completer and as a bindable command.  It expands the word the cursor is on if it is an alias.  The types of alias expanded can be controlled with the styles @t{regular}, "
"@t{global} and @t{disabled}."
msgstr "该函数可用作补全器和可绑定命令。 如果光标所在的单词是别名，它将展开该单词。 可以使用 @t{regular}、@t{global} 和 @t{disabled} 样式控制展开的别名类型。"

#. type: table
#: zsh.texi:24403
msgid ""
"When used as a bindable command there is one additional feature that can be selected by setting the @t{complete} style to `true'.  In this case, if the word is not the name of an alias, @t{_expand_alias} "
"tries to complete the word to a full alias name without expanding it.  It leaves the cursor directly after the completed word so that invoking @t{_expand_alias} once more will expand the now-complete "
"alias name."
msgstr ""
"当作为可绑定命令使用时，还有一个额外的功能，可以通过将 @t{complete} 样式设置为 `true' 来选择。 在这种情况下，如果单词不是别名的名称，@t{_expand_alias} 会尝试将单词补全为完整的别名，而不对其进行扩展。 它会"
"将光标直接留在已补全的单词之后，这样再次调用 @t{_expand_alias} 时，就会展开现已补全的别名。"

#. type: findex
#: zsh.texi:24404
#, no-wrap
msgid "_expand_word (^Xe)"
msgstr "_expand_word (^Xe)"

#. type: item
#: zsh.texi:24405
#, no-wrap
msgid "@t{_expand_word} (@t{^Xe})"
msgstr "@t{_expand_word} (@t{^Xe})"

#. type: table
#: zsh.texi:24410
msgid ""
"Performs expansion on the current word: equivalent to the standard @t{expand-word} command, but using the @t{_expand} completer.  Before calling it, the @var{function} field of the context is set to "
"`@t{expand-word}'."
msgstr "对当前单词进行扩展：等同于标准的 @t{expand-word} 命令，但使用 @t{_expand} 补全器。 调用前，上下文的 @var{function} 字段将被设置为`@t{expand-word}'。"

#. type: t{#1}
#: zsh.texi:24411 zsh.texi:24412
#, no-wrap
msgid "_generic"
msgstr "_generic"

#. type: table
#: zsh.texi:24420
msgid ""
"This function is not defined as a widget and not bound by default.  However, it can be used to define a widget and will then store the name of the widget in the @var{function} field of the context and "
"call the completion system.  This allows custom completion widgets with their own set of style settings to be defined easily.  For example, to define a widget that performs normal completion and starts "
"menu selection:"
msgstr ""
"该函数未定义为小部件，默认情况下不绑定。 不过，它可以用来定义一个小部件，然后会将小部件的名称存储在上下文的 @var{function} 字段中，并调用补全系统。 这样就可以轻松定义具有自己风格设置的自定义补全小部件。 例"
"如，定义一个执行正常补全并启动菜单选择的小部件："

#. type: example
#: zsh.texi:24426
#, no-wrap
msgid ""
"zle -C foo complete-word _generic\n"
"bindkey '...' foo\n"
"zstyle ':completion:foo:*' menu yes select=1\n"
msgstr ""
"zle -C foo complete-word _generic\n"
"bindkey '...' foo\n"
"zstyle ':completion:foo:*' menu yes select=1\n"

#. type: table
#: zsh.texi:24434
msgid ""
"Note in particular that the @t{completer} style may be set for the context in order to change the set of functions used to generate possible matches.  If @t{_generic} is called with arguments, those are "
"passed through to @t{_main_complete} as the list of completers in place of those defined by the @t{completer} style."
msgstr ""
"需要特别注意的是，可以为上下文设置 @t{completer} 样式，以更改用于生成可能匹配的函数集。 如果 @t{_generic} 在调用时带有参数，那么这些参数将作为补全函数列表传递给 @t{_main_complete}，以代替 @t{completer} 样"
"式所定义的补全函数。"

#. type: findex
#: zsh.texi:24435
#, no-wrap
msgid "_history_complete_word (\\e/)"
msgstr "_history_complete_word (\\e/)"

#. type: item
#: zsh.texi:24436
#, no-wrap
msgid "@t{_history_complete_word} (@t{\\e/})"
msgstr "@t{_history_complete_word} (@t{\\e/})"

#. type: table
#: zsh.texi:24439
msgid "Complete words from the shell's command history. This uses the @t{list}, @t{remove-all-dups}, @t{sort}, and @t{stop} styles."
msgstr "补全 shell 命令历史中的单词。它使用 @t{list}、@t{remove-all-dups}、@t{sort} 和 @t{stop} 样式。"

#. type: findex
#: zsh.texi:24440
#, no-wrap
msgid "_most_recent_file (^Xm)"
msgstr "_most_recent_file (^Xm)"

#. type: item
#: zsh.texi:24441
#, no-wrap
msgid "@t{_most_recent_file} (@t{^Xm})"
msgstr "@t{_most_recent_file} (@t{^Xm})"

#. type: table
#: zsh.texi:24446
msgid ""
"Complete the name of the most recently modified file matching the pattern on the command line (which may be blank).  If given a numeric argument @var{N}, complete the @var{N}th most recently modified "
"file.  Note the completion, if any, is always unique."
msgstr "补全与命令行模式匹配的最近修改的文件名（可能为空）。 如果给定一个数字参数 @var{N}，则补全第 @var{N} 个最近修改的文件。 请注意，补全（如果有）总是唯一的。"

#. type: findex
#: zsh.texi:24447
#, no-wrap
msgid "_next_tags (^Xn)"
msgstr "_next_tags (^Xn)"

#. type: item
#: zsh.texi:24448
#, no-wrap
msgid "@t{_next_tags} (@t{^Xn})"
msgstr "@t{_next_tags} (@t{^Xn})"

#. type: table
#: zsh.texi:24454
msgid ""
"This command alters the set of matches used to that for the next tag, or set of tags, either as given by the @t{tag-order} style or as set by default; these matches would otherwise not be available.  "
"Successive invocations of the command cycle through all possible sets of tags."
msgstr "这条命令会改变下一个标记或标记集的匹配集，可以是 @t{tag-order} 样式给出的匹配集，也可以是默认设置的匹配集；否则这些匹配集将不可用。 连续调用该命令将循环使用所有可能的标记集。"

#. type: findex
#: zsh.texi:24455
#, no-wrap
msgid "_read_comp (^X^R)"
msgstr "_read_comp (^X^R)"

#. type: item
#: zsh.texi:24456
#, no-wrap
msgid "@t{_read_comp} (@t{^X^R})"
msgstr "@t{_read_comp} (@t{^X^R})"

#. type: table
#: zsh.texi:24464
msgid ""
"Prompt the user for a string, and use that to perform completion on the current word.  There are two possibilities for the string.  First, it can be a set of words beginning `@t{_}', for example "
"`@t{_files -/}', in which case the function with any arguments will be called to generate the completions.  Unambiguous parts of the function name will be completed automatically (normal completion is not "
"available at this point) until a space is typed."
msgstr ""
"提示符会提示用户输入一个字符串，并使用该字符串对当前单词进行补全。 字符串有两种可能。 首先，它可以是一组以 `@t{_}' 开头的单词，例如 `@t{_files -/}'，在这种情况下，将调用带有任何参数的函数来生成补全。 函数"
"名中不明确的部分将自动补全（此时无法使用普通补全），直到键入空格为止。"

#. type: table
#: zsh.texi:24469
msgid "Second, any other string will be passed as a set of arguments to @t{compadd} and should hence be an expression specifying what should be completed."
msgstr "其次，任何其他字符串都将作为一组参数传递给 @t{comppadd}，因此应该是一个表达式，指定应该补全的内容。"

#. type: table
#: zsh.texi:24476
msgid ""
"A very restricted set of editing commands is available when reading the string: `@t{DEL}' and `@t{^H}' delete the last character; `@t{^U}' deletes the line, and `@t{^C}' and `@t{^G}' abort the function, "
"while `@t{RET}' accepts the completion.  Note the string is used verbatim as a command line, so arguments must be quoted in accordance with standard shell rules."
msgstr ""
"读取字符串时，只能使用一组非常有限的编辑命令：`@t{DEL}' 和 `@t{^H}' 删除最后一个字符；`@t{^U}' 删除行， `@t{^C}' 和 `@t{^G}' 中止函数，而 `@t{RET}' 接受补全。 请注意，字符串是作为命令行逐字使用的，因此参数"
"必须按照标准 shell 规则加引号。"

#. type: table
#: zsh.texi:24481
msgid "Once a string has been read, the next call to @t{_read_comp} will use the existing string instead of reading a new one.  To force a new string to be read, call @t{_read_comp} with a numeric argument."
msgstr "一旦读取了一个字符串，下一次调用 @t{_read_comp} 时，将使用现有的字符串，而不会读取新的字符串。 如果要强制读取新字符串，请在调用 @t{_read_comp} 时输入数字参数。"

#. type: findex
#: zsh.texi:24482
#, no-wrap
msgid "_complete_debug (^X?)"
msgstr "_complete_debug (^X?)"

#. type: item
#: zsh.texi:24483
#, no-wrap
msgid "@t{_complete_debug} (@t{^X?})"
msgstr "@t{_complete_debug} (@t{^X?})"

#. type: table
#: zsh.texi:24488
msgid ""
"This widget performs ordinary completion, but captures in a temporary file a trace of the shell commands executed by the completion system.  Each completion attempt gets its own file.  A command to view "
"each of these files is pushed onto the editor buffer stack."
msgstr "该小部件执行普通补全，但会在一个临时文件中捕获补全系统执行的 shell 命令的跟踪信息。 每次补全尝试都有自己的文件。 查看每个文件的命令会被推入编辑器缓冲堆栈。"

#. type: findex
#: zsh.texi:24489
#, no-wrap
msgid "_complete_help (^Xh)"
msgstr "_complete_help (^Xh)"

#. type: item
#: zsh.texi:24490
#, no-wrap
msgid "@t{_complete_help} (@t{^Xh})"
msgstr "@t{_complete_help} (@t{^Xh})"

#. type: table
#: zsh.texi:24496
msgid ""
"This widget displays information about the context names, the tags, and the completion functions used when completing at the current cursor position. If given a numeric argument other than @t{1} (as in "
"`@t{ESC-2 ^Xh}'), then the styles used and the contexts for which they are used will be shown, too."
msgstr "该小部件显示在当前光标位置补全时使用的上下文名称、标记和补全函数等信息。如果给定的数字参数不是 @t{1}（如 `@t{ESC-2 ^Xh}'），则还将显示使用的样式和上下文。"

#. type: table
#: zsh.texi:24501
msgid ""
"Note that the information about styles may be incomplete; it depends on the information available from the completion functions called, which in turn is determined by the user's own styles and other "
"settings."
msgstr "请注意，有关样式的信息可能是不完整的；它取决于所调用的补全函数提供的信息，而补全函数的信息又是由用户自己的样式和其他设置决定的。"

#. type: t{#1}
#: zsh.texi:24502 zsh.texi:24503
#, no-wrap
msgid "_complete_help_generic"
msgstr "_complete_help_generic"

#. type: table
#: zsh.texi:24508
msgid ""
"Unlike other commands listed here, this must be created as a normal ZLE widget rather than a completion widget (i.e. with @t{zle -N}).  It is used for generating help with a widget bound to the "
"@t{_generic} widget that is described above."
msgstr "与此处列出的其他命令不同，它必须作为普通 ZLE 小部件而非补全小部件创建（即使用 @t{zle -N}）。 它用于生成与上述 @t{_generic} 小部件绑定的帮助。"

#. type: table
#: zsh.texi:24516
msgid ""
"If this widget is created using the name of the function, as it is by default, then when executed it will read a key sequence.  This is expected to be bound to a call to a completion function that uses "
"the @t{_generic} widget.  That widget will be executed, and information provided in the same format that the @t{_complete_help} widget displays for contextual completion."
msgstr ""
"如果该小部件是使用函数名称创建的（默认情况下是这样），那么执行时它将读取一个按键序列。 这将绑定到使用 @t{_generic} 小部件的补全函数的调用。 该小部件将被执行，并以 @t{_complete_help} 小部件显示上下文补全的"
"相同格式提供信息。"

#. type: table
#: zsh.texi:24523
msgid ""
"If the widget's name contains @t{debug}, for example if it is created as `@t{zle -N _complete_debug_generic _complete_help_generic}', it will read and execute the keystring for a generic widget as before, "
"but then generate debugging information as done by @t{_complete_debug} for contextual completion."
msgstr ""
"如果小部件的名称中包含 @t{debug}，例如以 `@t{zle -N _complete_debug_generic _complete_help_generic}' 的方式创建，它就会像之前一样读取并执行通用小部件的密钥(keystring)，但随后会像 @t{_complete_debug} 为上下"
"文补全所做的那样生成调试信息。"

#. type: table
#: zsh.texi:24528
msgid "If the widget's name contains @t{noread}, it will not read a keystring but instead arrange that the next use of a generic widget run in the same shell will have the effect as described above."
msgstr "如果小部件的名称中包含 @t{noread}，它将不会读取密钥，而是安排下一次使用在同一 shell 中运行的通用小部件时,产生上述效果。"

#. type: table
#: zsh.texi:24533
msgid "The widget works by setting the shell parameter @t{ZSH_TRACE_GENERIC_WIDGET} which is read by @t{_generic}.  Unsetting the parameter cancels any pending effect of the @t{noread} form."
msgstr "小部件通过设置由 @t{_generic} 读取的 shell 参数 @t{ZSH_TRACE_GENERIC_WIDGET} 来工作。 取消参数设置后，@t{noread} 形式的任何待定效果都将被取消。"

#. type: table
#: zsh.texi:24536
msgid "For example, after executing the following:"
msgstr "例如，执行以下操作后:"

#. type: example
#: zsh.texi:24541
#, no-wrap
msgid ""
"zle -N _complete_debug_generic _complete_help_generic\n"
"bindkey '^x:' _complete_debug_generic\n"
msgstr ""
"zle -N _complete_debug_generic _complete_help_generic\n"
"bindkey '^x:' _complete_debug_generic\n"

#. type: table
#: zsh.texi:24546
msgid "typing `@t{C-x :}' followed by the key sequence for a generic widget will cause trace output for that widget to be saved to a file."
msgstr "键入 `@t{C-x :}'，然后输入通用小部件的按键序列，就会将该小部件的跟踪输出保存到文件中。"

#. type: findex
#: zsh.texi:24547
#, no-wrap
msgid "_complete_tag (^Xt)"
msgstr "_complete_tag (^Xt)"

#. type: item
#: zsh.texi:24548
#, no-wrap
msgid "@t{_complete_tag} (@t{^Xt})"
msgstr "@t{_complete_tag} (@t{^Xt})"

#. type: table
#: zsh.texi:24558
msgid ""
"This widget completes symbol tags created by the @t{etags} or @t{ctags} programmes (note there is no connection with the completion system's tags)  stored in a file @t{TAGS}, in the format used by "
"@t{etags}, or @t{tags}, in the format created by @t{ctags}.  It will look back up the path hierarchy for the first occurrence of either file; if both exist, the file @t{TAGS} is preferred.  You can "
"specify the full path to a @t{TAGS} or @t{tags} file by setting the parameter @t{$TAGSFILE} or @t{$tagsfile} respectively.  The corresponding completion tags used are @t{etags} and @t{vtags}, after emacs "
"and vi respectively."
msgstr ""
"该小部件补全由 @t{etags} 或 @t{ctags} 程序（注意与补全系统的标签没有任何联系）创建的符号标记，这些标记存储在 @t{TAGS} 文件中，格式为 @t{etags} 使用的格式，或 @t{tags} 文件中，格式为 @t{ctags} 创建的格式。 "
"它将在路径层次结构中查找第一个出现的文件；如果两个文件都存在，则优先选择 @t{TAGS} 文件。 您可以通过设置参数 @t{$TAGSFILE} 或 @t{$tagsfile} 分别指定 @t{TAGS} 或 @t{tags} 文件的完整路径。 相应使用的补全标记"
"是 @t{etags} 和 @t{vtags}，分别与 emacs 和 vi 后缀相同。"

#. type: subsection
#: zsh.texi:24564 zsh.texi:39509
#, no-wrap
msgid "Utility Functions"
msgstr "实用函数"

#. type: cindex
#: zsh.texi:24566
#, no-wrap
msgid "completion system, utility functions"
msgstr "补全系统, 实用函数"

#. type: Plain text
#: zsh.texi:24577
msgid ""
"Descriptions follow for utility functions that may be useful when writing completion functions.  If functions are installed in subdirectories, most of these reside in the @t{Base} subdirectory.  Like the "
"example functions for commands in the distribution, the utility functions generating matches all follow the convention of returning status zero if they generated completions and non-zero if no matching "
"completions could be added."
msgstr ""
"下面将介绍在编写补全函数时可能有用的实用函数。 如果函数安装在子目录中，其中大部分位于 @t{Base} 子目录中。 与分发版中的命令的示例函数一样，生成匹配的实用函数都遵循这样的惯例：如果生成补全，则返回状态为 0；"
"如果无法添加匹配的补全，则返回非 0。"

#. type: t{#1}
#: zsh.texi:24580 zsh.texi:24581
#, no-wrap
msgid "_absolute_command_paths"
msgstr "_absolute_command_paths"

#. type: table
#: zsh.texi:24585
msgid "This function completes external commands as absolute paths (unlike @t{_command_names -e} which completes their basenames).  It takes no arguments."
msgstr "该函数将外部命令补全为绝对路径（与 @t{_command_names -e} 不同，后者补全的是其基名）。 它不需要参数。"

#. type: findex
#: zsh.texi:24586
#, no-wrap
msgid "_all_labels"
msgstr "_all_labels"

#. type: item
#: zsh.texi:24587
#, no-wrap
msgid "@t{_all_labels} [ @t{-x} ] [ @t{-12VJ} ] @var{tag} @var{name} @var{descr} [ @var{command} @var{arg} ... ]"
msgstr "@t{_all_labels} [ @t{-x} ] [ @t{-12VJ} ] @var{tag} @var{name} @var{descr} [ @var{command} @var{arg} ... ]"

#. type: table
#: zsh.texi:24599
msgid ""
"This is a convenient interface to the @t{_next_label} function below, implementing the loop shown in the @t{_next_label} example.  The @var{command} and its arguments are called to generate the matches.  "
"The options stored in the parameter @var{name} will automatically be inserted into the @var{arg}s passed to the @var{command}.  Normally, they are put directly after the @var{command}, but if one of the "
"@var{arg}s is a single hyphen, they are inserted directly before that.  If the hyphen is the last argument, it will be removed from the argument list before the @var{command} is called.  This allows "
"@t{_all_labels} to be used in almost all cases where the matches can be generated by a single call to the @t{compadd} builtin command or by a call to one of the utility functions."
msgstr ""
"这是下面 @t{_next_label} 函数的一个便捷接口，用于实现 @t{_next_label} 示例中的循环。 调用 @var{command} 及其参数可生成匹配结果。 存储在参数 @var{name} 中的选项会自动插入传给 @var{command} 的 @var{arg}s "
"中。 通常情况下，这些选项会直接放在 @var{command} 之后，但如果 @var{arg}s 中有一个是连字符，这些选项就会直接插入 @var{command} 之前。 如果连字符是最后一个参数，则会在调用 @var{command} 之前从参数列表中删"
"除。 这样一来，@t{_all_labels} 几乎可以在所有情况下使用，只需调用 @t{compadd} 内置命令或调用其中一个实用函数，即可生成匹配结果。"

#. type: example
#: zsh.texi:24611
#, no-wrap
msgid ""
"local expl\n"
"...\n"
"if _requested foo; then\n"
"  ...\n"
"  _all_labels foo expl '...' compadd ... - $matches\n"
"fi\n"
msgstr ""
"local expl\n"
"...\n"
"if _requested foo; then\n"
"  ...\n"
"  _all_labels foo expl '...' compadd ... - $matches\n"
"fi\n"

#. type: table
#: zsh.texi:24617
msgid "Will complete the strings from the @t{matches} parameter, using @t{compadd} with additional options which will take precedence over those generated by @t{_all_labels}."
msgstr "将补全 @t{matches} 参数中的字符串，使用 @t{compadd} 和附加选项，这些选项优先于 @t{_all_labels} 生成的选项。"

#. type: findex
#: zsh.texi:24618
#, no-wrap
msgid "_alternative"
msgstr "_alternative"

#. type: item
#: zsh.texi:24619
#, no-wrap
msgid "@t{_alternative} [ @t{-O} @var{name} ] [ @t{-C} @var{name} ] @var{spec} ..."
msgstr "@t{_alternative} [ @t{-O} @var{name} ] [ @t{-C} @var{name} ] @var{spec} ..."

#. type: table
#: zsh.texi:24623
msgid "This function is useful in simple cases where multiple tags are available.  Essentially it implements a loop like the one described for the @t{_tags} function below."
msgstr "该函数适用于有多个标记的简单情况。 本质上，它实现了一个循环，就像下面描述的 @t{_tags} 函数一样。"

#. type: table
#: zsh.texi:24632
msgid ""
"The tags to use and the action to perform if a tag is requested are described using the @var{spec}s which are of the form: `@var{tag}@t{:}@var{descr}@t{:}@var{action}'.  The @var{tag}s are offered using "
"@t{_tags} and if the tag is requested, the @var{action} is executed with the given description @var{descr}.  The @var{action}s are those accepted by the @t{_arguments} function (described below), with the "
"following exceptions:"
msgstr ""
"@var{spec} 的形式描述了要使用的标记和请求标记时要执行的操作：`@var{tag}@t{:}@var{descr}@t{:}@var{action}'。 @var{tag}s 使用 @t{_tags} 提供，如果标记被请求，则执行 @var{action} 并给出描述 @var{descr}。 "
"@var{action}s 是 @t{_arguments} 函数（如下所述）接受的参数，但以下情况除外："

#. type: itemize
#: zsh.texi:24636
msgid "The `@t{->}@var{state}' and `@t{=}@var{...}' forms are not supported."
msgstr "不支持 `@t{->}@var{state}' 和 `@t{=}@var{...}' 形式。"

#. type: itemize
#: zsh.texi:24641
msgid "The `@t{((a\\:bar b\\:baz}@t{))}' form does not need the colon to be escaped, since the @var{spec}s have no colon-separated fields after the @var{action}."
msgstr " `@t{((a\\:bar b\\:baz}@t{))}' 形式不需要转义冒号，因为 @var{spec}s 在 @var{action} 之后没有以冒号分隔的字段。"

#. type: table
#: zsh.texi:24646
msgid "For example, the @var{action} may be a simple function call:"
msgstr "例如，@var{action} 可能是一个简单的函数调用："

#. type: example
#: zsh.texi:24652
#, no-wrap
msgid ""
"_alternative \\ \n"
"    'users:user:_users' \\ \n"
"    'hosts:host:_hosts'\n"
msgstr ""
"_alternative \\ \n"
"    'users:user:_users' \\ \n"
"    'hosts:host:_hosts'\n"

#. type: table
#: zsh.texi:24657
msgid "offers usernames and hostnames as possible matches, generated by the @t{_users} and @t{_hosts} functions respectively."
msgstr "提供用户名和主机名作为可能的匹配项，分别由 @t{_users} 和 @t{_hosts} 函数生成。"

#. type: table
#: zsh.texi:24663
msgid ""
"Like @t{_arguments}, this function uses @t{_all_labels} to execute the actions, which will loop over all sets of tags.  Special handling is only required if there is an additional valid tag, for example "
"inside a function called from @t{_alternative}."
msgstr "与 @t{_arguments} 一样，该函数使用 @t{_all_labels} 来执行操作，将循环遍历所有标记集。 只有在有额外有效标记的情况下，例如在 @t{_alternative} 调用的函数内部，才需要进行特殊处理。"

#. type: table
#: zsh.texi:24668
msgid "The option `@t{-O} @var{name}' is used in the same way as by the @t{_arguments} function.  In other words, the elements of the @var{name} array will be passed to @t{compadd} when executing an action."
msgstr "选项 `@t{-O} @var{name}' 的使用方式与 @t{_arguments} 函数相同。 换句话说，在执行操作时，@var{name} 数组中的元素将传递给 @t{compadd}。"

#. type: table
#: zsh.texi:24672
msgid "Like @t{_tags} this function supports the @t{-C} option to give a different name for the argument context field."
msgstr "与 @t{_tags} 类似，该函数支持 @t{-C} 选项，可为参数上下文字段赋予不同的名称。"

#. type: findex
#: zsh.texi:24673
#, no-wrap
msgid "_arguments"
msgstr "_arguments"

#. type: item
#: zsh.texi:24675
#, no-wrap
msgid "@t{_arguments }[ @t{-nswWCRS} ] [ @t{-A} @var{pat} ] [ @t{-O} @var{name} ] [ @t{-M} @var{matchspec} ]"
msgstr "@t{_arguments }[ @t{-nswWCRS} ] [ @t{-A} @var{pat} ] [ @t{-O} @var{name} ] [ @t{-M} @var{matchspec} ]"

#. type: itemx
#: zsh.texi:24676
#, no-wrap
msgid "@t{@ @ @ @ @ @ @ @ @ @ @ }[ @t{:} ] @var{spec} ..."
msgstr "@t{@ @ @ @ @ @ @ @ @ @ @ }[ @t{:} ] @var{spec} ..."

#. type: itemx
#: zsh.texi:24677
#, no-wrap
msgid "@t{_arguments }[ @var{opt} ... ] @t{-}@t{-} [ @t{-l} ] [ @t{-i} @var{pats} ] [ @t{-s} @var{pair} ]"
msgstr "@t{_arguments }[ @var{opt} ... ] @t{-}@t{-} [ @t{-l} ] [ @t{-i} @var{pats} ] [ @t{-s} @var{pair} ]"

#. type: itemx
#: zsh.texi:24678
#, no-wrap
msgid "@t{@ @ @ @ @ @ @ @ @ @ @ }[ @var{helpspec} ...]"
msgstr "@t{@ @ @ @ @ @ @ @ @ @ @ }[ @var{helpspec} ...]"

#. type: table
#: zsh.texi:24682
msgid "This function can be used to give a complete specification for completion for a command whose arguments follow standard UNIX option and argument conventions."
msgstr "该函数可用于为参数遵循标准 UNIX 选项和参数约定的命令提供完整的补全规范。"

#. type: emph{#1}
#: zsh.texi:24685
msgid "Options Overview"
msgstr "选项概述"

#. type: table
#: zsh.texi:24692
msgid ""
"Options to @t{_arguments} itself must be in separate words, i.e. @t{-s -w}, not @t{-sw}.  The options are followed by @var{spec}s that describe options and arguments of the analyzed command.  To avoid "
"ambiguity, all options to @t{_arguments} itself may be separated from the @var{spec} forms by a single colon."
msgstr ""
"@t{_arguments} 本身的选项必须使用单独的单词，即 @t{-s -w}，而不是 @t{-sw}。 选项后面的 @var{spec}s 描述了已分析命令的选项和参数。 为避免歧义，@t{_arguments} 本身的所有选项可以用一个冒号与 @var{spec} 分开。"

#. type: table
#: zsh.texi:24700
msgid ""
"The `@t{-}@t{-}' form is used to intuit @var{spec} forms from the help output of the command being analyzed, and is described in detail below.  The @var{opts} for the `@t{-}@t{-}' form are otherwise the "
"same options as the first form.  Note that `@t{-s}' following `@t{-}@t{-}' has a distinct meaning from `@t{-s}' preceding `@t{-}@t{-}', and both may appear."
msgstr ""
" `@t{-}@t{-}' 形式用于从被分析命令的帮助输出中直观获取 @var{spec} 形式，下文将详细介绍。 此外， `@t{-}@t{-}' 形式的 @var{opts} 与第一种形式相同。 请注意，`@t{-}@t{-}' 后面的 `@t{-s}' 与 `@t{-}@t{-}' 前面"
"的 `@t{-s}' 含义不同，两者都可能出现。"

#. type: table
#: zsh.texi:24705
msgid ""
"The option switches @t{-s}, @t{-S}, @t{-A}, @t{-w}, and @t{-W} affect how @t{_arguments} parses the analyzed command line's options.  These switches are useful for commands with standard argument parsing."
msgstr "选项开关 @t{-s}、@t{-S}、@t{-A}、@t{-w} 和 @t{-W} 会影响 @t{_arguments} 分析命令行选项的方式。 这些开关对使用标准参数解析的命令非常有用。"

#. type: table
#: zsh.texi:24708
msgid "The options of @t{_arguments} have the following meanings:"
msgstr "@t{_arguments} 的选项含义如下："

#. type: table
#: zsh.texi:24718
msgid ""
"With this option, @t{_arguments} sets the parameter @t{NORMARG} to the position of the first normal argument in the @t{$words} array, i.e. the position after the end of the options.  If that argument has "
"not been reached, @t{NORMARG} is set to @t{-1}.  The caller should declare `@t{integer NORMARG}' if the @t{-n} option is passed; otherwise the parameter is not used."
msgstr ""
"使用此选项后，@t{_arguments} 会将参数 @t{NORMARG} 设置为 @t{$words} 数组中第一个正常参数的位置，即选项结束后的位置。 如果该参数尚未到达，@t{NORMARG} 将被设置为 @t{-1}。 如果传递了 @t{-n} 选项，调用者应声"
"明 `@t{integer NORMARG}' ，否则将不使用该参数。"

#. type: table
#: zsh.texi:24725
msgid ""
"Enable @emph{option stacking} for single-letter options, whereby multiple single-letter options may be combined into a single word.  For example, the two options `@t{-x}' and `@t{-y}' may be combined into "
"a single word `@t{-xy}'.  By default, every word corresponds to a single option name (`@t{-xy}' is a single option named `@t{xy}')."
msgstr ""
"启用单字母选项的 @emph{选项堆叠}，可以将多个单字母选项合并为一个单词。 例如，两个选项 `@t{-x}' 和 `@t{-y}' 可以合并为一个单词 `@t{-xy}'。 默认情况下，每个单词对应一个选项名称（`@t{-xy}' 是一个名为 "
"`@t{xy}' 的选项）。"

#. type: table
#: zsh.texi:24729
msgid "Options beginning with a single hyphen or plus sign are eligible for stacking; words beginning with two hyphens are not."
msgstr "以单个连字符或加号开头的选项可叠加；以两个连字符开头的词不可叠加。"

#. type: table
#: zsh.texi:24733
msgid "Note that @t{-s} after @t{-}@t{-} has a different meaning, which is documented in the segment entitled `Deriving @var{spec} forms from the help output'."
msgstr "请注意，@t{-}@t{-} 后的 @t{-s} 含义不同，这在题为 `从帮助输出中获取 @var{spec} 形式' 的部分有详细说明。"

#. type: table
#: zsh.texi:24743
msgid ""
"In combination with @t{-s}, allow option stacking even if one or more of the options take arguments.  For example, if @t{-x} takes an argument, with no @t{-s}, `@t{-xy}' is considered as a single "
"(unhandled) option; with @t{-s}, @t{-xy} is an option with the argument `@t{y}'; with both @t{-s} and @t{-w}, @t{-xy} is the option @t{-x} and the option @t{-y} with arguments to @t{-x} (and to @t{-y}, if "
"it takes arguments) still to come in subsequent words."
msgstr ""
"与 @t{-s} 结合使用时，即使一个或多个选项带有参数，也允许堆叠选项。 例如，如果 @t{-x} 包含一个参数，在没有 @t{-s} 的情况下， `@t{-xy}' 被视为一个单独的（未处理的）选项；在有 @t{-s} 的情况下，@t{-xy} 是一个"
"包含参数 `@t{y}' 的选项； 同时使用 @t{-s} 和 @t{-w} 时，@t{-xy} 是选项 @t{-x} 和选项 @t{-y}，@t{-x} 的参数（以及 @t{-y} 的参数，如果它需要参数）仍在后面的语句中。"

#. type: table
#: zsh.texi:24750
msgid ""
"This option takes @t{-w} a stage further: it is possible to complete single-letter options even after an argument that occurs in the same word.  However, it depends on the action performed whether options "
"will really be completed at this point.  For more control, use a utility function like @t{_guard} as part of the action."
msgstr ""
"该选项使 @t{-w} 更进了一步：即使在出现在同一单词中的参数之后，也可以补全单字母选项。 不过，选项是否真的会在此时补全取决于所执行的操作。 为了获得更多的控制权，可以使用 @t{_guard} 这样的实用程序作为操作的一"
"部分。"

#. type: table
#: zsh.texi:24754
msgid "Modify the @t{curcontext} parameter for an action of the form `@t{->}@var{state}'.  This is discussed in detail below."
msgstr "为 `@t{->}@var{state}' 形式的操作修改 @t{curcontext} 参数。 下文将对此进行详细讨论。"

#. type: table
#: zsh.texi:24758
msgid "Return status 300 instead of zero when a @t{$state} is to be handled, in the `@t{->}@var{string}' syntax."
msgstr "当要处理 @t{$state} 时，以 `@t{->}@var{string}' 语法返回状态 300 而不是 0。"

#. type: table
#: zsh.texi:24762
msgid "Do not complete options after a `@t{-}@t{-}' appearing on the line, and ignore the `@t{-}@t{-}'.  For example, with @t{-S}, in the line"
msgstr "不要在行中出现的 `@t{-}@t{-}' 之后补全选项，并忽略 `@t{-}@t{-}'。 例如，在行中,带有 @t{-S}"

#. type: example
#: zsh.texi:24766
#, no-wrap
msgid "foobar -x -- -y\n"
msgstr "foobar -x -- -y\n"

#. type: table
#: zsh.texi:24771
msgid "the `@t{-x}' is considered an option, the `@t{-y}' is considered an argument, and the `@t{-}@t{-}' is considered to be neither."
msgstr " `@t{-x}' 被视为选项， `@t{-y}' 被视为参数，而 `@t{-}@t{-}' 既不是选项也不是参数。"

#. type: item
#: zsh.texi:24772
#, no-wrap
msgid "@t{-A} @var{pat}"
msgstr "@t{-A} @var{pat}"

#. type: table
#: zsh.texi:24779
msgid ""
"Do not complete options after the first non-option argument on the line.  @var{pat} is a pattern matching all strings which are not to be taken as arguments.  For example, to make @t{_arguments} stop "
"completing options after the first normal argument, but ignoring all strings starting with a hyphen even if they are not described by one of the @var{optspec}s, the form is `@t{-A \"-*\"}'."
msgstr ""
"在该行第一个非选项参数之后，选项不再补全。 @var{pat} 是一个匹配所有不作为参数的字符串的模式。 例如，要使 @t{_arguments} 在第一个普通参数之后不再补全选项，但忽略所有以连字符开头的字符串，即使这些字符串没有"
"被 @var{optspec} 之一描述，其形式为 `@t{-A \"-*\"}'。"

#. type: item
#: zsh.texi:24780
#, no-wrap
msgid "@t{-O} @var{name}"
msgstr "@t{-O} @var{name}"

#. type: table
#: zsh.texi:24784
msgid "Pass the elements of the array @var{name} as arguments to functions called to execute @var{action}s.  This is discussed in detail below."
msgstr "将数组 @var{name} 中的元素作为参数传递给执行 @var{action}s 的函数。 下文将对此进行详细讨论。"

#. type: item
#: zsh.texi:24785
#, no-wrap
msgid "@t{-M} @var{matchspec}"
msgstr "@t{-M} @var{matchspec}"

#. type: table
#: zsh.texi:24790
msgid ""
"Use the match specification @var{matchspec} for completing option names and values.  The default @var{matchspec} allows partial word completion after `@t{_}' and `@t{-}', such as completing `@t{-f-b}' to "
"`@t{-foo-bar}'.  The default @var{matchspec} is:"
msgstr "使用匹配规范 @var{matchspec} 来补全选项名和值。 默认的 @var{matchspec} 允许在 `@t{_}' 和 `@t{-}' 之后补全部分单词，例如将 `@t{-f-b}' 补全为 `@t{-foo-bar}'。 默认的 @var{matchspec} 是："

#. type: example
#: zsh.texi:24792
#, no-wrap
msgid "@t{r:|[_-]=* r:|=*}\n"
msgstr "@t{r:|[_-]=* r:|=*}\n"

#. type: table
#: zsh.texi:24799
msgid ""
"When populating values of the `@t{opt_args}' associative array, don't backslash-escape colons and backslashes and use NUL rather than colon for joining multiple values. This option is described in more "
"detail below, under the heading @emph{@var{spec}s: actions}."
msgstr "在填充关联数组 `@t{opt_args}' 的值时，不要反斜线转义冒号和反斜线，在连接多个值时使用 NUL 而不是冒号。下文将在 @emph{@var{spec}s: actions} 标题下详细介绍该选项。"

#. type: emph{#1}
#: zsh.texi:24804
msgid "@var{spec}s: overview"
msgstr "@var{spec}s: 概述"

#. type: table
#: zsh.texi:24808
msgid "Each of the following forms is a @var{spec} describing individual sets of options or arguments on the command line being analyzed."
msgstr "以下每种形式都是一个 @var{spec}，用于描述被分析命令行上的各组选项或参数。"

#. type: item
#: zsh.texi:24811
#, no-wrap
msgid "@var{n}@t{:}@var{message}@t{:}@var{action}"
msgstr "@var{n}@t{:}@var{message}@t{:}@var{action}"

#. type: itemx
#: zsh.texi:24812
#, no-wrap
msgid "@var{n}@t{::}@var{message}@t{:}@var{action}"
msgstr "@var{n}@t{::}@var{message}@t{:}@var{action}"

#. type: table
#: zsh.texi:24819
msgid ""
"This describes the @var{n}'th normal argument.  The @var{message} will be printed above the matches generated and the @var{action} indicates what can be completed in this position (see below).  If there "
"are two colons before the @var{message} the argument is optional.  If the @var{message} contains only white space, nothing will be printed above the matches unless the action adds an explanation string "
"itself."
msgstr ""
"这描述了第 @var{n} 个普通参数。 @var{message} 将打印在生成的匹配结果上方，而 @var{action} 则表示在这个位置可以补全的内容（见下文）。 如果 @var{message} 前面有两个冒号，则该参数为可选参数。 如果 "
"@var{message} 只包含空格，除非操作本身添加了解释字符串，否则匹配结果上方不会打印任何内容。"

#. type: item
#: zsh.texi:24820 zsh.texi:24921
#, no-wrap
msgid "@t{:}@var{message}@t{:}@var{action}"
msgstr "@t{:}@var{message}@t{:}@var{action}"

#. type: itemx
#: zsh.texi:24821 zsh.texi:24922
#, no-wrap
msgid "@t{::}@var{message}@t{:}@var{action}"
msgstr "@t{::}@var{message}@t{:}@var{action}"

#. type: table
#: zsh.texi:24825
msgid "Similar, but describes the @emph{next} argument, whatever number that happens to be.  If all arguments are specified in this form in the correct order the numbers are unnecessary."
msgstr "类似，但描述的是 @emph{下一个} 参数，不管它是什么数字。 如果所有参数都按正确的顺序以这种形式指定，数字就没有必要了。"

#. type: item
#: zsh.texi:24826
#, no-wrap
msgid "@t{*:}@var{message}@t{:}@var{action}"
msgstr "@t{*:}@var{message}@t{:}@var{action}"

#. type: itemx
#: zsh.texi:24827
#, no-wrap
msgid "@t{*::}@var{message}@t{:}@var{action}"
msgstr "@t{*::}@var{message}@t{:}@var{action}"

#. type: itemx
#: zsh.texi:24828
#, no-wrap
msgid "@t{*:::}@var{message}@t{:}@var{action}"
msgstr "@t{*:::}@var{message}@t{:}@var{action}"

#. type: table
#: zsh.texi:24833
msgid ""
"This describes how arguments (usually non-option arguments, those not beginning with @t{-} or @t{+}) are to be completed when neither of the first two forms was provided.  Any number of arguments can be "
"completed in this fashion."
msgstr "说明在没有提供前两种形式的参数时，如何补全参数（通常是非选项参数，即不是以 @t{-} 或 @t{+} 开头的参数）。 任何数量的参数都可以用这种方式补全。"

#. type: table
#: zsh.texi:24840
msgid ""
"With two colons before the @var{message}, the @t{words} special array and the @t{CURRENT} special parameter are modified to refer only to the normal arguments when the @var{action} is executed or "
"evaluated.  With three colons before the @var{message} they are modified to refer only to the normal arguments covered by this description."
msgstr ""
"如果 @var{message} 之前有两个冒号，@t{words} 特殊数组和 @t{CURRENT} 特殊参数将被修改为在 @var{action} 执行或求值时仅引用常规参数。 如果在 @var{message} 之前加上三个冒号，它们将被修改为仅指本说明涵盖的正常"
"参数。"

#. type: var{#1}
#: zsh.texi:24841
#, no-wrap
msgid "optspec"
msgstr "optspec"

#. type: itemx
#: zsh.texi:24842
#, no-wrap
msgid "@var{optspec}@t{:}@var{...}"
msgstr "@var{optspec}@t{:}@var{...}"

#. type: table
#: zsh.texi:24846
msgid "This describes an option.  The colon indicates handling for one or more arguments to the option; if it is not present, the option is assumed to take no arguments."
msgstr "描述一个选项。 冒号表示处理该选项的一个或多个参数；如果没有冒号，则假定该选项不带参数。"

#. type: table
#: zsh.texi:24850
msgid "The following forms are available for the initial @var{optspec}, whether or not the option has arguments."
msgstr "无论选项是否有参数，初始的 @var{optspec} 都有以下几种形式。"

#. type: item
#: zsh.texi:24853
#, no-wrap
msgid "@t{*}@var{optspec}"
msgstr "@t{*}@var{optspec}"

#. type: table
#: zsh.texi:24858
msgid ""
"Here @var{optspec} is one of the remaining forms below.  This indicates the following @var{optspec} may be repeated.  Otherwise if the corresponding option is already present on the command line to the "
"left of the cursor it will not be offered again."
msgstr "这里的 @var{optspec} 是以下其余形式之一。 这表示后面的 @var{optspec} 可以重复。 否则，如果光标左侧的命令行中已有相应选项，则不会再次提供。"

#. type: item
#: zsh.texi:24859
#, no-wrap
msgid "@t{-}@var{optname}"
msgstr "@t{-}@var{optname}"

#. type: itemx
#: zsh.texi:24860
#, no-wrap
msgid "@t{+}@var{optname}"
msgstr "@t{+}@var{optname}"

#. type: table
#: zsh.texi:24865
msgid ""
"In the simplest form the @var{optspec} is just the option name beginning with a minus or a plus sign, such as `@t{-foo}'.  The first argument for the option (if any) must follow as a @emph{separate} word "
"directly after the option."
msgstr "在最简单的形式中，@var{optspec} 只是以减号或加号开头的选项名称，如 `@t{-foo}'。 选项的第一个参数（如果有）必须以 @emph{separate} 的形式出现在选项之后。"

#. type: table
#: zsh.texi:24869
msgid "Either of `@t{-+}@var{optname}' and `@t{+-}@var{optname}' can be used to specify that @t{-}@var{optname} and @t{+}@var{optname} are both valid."
msgstr " `@t{-+}@var{optname}' 和 `@t{+-}@var{optname}' 中的任一个都可以用来指定 @t{-}@var{optname} 和 @t{+}@var{optname} 都有效。"

#. type: table
#: zsh.texi:24873
msgid "In all the remaining forms, the leading `@t{-}' may be replaced by or paired with `@t{+}' in this way."
msgstr "在其余所有形式中，前导符 `@t{-}' 都可以以这个的方式用 `@t{+}' 替换或配对。"

#. type: item
#: zsh.texi:24874
#, no-wrap
msgid "@t{-}@var{optname}@t{-}"
msgstr "@t{-}@var{optname}@t{-}"

#. type: table
#: zsh.texi:24878
msgid ""
"The first argument of the option must come directly after the option name @emph{in the same word}.  For example, `@t{-foo-:}@var{...}' specifies that the completed option and argument will look like `@t{-"
"foo}@var{arg}'."
msgstr "选项的第一个参数必须直接位于 @emph{同一个词中} 的选项名称之后。例如， `@t{-foo-:}@var{...}' 指定补全的选项和参数看起来像 `@t{-foo}@var{arg}'。"

#. type: item
#: zsh.texi:24879
#, no-wrap
msgid "@t{-}@var{optname}@t{+}"
msgstr "@t{-}@var{optname}@t{+}"

#. type: table
#: zsh.texi:24884
msgid ""
"The first argument may appear immediately after @var{optname} in the same word, or may appear as a separate word after the option.  For example, `@t{-foo+:}@var{...}' specifies that the completed option "
"and argument will look like either `@t{-foo}@var{arg}' or `@t{-foo} @var{arg}'."
msgstr ""
"第一个参数可以紧跟在 @var{optname} 之后出现在同一个词中，也可以在选项之后作为一个单独的词出现。 例如，`@t{-foo+:}@var{...}' 表示补全后的选项和参数看上去像 `@t{-foo}@var{arg}' 或 `@t{-foo} @var{arg}'。"

#. type: item
#: zsh.texi:24885
#, no-wrap
msgid "@t{-}@var{optname}@t{=}"
msgstr "@t{-}@var{optname}@t{=}"

#. type: table
#: zsh.texi:24889
msgid "The argument may appear as the next word, or in same word as the option name provided that it is separated from it by an equals sign, for example `@t{-foo=}@var{arg}' or `@t{-foo} @var{arg}'."
msgstr "参数可以作为下一个单词出现，也可以与选项名称出现在同一个单词中，但必须用等号分隔，例如 `@t{-foo=}@var{arg}' 或 `@t{-foo} @var{arg}'。"

#. type: item
#: zsh.texi:24890
#, no-wrap
msgid "@t{-}@var{optname}@t{=-}"
msgstr "@t{-}@var{optname}@t{=-}"

#. type: table
#: zsh.texi:24893
msgid "The argument to the option must appear after an equals sign in the same word, and may not be given in the next argument."
msgstr "选项的参数必须出现在同一单词的等号之后，且不得在下一个参数中给出。"

#. type: item
#: zsh.texi:24894
#, no-wrap
msgid "@var{optspec}@t{[}@var{explanation}@t{]}"
msgstr "@var{optspec}@t{[}@var{explanation}@t{]}"

#. type: table
#: zsh.texi:24897
msgid "An explanation string may be appended to any of the preceding forms of @var{optspec} by enclosing it in brackets, as in `@t{-q[query operation]}'."
msgstr "在 @var{optspec}的任何前述形式中，都可以用括号括起解释字符串，如 `@t{-q[query operation]}'。"

#. type: table
#: zsh.texi:24901
msgid "The @t{verbose} style is used to decide whether the explanation strings are displayed with the option in a completion listing."
msgstr "@t{verbose} 样式用于决定是否在补全列表中与选项一起显示解释字符串。"

#. type: table
#: zsh.texi:24908
msgid ""
"If no bracketed explanation string is given but the @t{auto-description} style is set and only one argument is described for this @var{optspec}, the value of the style is displayed, with any appearance of "
"the sequence `@t{%d}' in it replaced by the @var{message} of the first @var{optarg} that follows the @var{optspec}; see below."
msgstr ""
"如果没有给出括号内的解释字符串，但设置了 @t{auto-description} 样式，且该 @var{optspec} 只描述了一个参数，则会显示该样式的值，其中出现的任何序列 `@t{%d}' 都会被 @var{optspec} 后面的第一个 @var{optarg} 的 "
"@var{message} 所替换；见下文。"

#. type: table
#: zsh.texi:24914
msgid "It is possible for options with a literal `@t{+}' or `@t{=}' to appear, but that character must be quoted, for example `@t{-\\+}'."
msgstr "选项中可以出现字面的 `@t{+}' 或 `@t{=}' ，但必须加上引号，例如 `@t{-\\+}'。"

#. type: table
#: zsh.texi:24918
msgid "Each @var{optarg} following an @var{optspec} must take one of the following forms:"
msgstr "在 @var{optspec} 之后的每个 @var{optarg} 必须是以下形式之一："

#. type: table
#: zsh.texi:24926
msgid "An argument to the option; @var{message} and @var{action} are treated as for ordinary arguments.  In the first form, the argument is mandatory, and in the second form it is optional."
msgstr "选项的参数；@var{message} 和 @var{action} 与普通参数一样。 在第一种形式中，参数是必选的，而在第二种形式中，参数是可选的。"

#. type: table
#: zsh.texi:24932
msgid ""
"This group may be repeated for options which take multiple arguments.  In other words, @t{:}@var{message1}@t{:}@var{action1}@t{:}@var{message2}@t{:}@var{action2} specifies that the option takes two "
"arguments."
msgstr "对于包含多个参数的选项，可以重复使用这组参数。 换句话说， @t{:}@var{message1}@t{:}@var{action1}@t{:}@var{message2}@t{:}@var{action2} 表示该选项有两个参数。"

#. type: item
#: zsh.texi:24933
#, no-wrap
msgid "@t{:*}@var{pattern}@t{:}@var{message}@t{:}@var{action}"
msgstr "@t{:*}@var{pattern}@t{:}@var{message}@t{:}@var{action}"

#. type: itemx
#: zsh.texi:24934
#, no-wrap
msgid "@t{:*}@var{pattern}@t{::}@var{message}@t{:}@var{action}"
msgstr "@t{:*}@var{pattern}@t{::}@var{message}@t{:}@var{action}"

#. type: itemx
#: zsh.texi:24935
#, no-wrap
msgid "@t{:*}@var{pattern}@t{:::}@var{message}@t{:}@var{action}"
msgstr "@t{:*}@var{pattern}@t{:::}@var{message}@t{:}@var{action}"

#. type: table
#: zsh.texi:24942
msgid ""
"This describes multiple arguments.  Only the last @var{optarg} for an option taking multiple arguments may be given in this form.  If the @var{pattern} is empty (i.e. @t{:*:}), all the remaining words on "
"the line are to be completed as described by the @var{action}; otherwise, all the words up to and including a word matching the @var{pattern} are to be completed using the @var{action}."
msgstr ""
"描述多个参数。 对于包含多个参数的选项，只有最后一个 @var{optarg} 可以用这种形式给出。 如果 @var{pattern} 为空（即 @t{:*:}），则该行剩余的所有单词都将按 @var{action} 所描述的方式补全；否则，所有单词（直到和"
"包括与 @var{pattern} 匹配的单词）都将按 @var{action} 所描述的方式补全。"

#. type: table
#: zsh.texi:24950
msgid ""
"Multiple colons are treated as for the `@t{*:}@var{...}' forms for ordinary arguments: when the @var{message} is preceded by two colons, the @t{words} special array and the @t{CURRENT} special parameter "
"are modified during the execution or evaluation of the @var{action} to refer only to the words after the option.  When preceded by three colons, they are modified to refer only to the words covered by "
"this description."
msgstr ""
"多个冒号的处理方式与普通参数的 `@t{*:}@var{...}' 形式相同：当 @var{message} 前面有两个冒号时，@t{words} 特殊数组和 @t{CURRENT} 特殊参数会在 @var{action} 执行或求值过程中被修改为仅指选项后面的单词。 如果前"
"面有三个冒号，它们将被修改为仅指本说明所涉及的字词。"

#. type: table
#: zsh.texi:24958
msgid "Any literal colon in an @var{optname}, @var{message}, or @var{action} must be preceded by a backslash, `@t{\\:}'."
msgstr "在 @var{optname}、@var{message} 或 @var{action} 中的任何字面冒号前都必须加上反斜线 `@t{\\:}'。"

#. type: table
#: zsh.texi:24969
msgid ""
"Each of the forms above may be preceded by a list in parentheses of option names and argument numbers.  If the given option is on the command line, the options and arguments indicated in parentheses will "
"not be offered.  For example, `@t{(-two -three 1)-one:}@var{...}' completes the option `@t{-one}'; if this appears on the command line, the options @t{-two} and @t{-three} and the first ordinary argument "
"will not be completed after it.  `@t{(-foo):}@var{...}' specifies an ordinary argument completion; @t{-foo} will not be completed if that argument is already present."
msgstr ""
"上述每种形式的前面都可以用括号列出选项名称和参数编号。 如果给定选项在命令行中，则不提供括号中的选项和参数。 例如，`@t{(-two -three 1)-one:}@var{...}' 补全了选项 `@t{-one}'；如果该选项出现在命令行中，在它之"
"后将不会补全选项 @t{-two} 和 @t{-three} 以及第一个普通参数。 `@t{(-foo):}@var{...}' 指定普通参数补全；如果该参数已经存在，则不会补全 @t{-foo} 。"

#. type: table
#: zsh.texi:24980
msgid ""
"Other items may appear in the list of excluded options to indicate various other items that should not be applied when the current specification is matched: a single star (@t{*}) for the rest arguments (i."
"e. a specification of the form `@t{*:}@var{...}'); a colon (@t{:})  for all normal (non-option-) arguments; and a hyphen (@t{-}) for all options.  For example, if `@t{(*)}' appears before an option and "
"the option appears on the command line, the list of remaining arguments (those shown in the above table beginning with `@t{*:}') will not be completed."
msgstr ""
"排除选项列表中还可能出现其他项目，以表示在匹配当前规范时不应应用的其他各种项目：单星号（@t{*}）表示其余参数（即格式为 `@t{*:}@var{...}' 的规范）；冒号（@t{:}）表示所有普通（非选项）参数；连字符（@t{-}）表"
"示所有选项。 例如，如果`@t{(*)}' 出现在某个选项之前，并且该选项出现在命令行中，那么剩余的参数列表（上表中以 `@t{*:}' 开头的参数）将不会补全。"

#. type: table
#: zsh.texi:24989
msgid ""
"To aid in reuse of specifications, it is possible to precede any of the forms above with `@t{!}'; then the form will no longer be completed, although if the option or argument appears on the command line "
"they will be skipped as normal.  The main use for this is when the arguments are given by an array, and @t{_arguments} is called repeatedly for more specific contexts: on the first call `@t{_arguments "
"$global_options}' is used, and on subsequent calls `@t{_arguments !$^global_options}'."
msgstr ""
"为了帮助规范的重复使用，可以在上述任何形式前加上 `@t{!}'；这样形式将不再补全，但如果选项或参数出现在命令行中，它们将被正常跳过。 这样做的主要用途是当参数由数组给出时，@t{_arguments} 会在更具体的上下文中被"
"重复调用：第一次调用时使用 `@t{_arguments $global_options}'，随后调用时使用 `@t{_arguments !$^global_options}'。"

#. type: emph{#1}
#: zsh.texi:24992
msgid "@var{spec}s: actions"
msgstr "@var{spec}s: 行为"

#. type: table
#: zsh.texi:25000
msgid ""
"In each of the forms above the @var{action} determines how completions should be generated.  Except for the `@t{->}@var{string}' form below, the @var{action} will be executed by calling the "
"@t{_all_labels} function to process all tag labels.  No special handling of tags is needed unless a function call introduces a new one."
msgstr ""
"在上述每个形式中，@var{action} 都决定了补全的生成方式。 除了下面的 `@t{->}@var{string}' 形式，@var{action} 将通过调用 @t{_all_labels} 函数处理所有标记标签来执行。 除非函数调用引入了新标签，否则无需对标记进"
"行特殊处理。"

#. type: table
#: zsh.texi:25006
msgid ""
"The functions called to execute @var{action}s will be called with the elements of the array named by the `@t{-O} @var{name}' option as arguments.  This can be used, for example, to pass the same set of "
"options for the @t{compadd} builtin to all @var{action}s."
msgstr "执行 @var{action}s 时调用的函数将以 `@t{-O} @var{name}' 选项命名的数组元素作为参数。 例如，这可以用来将 @t{compadd} 内置函数的同一选项集传递给所有 @var{action}s 。"

#. type: table
#: zsh.texi:25009
msgid "The forms for @var{action} are as follows."
msgstr "@var{action} 的形式如下。"

#. type: item
#: zsh.texi:25012
#, no-wrap
msgid "@t{@ }(single unquoted space)"
msgstr "@t{@ }(single unquoted space)"

#. type: table
#: zsh.texi:25019
msgid ""
"This is useful where an argument is required but it is not possible or desirable to generate matches for it.  The @var{message} will be displayed but no completions listed.  Note that even in this case "
"the colon at the end of the @var{message} is needed; it may only be omitted when neither a @var{message} nor an @var{action} is given."
msgstr ""
"This is useful where an argument is required but it is not possible or desirable to generate matches for it.  The @var{message} will be displayed but no completions listed.  Note that even in this case "
"the colon at the end of the @var{message} is needed; it may only be omitted when neither a @var{message} nor an @var{action} is given."

#. type: item
#: zsh.texi:25020
#, no-wrap
msgid "@t{(}@var{item1} @var{item2} @var{...}@t{)}"
msgstr "@t{(}@var{item1} @var{item2} @var{...}@t{)}"

#. type: table
#: zsh.texi:25022
msgid "One of a list of possible matches, for example:"
msgstr "例如，可能匹配的列表之一："

#. type: example
#: zsh.texi:25026
#, no-wrap
msgid "@t{:foo:(foo bar baz}@t{)}\n"
msgstr "@t{:foo:(foo bar baz}@t{)}\n"

#. type: t{#1}
#: zsh.texi:25028
#, no-wrap
msgid "((@var{item1}\\:@var{desc1} @var{...}))"
msgstr "((@var{item1}\\:@var{desc1} @var{...}))"

#. type: table
#: zsh.texi:25031
msgid "Similar to the above, but with descriptions for each possible match.  Note the backslash before the colon.  For example,"
msgstr "与上述类似，但对每种可能的匹配都进行了说明。 注意冒号前的反斜杠。 例如"

#. type: example
#: zsh.texi:25035
#, no-wrap
msgid "@t{:foo:((a\\:bar b\\:baz}@t{))}\n"
msgstr "@t{:foo:((a\\:bar b\\:baz}@t{))}\n"

#. type: table
#: zsh.texi:25040
msgid "The matches will be listed together with their descriptions if the @t{description} style is set with the @t{values} tag in the context."
msgstr "如果上下文中的 @t{values} 标记设置了 @t{description} 样式，则匹配项将与其描述一起列出。"

#. type: item
#: zsh.texi:25041
#, no-wrap
msgid "@t{->}@var{string}"
msgstr "@t{->}@var{string}"

#. type: vindex
#: zsh.texi:25042
#, no-wrap
msgid "context, use of"
msgstr "context, use of"

#. type: vindex
#: zsh.texi:25043
#, no-wrap
msgid "line, use of"
msgstr "line, use of"

#. type: vindex
#: zsh.texi:25044
#, no-wrap
msgid "opt_args, use of"
msgstr "opt_args, use of"

#. type: table
#: zsh.texi:25050
msgid ""
"In this form, @t{_arguments} processes the arguments and options and then returns control to the calling function with parameters set to indicate the state of processing; the calling function then makes "
"its own arrangements for generating completions.  For example, functions that implement a state machine can use this type of action."
msgstr "在这种形式中，@t{_arguments} 处理参数和选项，然后将控制权返回给调用函数，并设置参数指示处理状态；正在调用的函数然后自行安排生成补全。 例如，实现状态机的函数就可以使用这种操作。"

#. type: table
#: zsh.texi:25058
msgid ""
"Where @t{_arguments} encounters @var{action} in the `@t{->}@var{string}' format, it will strip all leading and trailing whitespace from @var{string} and set the array @t{state} to the set of all "
"@var{string}s for which an action is to be performed.  The elements of the array @t{state_descr} are assigned the corresponding @var{message} field from each @var{optarg} containing such an @var{action}."
msgstr ""
"当 @t{_arguments} 遇到格式为 `@t{->}@var{string}' 的 @var{action} 时，它将从 @var{string} 中删除所有前导和尾部空白，并将数组 @t{state} 设置为要执行操作的所有 @var{string}s 的集合。 数组 @t{state_descr} 中"
"的元素将分配给每个 @var{optarg} 中包含此类 @var{action} 的 @var{message} 字段。"

#. type: table
#: zsh.texi:25065
msgid ""
"By default and in common with all other well behaved completion functions, _arguments returns status zero if it was able to add matches and non-zero otherwise. However, if the @t{-R} option is given, "
"@t{_arguments} will instead return a status of 300 to indicate that @t{$state} is to be handled."
msgstr "默认情况下，与所有其他行为良好的补全函数一样，_arguments 在能够添加匹配时返回状态 0，否则返回非 0。但是，如果给出 @t{-R} 选项，@t{_arguments} 将返回状态 300，表示 @t{$state} 将被处理。"

#. type: table
#: zsh.texi:25073
msgid ""
"In addition to @t{$state} and @t{$state_descr}, @t{_arguments} also sets the global parameters `@t{context}', `@t{line}' and `@t{opt_args}' as described below, and does not reset any changes made to the "
"special parameters such as @t{PREFIX} and @t{words}.  This gives the calling function the choice of resetting these parameters or propagating changes in them."
msgstr ""
"除了 @t{$state} 和 @t{$state_descr} 之外，@t{_arguments} 还会如下所述设置全局参数 `@t{context}', `@t{line}' 和 `@t{opt_args}' ，并且不会重置任何对 @t{PREFIX} 和 @t{words} 等特殊参数的修改。 这使得调用函数"
"可以选择重置这些参数或传播参数的更改。"

#. type: table
#: zsh.texi:25078
msgid "A function calling @t{_arguments} with at least one action containing a `@t{->}@var{string}' must therefore declare appropriate local parameters:"
msgstr "因此，调用 @t{_arguments} 时至少有一个动作包含 `@t{->}@var{string}' 的函数，必须声明适当的本地参数："

#. type: example
#: zsh.texi:25083
#, no-wrap
msgid ""
"local context state state_descr line\n"
"typeset -A opt_args\n"
msgstr ""
"local context state state_descr line\n"
"typeset -A opt_args\n"

#. type: table
#: zsh.texi:25087
msgid "to prevent @t{_arguments} from altering the global environment."
msgstr "以防止 @t{_arguments} 改变全局环境。"

#. type: item
#: zsh.texi:25088
#, no-wrap
msgid "@t{@{}@var{eval-string}@t{@}}"
msgstr "@t{@{}@var{eval-string}@t{@}}"

#. type: vindex
#: zsh.texi:25089
#, no-wrap
msgid "expl, use of"
msgstr "expl, use of"

#. type: table
#: zsh.texi:25093
msgid ""
"A string in braces is evaluated as shell code to generate matches.  If the @var{eval-string} itself does not begin with an opening parenthesis or brace it is split into separate words before execution."
msgstr "括号中的字符串将作为 shell 代码进行计算，以生成匹配结果。 如果 @var{eval-string} 本身不是以开小括号或开大括号开头，则会在执行前被分割成单独的单词。"

#. type: item
#: zsh.texi:25094
#, no-wrap
msgid "@t{= }@var{action}"
msgstr "@t{= }@var{action}"

#. type: table
#: zsh.texi:25102
msgid ""
"If the @var{action} starts with `@t{= }' (an equals sign followed by a space), @t{_arguments} will insert the contents of the @var{argument} field of the current context as the new first element in the "
"@t{words} special array and increment the value of the @t{CURRENT} special parameter.  This has the effect of inserting a dummy word onto the completion command line while not changing the point at which "
"completion is taking place."
msgstr ""
"如果 @var{action} 以 `@t{= }' （等号后有空格）开头，@t{_arguments} 将插入当前上下文中 @var{argument} 字段的内容，作为 @t{words} 特殊数组中新的第一个元素，并递增 @t{CURRENT} 特殊参数的值。 这样做的效果是在"
"补全命令行中插入一个虚词，同时不改变补全正在进行的位置。"

#. type: table
#: zsh.texi:25110
msgid ""
"This is most useful with one of the specifiers that restrict the words on the command line on which the @var{action} is to operate (the two- and three-colon forms above).  One particular use is when an "
"@var{action} itself causes @t{_arguments} on a restricted range; it is necessary to use this trick to insert an appropriate command name into the range for the second call to @t{_arguments} to be able to "
"parse the line."
msgstr ""
"对于限制 @var{action} 在命令行中操作的字词的指定符之一（上述双冒号和三冒号形式），这一点最为有用。 一个特殊的用法是，当 @var{action} 本身导致 @t{_arguments} 在一个受限的范围内运行时；有必要使用这个技巧，"
"在 @t{_arguments} 的第二次调用的范围内插入一个适当的命令名称，以便能够解析该行。"

#. type: var{#1}
#: zsh.texi:25111
#, no-wrap
msgid "@t{@ }word..."
msgstr "@t{@ }word..."

#. type: var{#1}
#: zsh.texi:25112
#, no-wrap
msgid "word..."
msgstr "word..."

#. type: table
#: zsh.texi:25115
msgid "This covers all forms other than those above.  If the @var{action} starts with a space, the remaining list of words will be invoked unchanged."
msgstr "这涵盖了除上述形式以外的所有其他形式。 如果 @var{action} 以空格开头，剩余的单词列表将保持不变。"

#. type: table
#: zsh.texi:25126
msgid ""
"Otherwise it will be invoked with some extra strings placed after the first word; these are to be passed down as options to the @t{compadd} builtin.  They ensure that the state specified by "
"@t{_arguments}, in particular the descriptions of options and arguments, is correctly passed to the completion command.  These additional arguments are taken from the array parameter `@t{expl}'; this will "
"be set up before executing the @var{action} and hence may be referred to inside it, typically in an expansion of the form `@t{$expl[@@]}' which preserves empty elements of the array."
msgstr ""
"否则，调用时将在第一个单词后添加一些额外的字符串；这些字符串将作为选项传递给 @t{compadd} 内置函数。 它们确保 @t{_arguments} 指定的状态，尤其是选项和参数的描述，能正确地传递给补全命令。 这些附加参数取自数组"
"参数 `@t{expl}'；该参数将在执行 @var{action} 之前设置，因此可以在 @var{action} 中引用，通常以 `@t{$expl[@@]}' 的形式展开，这样可以保留数组中的空元素。"

#. type: table
#: zsh.texi:25142
msgid ""
"During the performance of the action the array `@t{line}' will be set to the normal arguments from the command line, i.e. the words from the command line after the command name excluding all options and "
"their arguments.  Options are stored in the associative array `@t{opt_args}' with option names as keys and their arguments as the values.  By default, all colons and backslashes in the value are escaped "
"with backslashes, and if an option has multiple arguments (for example, when using an @var{optspec} of the form `@t{*}@var{optspec}'), they are joined with (unescaped) colons.  However, if the @t{-0} "
"option was passed, no backslash escaping is performed, and multiple values are joined with NUL bytes.  For example, after `@t{zsh -o foo:foo -o bar:bar -o <TAB>}', the contents of `@t{opt_args}' would be"
msgstr ""
"在执行操作时，数组 `@t{line}' 将被设置为命令行中的正常参数，即命令行中命令名称之后的字词，不包括所有选项及其参数。 选项存储在关联数组 `@t{opt_args}' 中，选项名称为键，参数为值。 默认情况下，值中的所有冒号"
"和反斜线都用反斜线转义，如果一个选项有多个参数（例如，当使用形式为 `@t{*}@var{optspec}' 的 @var{optspec} 时），它们会用（未转义的）冒号连接起来。 但是，如果传递了 @t{-0} 选项，则不会执行反斜杠转义，而是用 "
"NUL 字节连接多个值。 例如，在 `@t{zsh -o foo:foo -o bar:bar -o <TAB>}' 之后，`@t{opt_args}' 的内容将是"

#. type: example
#: zsh.texi:25146
#, no-wrap
msgid "typeset -A opt_args=( [-o]='foo\\:foo:bar\\:bar:' )\n"
msgstr "typeset -A opt_args=( [-o]='foo\\:foo:bar\\:bar:' )\n"

#. type: table
#: zsh.texi:25150
msgid "by default, and"
msgstr "默认，并且"

#. type: example
#: zsh.texi:25154
#, no-wrap
msgid "typeset -A opt_args=( [-o]=$'foo:foo\\x00bar:bar\\x00' )\n"
msgstr "typeset -A opt_args=( [-o]=$'foo:foo\\x00bar:bar\\x00' )\n"

#. type: table
#: zsh.texi:25158
msgid "if @t{_arguments} had been called with the @t{-0} option."
msgstr "如果 @t{_arguments} 在调用时使用了 @t{-0} 选项。"

#. type: table
#: zsh.texi:25171
msgid ""
"The parameter `@t{context}' is set when returning to the calling function to perform an action of the form `@t{->}@var{string}'.  It is set to an array of elements corresponding to the elements of "
"@t{$state}.  Each element is a suitable name for the argument field of the context: either a string of the form `@t{option}@var{-opt}@t{-}@var{n}' for the @var{n}'th argument of the option @var{-opt}, or "
"a string of the form `@t{argument-}@var{n}' for the @var{n}'th argument.  For `rest' arguments, that is those in the list at the end not handled by position, @var{n} is the string `@t{rest}'.  For "
"example, when completing the argument of the @t{-o} option, the name is `@t{option-o-1}', while for the second normal (non-option-) argument it is `@t{argument-2}'."
msgstr ""
"参数 `@t{context}' 在返回调用函数执行形式为 `@t{->}@var{string}' 的操作时被设置。 它被设置为与 @t{$state} 的元素相对应的元素数组。 每个元素都是上下文参数字段的合适名称：或者是表示选项 @var{-opt} 的第 "
"@var{n} 个参数的形式为 `@t{option}@var{-opt}@t{-}@var{n}' 的字符串，或者是表示第 @var{n} 个参数的形式为 `@t{argument-}@var{n}' 的字符串。 对于 `rest' 参数，即列表末尾未被 position 处理的参数，@var{n} 是字"
"符串 `@t{rest}'。 例如，补全 @t{-o} 选项的参数时，名称为 `@t{option-o-1}'，而对于第二个正常（非选项）参数，名称为 `@t{argument-2}'。"

#. type: table
#: zsh.texi:25176
msgid "Furthermore, during the evaluation of the @var{action} the context name in the @t{curcontext} parameter is altered to append the same string that is stored in the @t{context} parameter."
msgstr "此外，在执行 @var{action} 时，会更改 @t{curcontext} 参数中的上下文名称，以附加 @t{context} 参数中存储的相同的字符串。"

#. type: table
#: zsh.texi:25184
msgid ""
"The option @t{-C} tells @t{_arguments} to modify the @t{curcontext} parameter for an action of the form `@t{->}@var{state}'.  This is the standard parameter used to keep track of the current context.  "
"Here it (and not the @t{context} array) should be made local to the calling function to avoid passing back the modified value and should be initialised to the current value at the start of the function:"
msgstr ""
"选项 @t{-C} 会告诉 @t{_arguments} 为形式为 `@t{->}@var{state}' 的操作修改 @t{curcontext} 参数。 这是用于跟踪当前上下文的标准参数。 在此，它（而非 @t{context} 数组）应被设置为调用函数的本地参数，以避免传回"
"修改后的值，并应在函数开始时初始化为当前值："

#. type: example
#: zsh.texi:25188
#, no-wrap
msgid "local curcontext=\"$curcontext\"\n"
msgstr "local curcontext=\"$curcontext\"\n"

#. type: table
#: zsh.texi:25193
msgid "This is useful where it is not possible for multiple states to be valid together."
msgstr "当多个状态不可能同时有效时，这种方法就很有用。"

#. type: emph{#1}
#: zsh.texi:25196
msgid "Grouping Options"
msgstr "选项分组"

#. type: table
#: zsh.texi:25203
msgid ""
"Options can be grouped to simplify exclusion lists. A group is introduced with `@t{+}' followed by a name for the group in the subsequent word. Whole groups can then be referenced in an exclusion list or "
"a group name can be used to disambiguate between two forms of the same option. For example:"
msgstr "可以对选项进行分组，以简化排除列表。一个组可以用 `@t{+}' 引入，后面的词是该组的名称。在排除列表中可以引用整个组，也可以使用组名来区分同一选项的两种形式。例如"

#. type: example
#: zsh.texi:25213
#, no-wrap
msgid ""
"_arguments \\ \n"
"    '(group2--x)-a' \\ \n"
"  + group1 \\ \n"
"    -m \\ \n"
"    '(group2)-n' \\ \n"
"  + group2 \\ \n"
"    -x -y\n"
msgstr ""
"_arguments \\ \n"
"    '(group2--x)-a' \\ \n"
"  + group1 \\ \n"
"    -m \\ \n"
"    '(group2)-n' \\ \n"
"  + group2 \\ \n"
"    -x -y\n"

#. type: table
#: zsh.texi:25221
msgid ""
"If the name of a group is specified in the form `@t{(}@var{name}@t{)}' then only one value from that group will ever be completed; more formally, all specifications are mutually exclusive to all other "
"specifications in that group. This is useful for defining options that are aliases for each other. For example:"
msgstr "如果以 `@t{(}@var{name}@t{)}' 的形式指定了一个组的名称，那么该组中只有一个值会被补全；更正式地说，所有规范与该组中的所有其他规范互斥。这对于定义互为别名的选项非常有用。例如:"

#. type: example
#: zsh.texi:25230
#, no-wrap
msgid ""
"_arguments \\ \n"
"    -a -b \\ \n"
"  + '(operation)' \\ \n"
"    @{-c,--compress@}'[compress]' \\ \n"
"    @{-d,--decompress@}'[decompress]' \\ \n"
"    @{-l,--list@}'[list]'\n"
msgstr ""
"_arguments \\ \n"
"    -a -b \\ \n"
"  + '(operation)' \\ \n"
"    @{-c,--compress@}'[compress]' \\ \n"
"    @{-d,--decompress@}'[decompress]' \\ \n"
"    @{-l,--list@}'[list]'\n"

#. type: table
#: zsh.texi:25237
msgid ""
"If an option in a group appears on the command line, it is stored in the associative array `@t{opt_args}' with '@var{group}@t{-}@var{option}' as a key.  In the example above, a key `@t{operation--c}' is "
"used if the option `@t{-c}' is present on the command line."
msgstr "如果命令行中出现了某个组中的选项，该选项就会以 '@var{group}@t{-}@var{option}' 为键存储在关联数组 `@t{opt_args}' 中。 在上例中，如果命令行中出现选项 `@t{-c}' ，则使用键 `@t{operation--c}' 。"

#. type: emph{#1}
#: zsh.texi:25240
msgid "Specifying Multiple Sets of Arguments"
msgstr "指定多个参数集"

#. type: table
#: zsh.texi:25245
msgid ""
"It is possible to specify multiple sets of options and arguments with the sets separated by single hyphens. This differs from groups in that sets are considered to be mutually exclusive of each other."
msgstr "可以指定多个选项和参数集(set)，各个集(set)之间用单个连字符隔开。这与组(group)不同，集与集之间是相互排斥的。"

#. type: table
#: zsh.texi:25249
msgid "Specifications before the first set and from any group are common to all sets. For example:"
msgstr "第一组之前和任何一组中的规格对所有组都是通用的。例如"

#. type: example
#: zsh.texi:25259
#, no-wrap
msgid ""
"_arguments \\ \n"
"    -a \\ \n"
"  - set1 \\ \n"
"    -c \\ \n"
"  - set2 \\ \n"
"    -d \\ \n"
"    ':arg:(x2 y2)'\n"
msgstr ""
"_arguments \\ \n"
"    -a \\ \n"
"  - set1 \\ \n"
"    -c \\ \n"
"  - set2 \\ \n"
"    -d \\ \n"
"    ':arg:(x2 y2)'\n"

#. type: table
#: zsh.texi:25267
msgid ""
"This defines two sets.  When the command line contains the option `@t{-c}', the `@t{-d}' option and the argument will not be considered possible completions.  When it contains `@t{-d}' or an argument, the "
"option `@t{-c}' will not be considered.  However, after `@t{-a}' both sets will still be considered valid."
msgstr ""
"这定义了两个集。 当命令行包含 `@t{-c}' 选项时， `@t{-d}' 选项和参数将不被视为可能的补全。 当命令行包含 `@t{-d}' 或一个参数时， `@t{-c}' 选项将不被考虑。 但是，在 `@t{-a}' 之后，这两个集仍将被视为有效。"

#. type: table
#: zsh.texi:25271
msgid "As for groups, the name of a set may appear in exclusion lists, either alone or preceding a normal option or argument specification."
msgstr "至于组，集合的名称可以单独出现在排除列表中，或者在普通选项或参数规范之前出现。"

#. type: table
#: zsh.texi:25278
msgid ""
"The completion code has to parse the command line separately for each set. This can be slow so sets should only be used when necessary.  A useful alternative is often an option specification with rest-"
"arguments (as in `@t{-foo:*:...}'); here the option @t{-foo} swallows up all remaining arguments as described by the @var{optarg} definitions."
msgstr ""
"补全代码必须为每个集分别解析命令行。这可能会很慢，因此只有在必要时才使用集合。 一个有用的替代方法通常是带有其余参数的选项说明（如  `@t{-foo:*:...}' 中）；在这里，选项 @t{-foo} 会吞掉 @var{optarg} 定义中描"
"述的所有其余参数。"

#. type: emph{#1}
#: zsh.texi:25281
msgid "Deriving @var{spec} forms from the help output"
msgstr "从帮助输出中派生 @var{spec} 形式"

#. type: table
#: zsh.texi:25289
msgid ""
"The option `@t{-}@t{-}' allows @t{_arguments} to work out the names of long options that support the `@t{-}@t{-help}' option which is standard in many GNU commands.  The command word is called with the "
"argument `@t{-}@t{-help}' and the output examined for option names.  Clearly, it can be dangerous to pass this to commands which may not support this option as the behaviour of the command is unspecified."
msgstr ""
"选项 `@t{-}@t{-}' 允许 @t{_arguments} 计算出支持 `@t{-}@t{-help}' 选项的长选项名称，该选项是许多 GNU 命令的标准选项。 在调用命令字时，会使用参数 `@t{-}@t{-help}' ，并检查输出的选项名称。 显然，将该选项传递"
"给可能不支持该选项的命令是很危险的，因为命令的行为是不明确的。"

#. type: table
#: zsh.texi:25302
msgid ""
"In addition to options, `@t{_arguments -}@t{-}' will try to deduce the types of arguments available for options when the form `@t{-}@t{-}@var{opt}@t{=}@var{val}' is valid.  It is also possible to provide "
"hints by examining the help text of the command and adding @var{helpspec} of the form `@var{pattern}@t{:}@var{message}@t{:}@var{action}'; note that other @t{_arguments} @var{spec} forms are not used.  The "
"@var{pattern} is matched against the help text for an option, and if it matches the @var{message} and @var{action} are used as for other argument specifiers.  The special case of `@t{*:}' means both "
"@var{message} and @var{action} are empty, which has the effect of causing options having no description in the help output to be ordered in listings ahead of options that have a description."
msgstr ""
"除选项外，当 `@t{-}@t{-}@var{opt}@t{=}@var{val}' 形式有效时，`@t{_arguments -}@t{-}' 将尝试推断出选项的参数类型。 还可以通过检查命令的帮助文本并添加形式为 `@var{pattern}@t{:}@var{message}@t{:}"
"@var{action}' 的 @var{helpspec} 来提供提示；注意，其他 @t{_arguments} @var{spec} 形式不被使用。 @var{pattern} 将与选项的帮助文本进行匹配，如果匹配成功，则使用 @var{message} 和 @var{action} 作为其他参数指定"
"符。  `@t{*:}' 的特殊情况意味着 @var{message} 和 @var{action} 都是空的，这将导致在帮助输出中没有说明的选项被排在有说明的选项之前。"

#. type: example
#: zsh.texi:25312
#, no-wrap
msgid ""
"_arguments -- '*\\*:toggle:(yes no)' \\ \n"
"              '*=FILE*:file:_files' \\ \n"
"              '*=DIR*:directory:_files -/' \\ \n"
"              '*=PATH*:directory:_files -/'\n"
msgstr ""
"_arguments -- '*\\*:toggle:(yes no)' \\ \n"
"              '*=FILE*:file:_files' \\ \n"
"              '*=DIR*:directory:_files -/' \\ \n"
"              '*=PATH*:directory:_files -/'\n"

#. type: table
#: zsh.texi:25322
msgid ""
"Here, `@t{yes}' and `@t{no}' will be completed as the argument of options whose description ends in a star; file names will be completed for options that contain the substring `@t{=FILE}' in the "
"description; and directories will be completed for options whose description contains `@t{=DIR}' or `@t{=PATH}'.  The last three are in fact the default and so need not be given explicitly, although it is "
"possible to override the use of these patterns.  A typical help text which uses this feature is:"
msgstr ""
"这里，`@t{yes}' 和 `@t{no}' 将作为描述是以星号结尾的选项的参数进行补全；选项的描述中包含子串 `@t{=FILE}' 的，文件会被补全；选项的描述中包含 `@t{=DIR}' 或 `@t{=PATH}' 的，目录会被补全。 后三种模式实际上是默"
"认的，因此不需要明确给出，不过可以覆盖这些模式的使用。 使用这一功能的典型帮助文本是:"

#. type: example
#: zsh.texi:25326
#, no-wrap
msgid "  -C, --directory=DIR          change to directory DIR\n"
msgstr "  -C, --directory=DIR          转到目录 DIR\n"

#. type: table
#: zsh.texi:25331
msgid "so that the above specifications will cause directories to be completed after `@t{-}@t{-directory}', though not after `@t{-C}'."
msgstr "因此，上述规范将导致目录在 `@t{-}@t{-directory}' 之后补全，但不会在 `@t{-C}' 之后补全。"

#. type: table
#: zsh.texi:25336
msgid "Note also that @t{_arguments} tries to find out automatically if the argument for an option is optional.  This can be specified explicitly by doubling the colon before the @var{message}."
msgstr "请注意，@t{_arguments} 会自动检测选项的参数是否为可选参数。 可以通过在 @var{message} 前面加双冒号来明确指定。"

#. type: table
#: zsh.texi:25342
msgid ""
"If the @var{pattern} ends in `@t{(-)}', this will be removed from the pattern and the @var{action} will be used only directly after the `@t{=}', not in the next word.  This is the behaviour of a normal "
"specification defined with the form `@t{=-}'."
msgstr "如果 @var{pattern} 以 `@t{(-)}' 结尾，则会将其从模式中删除，并且 @var{action} 只会在 `@t{=}' 之后直接使用，而不会在下一个词中使用。 这就是以 `@t{=-}' 形式定义的正常规范的行为。"

#. type: table
#: zsh.texi:25349
msgid ""
"By default, the command (with the option `@t{--help}') is run after resetting all the locale categories (except for @t{LC_CTYPE}) to `@t{C}'.  If the localized help output is known to work, the option "
"`@t{-l}' can be specified after the `@t{_arguments -}@t{-}' so that the command is run in the current locale."
msgstr ""
"默认情况下，命令（带选项 `@t{--help}'）会在将所有语言类别（@t{LC_CTYPE}除外）重置为 `@t{C}' 后运行。 如果已知本地化帮助输出有效，可以在 `@t{_arguments -}@t{-}' 之后指定选项 `@t{-l}' ，这样命令就会以当前的"
"本地化语言运行。"

#. type: table
#: zsh.texi:25355
msgid ""
"The `@t{_arguments -}@t{-}' can be followed by the option `@t{-i} @var{patterns}' to give patterns for options which are not to be completed.  The patterns can be given as the name of an array parameter "
"or as a literal list in parentheses.  For example,"
msgstr "在\" `@t{_arguments -}@t{-}' 后面可以加上 `@t{-i} @var{patterns}' 选项,以给出不需要补全的选项模式。 模式可以是数组参数的名称，也可以是括号中的字面列表。 例如,"

#. type: example
#: zsh.texi:25360
#, no-wrap
msgid ""
"_arguments -- -i \\ \n"
"    \"(--(en|dis)able-FEATURE*)\"\n"
msgstr ""
"_arguments -- -i \\ \n"
"    \"(--(en|dis)able-FEATURE*)\"\n"

#. type: table
#: zsh.texi:25366
msgid "will cause completion to ignore the options `@t{-}@t{-enable-FEATURE}' and `@t{-}@t{-disable-FEATURE}' (this example is useful with GNU @t{configure})."
msgstr "将导致补全忽略选项 `@t{-}@t{-enable-FEATURE}' 和 `@t{-}@t{-disable-FEATURE}' （本例在使用 GNU @t{configure} 时非常有用）。"

#. type: table
#: zsh.texi:25373
msgid ""
"The `@t{_arguments -}@t{-}' form can also be followed by the option `@t{-s} @var{pair}' to describe option aliases.  The @var{pair} consists of a list of alternating patterns and corresponding "
"replacements, enclosed in parens and quoted so that it forms a single argument word in the @t{_arguments} call."
msgstr " `@t{_arguments -}@t{-}' 形式后还可以加上 `@t{-s} @var{pair}' 选项来描述选项别名。 @var{pair} 由一系列可选的模式和相应的替换组成，用双引号括起来，以便在 @t{_arguments} 调用中形成一个参数词。"

#. type: table
#: zsh.texi:25378
msgid ""
"For example, some @t{configure}-script help output describes options only as `@t{-}@t{-enable-foo}', but the script also accepts the negated form `@t{-}@t{-disable-foo}'.  To allow completion of the "
"second form:"
msgstr "例如，某些 @t{configure} 脚本的帮助输出仅将选项描述为 `@t{-}@t{-enable-foo}'，但脚本也接受否定形式 `@t{-}@t{-disable-foo}'。 允许补全第二种形式："

#. type: example
#: zsh.texi:25382
#, no-wrap
msgid "_arguments -- -s \"((#s)--enable- --disable-)\"\n"
msgstr "_arguments -- -s \"((#s)--enable- --disable-)\"\n"

#. type: emph{#1}
#: zsh.texi:25386
msgid "Miscellaneous notes"
msgstr "杂项说明"

#. type: table
#: zsh.texi:25394
msgid ""
"Finally, note that @t{_arguments} generally expects to be the primary function handling any completion for which it is used.  It may have side effects which change the treatment of any matches added by "
"other functions called after it.  To combine @t{_arguments} with other functions, those functions should be called either before @t{_arguments}, as an @var{action} within a @var{spec}, or in handlers for "
"`@t{->}@var{state}' actions."
msgstr ""
"最后请注意，@t{_arguments} 通常希望自己是处理补全的主要函数。 它可能会产生副作用，改变在它之后调用的其他函数所添加的匹配项的处理方式。 要将 @t{_arguments} 与其他函数结合使用，应在 @t{_arguments} 之前,作为 "
"@var{spec} 中的 @var{action} 调用，或在 `@t{->}@var{state}' 操作的处理程序中调用。"

#. type: table
#: zsh.texi:25397
msgid "Here is a more general example of the use of @t{_arguments}:"
msgstr "下面是使用 @t{_arguments} 的一个更普通的示例："

#. type: example
#: zsh.texi:25405
#, no-wrap
msgid ""
"_arguments '-l+:left border:' \\ \n"
"           '-format:paper size:(letter A4)' \\ \n"
"           '*-copy:output file:_files::resolution:(300 600)' \\ \n"
"           ':postscript file:_files -g \\*.\\(ps\\|eps\\)' \\ \n"
"           '*:page number:'\n"
msgstr ""
"_arguments '-l+:left border:' \\ \n"
"           '-format:paper size:(letter A4)' \\ \n"
"           '*-copy:output file:_files::resolution:(300 600)' \\ \n"
"           ':postscript file:_files -g \\*.\\(ps\\|eps\\)' \\ \n"
"           '*:page number:'\n"

#. type: table
#: zsh.texi:25413
msgid ""
"This describes three options: `@t{-l}', `@t{-format}', and `@t{-copy}'.  The first takes one argument described as `@var{left border}' for which no completion will be offered because of the empty action.  "
"Its argument may come directly after the `@t{-l}' or it may be given as the next word on the line."
msgstr ""
"这里描述了三个选项： `@t{-l}', `@t{-format}' 和 `@t{-copy}'。 第一个选项需要一个参数，描述为`@var{left border}' ，由于是空操作，因此不会提供补全。 它的参数可以直接位于 `@t{-l}' 之后，也可以作为该行的下一个"
"单词给出。"

#. type: table
#: zsh.texi:25418
msgid "The `@t{-format}' option takes one argument in the next word, described as `@var{paper size}' for which only the strings `@t{letter}' and `@t{A4}' will be completed."
msgstr " `@t{-format}' 选项在下一个单词中接收一个参数，描述为 `@var{paper size}' ，对于该参数，只会补全 `@t{letter}' 和 `@t{A4}' 字符串。"

#. type: table
#: zsh.texi:25425
msgid ""
"The `@t{-copy}' option may appear more than once on the command line and takes two arguments.  The first is mandatory and will be completed as a filename.  The second is optional (because of the second "
"colon before the description `@var{resolution}') and will be completed from the strings `@t{300}' and `@t{600}'."
msgstr ""
" `@t{-copy}' 选项可以在命令行中出现多次，并包含两个参数。 第一个参数是必选参数，将以文件名形式补全。 第二个参数是可选参数（因为在描述符 `@var{resolution}' 前有第二个冒号），将由字符串 `@t{300}' 和 "
"`@t{600}' 补全。"

#. type: table
#: zsh.texi:25432
msgid ""
"The last two descriptions say what should be completed as arguments.  The first describes the first argument as a `@var{postscript file}' and makes files ending in `@t{ps}' or `@t{eps}' be completed.  The "
"last description gives all other arguments the description `@var{page number}' but does not offer completions."
msgstr "后两处说明了应补全的参数。 第一个说明将第一个参数描述为 `@var{postscript file}'，并要求补全以 `@t{ps}' 或 `@t{eps}' 结尾的文件。 最后一种描述将所有其他参数描述为 `@var{page number}' ，但不提供补全。"

#. type: findex
#: zsh.texi:25433
#, no-wrap
msgid "_cache_invalid"
msgstr "_cache_invalid"

#. type: item
#: zsh.texi:25434
#, no-wrap
msgid "@t{_cache_invalid} @var{cache_identifier}"
msgstr "@t{_cache_invalid} @var{cache_identifier}"

#. type: table
#: zsh.texi:25440
msgid ""
"This function returns status zero if the completions cache corresponding to the given cache identifier needs rebuilding.  It determines this by looking up the @t{cache-policy} style for the current "
"context.  This should provide a function name which is run with the full path to the relevant cache file as the only argument."
msgstr "如果给定的补全缓存标识符对应的补全缓存需要重建，则此函数返回状态 0。 它通过查找当前上下文的 @t{cache-policy} 样式来确定。 它应提供一个函数名，该函数名的唯一参数是相关缓存文件的完整路径。"

#. type: Plain text
#: zsh.texi:25443 zsh.texi:26618 zsh.texi:37420
msgid "Example:"
msgstr "例如："

#. type: example
#: zsh.texi:25452
#, no-wrap
msgid ""
"_example_caching_policy () @{\n"
"    # rebuild if cache is more than a week old\n"
"    local -a oldp\n"
"    oldp=( \"$1\"(Nm+7) )\n"
"    (( $#oldp ))\n"
"@}\n"
msgstr ""
"_example_caching_policy () @{\n"
"    # rebuild if cache is more than a week old\n"
"    local -a oldp\n"
"    oldp=( \"$1\"(Nm+7) )\n"
"    (( $#oldp ))\n"
"@}\n"

#. type: findex
#: zsh.texi:25454
#, no-wrap
msgid "_call_function"
msgstr "_call_function"

#. type: item
#: zsh.texi:25455
#, no-wrap
msgid "@t{_call_function} @var{return} @var{name} [ @var{arg} ... ]"
msgstr "@t{_call_function} @var{return} @var{name} [ @var{arg} ... ]"

#. type: table
#: zsh.texi:25460
msgid ""
"If a function @var{name} exists, it is called with the arguments @var{arg}s.  The @var{return} argument gives the name of a parameter in which the return status from the function @var{name} should be "
"stored; if @var{return} is empty or a single hyphen it is ignored."
msgstr "如果存在函数 @var{name}，则使用参数 @var{arg}s 调用该函数。 @var{return} 参数给出了一个参数的名称，函数 @var{name} 的返回状态应存储在该参数中；如果 @var{return} 为空或单个连字符，则该参数将被忽略。"

#. type: table
#: zsh.texi:25464
msgid "The return status of @t{_call_function} itself is zero if the function @var{name} exists and was called and non-zero otherwise."
msgstr "如果函数 @var{name} 存在并被调用，@t{_call_function} 本身的返回状态为 0，否则为非 0。"

#. type: findex
#: zsh.texi:25465
#, no-wrap
msgid "_call_program"
msgstr "_call_program"

#. type: item
#: zsh.texi:25466
#, no-wrap
msgid "@t{_call_program} [ @t{-l} ] [ @t{-p} ] @var{tag} @var{string} ..."
msgstr "@t{_call_program} [ @t{-l} ] [ @t{-p} ] @var{tag} @var{string} ..."

#. type: table
#: zsh.texi:25474
msgid ""
"This function provides a mechanism for the user to override the use of an external command.  It looks up the @t{command} style with the supplied @var{tag}.  If the style is set, its value is used as the "
"command to execute.  The @var{string}s from the call to @t{_call_program}, or from the style if set, are concatenated with spaces between them and the resulting string is evaluated.  The return status is "
"the return status of the command called."
msgstr ""
"该函数为用户提供了一种覆盖外部命令使用的机制。 它使用提供的 @var{tag} 查找 @t{command} 样式。 如果设置了样式，其值将作为要执行的命令。 调用 @t{_call_program} 的 @var{string}s ，或样式（如果已设置）中的 "
"@var{string}s， 会以空格连接起来，并对得到的字符串进行求值。 返回状态是被调用命令的返回状态。"

#. type: table
#: zsh.texi:25480
msgid ""
"By default, the command is run in an environment where all the locale categories (except for @t{LC_CTYPE}) are reset to `@t{C}' by calling the utility function @t{_comp_locale} (see below). If the option "
"`@t{-l}' is given, the command is run with the current locale."
msgstr "默认情况下，命令的运行环境是通过调用实用程序 @t{_comp_locale}（见下文）将所有语言类别（@t{LC_CTYPE}除外）重置为 `@t{C}' 。如果给出选项 `@t{-l}' ，命令将以当前的本地语言运行。"

#. type: table
#: zsh.texi:25490
msgid ""
"If the option `@t{-p}' is supplied it indicates that the command output is influenced by the permissions it is run with. If the @t{gain-privileges} style is set to true, @t{_call_program} will make use of "
"commands such as @t{sudo}, if present on the command-line, to match the permissions to whatever the final command is likely to run under. When looking up the @t{gain-privileges} and @t{command} styles, "
"the command component of the zstyle context will end with a slash (`@t{/}') followed by the command that would be used to gain privileges."
msgstr ""
"如果提供了选项 `@t{-p}' ，则表示命令输出受运行权限的影响。如果 @t{gain-privileges} 样式设置为 true，@t{_call_program} 将使用 @t{sudo} 等命令（如果命令行中存在），以匹配最终命令可能的运行权限。在查找 "
"@t{gain-privileges} 和 @t{command} 样式时，zstyle 上下文中的命令组件将以斜线 (`@t{/}')结尾，之后是用于获取权限的命令。"

#. type: findex
#: zsh.texi:25491
#, no-wrap
msgid "_combination"
msgstr "_combination"

#. type: item
#: zsh.texi:25492
#, no-wrap
msgid "@t{_combination} [ @t{-s} @var{pattern} ] @var{tag} @var{style} @var{spec} ... @var{field} @var{opts} ..."
msgstr "@t{_combination} [ @t{-s} @var{pattern} ] @var{tag} @var{style} @var{spec} ... @var{field} @var{opts} ..."

#. type: table
#: zsh.texi:25497
msgid ""
"This function is used to complete combinations of values, for example pairs of hostnames and usernames.  The @var{style} argument gives the style which defines the pairs; it is looked up in a context with "
"the @var{tag} specified."
msgstr "该函数用于补全值的组合，例如主机名和用户名的组合。 @var{style} 参数给出了定义成对值的样式；该样式将在指定了 @var{tag} 的上下文中查找。"

#. type: table
#: zsh.texi:25504
msgid ""
"The style name consists of field names separated by hyphens, for example `@t{users-hosts-ports}'.  For each field for a value is already known, a @var{spec} of the form `@var{field}@t{=}@var{pattern}' is "
"given.  For example, if the command line so far specifies a user `@t{pws}', the argument `@t{users=pws}' should appear."
msgstr ""
"样式名称由用连字符分隔的字段名组成，例如 `@t{users-hosts-ports}'。 对于已知值的每个字段，都会给出一个格式为 `@var{field}@t{=}@var{pattern}' 的 @var{spec}。 例如，如果命令行指定了用户 `@t{pws}'，则参数 "
"`@t{users=pws}' 应当出现。"

#. type: table
#: zsh.texi:25509
msgid "The next argument with no equals sign is taken as the name of the field for which completions should be generated (presumably not one of the @var{field}s for which the value is known)."
msgstr "下一个不带等号的参数将作为应生成补全的字段名（可能不是已知值的 @var{field}s 中的一个）。"

#. type: table
#: zsh.texi:25521
msgid ""
"The matches generated will be taken from the value of the style.  These should contain the possible values for the combinations in the appropriate order (users, hosts, ports in the example above).  The "
"values for the different fields are separated by colons.  This can be altered with the option @t{-s} to @t{_combination} which specifies a pattern.  Typically this is a character class, as for example "
"`@t{-s \"[:@@]\"}' in the case of the @t{users-hosts} style.  Each `@var{field}@t{=}@var{pattern}' specification restricts the completions which apply to elements of the style with appropriately matching "
"fields."
msgstr ""
"生成的匹配结果将取自样式值。 这些值应按适当顺序（如上例中的用户、主机、端口）包含可能的组合值。 不同字段的值用冒号分隔。 可以使用选项 @t{-s} 将其改为 @t{_combination}，以指定一个模式。 通常情况下，这是一个"
"字符类，例如，在 @t{users-hosts} 样式中使用了 `@t{-s \"[:@@]\"}' 。 每个 `@var{field}@t{=}@var{pattern}' 规范都会限制补全,这些补全适用于具有相应匹配字段的样式的元素。"

#. type: table
#: zsh.texi:25530
msgid ""
"If no style with the given name is defined for the given tag, or if none of the strings in style's value match, but a function name of the required field preceded by an underscore is defined, that "
"function will be called to generate the matches.  For example, if there is no `@t{users-hosts-ports}' or no matching hostname when a host is required, the function `@t{_hosts}' will automatically be "
"called."
msgstr ""
"如果没有为给定标记定义具有给定名称的样式，或者样式值中的字符串都不匹配，但定义了带前导下划线的所需字段的函数名，则将调用该函数生成匹配值。 例如，如果没有 `@t{users-hosts-ports}' 或在需要主机时没有匹配的主"
"机名，将自动调用函数 `@t{_hosts}' 。"

#. type: table
#: zsh.texi:25536
msgid ""
"If the same name is used for more than one field, in both the `@var{field}@t{=}@var{pattern}' and the argument that gives the name of the field to be completed, the number of the field (starting with one) "
"may be given after the fieldname, separated from it by a colon."
msgstr "如果同一名称用于多个字段，在 `@var{field}@t{=}@var{pattern}' 和给出要补全的字段名称的参数中，可以在字段名称后给出字段编号（从 1 开始），并用冒号隔开。"

#. type: table
#: zsh.texi:25541
msgid "All arguments after the required field name are passed to @t{compadd} when generating matches from the style value, or to the functions for the fields if they are called."
msgstr "在根据样式值生成匹配时，必填字段名后的所有参数都会传递给 @t{compadd}，或者在为字段调用函数时传递给这些函数。"

#. type: findex
#: zsh.texi:25542
#, no-wrap
msgid "_command_names"
msgstr "_command_names"

#. type: item
#: zsh.texi:25543
#, no-wrap
msgid "@t{_command_names} [ @t{-e} | @t{-} ]"
msgstr "@t{_command_names} [ @t{-e} | @t{-} ]"

#. type: table
#: zsh.texi:25547
msgid ""
"This function completes words that are valid at command position: names of aliases, builtins, hashed commands, functions, and so on.  With the @t{-e} flag, only hashed commands are completed.  The @t{-} "
"flag is ignored."
msgstr "该函数补全在命令位置有效的单词：别名、内置命令、散列命令、函数等的名称。 使用 @t{-e} 标志时，只补全散列命令。 @t{-} 标志将被忽略。"

#. type: t{#1}
#: zsh.texi:25548 zsh.texi:25549
#, no-wrap
msgid "_comp_locale"
msgstr "_comp_locale"

#. type: table
#: zsh.texi:25555
msgid ""
"This function resets all the locale categories other than @t{LC_CTYPE} to `@t{C}' so that the output from external commands can be easily analyzed by the completion system. @t{LC_CTYPE} retains the "
"current value (taking @t{LC_ALL} and @t{LANG} into account), ensuring that non-ASCII characters in file names are still handled properly."
msgstr ""
"该函数将 @t{LC_CTYPE} 以外的所有区域设置类别重置为 `@t{C}' ，以便补全系统可以轻松分析外部命令的输出。@t{LC_CTYPE} 保留当前值（将 @t{LC_ALL} 和 @t{LANG} 考虑在内），确保文件名中的非 ASCII 字符仍能得到正确处"
"理。"

#. type: table
#: zsh.texi:25560
msgid "This function should normally be run only in a subshell, because the new locale is exported to the environment. Typical usage would be `@t{$(_comp_locale; }@var{command} ...@t{)}'."
msgstr "该函数通常只能在子 shell 中运行，因为新的本地语言(locale)会导出到环境中。典型用法是 `@t{$(_comp_locale; }@var{command} ...@t{)}'。"

#. type: findex
#: zsh.texi:25561
#, no-wrap
msgid "_completers"
msgstr "_completers"

#. type: item
#: zsh.texi:25562
#, no-wrap
msgid "@t{_completers} [ @t{-p} ]"
msgstr "@t{_completers} [ @t{-p} ]"

#. type: table
#: zsh.texi:25564
msgid "This function completes names of completers."
msgstr "该函数可补全补全器的名称。"

#. type: table
#: zsh.texi:25569
msgid "Include the leading underscore (`@t{_}') in the matches."
msgstr "在匹配中包含前导下划线 (`@t{_}')。"

#. type: t{#1}
#: zsh.texi:25572 zsh.texi:25573
#, no-wrap
msgid "_default"
msgstr "_default"

#. type: table
#: zsh.texi:25580
msgid ""
"This function corresponds to the @t{-default-} special context which is applied where no completion is defined.  It is useful to call it under certain error conditions such as completion after an "
"unrecognised subcommand.  This applies the concept of graceful degradation to the completion system, allowing it to fallback on basic completion of commonly useful things like filenames."
msgstr ""
"该函数对应于 @t{-default-} 特殊上下文，适用于未定义补全的情况。 在某些错误条件下调用该函数非常有用，例如在未识别子命令后补全。 这将优美降级的概念应用于补全系统，允许它在基本补全文件名等常用内容时回退。"

#. type: findex
#: zsh.texi:25581
#, no-wrap
msgid "_describe"
msgstr "_describe"

#. type: item
#: zsh.texi:25583
#, no-wrap
msgid "@t{_describe }[@t{-12JVx}] [ @t{-oO} | @t{-t} @var{tag} ] @var{descr} @var{name1} [ @var{name2} ] [ @var{opt} ... ]"
msgstr "@t{_describe }[@t{-12JVx}] [ @t{-oO} | @t{-t} @var{tag} ] @var{descr} @var{name1} [ @var{name2} ] [ @var{opt} ... ]"

#. type: itemx
#: zsh.texi:25584
#, no-wrap
msgid "@t{@ @ @ @ @ @ @ @ @ @ }[ @t{-}@t{-} @var{name1} [ @var{name2} ] [ @var{opt} ... ] ... ]"
msgstr "@t{@ @ @ @ @ @ @ @ @ @ }[ @t{-}@t{-} @var{name1} [ @var{name2} ] [ @var{opt} ... ] ... ]"

#. type: table
#: zsh.texi:25588
msgid "This function associates completions with descriptions.  Multiple groups separated by @t{-}@t{-} can be supplied, potentially with different completion options @var{opt}s."
msgstr "此函数将补全与描述关联起来。 可以提供多个用 @t{-}@t{-} 分隔的组，可能会有不同的补全选项 @var{opt}s。"

#. type: table
#: zsh.texi:25601
msgid ""
"The @var{descr} is taken as a string to display above the matches if the @t{format} style for the @t{descriptions} tag is set.  This is followed by one or two names of arrays followed by options to pass "
"to @t{compadd}.  The array @var{name1} contains the possible completions with their descriptions in the form `@var{completion}@t{:}@var{description}'.  Any literal colons in @var{completion} must be "
"quoted with a backslash.  If a @var{name2} is given, it should have the same number of elements as @var{name1}; in this case the corresponding elements are added as possible completions instead of the "
"@var{completion} strings from @var{name1}.  The completion list will retain the descriptions from @var{name1}.  Finally, a set of completion options can appear."
msgstr ""
"如果 @t{descr} 标记的 @t{format} 样式被设置，则 @var{descr} 将作为字符串显示在匹配结果的上方。 接下来是一个或两个数组的名称，后面是传递给 @t{compadd} 的选项。 数组 @var{name1} 包含可能的补全及其描述，格式"
"为 `@var{completion}@t{:}@var{description}'。 @var{completion} 中任何字面上的冒号都必须用反斜杠引出。 如果给出 @var{name2}，则其元素个数应与 @var{name1} 相同；在这种情况下，相应的元素将作为可能的补全元素添"
"加，而不是 @var{name1} 中的 @var{completion} 字符串。 补全列表将保留 @var{name1} 中的描述。 最后，可以出现一补全选项集。"

#. type: table
#: zsh.texi:25613
msgid ""
"If the option `@t{-o}' appears before the first argument, the matches added will be treated as names of command options (N.B. not shell options), typically following a `@t{-}', `@t{-}@t{-}' or `@t{+}' on "
"the command line.  In this case @t{_describe} uses the @t{prefix-hidden}, @t{prefix-needed} and @t{verbose} styles to find out if the strings should be added as completions and if the descriptions should "
"be shown.  Without the `@t{-o}' option, only the @t{verbose} style is used to decide how descriptions are shown.  If `@t{-O}' is used instead of `@t{-o}', command options are completed as above but "
"@t{_describe} will not handle the @t{prefix-needed} style."
msgstr ""
"如果第一个参数前出现了选项 `@t{-o}' ，则添加的匹配字符串将被视为命令选项名称（注意：不是 shell 选项），通常位于命令行上的 `@t{-}', `@t{-}@t{-}' 或 `@t{+}' 之后。 在这种情况下，@t{_describe} 会使用 "
"@t{prefix-hidden}、@t{prefix-needed} 和 @t{verbose} 样式来查找是否应将字符串添加为补全，以及是否显示说明。 如果不使用 `@t{-o}' 选项，则只使用 @t{verbose} 样式来决定如何显示说明。 如果使用 `@t{-O}' 而不是 "
"`@t{-o}'，命令选项的补全方式如上，但 @t{_describe} 不会处理 @t{prefix-needed} 样式。"

#. type: table
#: zsh.texi:25617
msgid "With the @t{-t} option a @var{tag} can be specified.  The default is `@t{values}' or, if the @t{-o} option is given, `@t{options}'."
msgstr "使用 @t{-t} 选项可以指定一个 @var{tag} 。 默认值为 `@t{values}' ，如果使用 @t{-o} 选项，则为 `@t{options}'。"

#. type: table
#: zsh.texi:25621
msgid "The options @t{-1}, @t{-2}, @t{-J}, @t{-V}, @t{-x} are passed to @t{_next_label}."
msgstr "选项 @t{-1}, @t{-2}, @t{-J}, @t{-V}, @t{-x} 将传递给 @t{_next_label}。"

#. type: table
#: zsh.texi:25625
msgid "If selected by the @t{list-grouped} style, strings with the same description will appear together in the list."
msgstr "如果通过使用 @t{list-grouped} 样式选择，具有相同描述的字符串将一起出现在列表中。"

#. type: table
#: zsh.texi:25629
msgid "@t{_describe} uses the @t{_all_labels} function to generate the matches, so it does not need to appear inside a loop over tag labels."
msgstr "@t{_describe} 使用 @t{_all_labels} 函数来生成匹配结果，因此它无需出现在标记标签的循环中。"

#. type: findex
#: zsh.texi:25630
#, no-wrap
msgid "_description"
msgstr "_description"

#. type: item
#: zsh.texi:25631
#, no-wrap
msgid "@t{_description} [ @t{-x} ] [ @t{-12VJ} ] @var{tag} @var{name} @var{descr} [ @var{spec} ... ]"
msgstr "@t{_description} [ @t{-x} ] [ @t{-12VJ} ] @var{tag} @var{name} @var{descr} [ @var{spec} ... ]"

#. type: table
#: zsh.texi:25636
msgid ""
"This function is not to be confused with the previous one; it is used as a helper function for creating options to @t{compadd}.  It is buried inside many of the higher level completion functions and so "
"often does not need to be called directly."
msgstr "不要将此函数与前一个函数混淆；它是用于为创建 @t{compadd} 的选项的辅助函数。 它被埋藏在许多高级补全函数中，因此通常不需要直接调用。"

#. type: table
#: zsh.texi:25643
msgid ""
"The styles listed below are tested in the current context using the given @var{tag}.  The resulting options for @t{compadd} are put into the array named @var{name} (this is traditionally `@t{expl}', but "
"this convention is not enforced).  The description for the corresponding set of matches is passed to the function in @var{descr}."
msgstr ""
"下面列出的样式将在当前上下文中使用给定的 @var{tag} 进行测试。 @t{compadd} 产生的选项会被放入名为 @var{name} 的数组（传统上是 `@t{expl}'，但这一约定并不强制执行）。 相应匹配集的描述信息将以 @var{descr} 的形"
"式传递给函数。"

#. type: table
#: zsh.texi:25651
msgid ""
"The styles tested are: @t{format}, @t{hidden}, @t{matcher}, @t{ignore-line}, @t{ignored-patterns}, @t{group-name} and @t{sort}.  The @t{format} style is first tested for the given @var{tag} and then for "
"the @t{descriptions} tag if no value was found, while the remainder are only tested for the tag given as the first argument.  The function also calls @t{_setup} which tests some more styles."
msgstr ""
"测试的样式有 @t{format}、@t{hidden}、@t{matcher}、@t{ignore-line}、@t{ignored-patterns}、@t{group-name} 和 @t{sort}。 首先针对给定的 @var{tag} 对 @t{format} 样式进行测试，如果未找到值，则针对 "
"@t{descriptions} 标签进行测试，其余的只针对作为第一个参数给定的标签进行测试。 函数还会调用 @t{_setup}，以测试更多样式。"

#. type: table
#: zsh.texi:25659
msgid ""
"The string returned by the @t{format} style (if any) will be modified so that the sequence `@t{%d}' is replaced by the @var{descr} given as the third argument without any leading or trailing white space.  "
"If, after removing the white space, the @var{descr} is the empty string, the format style will not be used and the options put into the @var{name} array will not contain an explanation string to be "
"displayed above the matches."
msgstr ""
"由 @t{format} 样式（如果有）返回的字符串将被修改，使 `@t{%d}' 序列被作为第三个参数给出的 @var{descr} 所替换，且不留任何前导或尾部空白。 如果删除空白后，@var{descr} 为空字符串，则格式样式将不被使用，放入 "
"@var{name} 数组的选项将不包含显示在匹配结果上方的解释字符串。"

#. type: table
#: zsh.texi:25673
msgid ""
"If @t{_description} is called with more than three arguments, the additional @var{spec}s should be of the form `@var{char}@t{:}@var{str}'.  These supply escape sequence replacements for the @t{format} "
"style: every appearance of `@t{%}@var{char}' will be replaced by @var{string}.  If no additional @var{spec}s are given but the description in @var{descr} conforms to a common form then further escape "
"sequences are set for elements of that description.  These elements correspond to a default value (`@t{%o}'), the units (`@t{%m}') range of acceptable values (`@t{%r}') and the remaining initial part of "
"the description (`@t{%h}').  The form the description takes consists of specifying the units and range in parentheses and the default value in square brackets, for example:"
msgstr ""
"如果调用 @t{_description} 时有三个以上的参数，则附加的 @var{spec}s 应为 `@var{char}@t{:}@var{str}' 形式。 这些参数将为 @t{format} 样式提供转义序列替换：每次出现 `@t{%}@var{char}' 时，都会被 @var{string} 替"
"换。 如果没有给出额外的 @var{spec}s，但 @var{descr} 中的描述符合通用格式，则会为描述中的元素设置更多转义序列。  这些元素分别对应默认值 (`@t{%o}')、可接受值的单位(`@t{%m}') 范围和描述 (`@t{%h}')的其余初始部"
"分。  描述的形式包括在括号中指定单位和范围，和在方括号中指定的默认值，例如："

#. type: example
#: zsh.texi:25677
#, no-wrap
msgid "_description times expl 'timeout (seconds) (0-60) [20]'\n"
msgstr "_description times expl 'timeout (seconds) (0-60) [20]'\n"

#. type: table
#: zsh.texi:25684
msgid ""
"It is possible to use @t{zformat} conditional expressions when styling these elements. So, for example, to add `@t{default:}' as a tag but only when there is a default value to show, the @t{format} style "
"might include `@t{%(o.default: %o.)}'."
msgstr "在为这些元素设计样式时，可以使用 @t{zformat} 条件表达式。因此，举例来说，要添加 `@t{default:}' 作为标记，但只在有默认值要显示时，@t{format} 样式可能包括 `@t{%(o.default: %o.)}'。"

#. type: table
#: zsh.texi:25690
msgid ""
"If the @t{-x} option is given, the description will be passed to @t{compadd} using the @t{-x} option instead of the default @t{-X}.  This means that the description will be displayed even if there are no "
"corresponding matches."
msgstr "如果给出 @t{-x} 选项，描述将使用 @t{-x} 选项而不是默认的 @t{-X} 传递给 @t{compadd}。 这意味着即使没有相应的匹配，描述也会显示。"

#. type: table
#: zsh.texi:25700
msgid ""
"The options placed in the array @var{name} take account of the @t{group-name} style, so matches are placed in a separate group where necessary.  The group normally has its elements sorted (by passing the "
"option @t{-J} to @t{compadd}), but if an option starting with `@t{-V}', `@t{-J}', `@t{-1}', or `@t{-2}' is passed to @t{_description}, that option will be included in the array.  Hence it is possible for "
"the completion group to be unsorted by giving the option `@t{-V}', `@t{-1V}', or `@t{-2V}'."
msgstr ""
"放在 @var{name} 数组中的选项会考虑 @t{group-name} 样式，因此必要时会将匹配结果放在一个单独的组中。 通常情况下，组中的元素是排序的（通过向 @t{compadd} 传递 @t{-J} 选项），但如果向 @t{_description} 传递了以"
"`@t{-V}', `@t{-J}', `@t{-1}' 或 `@t{-2}' 开头的选项，则该选项将包含在数组中。 因此，可以通过给出选项 `@t{-V}', `@t{-1V}' 或 `@t{-2V}' 来取消补全组的排序。"

#. type: table
#: zsh.texi:25703
msgid "In most cases, the function will be used like this:"
msgstr "在大多数情况下，函数的使用方法是这样的："

#. type: example
#: zsh.texi:25709
#, no-wrap
msgid ""
"local expl\n"
"_description files expl file\n"
"compadd \"$expl[@@]\" - \"$files[@@]\"\n"
msgstr ""
"local expl\n"
"_description files expl file\n"
"compadd \"$expl[@@]\" - \"$files[@@]\"\n"

#. type: table
#: zsh.texi:25716
msgid ""
"Note the use of the parameter @t{expl}, the hyphen, and the list of matches.  Almost all calls to @t{compadd} within the completion system use a similar format; this ensures that user-specified styles are "
"correctly passed down to the builtins which implement the internals of completion."
msgstr "请注意参数 @t{expl}、连字符和匹配列表的使用。 补全系统中几乎所有对 @t{compadd} 的调用都使用了类似的格式；这样可以确保用户指定的样式正确地传递给实现补全内部结构的内置程序。"

#. type: findex
#: zsh.texi:25717
#, no-wrap
msgid "_dir_list"
msgstr "_dir_list"

#. type: item
#: zsh.texi:25718
#, no-wrap
msgid "@t{_dir_list} [ @t{-s} @var{sep} ] [ @t{-S} ]"
msgstr "@t{_dir_list} [ @t{-s} @var{sep} ] [ @t{-S} ]"

#. type: table
#: zsh.texi:25721
msgid "Complete a list of directory names separated by colons (the same format as @t{$PATH})."
msgstr "补全一个用冒号分隔的目录名列表（格式与 @t{$PATH}相同）。"

#. type: item
#: zsh.texi:25724
#, no-wrap
msgid "@t{-s} @var{sep}"
msgstr "@t{-s} @var{sep}"

#. type: table
#: zsh.texi:25727
msgid "Use @var{sep} as separator between items.  @var{sep} defaults to a colon (`@t{:}')."
msgstr "使用 @var{sep} 作为项目之间的分隔符。 @var{sep} 默认为冒号 (`@t{:}')。"

#. type: table
#: zsh.texi:25730
msgid "Add @var{sep} instead of slash (`@t{/}') as an autoremoveable suffix."
msgstr "添加 @var{sep} 代替斜线 (`@t{/}')，作为可自动删除的后缀。"

#. type: findex
#: zsh.texi:25733
#, no-wrap
msgid "_dispatch"
msgstr "_dispatch"

#. type: item
#: zsh.texi:25734
#, no-wrap
msgid "@t{_dispatch} @var{context string} ..."
msgstr "@t{_dispatch} @var{context string} ..."

#. type: table
#: zsh.texi:25742
msgid ""
"This sets the current context to @var{context} and looks for completion functions to handle this context by hunting through the list of command names or special contexts (as described above for "
"@t{compdef})  given as @var{string}s.  The first completion function to be defined for one of the contexts in the list is used to generate matches.  Typically, the last @var{string} is @t{-default-} to "
"cause the function for default completion to be used as a fallback."
msgstr ""
"此操作会将当前上下文设置为 @var{context}，并通过搜索作为 @var{string}s 给出的命令名称或特殊上下文（如上文针对 @t{compdef} 所述）列表来查找处理此上下文的补全函数。 第一个为列表中某个上下文定义的补全函数将用"
"于生成匹配。 通常情况下，最后一个 @var{string} 是 @t{-default-}，以便使用默认补全函数作为备用。"

#. type: table
#: zsh.texi:25748
msgid ""
"The function sets the parameter @t{$service} to the @var{string} being tried, and sets the @var{context/command} field (the fourth) of the @t{$curcontext} parameter to the @var{context} given as the first "
"argument."
msgstr "该函数将参数 @t{$service} 设置为正在尝试的 @var{string}，并将 @t{$curcontext} 参数的 @var{context/command} 字段（第四字段）设置为作为第一个参数给定的 @var{context}。"

#. type: findex
#: zsh.texi:25749
#, no-wrap
msgid "_email_addresses"
msgstr "_email_addresses"

#. type: item
#: zsh.texi:25750
#, no-wrap
msgid "@t{_email_addresses} [ @t{-c} ] [ @t{-n} @var{plugin} ]"
msgstr "@t{_email_addresses} [ @t{-c} ] [ @t{-n} @var{plugin} ]"

#. type: table
#: zsh.texi:25752
msgid "Complete email addresses.  Addresses are provided by plugins."
msgstr "补全电子邮件地址。 地址由插件提供。"

#. type: table
#: zsh.texi:25760
msgid "Complete bare @t{localhost@@domain.tld} addresses, without a name part or a comment.  Without this option, RFC822 `@var{Firstname Lastname} @t{<}@var{address}@t{>}' strings are completed."
msgstr "补全裸 @t{localhost@@domain.tld} 地址，不含名称部分或注释。 如果不使用该选项，RFC822 中的`@var{Firstname Lastname} @t{<}@var{address}@t{>}' 字符串将被补全。"

#. type: item
#: zsh.texi:25761
#, no-wrap
msgid "@t{-n} @var{plugin}"
msgstr "@t{-n} @var{plugin}"

#. type: table
#: zsh.texi:25763
msgid "Complete aliases from @var{plugin}."
msgstr "补全来自 @var{plugin} 的别名。"

#. type: table
#: zsh.texi:25775
msgid ""
"The following plugins are available by default: @t{_email-ldap} (see the @t{filter} style), @t{_email-local} (completes @var{user}@t{@@}@var{hostname} Unix addresses), @t{_email-mail} (completes aliases "
"from @t{~/.mailrc}), @t{_email-mush}, @t{_email-mutt}, and @t{_email-pine}."
msgstr ""
"默认情况下可使用以下插件： @t{_email-ldap} （参见 @t{filter} 样式）、@t{_email-local}（补全 @var{user}@t{@@}@var{hostname} Unix 地址）、@t{_email-mail}（补全 @t{~/.mailrc} 中的别名）、@t{_email-mush}、"
"@t{_email-mutt} 和 @t{_email-pine}。"

#. type: table
#: zsh.texi:25779
msgid "Addresses from the @t{_email-}@var{foo} plugin are added under the tag `@t{email-}@var{foo}'."
msgstr "来自 @t{_email-}@var{foo}  插件的地址会添加到标记 `@t{email-}@var{foo}' 下。"

#. type: emph{#1}
#: zsh.texi:25782
msgid "Writing plugins"
msgstr "编写插件"

#. type: table
#: zsh.texi:25789
msgid ""
"Plugins are written as separate functions with names starting with `@t{_email-}'.  They are invoked with the @t{-c} option and @t{compadd} options.  They should either do their own completion or set the "
"@t{$reply} array to a list of `@var{alias}@t{:}@var{address}' elements and return @t{300}.  New plugins will be picked up and run automatically."
msgstr ""
"插件以单独函数的形式编写，名称以 `@t{_email-}' 开头。 调用时使用 @t{-c} 选项和 @t{compadd} 选项。 它们应自行补全或将 @t{$reply} 数组设置为 `@var{alias}@t{:}@var{address}' 元素列表，并返回 @t{300}。 新插件"
"将被拾取并自动运行。"

#. type: t{#1}
#: zsh.texi:25790 zsh.texi:25791
#, no-wrap
msgid "_files"
msgstr "_files"

#. type: table
#: zsh.texi:25798
msgid ""
"The function @t{_files} is a wrapper around @t{_path_files}. It supports all of the same functionality, with some enhancements --- notably, it respects the @t{list-dirs-first} style, and it allows users "
"to override the behaviour of the @t{-g} and @t{-/} options with the @t{file-patterns} style. @t{_files} should therefore be preferred over @t{_path_files} in most cases."
msgstr ""
"函数 @t{_files} 是 @t{_path_files} 的包装器。它支持所有相同的功能，并做了一些改进 --- 尤其是，它尊重 @t{list-dirs-first} 样式，并允许用户使用 @t{file-patterns} 样式覆盖 @t{-g} 和 @t{-/} 选项的行为。因此，"
"在大多数情况下，@t{_files} 比 @t{_path_files} 更受青睐。"

#. type: table
#: zsh.texi:25802
msgid "This function accepts the full set of options allowed by @t{_path_files}, described below."
msgstr "该函数接受 @t{_path_files} 允许的全部选项，具体描述如下。"

#. type: t{#1}
#: zsh.texi:25803 zsh.texi:25804
#, no-wrap
msgid "_gnu_generic"
msgstr "_gnu_generic"

#. type: table
#: zsh.texi:25811
msgid ""
"This function is a simple wrapper around the @t{_arguments} function described above.  It can be used to determine automatically the long options understood by commands that produce a list when passed the "
"option `@t{-}@t{-help}'.  It is intended to be used as a top-level completion function in its own right.  For example, to enable option completion for the commands @t{foo} and @t{bar}, use"
msgstr ""
"该函数是上述 @t{_arguments} 函数的一个简单封装。 它可用于自动确定命令所能理解的长选项，这些命令在传递选项 `@t{-}@t{-help}' 时会产生一个列表。 它本身就是一个顶级补全函数。 例如，要启用 @t{foo} 和 @t{bar} 命"
"令的选项补全功能，请使用"

#. type: example
#: zsh.texi:25815
#, no-wrap
msgid "compdef _gnu_generic foo bar\n"
msgstr "compdef _gnu_generic foo bar\n"

#. type: table
#: zsh.texi:25819
msgid "after the call to @t{compinit}."
msgstr "在调用 @t{compinit} 后。"

#. type: table
#: zsh.texi:25824
msgid "The completion system as supplied is conservative in its use of this function, since it is important to be sure the command understands the option `@t{-}@t{-help}'."
msgstr "补全系统在使用该函数时比较保守，因为必须确保命令理解选项 `@t{-}@t{-help}'。"

#. type: findex
#: zsh.texi:25825
#, no-wrap
msgid "_guard"
msgstr "_guard"

#. type: item
#: zsh.texi:25826
#, no-wrap
msgid "@t{_guard} [ @var{options} ] @var{pattern descr}"
msgstr "@t{_guard} [ @var{options} ] @var{pattern descr}"

#. type: table
#: zsh.texi:25830
msgid ""
"This function displays @var{descr} if @var{pattern} matches the string to be completed.  It is intended to be used in the @var{action} for the specifications passed to @t{_arguments} and similar functions."
msgstr "如果 @var{pattern} 与要补全的字符串匹配，该函数将显示 @var{descr}。 该函数用于 @var{action} 中传递给 @t{_arguments} 和类似函数的规范。"

#. type: table
#: zsh.texi:25834
msgid "The return status is zero if the message was displayed and the word to complete is not empty, and non-zero otherwise."
msgstr "如果信息已显示且待补全字不为空，则返回状态为零，否则为非零。"

#. type: table
#: zsh.texi:25841
msgid ""
"The @var{pattern} may be preceded by any of the options understood by @t{compadd} that are passed down from @t{_description}, namely @t{-M}, @t{-J}, @t{-V}, @t{-1}, @t{-2}, @t{-n}, @t{-F} and @t{-X}.  All "
"of these options will be ignored.  This fits in conveniently with the argument-passing conventions of actions for @t{_arguments}."
msgstr ""
"在 @var{pattern} 之前可以加上 @t{compadd} 可以理解的任何选项，这些选项是从 @t{_description} 传递下来的，即 @t{-M}、@t{-J}、@t{-V}、@t{-1}、@t{-2}、@t{-n}、@t{-F} 和 @t{-X}。 所有这些选项都将被忽略。 这与 "
"@t{_arguments} 动作的参数传递约定非常吻合。"

#. type: table
#: zsh.texi:25846
msgid "As an example, consider a command taking the options @t{-n} and @t{-none}, where @t{-n} must be followed by a numeric value in the same word.  By using:"
msgstr "例如，考虑一个命令，包含 @t{-n} 和 @t{-none} 两个选项，其中 -n 必须在同一个单词中后跟一个数值。通过使用："

#. type: example
#: zsh.texi:25850
#, no-wrap
msgid "_arguments '-n-: :_guard \"[0-9]#\" \"numeric value\"' '-none'\n"
msgstr "_arguments '-n-: :_guard \"[0-9]#\" \"numeric value\"' '-none'\n"

#. type: table
#: zsh.texi:25858
msgid ""
"@t{_arguments} can be made to both display the message `@t{numeric value}' and complete options after `@t{-n<TAB>}'.  If the `@t{-n}' is already followed by one or more digits (the pattern passed to "
"@t{_guard}) only the message will be displayed; if the `@t{-n}' is followed by another character, only options are completed."
msgstr ""
"@t{_arguments} 可以同时显示`@t{numeric value}' 和 `@t{-n<TAB>}' 之后的补全选项。 如果 `@t{-n}' 后面已经有一个或多个数字（传给 @t{_guard} 的模式），则只显示信息；如果 `@t{-n}' 后面有其他字符，则只补全选项。"

#. type: findex
#: zsh.texi:25859
#, no-wrap
msgid "_message"
msgstr "_message"

#. type: item
#: zsh.texi:25860
#, no-wrap
msgid "@t{_message} [ @t{-r12} ] [ @t{-VJ} @var{group} ] @var{descr}"
msgstr "@t{_message} [ @t{-r12} ] [ @t{-VJ} @var{group} ] @var{descr}"

#. type: itemx
#: zsh.texi:25861
#, no-wrap
msgid "@t{_message -e} [ @var{tag} ] @var{descr}"
msgstr "@t{_message -e} [ @var{tag} ] @var{descr}"

#. type: table
#: zsh.texi:25867
msgid ""
"The @var{descr} is used in the same way as the third argument to the @t{_description} function, except that the resulting string will always be shown whether or not matches were generated.  This is useful "
"for displaying a help message in places where no completions can be generated."
msgstr "@var{descr} 的使用方式与 @t{_description} 函数的第三个参数相同，不同的是，无论是否生成了匹配结果，都会显示生成的字符串。 这对于在无法生成补全的地方显示帮助信息非常有用。"

#. type: table
#: zsh.texi:25872
msgid "The @t{format} style is examined with the @t{messages} tag to find a message; the usual tag, @t{descriptions}, is used only if the style is not set with the former."
msgstr "@t{format} 样式与 @t{messages} 标记一起检查，以查找消息；只有在前者未设置样式时，才会使用通常的标签 @t{descriptions}。"

#. type: table
#: zsh.texi:25880
msgid ""
"If the @t{-r} option is given, no style is used; the @var{descr} is taken literally as the string to display.  This is most useful when the @var{descr} comes from a pre-processed argument list which "
"already contains an expanded description.  Note that this option does not disable the `@t{%}'-sequence parsing done by @t{compadd}."
msgstr ""
"如果给出 @t{-r} 选项，则不使用任何样式；@var{descr} 将作为要显示的字面字符串。 当 @var{descr} 来自预处理过的参数列表，而该参数列表已包含扩展的描述时，该选项最为有用。 请注意，此选项不会禁用 @t{compadd} 的 "
"`@t{%}' 序列解析。"

#. type: table
#: zsh.texi:25884
msgid "The @t{-12VJ} options and the @var{group} are passed to @t{compadd} and hence determine the group the message string is added to."
msgstr "@t{-12VJ} 选项和 @var{group} 被传递给 @t{comppadd}，从而决定信息字符串被添加到哪个组。"

#. type: table
#: zsh.texi:25894
msgid ""
"The second @t{-e} form gives a description for completions with the tag @var{tag} to be shown even if there are no matches for that tag.  This form is called by @t{_arguments} in the event that there is "
"no action for an option specification.  The tag can be omitted and if so the tag is taken from the parameter @t{$curtag}; this is maintained by the completion system and so is usually correct.  Note that "
"if there are no matches at the time this function is called, @t{compstate[insert]} is cleared, so additional matches generated later are not inserted on the command line."
msgstr ""
"第二个 @t{-e} 形式为带有 @var{tag} 标记的补全提供说明，即使该标记没有匹配项也会显示。 如果选项说明中没有任何操作，@t{_arguments} 将调用该形式。 标记可以省略，如果省略，则标记取自参数 @t{$curtag}；该参数由"
"补全系统维护，因此通常是正确的。 需要注意的是，如果调用此函数时没有匹配项，@t{compstate[insert]} 将被清除，因此不会在命令行中插入随后生成的匹配项。"

#. type: findex
#: zsh.texi:25895
#, no-wrap
msgid "_multi_parts"
msgstr "_multi_parts"

#. type: item
#: zsh.texi:25896
#, no-wrap
msgid "@t{_multi_parts} [ @t{-i} ] @var{sep} @var{array}"
msgstr "@t{_multi_parts} [ @t{-i} ] @var{sep} @var{array}"

#. type: table
#: zsh.texi:25906
msgid ""
"The argument @var{sep} is a separator character.  The @var{array} may be either the name of an array parameter or a literal array in the form `@t{(foo bar}@t{)}', a parenthesised list of words separated "
"by whitespace.  The possible completions are the strings from the array.  However, each chunk delimited by @var{sep} will be completed separately.  For example, the @t{_tar} function uses "
"`@t{_multi_parts} @t{/} @var{patharray}' to complete partial file paths from the given array of complete file paths."
msgstr ""
"参数 @var{sep} 是一个分隔字符。 @var{array} 可以是一个数组参数的名称，也可以是一个形式为 `@t{(foo bar}@t{)}' 的字面数组，即一个用括号括起来的以空白分隔的单词列表。 可能的补全是数组中的字符串。 不过，由 "
"@var{sep} 分隔的每个词块都将单独补全。 例如，@t{_tar} 函数使用 `@t{_multi_parts} @t{/} @var{patharray}' 来从给定的完整文件路径数组中补全部分文件路径。"

#. type: table
#: zsh.texi:25913
msgid ""
"The @t{-i} option causes @t{_multi_parts} to insert a unique match even if that requires multiple separators to be inserted.  This is not usually the expected behaviour with filenames, but certain other "
"types of completion, for example those with a fixed set of possibilities, may be more suited to this form."
msgstr "@t{-i} 选项会使 @t{_multi_parts} 插入唯一匹配，即使需要插入多个分隔符。 这通常不是文件名的预期行为，但某些其他类型的补全，例如有固定可能性的补全集，可能更适合这种形式。"

#. type: table
#: zsh.texi:25919
msgid ""
"Like other utility functions, this function accepts the `@t{-V}', `@t{-J}', `@t{-1}', `@t{-2}', `@t{-n}', `@t{-f}', `@t{-X}', `@t{-M}', `@t{-P}', `@t{-S}', `@t{-r}', `@t{-R}', and `@t{-q}' options and "
"passes them to the @t{compadd} builtin."
msgstr ""
"与其他实用用函数一样，该函数接受 `@t{-V}', `@t{-J}', `@t{-1}', `@t{-2}', `@t{-n}', `@t{-f}', `@t{-X}', `@t{-M}', `@t{-P}', `@t{-S}', `@t{-r}', `@t{-R}' 和 `@t{-q}' 选项，并将它们传递给 @t{compadd} 内置函"
"数。"

#. type: findex
#: zsh.texi:25920
#, no-wrap
msgid "_next_label"
msgstr "_next_label"

#. type: item
#: zsh.texi:25921
#, no-wrap
msgid "@t{_next_label} [ @t{-x} ] [ @t{-12VJ} ] @var{tag} @var{name} @var{descr} [ @var{option} ... ]"
msgstr "@t{_next_label} [ @t{-x} ] [ @t{-12VJ} ] @var{tag} @var{name} @var{descr} [ @var{option} ... ]"

#. type: table
#: zsh.texi:25928
msgid ""
"This function is used to implement the loop over different tag labels for a particular tag as described above for the @t{tag-order} style.  On each call it checks to see if there are any more tag labels; "
"if there is it returns status zero, otherwise non-zero.  As this function requires a current tag to be set, it must always follow a call to @t{_tags} or @t{_requested}."
msgstr ""
"该函数用于实现上述在 @t{tag-order} 样式的特定标记的不同标记(tag labels)上的循环。 每次调用时，它都会检查是否还有其他标签；如果有，则返回状态 0，否则返回非 0。 由于该函数需要设置一个当前标签，因此它必须始终"
"跟随 @t{_tags} 或 @t{_requested} 的调用。"

#. type: table
#: zsh.texi:25935
msgid ""
"The @t{-x12VJ} options and the first three arguments are passed to the @t{_description} function.  Where appropriate the @var{tag} will be replaced by a tag label in this call.  Any description given in "
"the @t{tag-order} style is preferred to the @var{descr} passed to @t{_next_label}."
msgstr " @t{-x12VJ} 选项和前三个参数会传递给 @t{_description} 函数。 在此调用中，@var{tag} 将酌情替换为标签(tag label)。 任何以 @t{tag-order} 样式给出的描述都优先于传递给 @t{_next_label} 的 @var{descr}。"

#. type: table
#: zsh.texi:25940
msgid "The @var{option}s given after the @var{descr} are set in the parameter given by @var{name}, and hence are to be passed to @t{compadd} or whatever function is called to add the matches."
msgstr "在 @var{descr} 后面给出的 @var{option}s 是在 @var{name} 给出的参数中设置的，因此应传递给 @t{compadd} 或任何调用以用于添加匹配的函数。"

#. type: table
#: zsh.texi:25946
msgid ""
"Here is a typical use of this function for the tag @t{foo}.  The call to @t{_requested} determines if tag @t{foo} is required at all; the loop over @t{_next_label} handles any labels defined for the tag "
"in the @t{tag-order} style."
msgstr "下面是该函数在标记 @t{foo} 中的典型用法。 对 @t{_requested} 的调用确定是否需要 @t{foo} 标记；对 @t{_next_label} 的循环,处理为 @t{tag-order} 样式中的标记定义的标签（labels）。"

#. type: example
#: zsh.texi:25959
#, no-wrap
msgid ""
"local expl ret=1\n"
"...\n"
"if _requested foo; then\n"
"  ...\n"
"  while _next_label foo expl '...'; do\n"
"    compadd \"$expl[@@]\" ... && ret=0\n"
"  done\n"
"  ...\n"
"fi\n"
"return ret\n"
msgstr ""
"local expl ret=1\n"
"...\n"
"if _requested foo; then\n"
"  ...\n"
"  while _next_label foo expl '...'; do\n"
"    compadd \"$expl[@@]\" ... && ret=0\n"
"  done\n"
"  ...\n"
"fi\n"
"return ret\n"

#. type: findex
#: zsh.texi:25961
#, no-wrap
msgid "_normal"
msgstr "_normal"

#. type: item
#: zsh.texi:25962
#, no-wrap
msgid "@t{_normal} [ @t{-P} | @t{-p} @var{precommand} ]"
msgstr "@t{_normal} [ @t{-P} | @t{-p} @var{precommand} ]"

#. type: table
#: zsh.texi:25968
msgid ""
"This is the standard function called to handle completion outside any special @t{-}@var{context}@t{-}.  It is called both to complete the command word and also the arguments for a command.  In the second "
"case, @t{_normal} looks for a special completion for that command, and if there is none it uses the completion for the @t{-default-} context."
msgstr ""
"这是一个标准函数，用于处理任何特殊 @t{-}@var{context}@t{-} 以外的补全。 它既可用于补全命令字，也可用于补全命令的参数。 在第二种情况下，@t{_normal} 会查找该命令的特殊补全，如果没有，则使用 @t{-default-} 上"
"下文的补全。"

#. type: table
#: zsh.texi:25977
msgid ""
"A second use is to reexamine the command line specified by the @t{$words} array and the @t{$CURRENT} parameter after those have been modified.  For example, the function @t{_precommand}, which completes "
"after precommand specifiers such as @t{nohup}, removes the first word from the @t{words} array, decrements the @t{CURRENT} parameter, then calls `@t{_normal -p $service}'.  The effect is that `@t{nohup} "
"@var{cmd ...}' is treated in the same way as `@var{cmd ...}'."
msgstr ""
"第二个用途是在 @t{$words} 数组和 @t{$CURRENT} 参数被修改后，重新检查它们指定的命令行。 例如，函数 @t{_precommand} 在 @t{nohup} 等前置命令指定符之后补全，它会删除 @t{words} 数组中的第一个单词，递减 "
"@t{CURRENT} 参数，然后调用 `@t{_normal -p $service}'。 其效果是： `@t{nohup} @var{cmd ...}' 的处理方式与 `@var{cmd ...}' 相同。"

#. type: table
#: zsh.texi:25984
msgid ""
"Reset the list of precommands. This option should be used if completing a command line which allows internal commands (e.g. builtins and functions) regardless of prior precommands (e.g. `@t{zsh -c}')."
msgstr "重置前置命令列表。如果补全的命令行允许使用内部命令（如内置命令和函数）而不考虑先前的前置命令（如 `@t{zsh -c}'），则应使用该选项。"

#. type: item
#: zsh.texi:25985
#, no-wrap
msgid "@t{-p} @var{precommand}"
msgstr "@t{-p} @var{precommand}"

#. type: table
#: zsh.texi:25988
msgid "Append @var{precommand} to the list of precommands. This option should be used in nearly all cases in which @t{-P} is not applicable."
msgstr "将 @var{precommand} 追加到前置命令列表中。该选项几乎适用于 @t{-P} 不适用的所有情况。"

#. type: table
#: zsh.texi:25998
msgid ""
"If the command name matches one of the patterns given by one of the options @t{-p} or @t{-P} to @t{compdef}, the corresponding completion function is called and then the parameter @t{_compskip} is "
"checked.  If it is set completion is terminated at that point even if no matches have been found.  This is the same effect as in the @t{-first-} context."
msgstr ""
"如果命令名与 @t{compdef} 的 @t{-p} 或 @t{-P} 的选项之一给出的模式之一匹配，则调用相应的补全函数，然后检查参数 @t{_compskip}。 如果参数 @t{_compskip} 被设置，即使未找到匹配结果，也会在此时终止补全。 这与 "
"@t{-first-} 上下文中的效果相同。"

#. type: findex
#: zsh.texi:25999
#, no-wrap
msgid "_numbers"
msgstr "_numbers"

#. type: item
#: zsh.texi:26000
#, no-wrap
msgid "@t{_numbers} [ @var{option} ... ] [ @var{description} ] [ @var{suffix} ... ]"
msgstr "@t{_numbers} [ @var{option} ... ] [ @var{description} ] [ @var{suffix} ... ]"

#. type: table
#: zsh.texi:26004
msgid ""
"This can be used where a number is followed by a suffix to indicate the units.  The unit suffixes are completed and can also be included in the description used when completion is invoked for the "
"preceding number."
msgstr "当一个数字后面有一个表示单位的后缀时，就可以使用这种方法。 单位后缀可以补全，也可以包含在为前一个数字调用补全时使用的描述中。"

#. type: table
#: zsh.texi:26008
msgid "In addition to common @t{compadd} options, @t{_numbers} accepts the following options:"
msgstr "除了常用的 @t{compadd} 选项外，@t{_numbers} 还接受以下选项："

#. type: item
#: zsh.texi:26011
#, no-wrap
msgid "@t{-t} @var{tag}"
msgstr "@t{-t} @var{tag}"

#. type: table
#: zsh.texi:26013
msgid "Specify a tag to use instead of the default of @t{numbers}."
msgstr "指定一个要使用的标记，而不是默认的 @t{numbers}。"

#. type: item
#: zsh.texi:26014
#, no-wrap
msgid "@t{-u} @var{units}"
msgstr "@t{-u} @var{units}"

#. type: table
#: zsh.texi:26016
msgid "Indicate the default units for the number, e.g. @t{bytes}."
msgstr "指出数字的默认单位，例如 @t{字节}。"

#. type: item
#: zsh.texi:26017
#, no-wrap
msgid "@t{-l} @var{min}"
msgstr "@t{-l} @var{min}"

#. type: table
#: zsh.texi:26019
msgid "Specify the lowest possible value for the number."
msgstr "指定数字的最小可能值。"

#. type: item
#: zsh.texi:26020
#, no-wrap
msgid "@t{-m} @var{max}"
msgstr "@t{-m} @var{max}"

#. type: table
#: zsh.texi:26022
msgid "Specify the highest possible value for the number."
msgstr "指定数字的最大可能值。"

#. type: item
#: zsh.texi:26023
#, no-wrap
msgid "@t{-d} @var{default}"
msgstr "@t{-d} @var{default}"

#. type: table
#: zsh.texi:26025
msgid "Specify the default value."
msgstr "指定默认值。"

#. type: table
#: zsh.texi:26028
msgid "Allow negative numbers.  This is implied if the range includes a negative."
msgstr "允许负数。 如果范围中包含负数,那么这是隐含的。"

#. type: table
#: zsh.texi:26031
msgid "Allow decimal numbers."
msgstr "允许使用小数。"

#. type: table
#: zsh.texi:26040
msgid ""
"Where a particular suffix represents the default units for a number, it should be prefixed with a colon.  Additionally, suffixes can be followed by a colon and a description.  So for example, the "
"following allows the age of something to be specified, either in seconds or with an optional suffix with a longer unit of time:"
msgstr "如果某个后缀代表一个数字的默认单位，则应在其前加上冒号。 此外，后缀后面还可以加上冒号和说明。 因此，举例来说，下面可以指定某事物的年龄，可以用秒或可选的后缀来表示更长的时间单位："

#. type: example
#: zsh.texi:26044
#, no-wrap
msgid "_numbers -u seconds age :s:seconds m:minutes h:hours d:days\n"
msgstr "_numbers -u seconds age :s:seconds m:minutes h:hours d:days\n"

#. type: table
#: zsh.texi:26050
msgid "It is typically helpful for units to be presented in order of magnitude when completed.  To facilitate this, the order in which they are given is preserved."
msgstr "补全时，按大小顺序排列单位通常会有帮助。 为方便起见，我们保留了给出单位的顺序。"

#. type: table
#: zsh.texi:26066
msgid ""
"When the @t{format} style is looked up with the @t{descriptions} tag or the tag specified with @t{-t}, the list of suffixes is available as a `@t{%x}' escape sequence. This is in addition to the usual "
"sequences documented under the @t{format} style. The form this list takes can also be configured. To this end, the @t{format} style is first looked up with the tag @t{unit-suffixes}. The retrieved format "
"is applied to each suffix in turn and the results are then concatenated to form the completed list. For the @t{unit-suffixes} format, `@t{%x}' expands to the individual suffix and `@t{%X}' to its "
"description. @t{%d}' indicates a default suffix and can be used in a condition. The index and reverse index are set in `@t{%i}' and `@t{%r}' respectively and are useful for text included only with the "
"first and last suffixes in the list. So for example, the following joins the suffixes together as a comma-separated list:"
msgstr ""
"使用 @t{descriptions} 标记或 @t{-t} 指定的标记查找 @t{format} 样式时，后缀列表可作为 `@t{%x}' 转义序列使用。这是 @t{format} 样式下记录的常规序列之外的另一种形式。该列表的形式也可以配置。为此，首先使用 "
"@t{unit-suffixes} 标记查找 @t{format} 样式。检索到的格式依次应用于每个后缀，然后将结果连接起来，形成补全列表。对于 @t{unit-suffixes} 格式，`@t{%x}' 表示单个后缀， `@t{%X}' 表示其描述。 `@t{%d}' 表示默认后"
"缀，可在条件中使用。索引和反向索引分别设置在 `@t{%i}' 和 `@t{%r}' 中，适用于只包含列表中第一和最后一个后缀的文本。例如，下文将后缀以逗号分隔的列表形式连接在一起："

#. type: example
#: zsh.texi:26070
#, no-wrap
msgid "zstyle ':completion:*:unit-suffixes' format '%x%(r::,)'\n"
msgstr "zstyle ':completion:*:unit-suffixes' format '%x%(r::,)'\n"

#. type: t{#1}
#: zsh.texi:26074 zsh.texi:26075
#, no-wrap
msgid "_options"
msgstr "_options"

#. type: table
#: zsh.texi:26082
msgid ""
"This can be used to complete the names of shell options.  It provides a matcher specification that ignores a leading `@t{no}', ignores underscores and allows upper-case letters to match their lower-case "
"counterparts (for example, `@t{glob}', `@t{noglob}', `@t{NO_GLOB}' are all completed).  Any arguments are propagated to the @t{compadd} builtin."
msgstr ""
"可用于补全 shell 选项的名称。 它提供了一个忽略前导 `@t{no}'、忽略下划线并允许大写字母匹配小写字母的匹配规范（例如，`@t{glob}', `@t{noglob}', `@t{NO_GLOB}' 均可补全）。 任何参数都会传播给 @t{compadd} 内置函"
"数。"

#. type: findex
#: zsh.texi:26083
#, no-wrap
msgid "_options_set"
msgstr "_options_set"

#. type: findex
#: zsh.texi:26084
#, no-wrap
msgid "_options_unset"
msgstr "_options_unset"

#. type: item
#: zsh.texi:26085
#, no-wrap
msgid "@t{_options_set} and @t{_options_unset}"
msgstr "@t{_options_set} and @t{_options_unset}"

#. type: table
#: zsh.texi:26088
msgid "These functions complete only set or unset options, with the same matching specification used in the @t{_options} function."
msgstr "这些函数只补全设置或取消设置的选项，其匹配规范与 @t{_options} 函数中使用的相同。"

#. type: table
#: zsh.texi:26095
msgid ""
"Note that you need to uncomment a few lines in the @t{_main_complete} function for these functions to work properly.  The lines in question are used to store the option settings in effect before the "
"completion widget locally sets the options it needs.  Hence these functions are not generally used by the completion system."
msgstr "请注意，要使这些函数正常工作，需要取消 @t{_main_complete} 函数中的几行注释。 在补全小部件本地设置所需的选项之前，这些行用于存储有效的选项设置。 因此，补全系统一般不会使用这些函数。"

#. type: t{#1}
#: zsh.texi:26096 zsh.texi:26097
#, no-wrap
msgid "_parameters"
msgstr "_parameters"

#. type: table
#: zsh.texi:26099
msgid "This is used to complete the names of shell parameters."
msgstr "用于补全 shell 参数的名称。"

#. type: table
#: zsh.texi:26105
msgid ""
"The option `@t{-g} @var{pattern}' limits the completion to parameters whose type matches the @var{pattern}.  The type of a parameter is that shown by `@t{print $@{(t)}@var{param}@t{@}}', hence judicious "
"use of `@t{*}' in @var{pattern} is probably necessary."
msgstr "选项 `@t{-g} @var{pattern}' 限制补全的参数类型与 @var{pattern} 匹配。 参数的类型由 `@t{print $@{(t)}@var{param}@t{@}}' 显示，因此在 @var{pattern} 中明智地使用 `@t{*}' 可能是必要的。"

#. type: table
#: zsh.texi:26108
msgid "All other arguments are passed to the @t{compadd} builtin."
msgstr "所有其他参数都将传递给 @t{compadd} 内置函数。"

#. type: t{#1}
#: zsh.texi:26109 zsh.texi:26110
#, no-wrap
msgid "_path_files"
msgstr "_path_files"

#. type: table
#: zsh.texi:26115
msgid ""
"This function is used throughout the completion system to complete filenames.  It allows completion of partial paths.  For example, the string `@t{/u/i/s/sig}' may be completed to `@t{/usr/include/sys/"
"signal.h}'."
msgstr "该函数在整个补全系统中用于补全文件名。 它允许补全部分路径。 例如，字符串 `@t{/u/i/sig}' 可以补全为 `@t{/usr/include/sys/signal.h}'。"

#. type: table
#: zsh.texi:26118
msgid "The options accepted by both @t{_path_files} and @t{_files} are:"
msgstr "@t{_path_files} 和 @t{_files} 都接受的选项有:"

#. type: table
#: zsh.texi:26123
msgid "Complete all filenames.  This is the default."
msgstr "补全所有文件名。 这是默认设置。"

#. type: t{#1}
#: zsh.texi:26124 zsh.texi:27020
#, no-wrap
msgid "-/"
msgstr "-/"

#. type: table
#: zsh.texi:26126
msgid "Specifies that only directories should be completed."
msgstr "指定只补全目录。"

#. type: item
#: zsh.texi:26127
#, no-wrap
msgid "@t{-g} @var{pattern}"
msgstr "@t{-g} @var{pattern}"

#. type: table
#: zsh.texi:26129
msgid "Specifies that only files matching the @var{pattern} should be completed."
msgstr "指定只补全与 @var{pattern} 匹配的文件。"

#. type: item
#: zsh.texi:26130
#, no-wrap
msgid "@t{-W} @var{paths}"
msgstr "@t{-W} @var{paths}"

#. type: table
#: zsh.texi:26136
msgid ""
"Specifies path prefixes that are to be prepended to the string from the command line to generate the filenames but that should not be inserted as completions nor shown in completion listings.  Here, "
"@var{paths} may be the name of an array parameter, a literal list of paths enclosed in parentheses or an absolute pathname."
msgstr "指定路径前缀，这些路径前缀将被放到命令行字符串前以生成文件名，但不会作为补全插入，也不会显示在补全列表中。 在这里，@var{paths} 可以是数组参数的名称、用括号括起来的（字面值的）路径列表或绝对路径名。"

#. type: item
#: zsh.texi:26137
#, no-wrap
msgid "@t{-F} @var{ignored-files}"
msgstr "@t{-F} @var{ignored-files}"

#. type: table
#: zsh.texi:26142
msgid ""
"This behaves as for the corresponding option to the @t{compadd} builtin.  It gives direct control over which filenames should be ignored.  If the option is not present, the @t{ignored-patterns} style is "
"used."
msgstr "行为与 @t{compadd} 内置程序的相应选项相同。 它可以直接控制哪些文件名应被忽略。 如果没有该选项，则使用 @t{ignored-patterns} 样式。"

#. type: table
#: zsh.texi:26150
msgid ""
"Both @t{_path_files} and @t{_files} also accept the following options which are passed to @t{compadd}: `@t{-J}', `@t{-V}', `@t{-1}', `@t{-2}', `@t{-n}', `@t{-X}', `@t{-M}', `@t{-P}', `@t{-S}', `@t{-q}', "
"`@t{-r}', and `@t{-R}'."
msgstr "@t{_path_files} 和 @t{_files} 还接受以下传递给 @t{compadd} 的选项：`@t{-J}', `@t{-V}', `@t{-1}', `@t{-2}', `@t{-n}', `@t{-X}', `@t{-M}', `@t{-P}', `@t{-S}', `@t{-q}', `@t{-r}' 和 `@t{-R}'。"

#. type: table
#: zsh.texi:26155
msgid "Finally, the @t{_path_files} function uses the styles @t{expand}, @t{ambiguous}, @t{special-dirs}, @t{list-suffixes} and @t{file-sort} described above."
msgstr "最后，@t{_path_files} 函数使用了上述 @t{expand}、@t{ambiguous}、@t{special-dirs}、@t{list-ffixes} 和 @t{file-sort} 样式。"

#. type: findex
#: zsh.texi:26156
#, no-wrap
msgid "_pick_variant"
msgstr "_pick_variant"

#. type: item
#: zsh.texi:26158
#, no-wrap
msgid "@t{_pick_variant }[ @t{-b} @var{builtin-label} ] [ @t{-c} @var{command} ] [ @t{-r} @var{name} ]"
msgstr "@t{_pick_variant }[ @t{-b} @var{builtin-label} ] [ @t{-c} @var{command} ] [ @t{-r} @var{name} ]"

#. type: itemx
#: zsh.texi:26159
#, no-wrap
msgid "@t{@ @ @ @ @ @ @ @ @ @ @ @ @ @ }@var{label}@t{=}@var{pattern} ... @var{label} [ @var{arg} ... ]"
msgstr "@t{@ @ @ @ @ @ @ @ @ @ @ @ @ @ }@var{label}@t{=}@var{pattern} ... @var{label} [ @var{arg} ... ]"

#. type: table
#: zsh.texi:26164
msgid ""
"This function is used to resolve situations where a single command name requires more than one type of handling, either because it has more than one variant or because there is a name clash between two "
"different commands."
msgstr "该函数用于解决单个命令名称需要不止一种处理方式的情况，原因可能是该命令名称有多个变体，或者是两个不同命令之间存在名称冲突。"

#. type: table
#: zsh.texi:26175
msgid ""
"The command to run is taken from the first element of the array @t{words} unless this is overridden by the option @t{-c}.  This command is run and its output is compared with a series of patterns.  "
"Arguments to be passed to the command can be specified at the end after all the other arguments.  The patterns to try in order are given by the arguments @var{label}@t{=}@var{pattern}; if the output of "
"`@var{command} @var{arg} ...' contains @var{pattern}, then @var{label} is selected as the label for the command variant.  If none of the patterns match, the final command label is selected and status 1 is "
"returned."
msgstr ""
"要运行的命令取自 @t{words} 数组的第一个元素，除非被选项 @t{-c} 改写。 命令运行后，其输出将与一系列模式进行比较。 要传递给命令的参数可以在所有其他参数之后指定。 要依次尝试的模式由参数 @var{label}@t{=}"
"@var{pattern} 提供；如果 `@var{command} @var{arg} ...' 的输出包含 @var{pattern}，那么 @var{label} 将被选为命令变量的标签。 如果没有模式匹配，则选择最后的命令标签并返回状态 1。"

#. type: table
#: zsh.texi:26180
msgid ""
"If the `@t{-b} @var{builtin-label}' is given, the command is tested to see if it is provided as a shell builtin, possibly autoloaded; if so, the label @var{builtin-label} is selected as the label for the "
"variant."
msgstr "如果给出 `@t{-b} @var{builtin-label}' 则会测试该命令是否作为 shell 内置命令（可能是自动加载的）提供；如果是，则会选择 @var{builtin-label} 作为变量的标签。"

#. type: table
#: zsh.texi:26184
msgid "If the `@t{-r} @var{name}' is given, the @var{label} picked is stored in the parameter named @var{name}."
msgstr "如果给出 `@t{-r} @var{name}' ，则选中的 @var{label} 将存储在名为 @var{name} 的参数中。"

#. type: table
#: zsh.texi:26188
msgid "The results are also cached in the @t{_cmd_variant} associative array indexed by the name of the command run."
msgstr "结果也会缓存在 @t{_cmd_variant} 关联数组中，该数组以运行命令的名称为索引。"

#. type: findex
#: zsh.texi:26189
#, no-wrap
msgid "_regex_arguments"
msgstr "_regex_arguments"

#. type: item
#: zsh.texi:26190
#, no-wrap
msgid "@t{_regex_arguments} @var{name} @var{spec} ..."
msgstr "@t{_regex_arguments} @var{name} @var{spec} ..."

#. type: table
#: zsh.texi:26198
msgid ""
"This function generates a completion function @var{name} which matches the specifications @var{spec}s, a set of regular expressions as described below.  After running @t{_regex_arguments}, the function "
"@var{name} should be called as a normal completion function.  The pattern to be matched is given by the contents of the @t{words} array up to the current cursor position joined together with null "
"characters; no quotation is applied."
msgstr ""
"该函数生成一个补全函数 @var{name}，该函数与 @var{spec}s（如下所述的一组正则表达式）的规范相匹配。 运行 @t{_regex_arguments} 后，应将函数 @var{name} 作为普通补全函数调用。 要匹配的模式由 @t{words} 数组中直"
"到当前光标位置的内容和空字符组成；不使用引号。"

#. type: table
#: zsh.texi:26208
msgid ""
"The arguments are grouped as sets of alternatives separated by `@t{|}', which are tried one after the other until one matches.  Each alternative consists of a one or more specifications which are tried "
"left to right, with each pattern matched being stripped in turn from the command line being tested, until all of the group succeeds or until one fails; in the latter case, the next alternative is tried.  "
"This structure can be repeated to arbitrary depth by using parentheses; matching proceeds from inside to outside."
msgstr ""
"参数以备选方案集的形式分组，中间用 `@t{|}' 隔开，一个接一个地测试，直到有一个匹配为止。 每个备选方案由一个或多个规范组成，从左到右依次测试，每个匹配的模式都会从被测试的命令行中依次剥离，直到该组全部成功或"
"有一个失败为止；在后一种情况下，将测试下一个备选方案。 通过使用括号，这种结构可以重复到任意深度；匹配从内向外进行。"

#. type: table
#: zsh.texi:26220
msgid ""
"A special procedure is applied if no test succeeds but the remaining command line string contains no null character (implying the remaining word is the one for which completions are to be generated).  The "
"completion target is restricted to the remaining word and any @var{action}s for the corresponding patterns are executed.  In this case, nothing is stripped from the command line string.  The order of "
"evaluation of the @var{action}s can be determined by the @t{tag-order} style; the various formats supported by @t{_alternative} can be used in @var{action}.  The @var{descr} is used for setting up the "
"array parameter @t{expl}."
msgstr ""
"如果没有测试成功，但剩余的命令行字符串不包含空字符（意味着剩余的单词就是要生成补全的单词），则会应用一个特殊程序。 补全目标仅限于剩余的单词，并执行相应模式的任何 @var{action}s 。 在这种情况下，不会从命令行"
"字符串中剥离任何内容。 @var{action}s 的计算顺序可以由 @t{tag-order} 样式决定；@t{_alternative}支持的各种格式都可以在 @var{action} 中使用。 @var{descr} 用于设置数组参数 @t{expl}。"

#. type: table
#: zsh.texi:26225
msgid "Specification arguments take one of following forms, in which metacharacters such as `@t{(}', `@t{)}', `@t{#}' and `@t{|}' should be quoted."
msgstr "规范参数有以下几种形式，其中 `@t{(}', `@t{)}', `@t{#}' 和 `@t{|}' 等元字符应加引号。"

#. type: item
#: zsh.texi:26228
#, no-wrap
msgid "@t{/}@var{pattern}@t{/} [@t{%}@var{lookahead}@t{%}] [@t{-}@var{guard}] [@t{:}@var{tag}@t{:}@var{descr}@t{:}@var{action}]"
msgstr "@t{/}@var{pattern}@t{/} [@t{%}@var{lookahead}@t{%}] [@t{-}@var{guard}] [@t{:}@var{tag}@t{:}@var{descr}@t{:}@var{action}]"

#. type: table
#: zsh.texi:26237
msgid ""
"This is a single primitive component.  The function tests whether the combined pattern `@t{(#b)((#B)}@var{pattern}@t{)}@var{lookahead}@t{*}' matches the command line string.  If so, `@var{guard}' is "
"evaluated and its return status is examined to determine if the test has succeeded.  The @var{pattern} string `@t{[]}' is guaranteed never to match.  The @var{lookahead} is not stripped from the command "
"line before the next pattern is examined."
msgstr ""
"这是一个单一的原始组件。 该函数测试组合模式 `@t{(#b)((#B)}@var{pattern}@t{)}@var{lookahead}@t{*}' 是否与命令行字符串匹配。 如果匹配，将计算 `@var{guard}' ，并检查其返回状态，以确定测试是否成功。 "
"@var{pattern} 字符串 `@t{[]}' 保证永远不会匹配。 在检查下一个模式之前，@var{lookahead} 不会从命令行中删除。"

#. type: table
#: zsh.texi:26241
msgid "The argument starting with @t{:} is used in the same manner as an argument to @t{_alternative}."
msgstr "以 @t{:} 开头的参数的使用方式与 @t{_alternative} 的参数相同。"

#. type: table
#: zsh.texi:26249
msgid ""
"A component is used as follows: @var{pattern} is tested to see if the component already exists on the command line.  If it does, any following specifications are examined to find something to complete.  "
"If a component is reached but no such pattern exists yet on the command line, the string containing the @var{action} is used to generate matches to insert at that point."
msgstr ""
"组件的使用方法如下： 检测 @var{pattern} ,以查看组件是否已存在于命令行中。 如果存在，则会检查下面的任何规范，以找到需要补全的内容。 如果找到了一个组件，但命令行中还没有这样的模式，则会使用包含 @var{action} "
"的字符串来生成匹配项，并在此处插入。"

#. type: item
#: zsh.texi:26250
#, no-wrap
msgid "@t{/}@var{pattern}@t{/+} [@t{%}@var{lookahead}@t{%}] [@t{-}@var{guard}] [@t{:}@var{tag}@t{:}@var{descr}@t{:}@var{action}]"
msgstr "@t{/}@var{pattern}@t{/+} [@t{%}@var{lookahead}@t{%}] [@t{-}@var{guard}] [@t{:}@var{tag}@t{:}@var{descr}@t{:}@var{action}]"

#. type: table
#: zsh.texi:26254
msgid "This is similar to `@t{/}@var{pattern}@t{/} ...' but the left part of the command line string (i.e. the part already matched by previous patterns)  is also considered part of the completion target."
msgstr "这与 `@t{/}@var{pattern}@t{/} ...' 类似，但命令行字符串的左侧部分（即已被前面的模式匹配的部分）也被视为补全目标的一部分。"

#. type: item
#: zsh.texi:26255
#, no-wrap
msgid "@t{/}@var{pattern}@t{/-} [@t{%}@var{lookahead}@t{%}] [@t{-}@var{guard}] [@t{:}@var{tag}@t{:}@var{descr}@t{:}@var{action}]"
msgstr "@t{/}@var{pattern}@t{/-} [@t{%}@var{lookahead}@t{%}] [@t{-}@var{guard}] [@t{:}@var{tag}@t{:}@var{descr}@t{:}@var{action}]"

#. type: table
#: zsh.texi:26259
msgid "This is similar to `@t{/}@var{pattern}@t{/} ...' but the @var{action}s of the current and previously matched patterns are ignored even if the following `@var{pattern}' matches the empty string."
msgstr "这类似于 `@t{/}@var{pattern}@t{/} ...' ，但是当前和先前匹配模式的 @var{action}s 会被忽略，即使接下来的 `@var{pattern}' 匹配空字符串。"

#. type: item
#: zsh.texi:26260
#, no-wrap
msgid "@t{(} @var{spec} @t{)}"
msgstr "@t{(} @var{spec} @t{)}"

#. type: table
#: zsh.texi:26263
msgid "Parentheses may be used to groups @var{spec}s; note each parenthesis is a single argument to @t{_regex_arguments}."
msgstr "括号可用于对 @var{spec}s 进行分组；请注意，每个括号都是 @t{_regex_arguments} 的一个参数。"

#. type: item
#: zsh.texi:26264
#, no-wrap
msgid "@var{spec} @t{#}"
msgstr "@var{spec} @t{#}"

#. type: table
#: zsh.texi:26266
msgid "This allows any number of repetitions of @var{spec}."
msgstr "这允许 @var{spec} 有任意次数的重复。"

#. type: item
#: zsh.texi:26267
#, no-wrap
msgid "@var{spec} @var{spec}"
msgstr "@var{spec} @var{spec}"

#. type: table
#: zsh.texi:26270
msgid "The two @var{spec}s are to be matched one after the other as described above."
msgstr "如上所述，两个 @var{spec} 将相继匹配。"

#. type: item
#: zsh.texi:26271
#, no-wrap
msgid "@var{spec} @t{|} @var{spec}"
msgstr "@var{spec} @t{|} @var{spec}"

#. type: table
#: zsh.texi:26273
msgid "Either of the two @var{spec}s can be matched."
msgstr "两个 @var{spec}s 中的任何一个都可以匹配。"

#. type: table
#: zsh.texi:26280
msgid "The function @t{_regex_words} can be used as a helper function to generate matches for a set of alternative words possibly with their own arguments as a command line argument."
msgstr "函数 @t{_regex_words} 可用作辅助函数，为一组备选词语生成匹配结果，这些词语可能带有自己的参数作为命令行参数。"

#. type: example
#: zsh.texi:26288
#, no-wrap
msgid ""
"_regex_arguments _tst /$'[^\\0]#\\0'/ \\ \n"
"    /$'[^\\0]#\\0'/ :'compadd aaa'\n"
msgstr ""
"_regex_arguments _tst /$'[^\\0]#\\0'/ \\ \n"
"    /$'[^\\0]#\\0'/ :'compadd aaa'\n"

#. type: table
#: zsh.texi:26297
msgid ""
"This generates a function @t{_tst} that completes @t{aaa} as its only argument.  The @var{tag} and @var{description} for the action have been omitted for brevity (this works but is not recommended in "
"normal use).  The first component matches the command word, which is arbitrary; the second matches any argument.  As the argument is also arbitrary, any following component would not depend on @t{aaa} "
"being present."
msgstr ""
"这会生成一个函数 @t{_tst}，该函数的唯一参数是 @t{aaa}。 为简洁起见，省略了动作的 @var{tag} 和 @var{description}（这样做可行，但不建议在正常使用中这样做）。 第一个组件匹配任意的命令字；第二个组件匹配任何参"
"数。 由于参数也是任意的，因此后面的任何组件都不取决于 @t{aaa} 是否存在。"

#. type: example
#: zsh.texi:26302
#, no-wrap
msgid ""
"_regex_arguments _tst /$'[^\\0]#\\0'/ \\ \n"
"    /$'aaa\\0'/ :'compadd aaa'\n"
msgstr ""
"_regex_arguments _tst /$'[^\\0]#\\0'/ \\ \n"
"    /$'aaa\\0'/ :'compadd aaa'\n"

#. type: table
#: zsh.texi:26307
msgid "This is a more typical use; it is similar, but any following patterns would only match if @t{aaa} was present as the first argument."
msgstr "这是一种更典型的用法；它与此相似，但只有在 @t{aaa} 作为第一个参数出现时，才会匹配下面的任何模式。"

#. type: example
#: zsh.texi:26313
#, no-wrap
msgid ""
"_regex_arguments _tst /$'[^\\0]#\\0'/ \\( \\ \n"
"    /$'aaa\\0'/ :'compadd aaa' \\ \n"
"    /$'bbb\\0'/ :'compadd bbb' \\) \\#\n"
msgstr ""
"_regex_arguments _tst /$'[^\\0]#\\0'/ \\( \\ \n"
"    /$'aaa\\0'/ :'compadd aaa' \\ \n"
"    /$'bbb\\0'/ :'compadd bbb' \\) \\#\n"

#. type: table
#: zsh.texi:26320
msgid ""
"In this example, an indefinite number of command arguments may be completed.  Odd arguments are completed as @t{aaa} and even arguments as @t{bbb}.  Completion fails unless the set of @t{aaa} and @t{bbb} "
"arguments before the current one is matched correctly."
msgstr "在本例中，可以补全不确定数量的命令参数。 奇数参数补全为 @t{aaa}，偶数参数补全为 @t{bbb}。 除非当前参数之前的 @t{aaa} 和 @t{bbb} 参数集匹配正确，否则补全失败。"

#. type: example
#: zsh.texi:26326
#, no-wrap
msgid ""
"_regex_arguments _tst /$'[^\\0]#\\0'/ \\ \n"
"    \\( /$'aaa\\0'/ :'compadd aaa' \\| \\ \n"
"    /$'bbb\\0'/ :'compadd bbb' \\) \\#\n"
msgstr ""
"_regex_arguments _tst /$'[^\\0]#\\0'/ \\ \n"
"    \\( /$'aaa\\0'/ :'compadd aaa' \\| \\ \n"
"    /$'bbb\\0'/ :'compadd bbb' \\) \\#\n"

#. type: table
#: zsh.texi:26332
msgid "This is similar, but either @t{aaa} or @t{bbb} may be completed for any argument.  In this case @t{_regex_words} could be used to generate a suitable expression for the arguments."
msgstr "这一点类似，但 @t{aaa} 或 @t{bbb} 可以为任意参数补全。 在这种情况下，可以使用 @t{_regex_words} 为参数生成合适的表达式。"

#. type: findex
#: zsh.texi:26335
#, no-wrap
msgid "_regex_words [ @t{-t} @var{term} ]"
msgstr "_regex_words [ @t{-t} @var{term} ]"

#. type: item
#: zsh.texi:26336
#, no-wrap
msgid "@t{_regex_words} @var{tag} @var{description} @var{spec} ..."
msgstr "@t{_regex_words} @var{tag} @var{description} @var{spec} ..."

#. type: table
#: zsh.texi:26343
msgid ""
"This function can be used to generate arguments for the @t{_regex_arguments} command which may be inserted at any point where a set of rules is expected.  The @var{tag} and @var{description} give a "
"standard tag and description pertaining to the current context.  Each @var{spec} contains two or three arguments separated by a colon: note that there is no leading colon in this case."
msgstr ""
"该函数可用于为 @t{_regex_arguments} 命令生成参数，这些参数可插入到任何需要规则集的地方。 @var{tag} 和 @var{description} 给出了与当前上下文相关的标准标记和描述。 每个 @var{spec} 包含两个或三个参数，参数之间"
"用冒号隔开：注意，这里没有前导冒号。"

#. type: table
#: zsh.texi:26348
msgid ""
"Each @var{spec} gives one of a set of words that may be completed at this point, together with arguments.  It is thus roughly equivalent to the @t{_arguments} function when used in normal (non-regex) "
"completion."
msgstr "每个 @var{spec} 都给出了此时可能补全的词的集中的一个，和参数一起。 因此，它大致等同于在普通（非 regex）补全中使用的 @t{_arguments} 函数。"

#. type: table
#: zsh.texi:26355
msgid ""
"The part of the @var{spec} before the first colon is the word to be completed.  This may contain a @t{*}; the entire word, before and after the @t{*} is completed, but only the text before the @t{*} is "
"required for the context to be matched, so that further arguments may be completed after the abbreviated form."
msgstr ""
"@var{spec} 中第一个冒号之前的部分是要补全的单词。 其中可能包含一个 @t{*}；整个单词, 在 @t{*} 前后的内容，都会被补全，但只有 @t{*} 之前的内容才需要进行上下文匹配，因此在缩写形式之后还可以补全其他参数。"

#. type: table
#: zsh.texi:26359
msgid "The second part of @var{spec} is a description for the word being completed."
msgstr "@var{spec} 的第二部分是对正在补全的单词的描述。"

#. type: table
#: zsh.texi:26366
msgid ""
"The optional third part of the @var{spec} describes how words following the one being completed are themselves to be completed.  It will be evaluated in order to avoid problems with quoting.  This means "
"that typically it contains a reference to an array containing previously generated regex arguments."
msgstr "@var{spec} 的第三部分是可选的，它描述了被补全词语后面的词语如何补全。 为了避免引号问题，将对其进行计算。 这意味着它通常包含对一个数组的引用，该数组包含先前生成的正则表达式参数。"

#. type: table
#: zsh.texi:26371
msgid "The option @t{-t} @var{term} specifies a terminator for the word instead of the usual space.  This is handled as an auto-removable suffix in the manner of the option @t{-s} @var{sep} to @t{_values}."
msgstr "选项 @t{-t} @var{term} 指定了单词的结束符，而不是通常的空格。这将作为一个可自动删除的后缀来处理，就像 @t{_values} 的选项 @t{-s} @var{sep} 一样。"

#. type: table
#: zsh.texi:26377
msgid ""
"The result of the processing by @t{_regex_words} is placed in the array @t{reply}, which should be made local to the calling function.  If the set of words and arguments may be matched repeatedly, a @t{#} "
"should be appended to the generated array at that point."
msgstr "@t{_regex_words} 的处理结果会被放入数组 @t{reply}，该数组应为调用函数的本地数组。 如果词组和参数的集可能重复匹配，则应在当前生成的数组中添加 @t{#}。"

#. type: example
#: zsh.texi:26389
#, no-wrap
msgid ""
"local -a reply\n"
"_regex_words mydb-commands 'mydb commands' \\ \n"
"  'add:add an entry to mydb:$mydb_add_cmds' \\ \n"
"  'show:show entries in mydb'\n"
"_regex_arguments _mydb \"$reply[@@]\"\n"
"_mydb \"$@@\"\n"
msgstr ""
"local -a reply\n"
"_regex_words mydb-commands 'mydb commands' \\ \n"
"  'add:add an entry to mydb:$mydb_add_cmds' \\ \n"
"  'show:show entries in mydb'\n"
"_regex_arguments _mydb \"$reply[@@]\"\n"
"_mydb \"$@@\"\n"

#. type: table
#: zsh.texi:26397
msgid ""
"This shows a completion function for a command @t{mydb} which takes two command arguments, @t{add} and @t{show}.  @t{show} takes no arguments, while the arguments for @t{add} have already been prepared in "
"an array @t{mydb_add_cmds}, quite possibly by a previous call to @t{_regex_words}."
msgstr ""
"这里显示的是命令 @t{mydb} 的补全函数，该命令需要两个命令参数：@t{add} 和 @t{show}。 @t{show} 不需要参数，而 @t{add} 的参数已经在数组 @t{mydb_add_cmds} 中准备好了，很可能是之前调用 @t{_regex_words} 时准备"
"的。"

#. type: findex
#: zsh.texi:26398
#, no-wrap
msgid "_requested"
msgstr "_requested"

#. type: item
#: zsh.texi:26399
#, no-wrap
msgid "@t{_requested} [ @t{-x} ] [ @t{-12VJ} ] @var{tag} [ @var{name} @var{descr} [ @var{command} [ @var{arg} ... ] ]"
msgstr "@t{_requested} [ @t{-x} ] [ @t{-12VJ} ] @var{tag} [ @var{name} @var{descr} [ @var{command} [ @var{arg} ... ] ]"

#. type: table
#: zsh.texi:26405
msgid ""
"This function is called to decide whether a tag already registered by a call to @t{_tags} (see below) has been requested by the user and hence completion should be performed for it.  It returns status "
"zero if the tag is requested and non-zero otherwise.  The function is typically used as part of a loop over different tags as follows:"
msgstr "调用此函数是为了判断用户是否请求了 @t{_tags}（见下文）中已经注册的标记，并因此需要对其进行补全。 如果该标记被请求，则返回状态 0，否则返回非 0。 该函数通常作为不同标记循环的一部分使用，如下所示："

#. type: example
#: zsh.texi:26416
#, no-wrap
msgid ""
"_tags foo bar baz\n"
"while _tags; do\n"
"  if _requested foo; then\n"
"    ... # perform completion for foo\n"
"  fi\n"
"  ... # test the tags bar and baz in the same way\n"
"  ... # exit loop if matches were generated\n"
"done\n"
msgstr ""
"_tags foo bar baz\n"
"while _tags; do\n"
"  if _requested foo; then\n"
"    ... # perform completion for foo\n"
"  fi\n"
"  ... # test the tags bar and baz in the same way\n"
"  ... # exit loop if matches were generated\n"
"done\n"

#. type: table
#: zsh.texi:26423
msgid ""
"Note that the test for whether matches were generated is not performed until the end of the @t{_tags} loop.  This is so that the user can set the @t{tag-order} style to specify a set of tags to be "
"completed at the same time."
msgstr "请注意，在 @t{_tags} 循环结束之前，不会对是否生成匹配进行测试。 这样用户就可以设置 @t{tag-order} 样式，指定同时补全一组标记。"

#. type: table
#: zsh.texi:26428
msgid "If @var{name} and @var{descr} are given, @t{_requested} calls the @t{_description} function with these arguments together with the options passed to @t{_requested}."
msgstr "如果给出 @var{name} 和 @var{descr}，@t{_requested} 就会调用 @t{_description} 函数，其中包含这些参数和传给 @t{_requested} 的选项。"

#. type: table
#: zsh.texi:26434
msgid ""
"If @var{command} is given, the @t{_all_labels} function will be called immediately with the same arguments.  In simple cases this makes it possible to perform the test for the tag and the matching in one "
"go.  For example:"
msgstr "如果给出 @var{command}，将立即调用带有相同参数的 @t{_all_labels} 函数。 在简单的情况下，这样就可以一次性完成标记测试和匹配。 例如:"

#. type: example
#: zsh.texi:26445
#, no-wrap
msgid ""
"local expl ret=1\n"
"_tags foo bar baz\n"
"while _tags; do\n"
"  _requested foo expl 'description' \\ \n"
"      compadd foobar foobaz && ret=0\n"
"  ...\n"
"  (( ret )) || break\n"
"done\n"
msgstr ""
"local expl ret=1\n"
"_tags foo bar baz\n"
"while _tags; do\n"
"  _requested foo expl 'description' \\ \n"
"      compadd foobar foobaz && ret=0\n"
"  ...\n"
"  (( ret )) || break\n"
"done\n"

#. type: table
#: zsh.texi:26450
msgid "If the @var{command} is not @t{compadd}, it must nevertheless be prepared to handle the same options."
msgstr "如果 @var{command} 不是 @t{comppadd}，则必须准备处理相同的选项。"

#. type: findex
#: zsh.texi:26451
#, no-wrap
msgid "_retrieve_cache"
msgstr "_retrieve_cache"

#. type: item
#: zsh.texi:26452
#, no-wrap
msgid "@t{_retrieve_cache} @var{cache_identifier}"
msgstr "@t{_retrieve_cache} @var{cache_identifier}"

#. type: table
#: zsh.texi:26460
msgid ""
"This function retrieves completion information from the file given by @var{cache_identifier}, stored in a directory specified by the @t{cache-path} style which defaults to @t{~/.zcompcache}.  The return "
"status is zero if retrieval was successful.  It will only attempt retrieval if the @t{use-cache} style is set, so you can call this function without worrying about whether the user wanted to use the "
"caching layer."
msgstr ""
"此函数从 @var{cache_identifier} 指定的文件中获取补全信息，该文件存储在 @t{cache-path} 样式指定的目录中，默认为 @t{~/.zcompcache}。 如果检索成功，返回状态为零。 只有设置了 @t{use-cache} 样式，才会尝试检索，"
"因此调用此函数时无需担心用户是否希望使用缓存层。"

#. type: table
#: zsh.texi:26463
msgid "See @t{_store_cache} below for more details."
msgstr "更多详情，请参阅下面的 @t{_store_cache}。"

#. type: t{#1}
#: zsh.texi:26464 zsh.texi:26465
#, no-wrap
msgid "_sep_parts"
msgstr "_sep_parts"

#. type: table
#: zsh.texi:26473
msgid ""
"This function is passed alternating arrays and separators as arguments.  The arrays specify completions for parts of strings to be separated by the separators.  The arrays may be the names of array "
"parameters or a quoted list of words in parentheses.  For example, with the array `@t{hosts=(ftp news)}' the call `@t{_sep_parts '(foo bar)' @@ hosts}' will complete the string `@t{f}' to `@t{foo}' and "
"the string `@t{b@@n}' to `@t{bar@@news}'."
msgstr ""
"该函数的参数是交替传递的数组和分隔符。 数组指定由分隔符分隔的字符串部分的补全。 数组可以是数组参数的名称，也可以是括号中的加引号单词的列表。 例如，使用数组 `@t{hosts=(ftp news)}' 调用 `@t{_sep_parts '(foo "
"bar)' @@ hosts}' 将把字符串 `@t{f}' 补全为 `@t{foo}' ，把字符串 `@t{b@@n}' 补全为 `@t{bar@@news}'。"

#. type: table
#: zsh.texi:26479
msgid ""
"This function accepts the @t{compadd} options `@t{-V}', `@t{-J}', `@t{-1}', `@t{-2}', `@t{-n}', `@t{-X}', `@t{-M}', `@t{-P}', `@t{-S}', `@t{-r}', `@t{-R}', and `@t{-q}' and passes them on to the "
"@t{compadd} builtin used to add the matches."
msgstr ""
"该函数接受 @t{compadd}选项 `@t{-V}', `@t{-J}', `@t{-1}', `@t{-2}', `@t{-n}', `@t{-X}', `@t{-M}', `@t{-P}', `@t{-S}', `@t{-r}', `@t{-R}' 和 `@t{-q}' ，并将它们传递给用于添加匹配的 @t{compadd} 内置命令。"

#. type: findex
#: zsh.texi:26480
#, no-wrap
msgid "_sequence"
msgstr "_sequence"

#. type: item
#: zsh.texi:26481
#, no-wrap
msgid "@t{_sequence} [ @t{-s} @var{sep} ] [ @t{-n} @var{max} ] [ @t{-d} ] @var{function} [ @t{-} ] ..."
msgstr "@t{_sequence} [ @t{-s} @var{sep} ] [ @t{-n} @var{max} ] [ @t{-d} ] @var{function} [ @t{-} ] ..."

#. type: table
#: zsh.texi:26488
msgid ""
"This function is a wrapper to other functions for completing items in a separated list. The same function is used to complete each item in the list. The separator is specified with the @t{-s} option. If "
"@t{-s} is omitted it will use `@t{,}'. Duplicate values are not matched unless @t{-d} is specified. If there is a fixed or maximum number of items in the list, this can be specified with the @t{-n} option."
msgstr ""
"该函数是其他函数的包装器，用于补全分隔列表中的项目。同一个函数用于补全列表中的每个项目。分隔符用 @t{-s} 选项指定。如果省略 @t{-s}，将使用 `@t{,}'。除非指定 @t{-d}，否则不会匹配重复值。如果列表中有固定或最"
"多的条目数，可以使用 @t{-n} 选项来指定。"

#. type: table
#: zsh.texi:26493
msgid "Common @t{compadd} options are passed on to the function. It is possible to use @t{compadd} directly with @t{_sequence}, though @t{_values} may be more appropriate in this situation."
msgstr "常用的 @t{compadd} 选项会传递给函数。@t{compadd} 也可以直接与 @t{_sequence} 搭配使用，不过 @t{_values} 在这种情况下可能更合适。"

#. type: findex
#: zsh.texi:26494
#, no-wrap
msgid "_setup"
msgstr "_setup"

#. type: item
#: zsh.texi:26495
#, no-wrap
msgid "@t{_setup} @var{tag} [ @var{group} ]"
msgstr "@t{_setup} @var{tag} [ @var{group} ]"

#. type: table
#: zsh.texi:26501
msgid ""
"This function sets up the special parameters used by the completion system appropriately for the @var{tag} given as the first argument.  It uses the styles @t{list-colors}, @t{list-packed}, @t{list-rows-"
"first}, @t{last-prompt}, @t{accept-exact}, @t{menu} and @t{force-list}."
msgstr "此函数为第一个参数 @var{tag} 适当设置补全系统使用的特殊参数。 它使用 @t{list-colors}、@t{list-packed}、@t{list-rows-first}、@t{last-prompt}、@t{accept-exact}、@t{menu} 和 @t{force-list} 样式。"

#. type: table
#: zsh.texi:26506
msgid "The optional @var{group} supplies the name of the group in which the matches will be placed.  If it is not given, the @var{tag} is used as the group name."
msgstr "可选的 @var{group} 提供匹配结果所在的组名。 如果没有给出，则使用 @var{tag} 作为组名。"

#. type: table
#: zsh.texi:26510
msgid "This function is called automatically from @t{_description} and hence is not normally called explicitly."
msgstr "该函数由 @t{_description} 自动调用，因此通常不会明确调用。"

#. type: findex
#: zsh.texi:26511
#, no-wrap
msgid "_store_cache"
msgstr "_store_cache"

#. type: item
#: zsh.texi:26512
#, no-wrap
msgid "@t{_store_cache} @var{cache_identifier} @var{param} ..."
msgstr "@t{_store_cache} @var{cache_identifier} @var{param} ..."

#. type: table
#: zsh.texi:26520
msgid ""
"This function, together with @t{_retrieve_cache} and @t{_cache_invalid}, implements a caching layer which can be used in any completion function.  Data obtained by costly operations are stored in "
"parameters; this function then dumps the values of those parameters to a file.  The data can then be retrieved quickly from that file via @t{_retrieve_cache}, even in different instances of the shell."
msgstr ""
"该函数与 @t{_retrieve_cache} 和 @t{_cache_invalid} 一起实现了一个缓存层，可用于任何补全函数。 通过代价高昂的操作获得的数据存储在参数中；然后，该函数会将这些参数的值转储到一个文件中。 然后，即使在 shell 的"
"不同实例中，也可以通过 @t{_retrieve_cache} 从文件中快速检索数据。"

#. type: table
#: zsh.texi:26526
msgid ""
"The @var{cache_identifier} specifies the file which the data should be dumped to.  The file is stored in a directory specified by the @t{cache-path} style which defaults to @t{~/.zcompcache}.  The "
"remaining @var{param}s arguments are the parameters to dump to the file."
msgstr "@var{cache_identifier} 指定了要转储数据的文件。 文件存储在 @t{cache-path} 样式指定的目录中，默认为 @t{~/.zcompcache}。 其余 @var{param}s 参数是要转储到文件中的参数。"

#. type: table
#: zsh.texi:26532
msgid ""
"The return status is zero if storage was successful.  The function will only attempt storage if the @t{use-cache} style is set, so you can call this function without worrying about whether the user wanted "
"to use the caching layer."
msgstr "如果存储成功，返回状态为零。 只有设置了 @t{use-cache} 样式，函数才会尝试存储，因此可以调用该函数，而不必担心用户是否希望使用缓存层。"

#. type: table
#: zsh.texi:26539
msgid ""
"The completion function may avoid calling @t{_retrieve_cache} when it already has the completion data available as parameters.  However, in that case it should call @t{_cache_invalid} to check whether the "
"data in the parameters and in the cache are still valid."
msgstr "当补全函数已经有了作为参数的补全数据时，它可能会避免调用 @t{_retrieve_cache}。 不过，在这种情况下，它应该调用 @t{_cache_invalid} 来检查参数和缓存中的数据是否仍然有效。"

#. type: table
#: zsh.texi:26543
msgid "See the _perl_modules completion function for a simple example of the usage of the caching layer."
msgstr "有关缓存层用法的简单示例，请参见 _perl_modules completion 函数。"

#. type: findex
#: zsh.texi:26544
#, no-wrap
msgid "_tags"
msgstr "_tags"

#. type: item
#: zsh.texi:26545
#, no-wrap
msgid "@t{_tags} [ [ @t{-C} @var{name} ] @var{tag} ... ]"
msgstr "@t{_tags} [ [ @t{-C} @var{name} ] @var{tag} ... ]"

#. type: table
#: zsh.texi:26549
msgid "If called with arguments, these are taken to be the names of tags valid for completions in the current context.  These tags are stored internally and sorted by using the @t{tag-order} style."
msgstr "如果调用时带有参数，这些参数将被视为当前上下文中有效的补全标记名称。 这些标记将存储在内部，并使用 @t{tag-order} 样式进行排序。"

#. type: table
#: zsh.texi:26557
msgid ""
"Next, @t{_tags} is called repeatedly without arguments from the same completion function.  This successively selects the first, second, etc. set of tags requested by the user.  The return status is zero "
"if at least one of the tags is requested and non-zero otherwise.  To test if a particular tag is to be tried, the @t{_requested} function should be called (see above)."
msgstr ""
"接下来，@t{_tags} 会在不带参数的情况下被同一个补全函数反复调用。 这将依次选择用户请求的第一、第二等标记的集。 如果至少有一个标记被请求，则返回状态为 0，否则为非 0。 要测试是否要尝试某个标记，应调用 "
"@t{_requested} 函数（见上文）。"

#. type: table
#: zsh.texi:26565
msgid ""
"If `@t{-C} @var{name}' is given, @var{name} is temporarily stored in the @var{argument} field (the fifth) of the context in the @t{curcontext} parameter during the call to @t{_tags}; the field is restored "
"on exit.  This allows @t{_tags} to use a more specific context without having to change and reset the @t{curcontext} parameter (which has the same effect)."
msgstr ""
"如果给出 `@t{-C} @var{name}' , 则 @var{name} 会在调用 @t{_tags} 时暂时保存在 @t{curcontext} 参数中上下文的 @var{argument} 字段（第五字段）中；退出时会恢复该字段。 这样，@t{_tags} 就可以使用更具体的上下文，"
"而无需更改和重置 @t{curcontext} 参数（这有相同效果）。"

#. type: t{#1}
#: zsh.texi:26566 zsh.texi:26567
#, no-wrap
msgid "_tilde_files"
msgstr "_tilde_files"

#. type: table
#: zsh.texi:26571
msgid "Like @t{_files}, but resolve leading tildes according to the rules of filename expansion, so the suggested completions don't start with a `@t{~}' even if the filename on the command-line does."
msgstr "与 @t{_files}类似，但会根据文件名扩展规则解决前导 tildes 问题，因此即使命令行上的文件名以 `@t{~}' 开头，建议的补全也不会以 `@t{~}' 开头。"

#. type: findex
#: zsh.texi:26572
#, no-wrap
msgid "_values"
msgstr "_values"

#. type: item
#: zsh.texi:26573
#, no-wrap
msgid "@t{_values} [ @t{-O} @var{name} ] [ @t{-s} @var{sep} ] [ @t{-S} @var{sep} ] [ @t{-wC} ] @var{desc} @var{spec} ..."
msgstr "@t{_values} [ @t{-O} @var{name} ] [ @t{-s} @var{sep} ] [ @t{-S} @var{sep} ] [ @t{-wC} ] @var{desc} @var{spec} ..."

#. type: table
#: zsh.texi:26576
msgid "This is used to complete arbitrary keywords (values) and their arguments, or lists of such combinations."
msgstr "用于补全任意关键字（值）及其参数，或此类组合的列表。"

#. type: table
#: zsh.texi:26582
msgid ""
"If the first argument is the option `@t{-O} @var{name}', it will be used in the same way as by the @t{_arguments} function.  In other words, the elements of the @var{name} array will be passed to "
"@t{compadd} when executing an action."
msgstr "如果第一个参数是选项 `@t{-O} @var{name}'，其使用方式将与 @t{_arguments} 函数相同。 换句话说，在执行操作时，@var{name} 数组中的元素将传递给 @t{compadd}。"

#. type: table
#: zsh.texi:26591
msgid ""
"If the first argument (or the first argument after `@t{-O} @var{name}')  is `@t{-s}', the next argument is used as the character that separates multiple values.  This character is automatically added "
"after each value in an auto-removable fashion (see below); all values completed by `@t{_values -s}' appear in the same word on the command line, unlike completion using @t{_arguments}.  If this option is "
"not present, only a single value will be completed per word."
msgstr ""
"如果第一个参数（或 `@t{-O} @var{name}' 后的第一个参数）是 `@t{-s}'，则下一个参数将作为分隔多个值的字符。 该字符会以自动可删除的方式（见下文）自动添加到每个值之后；与使用 @t{_arguments} 的补全方式不同，所有"
"通过 `@t{_values -s}' 补全的值在命令行中都显示为同一个单词。 如果不使用该选项，每个单词将只补全一个值。"

#. type: table
#: zsh.texi:26597
msgid ""
"Normally, @t{_values} will only use the current word to determine which values are already present on the command line and hence are not to be completed again.  If the @t{-w} option is given, other "
"arguments are examined as well."
msgstr "通常情况下，@t{_values} 只使用当前单词来确定哪些值已经存在于命令行中，因此不需要再次补全。 如果给出 @t{-w} 选项，其他参数也会被检查。"

#. type: table
#: zsh.texi:26601
msgid "The first non-option argument, @var{desc}, is used as a string to print as a description before listing the values."
msgstr "第一个非选项参数 @var{desc} 用作为一个字符串，在列出值之前作为描述打印。"

#. type: table
#: zsh.texi:26609
msgid ""
"All other arguments describe the possible values and their arguments in the same format used for the description of options by the @t{_arguments} function (see above).  The only differences are that no "
"minus or plus sign is required at the beginning, values can have only one argument, and the forms of action beginning with an equal sign are not supported."
msgstr "所有其他参数描述可能的值及其参数的格式与 @t{_arguments} 函数描述选项的格式相同（见上文）。 唯一不同的是，开头不需要负号或正号，值只能有一个参数，并且不支持以等号开头的操作形式。"

#. type: table
#: zsh.texi:26615
msgid ""
"The character separating a value from its argument can be set using the option @t{-S} (like @t{-s}, followed by the character to use as the separator in the next argument).  By default the equals sign "
"will be used as the separator between values and arguments."
msgstr "通过选项 @t{-S}（类似于 @t{-s}，后面跟着用作下一个参数分隔符的字符），可以设置字符,将值与其参数分隔开。默认情况下，等号将被用作值和参数之间的分隔符。"

#. type: example
#: zsh.texi:26625
#, no-wrap
msgid ""
"_values -s , 'description' \\ \n"
"        '*foo[bar]' \\ \n"
"        '(two)*one[number]:first count:' \\ \n"
"        'two[another number]::second count:(1 2 3)'\n"
msgstr ""
"_values -s , 'description' \\ \n"
"        '*foo[bar]' \\ \n"
"        '(two)*one[number]:first count:' \\ \n"
"        'two[another number]::second count:(1 2 3)'\n"

#. type: table
#: zsh.texi:26641
msgid ""
"This describes three possible values: `@t{foo}', `@t{one}', and `@t{two}'.  The first is described as `@t{bar}', takes no argument and may appear more than once.  The second is described as `@t{number}', "
"may appear more than once, and takes one mandatory argument described as `@t{first count}'; no action is specified, so it will not be completed.  The `@t{(two)}' at the beginning says that if the value "
"`@t{one}' is on the line, the value `@t{two}' will no longer be considered a possible completion.  Finally, the last value (`@t{two}') is described as `@t{another number}' and takes an optional argument "
"described as `@t{second count}' for which the completions (to appear after an `@t{=}') are `@t{1}', `@t{2}', and `@t{3}'.  The @t{_values} function will complete lists of these values separated by commas."
msgstr ""
"这描述了三种可能的值： `@t{foo}', `@t{one}' 和 `@t{two}'。 第一个值被描述为 `@t{bar}'，不需要参数，可能出现多次。 第二个描述为`@t{number}'，可能出现不止一次，需要一个强制参数，描述为`@t{first count}'；没有"
"指定操作，因此不会补全。 开头的 `@t{(two)}' 表示，如果该行出现了值`@t{one}' ，那么值 `@t{two}' 将不再被视为可能的补全。 最后，最后一个值（`@t{two}'）被描述为 `@t{another number}' ，并接受一个被描述为 "
"`@t{second count}' 的可选参数，其补全（将出现在 `@t{=}' 之后）为 `@t{1}', `@t{2}' 和 `@t{3}'。 @t{_values} 函数将补全由逗号分隔的这些值组成的列表。"

#. type: table
#: zsh.texi:26647
msgid ""
"Like @t{_arguments}, this function temporarily adds another context name component to the arguments element (the fifth) of the current context while executing the @var{action}.  Here this name is just the "
"name of the value for which the argument is completed."
msgstr "与 @t{_arguments}一样，该函数在执行 @var{action} 时也会在当前上下文的参数元素（第五个）中临时添加另一个上下文名称组件。 这里这个名称只是补全参数的值的名称。"

#. type: table
#: zsh.texi:26651
msgid "The style @t{verbose} is used to decide if the descriptions for the values (but not those for the arguments) should be printed."
msgstr "@t{verbose} 样式用于决定是否打印值的说明（但不打印参数的说明）。"

#. type: table
#: zsh.texi:26658
msgid ""
"The associative array @t{val_args} is used to report values and their arguments; this works similarly to the @t{opt_args} associative array used by @t{_arguments}.  Hence the function calling @t{_values} "
"should declare the local parameters @t{state}, @t{state_descr}, @t{line}, @t{context} and @t{val_args}:"
msgstr ""
"关联数组 @t{val_args} 用于报告值及其参数；其工作方式与 @t{_arguments} 使用的 @t{opt_args} 关联数组类似。 因此，调用 @t{_values} 的函数应声明本地参数 @t{state}、@t{state_descr}、@t{line}、@t{context} 和 "
"@t{val_args}："

#. type: example
#: zsh.texi:26663
#, no-wrap
msgid ""
"local context state state_descr line\n"
"typeset -A val_args\n"
msgstr ""
"local context state state_descr line\n"
"typeset -A val_args\n"

#. type: table
#: zsh.texi:26671
msgid ""
"when using an action of the form `@t{->}@var{string}'.  With this function the @t{context} parameter will be set to the name of the value whose argument is to be completed.  Note that for @t{_values}, the "
"@t{state} and @t{state_descr} are scalars rather than arrays.  Only a single matching state is returned."
msgstr ""
"当使用形式为 `@t{->}@var{string}' 的操作时。 使用此函数时，@t{context} 参数将被设置为要补全的值的名称。 请注意，对于 @t{_values}，@t{state} 和 @t{state_descr} 是标量而不是数组。 只会返回一个匹配的状态。"

#. type: table
#: zsh.texi:26681
msgid ""
"Note also that @t{_values} normally adds the character used as the separator between values as an auto-removable suffix (similar to a `@t{/}' after a directory).  However, this is not possible for a `@t{-"
">}@var{string}' action as the matches for the argument are generated by the calling function.  To get the usual behaviour, the calling function can add the separator @var{x} as a suffix by passing the "
"options `@t{-qS} @var{x}' either directly or indirectly to @t{compadd}."
msgstr ""
"还需注意的是，@t{_values} 通常会在值之间添加分隔符，作为自动删除的后缀（类似于目录后的 `@t{/}'）。 但是， `@t{->}@var{string}' 操作不可能这样做，因为参数的匹配是通过调用函数生成的。 要获得通常的行为，调用"
"函数可以通过直接或间接传递选项 `@t{-qS} @var{x}' 给 @t{compadd}，以添加分隔符 @var{x} 作为后缀。"

#. type: table
#: zsh.texi:26686
msgid "The option @t{-C} is treated in the same way as it is by @t{_arguments}.  In that case the parameter @t{curcontext} should be made local instead of @t{context} (as described above)."
msgstr "选项 @t{-C} 的处理方式与 @t{_arguments} 相同。 在这种情况下，应将参数 @t{curcontext} 本地化，而不是 @t{context}（如上所述）。"

#. type: findex
#: zsh.texi:26687
#, no-wrap
msgid "_wanted"
msgstr "_wanted"

#. type: item
#: zsh.texi:26688
#, no-wrap
msgid "@t{_wanted} [ @t{-x} ] [ @t{-C} @var{name} ]  [ @t{-12VJ} ] @var{tag} @var{name} @var{descr} @var{command} [ @var{arg} ...]"
msgstr "@t{_wanted} [ @t{-x} ] [ @t{-C} @var{name} ]  [ @t{-12VJ} ] @var{tag} @var{name} @var{descr} @var{command} [ @var{arg} ...]"

#. type: table
#: zsh.texi:26693
msgid ""
"In many contexts, completion can only generate one particular set of matches, usually corresponding to a single tag.  However, it is still necessary to decide whether the user requires matches of this "
"type.  This function is useful in such a case."
msgstr "在许多情况下，补全只能生成一个特定的匹配集，通常对应于一个标记。 但是，仍有必要确定用户是否需要这种类型的匹配。 在这种情况下，该函数就非常有用。"

#. type: table
#: zsh.texi:26700
msgid ""
"The arguments to @t{_wanted} are the same as those to @t{_requested}, i.e. arguments to be passed to @t{_description}.  However, in this case the @var{command} is not optional; all the processing of tags, "
"including the loop over both tags and tag labels and the generation of matches, is carried out automatically by @t{_wanted}."
msgstr ""
"@t{_wanted} 的参数与 @t{_requested} 的参数相同，即传递给 @t{_description} 的参数。 不过，在这种情况下，@var{command} 并非可选参数；所有的标记处理，包括标记和标记标签上的循环以及匹配结果的生成，都由 "
"@t{_wanted} 自动完成。"

#. type: table
#: zsh.texi:26704
msgid "Hence to offer only one tag and immediately add the corresponding matches with the given description:"
msgstr "因此，只提供一个标记，并立即添加与给定描述相对应的匹配项："

#. type: example
#: zsh.texi:26710
#, no-wrap
msgid ""
"local expl\n"
"_wanted tag expl 'description' \\ \n"
"    compadd -- @var{match1} @var{match2}...\n"
msgstr ""
"local expl\n"
"_wanted tag expl 'description' \\ \n"
"    compadd -- @var{match1} @var{match2}...\n"

#. type: table
#: zsh.texi:26715
msgid "See also the use of @t{_wanted} in the example function in @ref{Dynamic named directories}."
msgstr "另请参阅 @ref{动态命名目录} 示例函数中 @t{_wanted} 的使用。"

#. type: table
#: zsh.texi:26719
msgid "Note that, as for @t{_requested}, the @var{command} must be able to accept options to be passed down to @t{compadd}."
msgstr "需要注意的是，与 @t{_requested} 一样，@var{command} 必须能够接受向 @t{compadd} 传递的选项。"

#. type: table
#: zsh.texi:26724
msgid "Like @t{_tags} this function supports the @t{-C} option to give a different name for the argument context field.  The @t{-x} option has the same meaning as for @t{_description}."
msgstr "与 @t{_tags} 一样，该函数支持 @t{-C} 选项，以便为参数上下文字段赋予不同的名称。 @t{-x} 选项的含义与 @t{_description} 相同。"

#. type: findex
#: zsh.texi:26725
#, no-wrap
msgid "_widgets"
msgstr "_widgets"

#. type: item
#: zsh.texi:26726
#, no-wrap
msgid "@t{_widgets} [ @t{-g} @var{pattern} ]"
msgstr "@t{_widgets} [ @t{-g} @var{pattern} ]"

#. type: table
#: zsh.texi:26731
msgid ""
"This function completes names of zle widgets (see @ref{Zle Widgets}).  The @var{pattern}, if present, is matched against values of the @t{$widgets} special parameter, documented in @ref{The zsh/"
"zleparameter Module}."
msgstr "此函数补全 zle 小部件的名称（参见 @ref{Zle 小部件}）。 如果存在 @var{pattern}，则将与 @t{$widgets} 特殊参数的值进行匹配，该特殊参数在 @ref{zsh/zleparameter 模块} 中进行了记录。"

#. type: cindex
#: zsh.texi:26739
#, no-wrap
msgid "completion system, variables"
msgstr "补全系统, 变量"

#. type: Plain text
#: zsh.texi:26744
msgid "There are some standard variables, initialised by the @t{_main_complete} function and then used from other functions."
msgstr "有一些标准变量，由 @t{_main_complete} 函数初始化，然后在其他函数中使用。"

#. type: Plain text
#: zsh.texi:26747
msgid "The standard variables are:"
msgstr "标准变量是："

#. type: t{#1}
#: zsh.texi:26750
#, no-wrap
msgid "_comp_caller_options"
msgstr "_comp_caller_options"

#. type: table
#: zsh.texi:26758
msgid ""
"The completion system uses @t{setopt} to set a number of options. This allows functions to be written without concern for compatibility with every possible combination of user options. However, sometimes "
"completion needs to know what the user's option preferences are. These are saved in the @t{_comp_caller_options} associative array. Option names, spelled in lowercase without underscores, are mapped to "
"one or other of the strings `@t{on}' and `@t{off}'."
msgstr ""
"补全系统使用 @t{setopt} 来设置一系列选项。这样，在编写函数时就无需考虑是否与所有可能的用户选项组合兼容。不过，有时补全需要知道用户的选项偏好。这些选项保存在 @t{_comp_caller_options} 关联数组中。选项名称以"
"小写字母拼写，不含下划线，并映射到字符串 `@t{on}' 和 `@t{off}' 中的一个或多个。"

#. type: t{#1}
#: zsh.texi:26759
#, no-wrap
msgid "_comp_priv_prefix"
msgstr "_comp_priv_prefix"

#. type: table
#: zsh.texi:26763
msgid ""
"Completion functions such as @t{_sudo} can set the @t{_comp_priv_prefix} array to a command prefix that may then be used by @t{_call_program} to match the privileges when calling programs to generate "
"matches."
msgstr "@t{_sudo} 等补全函数可将 @t{_comp_priv_prefix} 数组设置为命令前缀，然后 @t{_call_program} 在调用程序时可使用该命令前缀来匹配权限，从而生成匹配结果。"

#. type: vindex
#: zsh.texi:26767
#, no-wrap
msgid "compprefuncs, use of"
msgstr "compprefuncs, use of"

#. type: vindex
#: zsh.texi:26768
#, no-wrap
msgid "comppostfuncs, use of"
msgstr "comppostfuncs, use of"

#. type: Plain text
#: zsh.texi:26774
msgid ""
"Two more features are offered by the @t{_main_complete} function.  The arrays @t{compprefuncs} and @t{comppostfuncs} may contain names of functions that are to be called immediately before or after "
"completion has been tried.  A function will only be called once unless it explicitly reinserts itself into the array."
msgstr "@t{_main_complete} 函数还提供了另外两个功能。 数组 @t{compprefuncs} 和 @t{comppostfuncs} 可以包含在尝试补全之前或之后要立即调用的函数名称。 除非函数明确重新插入数组，否则只会被调用一次。"

#. type: cindex
#: zsh.texi:26780
#, no-wrap
msgid "completion system, directory structure"
msgstr "补全系统, 目录结构"

#. type: Plain text
#: zsh.texi:26790
msgid ""
"In the source distribution, the files are contained in various subdirectories of the @t{Completion} directory.  They may have been installed in the same structure, or into one single function directory.  "
"The following is a description of the files found in the original directory structure.  If you wish to alter an installed file, you will need to copy it to some directory which appears earlier in your "
"@t{fpath} than the standard directory where it appears."
msgstr ""
"在源代码发布版中，这些文件包含在 @t{Completion} 目录的各个子目录中。 这些文件可能安装在同一结构中，也可能安装在同一个函数目录中。 以下是原始目录结构中文件的说明。 如果要修改已安装的文件，需要将其复制到 "
"@t{fpath} 中比标准目录更靠前的目录。"

#. type: t{#1}
#: zsh.texi:26793
#, no-wrap
msgid "Base"
msgstr "Base"

#. type: table
#: zsh.texi:26797
msgid ""
"The core functions and special completion widgets automatically bound to keys.  You will certainly need most of these, though will probably not need to alter them.  Many of these are documented above."
msgstr "核心函数和特殊补全小部件会自动绑定到按键上。 您肯定会用到其中的大部分，但可能不需要对它们进行修改。 其中许多已在上文记录。"

#. type: t{#1}
#: zsh.texi:26798
#, no-wrap
msgid "Zsh"
msgstr "Zsh"

#. type: table
#: zsh.texi:26802
msgid "Functions for completing arguments of shell builtin commands and utility functions for this.  Some of these are also used by functions from the @t{Unix} directory."
msgstr "用于补全 shell 内置命令参数的函数，以及用于此的实用函数。 @t{Unix} 目录中的函数也会使用其中的一些函数。"

#. type: t{#1}
#: zsh.texi:26803
#, no-wrap
msgid "Unix"
msgstr "Unix"

#. type: table
#: zsh.texi:26811
msgid ""
"Functions for completing arguments of external commands and suites of commands.  They may need modifying for your system, although in many cases some attempt is made to decide which version of a command "
"is present.  For example, completion for the @t{mount} command tries to determine the system it is running on, while completion for many other utilities try to decide whether the GNU version of the "
"command is in use, and hence whether the @t{-}@t{-help} option is supported."
msgstr ""
"用于补全外部命令和命令集参数的函数。 这些函数可能需要针对系统进行修改，不过在许多情况下，它们会尝试判断命令的版本。 例如，@t{mount} 命令的补全会尝试确定该命令所运行的系统，而许多其他实用程序的补全则会尝试"
"确定该命令是否使用了 GNU 版本，从而确定是否支持 @t{-}@t{-help} 选项。"

#. type: item
#: zsh.texi:26812
#, no-wrap
msgid "@t{X}, @t{AIX}, @t{BSD}, ..."
msgstr "@t{X}, @t{AIX}, @t{BSD}, ..."

#. type: table
#: zsh.texi:26817
msgid ""
"Completion and utility function for commands available only on some systems.  These are not arranged hierarchically, so, for example, both the @t{Linux} and @t{Debian} directories, as well as the @t{X} "
"directory, may be useful on your system."
msgstr "补全和实用函数，用于仅在某些系统上可用的命令。 这些目录并不是按层次排列的，因此，例如 @t{Linux} 和 @t{Debian} 目录以及 @t{X} 目录都可能对你的系统有用。"

#. type: section
#: zsh.texi:26828
#, no-wrap
msgid "Types of completion"
msgstr "补全的类型"

#. type: Plain text
#: zsh.texi:26836
msgid ""
"This version of zsh has two ways of performing completion of words on the command line.  New users of the shell may prefer to use the newer and more powerful system based on shell functions; this is "
"described in @ref{Completion System}, and the basic shell mechanisms which support it are described in @ref{Completion Widgets}.  This chapter describes the older @t{compctl} command."
msgstr ""
"此版本的 zsh 有两种方法来补全命令行上的单词。 shell 的新用户可能更倾向于使用基于 shell 函数的更新、更强大的系统；@ref{补全系统}将对此进行介绍，而支持该系统的基本 shell 机制将在 @ref{ 补全小部件}中进行介"
"绍。 本章将介绍较旧的 @t{compctl} 命令。"

#. type: item
#: zsh.texi:26842
#, no-wrap
msgid "@t{compctl} [ @t{-CDT} ] @var{options} [ @var{command} ... ]"
msgstr "@t{compctl} [ @t{-CDT} ] @var{options} [ @var{command} ... ]"

#. type: item
#: zsh.texi:26843 zsh.texi:27454
#, no-wrap
msgid "@t{compctl }[ @t{-CDT} ] @var{options} [ @t{-x} @var{pattern} @var{options} @t{-} ... @t{-}@t{-} ]"
msgstr "@t{compctl }[ @t{-CDT} ] @var{options} [ @t{-x} @var{pattern} @var{options} @t{-} ... @t{-}@t{-} ]"

#. type: item
#: zsh.texi:26844 zsh.texi:27455
#, no-wrap
msgid "@t{@ @ @ @ @ @ @ @ }[ @t{+} @var{options} [ @t{-x} ... @t{-}@t{-} ] ... [@t{+}] ] [ @var{command} ... ]"
msgstr "@t{@ @ @ @ @ @ @ @ }[ @t{+} @var{options} [ @t{-x} ... @t{-}@t{-} ] ... [@t{+}] ] [ @var{command} ... ]"

#. type: item
#: zsh.texi:26845
#, no-wrap
msgid "@t{compctl} @t{-M} @var{match-specs} ..."
msgstr "@t{compctl} @t{-M} @var{match-specs} ..."

#. type: item
#: zsh.texi:26846
#, no-wrap
msgid "@t{compctl} @t{-L} [ @t{-CDTM} ] [ @var{command} ... ]"
msgstr "@t{compctl} @t{-L} [ @t{-CDTM} ] [ @var{command} ... ]"

#. type: item
#: zsh.texi:26847
#, no-wrap
msgid "@t{compctl} @t{+} @var{command} ..."
msgstr "@t{compctl} @t{+} @var{command} ..."

#. type: Plain text
#: zsh.texi:26861
msgid ""
"Control the editor's completion behavior according to the supplied set of @var{options}.  Various editing commands, notably @t{expand-or-complete-word}, usually bound to tab, will attempt to complete a "
"word typed by the user, while others, notably @t{delete-char-or-list}, usually bound to ^D in EMACS editing mode, list the possibilities; @t{compctl} controls what those possibilities are.  They may for "
"example be filenames (the most common case, and hence the default), shell variables, or words from a user-specified list."
msgstr ""
"根据提供的 @var{options} 集来控制编辑器的补全行为。 各种编辑命令，特别是通常与 tab 绑定的 @t{expand-or-complete-word}，会尝试补全用户键入的单词，而其他命令，特别是在 EMACS 编辑模式下通常与 ^D 绑定的 "
"@t{delete-char-or-list}，则会列出各种可能性；@t{compctl} 控制这些可能性是什么。 例如，它们可以是文件名（最常见的情况，因此也是默认情况）、shell 变量或用户指定列表中的单词。"

#. type: node
#: zsh.texi:26870 zsh.texi:26872 zsh.texi:26980
#, no-wrap
msgid "Command Flags"
msgstr "命令标志"

#. type: node
#: zsh.texi:26870 zsh.texi:26980 zsh.texi:26982 zsh.texi:27009 zsh.texi:27110 zsh.texi:27193 zsh.texi:27421
#, no-wrap
msgid "Option Flags"
msgstr "选项标志"

#. type: Plain text
#: zsh.texi:26880
msgid ""
"Completion of the arguments of a command may be different for each command or may use the default.  The behavior when completing the command word itself may also be separately specified.  These correspond "
"to the following flags and arguments, all of which (except for @t{-L}) may be combined with any combination of the @var{options} described subsequently in @ref{Option Flags}:"
msgstr ""
"命令参数的补全可以因命令而异，也可以使用默认值。补全命令字本身时的行为也可以单独指定。 这些与下列标志和参数相对应，所有这些标志和参数（@t{-L}除外）都可以与随后在 @ref{选项标志} 中描述的 @var{options} 的任"
"意组合结合使用："

#. type: item
#: zsh.texi:26883
#, no-wrap
msgid "@var{command} ..."
msgstr "@var{command} ..."

#. type: table
#: zsh.texi:26889
msgid ""
"controls completion for the named commands, which must be listed last on the command line.  If completion is attempted for a command with a pathname containing slashes and no completion definition is "
"found, the search is retried with the last pathname component. If the command starts with a @t{=}, completion is tried with the pathname of the command."
msgstr "控制已命名命令的补全，这些命令必须列在命令行的最后。 如果对路径名包含斜线的命令尝试补全，但未找到补全定义，则使用最后一个路径名组件重试搜索。如果命令以 @t{=} 开头，则以命令的路径名尝试补全。"

#. type: table
#: zsh.texi:26901
msgid ""
"Any of the @var{command} strings may be patterns of the form normally used for filename generation.  These should be quoted to protect them from immediate expansion; for example the command string "
"@t{'foo*'} arranges for completion of the words of any command beginning with @t{foo}.  When completion is attempted, all pattern completions are tried in the reverse order of their definition until one "
"matches.  By default, completion then proceeds as normal, i.e. the shell will try to generate more matches for the specific command on the command line; this can be overridden by including @t{-tn} in the "
"flags for the pattern completion."
msgstr ""
"任何 @var{command} 字符串都可以是通常用于生成文件名的模式。这些命令应加引号，以防止被立即扩展；  例如，命令字符串 @t{'foo*'} 用于补全以 @t{foo} 开头的命令。 在尝试补全时，所有模式的补全都会按其定义的相反顺"
"序进行，直到有一个匹配为止。 默认情况下，补全将按正常方式进行，即 shell 将尝试为命令行上的特定命令生成更多匹配项；可以通过在模式补全的标志中包含 @t{-tn} 来覆盖该操作。"

#. type: table
#: zsh.texi:26907
msgid "Note that aliases are expanded before the command name is determined unless the @t{COMPLETE_ALIASES} option is set.  Commands may not be combined with the @t{-C}, @t{-D} or @t{-T} flags."
msgstr "请注意，除非设置了 @t{COMPLETE_ALIASES} 选项，否则别名会在确定命令名之前展开。 命令不得与 @t{-C}、@t{-D} 或 @t{-T} 标志结合使用。"

#. type: table
#: zsh.texi:26913
msgid ""
"controls completion when the command word itself is being completed.  If no @t{compctl -C} command has been issued, the names of any executable command (whether in the path or specific to the shell, such "
"as aliases or functions) are completed."
msgstr "在命令字本身正在补全时控制补全。 如果没有发出 @t{compctl -C} 命令，则会补全任何可执行命令的名称（无论是路径中的还是 shell 特有的，如别名或函数）。"

#. type: table
#: zsh.texi:26918
msgid "controls default completion behavior for the arguments of commands not assigned any special behavior.  If no @t{compctl -D} command has been issued, filenames are completed."
msgstr "控制未指定特殊行为的命令参数的默认补全行为。 如果没有发出 @t{compctl -D} 命令，文件名将被补全。"

#. type: table
#: zsh.texi:26929
msgid ""
"supplies completion flags to be used before any other processing is done, even before processing for @t{compctl}s defined for specific commands.  This is especially useful when combined with extended "
"completion (the @t{-x} flag, see @ref{Extended Completion} below).  Using this flag you can define default behavior which will apply to all commands without exception, or you can alter the standard "
"behavior for all commands.  For example, if your access to the user database is too slow and/or it contains too many users (so that completion after `@t{~}' is too slow to be usable), you can use"
msgstr ""
"提供补全标志，在进行其他处理之前使用，甚至在处理为特定命令定义的 @t{compctl}s 之前使用。 当与扩展补全（@t{-x} 标志，见下文 @ref{扩展补全}）结合使用时，这一点尤其有用。 使用该标志，你可以定义适用于所有命令"
"的默认行为，或者改变所有命令的标准行为。 例如，如果访问用户数据库的速度太慢和/或数据库中包含的用户太多（因此 `@t{~}' 后的补全速度太慢，无法使用），可以使用"

#. type: example
#: zsh.texi:26933
#, no-wrap
msgid "compctl -T -x 's[~] C[0,[^/]#]' -k friends -S/ -tn\n"
msgstr "compctl -T -x 's[~] C[0,[^/]#]' -k friends -S/ -tn\n"

#. type: table
#: zsh.texi:26940
msgid ""
"to complete the strings in the array @t{friends} after a `@t{~}'.  The @t{C[}@var{...}@t{]} argument is necessary so that this form of @t{~}-completion is not tried after the directory name is finished."
msgstr "以在 `@t{~}' 之后补全数组 @t{friends} 中的字符串。 @t{C[}@var{...}@t{]} 参数是必要的，这样, @t{~}-补全，这种形式就不会在目录名完成后再尝试。"

#. type: table
#: zsh.texi:26947
msgid ""
"lists the existing completion behavior in a manner suitable for putting into a start-up script; the existing behavior is not changed.  Any combination of the above forms, or the @t{-M} flag (which must "
"follow the @t{-L} flag), may be specified, otherwise all defined completions are listed.  Any other flags supplied are ignored."
msgstr "以适合放入启动脚本的方式列出现有的补全行为；现有行为不会改变。 可以指定上述形式的任意组合,或指定 @t{-M} 标志（必须在 @t{-L} 标志之后），否则将列出所有已定义的补全。 其他任何标志都将被忽略。"

#. type: emph{#1}
#: zsh.texi:26948
#, no-wrap
msgid "no argument"
msgstr "没有参数"

#. type: table
#: zsh.texi:26952
msgid ""
"If no argument is given, @t{compctl} lists all defined completions in an abbreviated form; with a list of @var{options}, all completions with those flags set (not counting extended completion) are listed."
msgstr "如果没有给出参数，@t{compctl} 会以缩写形式列出所有已定义的补全；如果给出 @var{options} 的列表，则会列出所有设置了这些标志集的补全（不包括扩展补全）。"

#. type: Plain text
#: zsh.texi:26960
msgid ""
"If the @t{+} flag is alone and followed immediately by the @var{command} list, the completion behavior for all the commands in the list is reset to the default.  In other words, completion will "
"subsequently use the options specified by the @t{-D} flag."
msgstr "如果只使用 @t{+} 标志，且紧接着使用 @var{command} 列表，则列表中所有命令的补全行为都将重置为默认。 换句话说，补全随后将使用 @t{-D} 标志指定的选项。"

#. type: Plain text
#: zsh.texi:26968
msgid ""
"The form with @t{-M} as the first and only option defines global matching specifications (see @ref{Completion Matching Control}). The match specifications given will be used for every completion attempt "
"(only when using @t{compctl}, not with the new completion system) and are tried in the order in which they are defined until one generates at least one match. E.g.:"
msgstr ""
"以 @t{-M} 为第一个也是唯一选项的形式定义了全局匹配规范（参见 @ref{补全匹配控制}）。所给出的匹配规范将用于每次补全尝试（仅在使用 @t{compctl} 时，新补全系统不使用），并按照定义的顺序进行尝试，直到产生至少一"
"个匹配。例如"

#. type: example
#: zsh.texi:26972
#, no-wrap
msgid "compctl -M @value{dsq} 'm:@{a-zA-Z@}=@{A-Za-z@}'\n"
msgstr "compctl -M @value{dsq} 'm:@{a-zA-Z@}=@{A-Za-z@}'\n"

#. type: Plain text
#: zsh.texi:26978
msgid "This will first try completion without any global match specifications (the empty string) and, if that generates no matches, will try case insensitive completion."
msgstr "这将先尝试不包含任何全局匹配规范（空字符串）的补全，如果没有匹配结果，将尝试不区分大小写的补全。"

#. type: node
#: zsh.texi:26980 zsh.texi:27421 zsh.texi:27423 zsh.texi:27440
#, no-wrap
msgid "Alternative Completion"
msgstr "备选补全"

#. type: item
#: zsh.texi:26985
#, no-wrap
msgid "[ @t{-fcFBdeaRGovNAIOPZEnbjrzu/12} ]"
msgstr "[ @t{-fcFBdeaRGovNAIOPZEnbjrzu/12} ]"

#. type: item
#: zsh.texi:26986
#, no-wrap
msgid "[ @t{-k} @var{array} ] [ @t{-g} @var{globstring} ] [ @t{-s} @var{subststring} ]"
msgstr "[ @t{-k} @var{array} ] [ @t{-g} @var{globstring} ] [ @t{-s} @var{subststring} ]"

#. type: item
#: zsh.texi:26987
#, no-wrap
msgid "[ @t{-K} @var{function} ]"
msgstr "[ @t{-K} @var{function} ]"

#. type: item
#: zsh.texi:26988
#, no-wrap
msgid "[ @t{-Q} ] [ @t{-P} @var{prefix} ] [ @t{-S} @var{suffix} ]"
msgstr "[ @t{-Q} ] [ @t{-P} @var{prefix} ] [ @t{-S} @var{suffix} ]"

#. type: item
#: zsh.texi:26989
#, no-wrap
msgid "[ @t{-W} @var{file-prefix} ] [ @t{-H} @var{num pattern} ]"
msgstr "[ @t{-W} @var{file-prefix} ] [ @t{-H} @var{num pattern} ]"

#. type: item
#: zsh.texi:26990
#, no-wrap
msgid "[ @t{-q} ] [ @t{-X} @var{explanation} ] [ @t{-Y} @var{explanation} ]"
msgstr "[ @t{-q} ] [ @t{-X} @var{explanation} ] [ @t{-Y} @var{explanation} ]"

#. type: item
#: zsh.texi:26991
#, no-wrap
msgid "[ @t{-y} @var{func-or-var} ] [ @t{-l} @var{cmd} ] [ @t{-h} @var{cmd} ] [ @t{-U} ]"
msgstr "[ @t{-y} @var{func-or-var} ] [ @t{-l} @var{cmd} ] [ @t{-h} @var{cmd} ] [ @t{-U} ]"

#. type: item
#: zsh.texi:26992
#, no-wrap
msgid "[ @t{-t} @var{continue} ] [ @t{-J} @var{name} ] [ @t{-V} @var{name} ]"
msgstr "[ @t{-t} @var{continue} ] [ @t{-J} @var{name} ] [ @t{-V} @var{name} ]"

#. type: item
#: zsh.texi:26993
#, no-wrap
msgid "[ @t{-M} @var{match-spec} ]"
msgstr "[ @t{-M} @var{match-spec} ]"

#. type: Plain text
#: zsh.texi:27002
msgid ""
"The remaining @var{options} specify the type of command arguments to look for during completion.  Any combination of these flags may be specified; the result is a sorted list of all the possibilities.  "
"The options are as follows."
msgstr "其余的 @var{options} 则指定在补全过程中要查找的命令参数类型。 可以指定这些标志的任意组合；结果是一个包含所有可能性的排序列表。 选项如下。"

#. type: menuentry
#: zsh.texi:27006
msgid "Simple Flags::"
msgstr "简单标志::"

#. type: menuentry
#: zsh.texi:27006
msgid "Flags with Arguments::"
msgstr "带参数的标志::"

#. type: subsection
#: zsh.texi:27006 zsh.texi:27110 zsh.texi:27193 zsh.texi:27195
#, no-wrap
msgid "Control Flags"
msgstr "控制标志"

#. type: node
#: zsh.texi:27009 zsh.texi:27011 zsh.texi:27110
#, no-wrap
msgid "Simple Flags"
msgstr "简单标志"

#. type: node
#: zsh.texi:27009 zsh.texi:27110 zsh.texi:27112 zsh.texi:27193
#, no-wrap
msgid "Flags with Arguments"
msgstr "带参数的标志"

#. type: Plain text
#: zsh.texi:27014
msgid "These produce completion lists made up by the shell itself:"
msgstr "这将产生由 shell 本身编制的补全列表："

#. type: table
#: zsh.texi:27019
msgid "Filenames and file system paths."
msgstr "文件名和文件系统路径。"

#. type: table
#: zsh.texi:27022
msgid "Just file system paths."
msgstr "只是文件系统路径。"

#. type: table
#: zsh.texi:27026
msgid "Command names, including aliases, shell functions, builtins and reserved words."
msgstr "命令名称，包括别名、shell 函数、内置命令和保留字。"

#. type: table
#: zsh.texi:27029
msgid "Function names."
msgstr "函数名。"

#. type: table
#: zsh.texi:27032
msgid "Names of builtin commands."
msgstr "内置命令名。"

#. type: table
#: zsh.texi:27035
msgid "Names of external commands."
msgstr "外部命令名。"

#. type: table
#: zsh.texi:27038
msgid "Reserved words."
msgstr "保留字。"

#. type: table
#: zsh.texi:27041
msgid "Alias names."
msgstr "别名。"

#. type: table
#: zsh.texi:27044
msgid "Names of regular (non-global) aliases."
msgstr "普通（非全局）别名。"

#. type: table
#: zsh.texi:27047
msgid "Names of global aliases."
msgstr "全局别名。"

#. type: table
#: zsh.texi:27052
msgid "This can be combined with @t{-F}, @t{-B}, @t{-w}, @t{-a}, @t{-R} and @t{-G} to get names of disabled functions, builtins, reserved words or aliases."
msgstr "可与 @t{-F}、@t{-B}、@t{-w}、@t{-a}、@t{-R} 和 @t{-G} 结合使用，以获取禁用的函数、内置命令、保留字或别名的名称。"

#. type: table
#: zsh.texi:27059
msgid ""
"This option (to show enabled commands) is in effect by default, but may be combined with @t{-d}; @t{-de} in combination with @t{-F}, @t{-B}, @t{-w}, @t{-a}, @t{-R} and @t{-G} will complete names of "
"functions, builtins, reserved words or aliases whether or not they are disabled."
msgstr "该选项（显示已启用的命令）默认有效，但可与 @t{-d} 结合使用；@t{-de} 与 @t{-F}、@t{-B}、@t{-w}、@t{-a}、@t{-R} 和 @t{-G} 结合使用时，将补全函数、内置程序、保留字或别名的名称，无论它们是否被禁用。"

#. type: table
#: zsh.texi:27063
msgid "Names of shell options (see @ref{Options})."
msgstr "shell 选项的名称（参见 @ref{选项}）。"

#. type: table
#: zsh.texi:27066
msgid "Names of any variable defined in the shell."
msgstr "shell 中定义的任何变量的名称。"

#. type: table
#: zsh.texi:27069
msgid "Names of scalar (non-array) parameters."
msgstr "标量（非数组）参数的名称。"

#. type: table
#: zsh.texi:27072
msgid "Array names."
msgstr "数组名。"

#. type: table
#: zsh.texi:27075
msgid "Names of integer variables."
msgstr "整型变量名。"

#. type: table
#: zsh.texi:27078
msgid "Names of read-only variables."
msgstr "只读变量名。"

#. type: table
#: zsh.texi:27081
msgid "Names of parameters used by the shell (including special parameters)."
msgstr "shell 使用的参数名称（包括特殊参数）。"

#. type: table
#: zsh.texi:27084
msgid "Names of shell special parameters."
msgstr "shell 特殊参数名。"

#. type: table
#: zsh.texi:27087
msgid "Names of environment variables."
msgstr "环境变量名。"

#. type: table
#: zsh.texi:27090
msgid "Named directories."
msgstr "命名的目录。"

#. type: table
#: zsh.texi:27093
msgid "Key binding names."
msgstr "键绑定名。"

#. type: t{#1}
#: zsh.texi:27094
#, no-wrap
msgid "-j"
msgstr "-j"

#. type: table
#: zsh.texi:27097
msgid "Job names: the first word of the job leader's command line.  This is useful with the @t{kill} builtin."
msgstr "作业名称：作业负责人(job leader's)命令行的第一个单词。 这对 @t{kill} 内置程序很有用。"

#. type: table
#: zsh.texi:27100
msgid "Names of running jobs."
msgstr "运行中作业的名称。"

#. type: table
#: zsh.texi:27103
msgid "Names of suspended jobs."
msgstr "暂停作业的名称。"

#. type: table
#: zsh.texi:27106
msgid "User names."
msgstr "用户名。"

#. type: Plain text
#: zsh.texi:27116
msgid "These have user supplied arguments to determine how the list of completions is to be made up:"
msgstr "这些参数由用户提供，用于确定如何组成补全列表："

#. type: item
#: zsh.texi:27119
#, no-wrap
msgid "@t{-k} @var{array}"
msgstr "@t{-k} @var{array}"

#. type: table
#: zsh.texi:27126
msgid ""
"Names taken from the elements of @t{$}@var{array} (note that the `@t{$}' does not appear on the command line).  Alternatively, the argument @var{array} itself may be a set of space- or comma-separated "
"values in parentheses, in which any delimiter may be escaped with a backslash; in this case the argument should be quoted.  For example,"
msgstr ""
"取自 @t{$}@var{array} 元素的名称（注意， `@t{$}' 不会出现在命令行中）。 或者，参数 @var{array} 本身可以是一个用空格或逗号分隔的值的集，放在括号中，其中的任何分隔符都可以用反斜杠转义；在这种情况下，参数应加"
"引号。 例如，"

#. type: example
#: zsh.texi:27131
#, no-wrap
msgid ""
"compctl -k \"(cputime filesize datasize stacksize\n"
"\t       coredumpsize resident descriptors)\" limit\n"
msgstr ""
"compctl -k \"(cputime filesize datasize stacksize\n"
"\t       coredumpsize resident descriptors)\" limit\n"

#. type: item
#: zsh.texi:27133
#, no-wrap
msgid "@t{-g} @var{globstring}"
msgstr "@t{-g} @var{globstring}"

#. type: table
#: zsh.texi:27141
msgid ""
"The @var{globstring} is expanded using filename globbing; it should be quoted to protect it from immediate expansion. The resulting filenames are taken as the possible completions.  Use `@t{*(/)}' instead "
"of `@t{*/}' for directories.  The @t{fignore} special parameter is not applied to the resulting files.  More than one pattern may be given separated by blanks. (Note that brace expansion is @emph{not} "
"part of globbing.  Use the syntax `@t{(either|or)}' to match alternatives.)"
msgstr ""
"@var{globstring} 使用文件名 globbing 扩展；应加引号以防止立即扩展。生成的文件名将作为可能的补全。 对于目录，请使用 `@t{*(/)}' 而不是 `@t{*/}' 。 @t{fignore} 特殊参数不适用于生成的文件。 可以使用空格分隔多"
"个模式。(请注意，括号扩展 @emph{不是} globbing 的一部分。 使用语法 `@t{(either|or)}' 可以匹配其他模式）。"

#. type: item
#: zsh.texi:27142
#, no-wrap
msgid "@t{-s} @var{subststring}"
msgstr "@t{-s} @var{subststring}"

#. type: table
#: zsh.texi:27148
msgid ""
"The @var{subststring} is split into words and these words are than expanded using all shell expansion mechanisms (see @ref{Expansion}).  The resulting words are taken as possible completions.  The "
"@t{fignore} special parameter is not applied to the resulting files.  Note that @t{-g} is faster for filenames."
msgstr ""
"@var{subststring} 会被分割成单词，然后使用所有 shell 扩展机制（参见 @ref{扩展}）对这些单词进行扩展。 生成的单词将作为可能的补全。 @t{fignore} 特殊参数不会应用于生成文件。 请注意，@t{-g} 对文件名的处理速度"
"更快。"

#. type: item
#: zsh.texi:27149
#, no-wrap
msgid "@t{-K} @var{function}"
msgstr "@t{-K} @var{function}"

#. type: table
#: zsh.texi:27163
msgid ""
"Call the given function to get the completions.  Unless the name starts with an underscore, the function is passed two arguments: the prefix and the suffix of the word on which completion is to be "
"attempted, in other words those characters before the cursor position, and those from the cursor position onwards.  The whole command line can be accessed with the @t{-c} and @t{-l} flags of the @t{read} "
"builtin. The function should set the variable @t{reply} to an array containing the completions (one completion per element); note that @t{reply} should not be made local to the function.  From such a "
"function the command line can be accessed with the @t{-c} and @t{-l} flags to the @t{read} builtin.  For example,"
msgstr ""
"调用给定函数获取补全。 除非函数名以下划线开头，否则函数会传入两个参数：要补全的单词的前缀和后缀，换句话说，就是光标位置之前的字符和光标位置之后的字符。 可以使用 @t{read} 内置函数的 @t{-c} 和 @t{-l} 标志访"
"问整个命令行。函数应将变量 @t{reply} 设置为包含补全信息的数组（每个元素一个补全信息）；注意 @t{reply} 不应设置为函数的局部变量。 在这样的函数中，可以使用 @t{read} 内置函数的 @t{-c} 和 @t{-l} 标志访问的命令"
"行。 例如，"

#. type: example
#: zsh.texi:27168
#, no-wrap
msgid ""
"function whoson @{ reply=(`users`); @}\n"
"compctl -K whoson talk\n"
msgstr ""
"function whoson @{ reply=(`users`); @}\n"
"compctl -K whoson talk\n"

#. type: table
#: zsh.texi:27173
msgid "completes only logged-on users after `@t{talk}'.  Note that `@t{whoson}' must return an array, so `@t{reply=`users`}' would be incorrect."
msgstr "在 `@t{talk}' 后只补全的登录用户。 请注意， `@t{whoson}' 必须返回一个数组，因此 `@t{reply=`users`}' 是不正确的。"

#. type: item
#: zsh.texi:27174
#, no-wrap
msgid "@t{-H} @var{num pattern}"
msgstr "@t{-H} @var{num pattern}"

#. type: table
#: zsh.texi:27180
msgid ""
"The possible completions are taken from the last @var{num} history lines.  Only words matching @var{pattern} are taken.  If @var{num} is zero or negative the whole history is searched and if @var{pattern} "
"is the empty string all words are taken (as with `@t{*}').  A typical use is"
msgstr ""
"可能的补全取自最后 @var{num} 行历史。 只有与 @var{pattern} 匹配的单词才会被选中。 如果 @var{num} 为零或负数，则搜索整个历史记录；如果 @var{pattern} 为空字符串，则搜索所有单词（如 `@t{*}'）。 典型的用法是"

#. type: example
#: zsh.texi:27184
#, no-wrap
msgid "compctl -D -f + -H 0 @value{dsq}\n"
msgstr "compctl -D -f + -H 0 @value{dsq}\n"

#. type: table
#: zsh.texi:27189
msgid "which forces completion to look back in the history list for a word if no filename matches."
msgstr "如果没有匹配的文件名，则强制补全功能在历史列表中查找单词。"

#. type: Plain text
#: zsh.texi:27199
msgid "These do not directly specify types of name to be completed, but manipulate the options that do:"
msgstr "这些选项并不直接指定要补全的名称的类型，而是对指定类型的选项进行操作："

#. type: table
#: zsh.texi:27211
msgid ""
"This instructs the shell not to quote any metacharacters in the possible completions.  Normally the results of a completion are inserted into the command line with any metacharacters quoted so that they "
"are interpreted as normal characters.  This is appropriate for filenames and ordinary strings.  However, for special effects, such as inserting a backquoted expression from a completion array (@t{-k}) so "
"that the expression will not be evaluated until the complete line is executed, this option must be used."
msgstr ""
"这将指示 shell 在可能的补全中不任何元字符加引号。 通常情况下，补全的结果会被插入命令行中，其中的元字符会被加引号，因此会被解释为普通字符。 这适合文件名和普通字符串。 但是，为了达到特殊效果，例如从补全数组"
"（@t{-k}）中插入反引号表达式，以便在执行完整行之前不对表达式进行求值，则必须使用该选项。"

#. type: table
#: zsh.texi:27216
msgid "The @var{prefix} is inserted just before the completed string; any initial part already typed will be completed and the whole @var{prefix} ignored for completion purposes.  For example,"
msgstr "@var{prefix} 插入到已补全的字符串之前；任何已键入的开头部分都将被补全，而整个 @var{prefix} 将被忽略，以达到补全的目的。 例如，"

#. type: example
#: zsh.texi:27220
#, no-wrap
msgid "compctl -j -P \"%\" kill\n"
msgstr "compctl -j -P \"%\" kill\n"

#. type: table
#: zsh.texi:27224
msgid "inserts a `%' after the kill command and then completes job names."
msgstr "会在删除命令后插入一个 `%'，然后补全作业名称。"

#. type: table
#: zsh.texi:27230
msgid ""
"When a completion is found the @var{suffix} is inserted after the completed string.  In the case of menu completion the suffix is inserted immediately, but it is still possible to cycle through the list "
"of completions by repeatedly hitting the same key."
msgstr "当找到补全时，@var{suffix} 会插入到补全的字符串之后。 在菜单补全的情况下，后缀会立即插入，但仍可以通过重复按同一按键来循环浏览补全列表。"

#. type: table
#: zsh.texi:27235
msgid ""
"With directory @var{file-prefix}: for command, file, directory and globbing completion (options @t{-c}, @t{-f}, @t{-/}, @t{-g}), the file prefix is implicitly added in front of the completion.  For "
"example,"
msgstr "使用目录 @var{file-prefix}：对于命令、文件、目录和 globbing 补全（选项 @t{-c}、@t{-f}、@t{-/}、@t{-g}），会在补全前面隐式添加文件前缀。 例如,"

#. type: example
#: zsh.texi:27239
#, no-wrap
msgid "compctl -/ -W ~/Mail maildirs\n"
msgstr "compctl -/ -W ~/Mail maildirs\n"

#. type: table
#: zsh.texi:27248
msgid ""
"completes any subdirectories to any depth beneath the directory @t{~/Mail}, although that prefix does not appear on the command line.  The @var{file-prefix} may also be of the form accepted by the @t{-k} "
"flag, i.e. the name of an array or a literal list in parenthesis. In this case all the directories in the list will be searched for possible completions."
msgstr ""
"补全目录 @t{~/Mail} 下任意深度的任何子目录，尽管该前缀不会出现在命令行中。 @var{file-prefix} 也可以是 @t{-k} 标志所接受的形式，即数组名称或括号中的字面列表。在这种情况下，将搜索列表中的所有目录，以查找可能"
"的补全。"

#. type: table
#: zsh.texi:27256
msgid ""
"If used with a suffix as specified by the @t{-S} option, this causes the suffix to be removed if the next character typed is a blank or does not insert anything or if the suffix consists of only one "
"character and the next character typed is the same character; this the same rule used for the @t{AUTO_REMOVE_SLASH} option.  The option is most useful for list separators (comma, colon, etc.)."
msgstr ""
"如果与 @t{-S} 选项指定的后缀一起使用，则在下一个键入的字符为空白或未插入任何内容时，或在后缀仅由一个字符组成且下一个键入的字符为相同字符时，后缀将被移除；这与 @t{AUTO_REMOVE_SLASH} 选项的规则相同。 该选项"
"对列表分隔符（逗号、冒号等）最有用。"

#. type: item
#: zsh.texi:27257
#, no-wrap
msgid "@t{-l} @var{cmd}"
msgstr "@t{-l} @var{cmd}"

#. type: table
#: zsh.texi:27268
msgid ""
"This option restricts the range of command line words that are considered to be arguments.  If combined with one of the extended completion patterns `@t{p[}...@t{]}', `@t{r[}...@t{]}', or `@t{R[}...@t{]}' "
"(see @ref{Extended Completion} below) the range is restricted to the range of arguments specified in the brackets.  Completion is then performed as if these had been given as arguments to the @var{cmd} "
"supplied with the option. If the @var{cmd} string is empty the first word in the range is instead taken as the command name, and command name completion performed on the first word in the range.  For "
"example,"
msgstr ""
"该选项限制了被视为参数的命令行单词的范围。 如果与扩展补全模式 `@t{p[}...@t{]}', `@t{r[}...@t{]}' 或 `@t{R[}...@t{]}'（见下文 @ref{扩展补全}）之一结合使用，则范围将限制在括号中指定的参数范围内。补全操作会被"
"执行，就好像这些东西已经作为参数传递给了使用该选项提供的 @var{cmd} 命令一样。（系统会将这些内容视为 @var{cmd} 命令的参数，并执行相应的补全操作。）如果 @var{cmd} 字符串为空，则范围内的第一个单词将作为命令名"
"称，并在范围内的第一个单词上执行命令名称补全。 例如"

#. type: example
#: zsh.texi:27272
#, no-wrap
msgid "compctl -x 'r[-exec,;]' -l @value{dsq} -- find\n"
msgstr "compctl -x 'r[-exec,;]' -l @value{dsq} -- find\n"

#. type: table
#: zsh.texi:27278
msgid "completes arguments between `@t{-exec}' and the following `@t{;}' (or the end of the command line if there is no such string) as if they were a separate command line."
msgstr "补全 `@t{-exec}' 和后面的 `@t{;}' （如果没有该字符串，则是命令行的末尾）之间的参数，就好像它们是单独的命令行。"

#. type: item
#: zsh.texi:27279
#, no-wrap
msgid "@t{-h} @var{cmd}"
msgstr "@t{-h} @var{cmd}"

#. type: table
#: zsh.texi:27287
msgid ""
"Normally zsh completes quoted strings as a whole. With this option, completion can be done separately on different parts of such strings. It works like the @t{-l} option but makes the completion code work "
"on the parts of the current word that are separated by spaces. These parts are completed as if they were arguments to the given @var{cmd}. If @var{cmd} is the empty string, the first part is completed as "
"a command name, as with @t{-l}."
msgstr ""
"通常，zsh 会将加引号的字符串作为一个整体补全。有了这个选项，可以分别对字符串的不同部分进行补全。它的作用与 @t{-l} 选项类似，但补全代码只针对当前单词中用空格分隔的部分。这些部分将像给定的 @var{cmd} 的参数一"
"样补全。如果 @var{cmd} 为空字符串，第一部分将作为命令名称补全，与 @t{-l} 一样。"

#. type: table
#: zsh.texi:27299
msgid ""
"Use the whole list of possible completions, whether or not they actually match the word on the command line.  The word typed so far will be deleted.  This is most useful with a function (given by the @t{-"
"K} option) which can examine the word components passed to it (or via the @t{read} builtin's @t{-c} and @t{-l} flags) and use its own criteria to decide what matches.  If there is no completion, the "
"original word is retained.  Since the produced possible completions seldom have interesting common prefixes and suffixes, menu completion is started immediately if @t{AUTO_MENU} is set and this flag is "
"used."
msgstr ""
"使用整个可能的补全列表，无论它们是否与命令行上的单词实际匹配。 目前输入的单词将被删除。 这在使用函数（由 @t{-K} 选项给出）时最有用，该函数可以检查传递给它的单词成分（或通过 @t{read} 内置函数的 @t{-c} 和 "
"@t{-l} 标志），并使用自己的标准来决定哪些匹配。 如果没有补全，则保留原词。 由于产生的可能补全很少有有趣的共同前缀和后缀，因此如果设置了 @t{AUTO_MENU} 并使用了该标志，则会立即启动菜单补全。"

#. type: item
#: zsh.texi:27300
#, no-wrap
msgid "@t{-y} @var{func-or-var}"
msgstr "@t{-y} @var{func-or-var}"

#. type: table
#: zsh.texi:27314
msgid ""
"The list provided by @var{func-or-var} is displayed instead of the list of completions whenever a listing is required; the actual completions to be inserted are not affected.  It can be provided in two "
"ways. Firstly, if @var{func-or-var} begins with a @t{$} it defines a variable, or if it begins with a left parenthesis a literal array, which contains the list.  A variable may have been set by a call to "
"a function using the @t{-K} option.  Otherwise it contains the name of a function which will be executed to create the list.  The function will be passed as an argument list all matching completions, "
"including prefixes and suffixes expanded in full, and should set the array @t{reply} to the result.  In both cases, the display list will only be retrieved after a complete list of matches has been "
"created."
msgstr ""
"只要请求一个列表，就会显示 @var{func-or-var} 提供的列表，而不是补全列表；实际要插入的补全不受影响。 可以通过两种方式提供该列表。首先，如果 @var{func-or-var} 以 @t{$} 开头，则定义了一个变量；如果以左括号开"
"头，则定义了一个字面数组，其中包含列表。 变量可能是通过调用使用 @t{-K} 选项函数设置的。 否则，它将包含一个函数的名称，该函数将被执行以创建列表。 函数将作为参数传递,列出所有匹配补全，包括前缀和后缀的完整扩"
"展，并应将数组 @t{reply} 设置为结果。 在这两种情况下，只有在创建了完整的匹配列表后，才会检索显示列表。"

#. type: table
#: zsh.texi:27321
msgid ""
"Note that the returned list does not have to correspond, even in length, to the original set of matches, and may be passed as a scalar instead of an array.  No special formatting of characters is "
"performed on the output in this case; in particular, newlines are printed literally and if they appear output in columns is suppressed."
msgstr ""
"请注意，返回的列表即使在长度上也不必与原始的匹配集一致，可以以标量而不是数组的形式传递。 在这种情况下，不会在输出结果的执行特殊字符格式化处理；特别是，换行符会按字面意思打印，如果换行符出现在列中，换行符将"
"被抑制。"

#. type: table
#: zsh.texi:27336
msgid ""
"Print @var{explanation} when trying completion on the current set of options. A `@t{%n}' in this string is replaced by the number of matches that were added for this explanation string.  The explanation "
"only appears if completion was tried and there was no unique match, or when listing completions. Explanation strings will be listed together with the matches of the group specified together with the @t{-"
"X} option (using the @t{-J} or @t{-V} option). If the same explanation string is given to multiple @t{-X} options, the string appears only once (for each group) and the number of matches shown for the "
"`@t{%n}' is the total number of all matches for each of these uses. In any case, the explanation string will only be shown if there was at least one match added for the explanation string."
msgstr ""
"在当前选项集上尝试补全时,打印 @var{explanation}。该字符串中的 `@t{%n}' 将被该解释字符串的匹配次数取代。 只有在尝试补全但没有唯一匹配时，或列出补全时，才会出现解释。解释字符串将与指定组的匹配一起列在一起，"
"这个组使用 @t{-X} 选项（使用 @t{-J} 或 @t{-V} 选项）指定。如果在多个 @t{-X} 选项中使用了相同的解释字符串，则该字符串只出现一次（针对每一组）， `@t{%n}' 显示的匹配数是每一次使用的所有匹配数的总和。在任何情"
"况下，只有在解释字符串至少有一个匹配项时，才会显示解释字符串。"

#. type: table
#: zsh.texi:27342
msgid ""
"The sequences @t{%B}, @t{%b}, @t{%S}, @t{%s}, @t{%U}, and @t{%u} specify output attributes (bold, standout, and underline), @t{%F}, @t{%f}, @t{%K}, @t{%k} specify foreground and background colours, and "
"@t{%@{}@var{...}@t{%@}} can be used to include literal escape sequences as in prompts."
msgstr ""
"序列 @t{%B}, @t{%b}, @t{%S}, @t{%s}, @t{%U} 和 @t{%u} 指定输出属性（粗体、突出和下划线），@t{%F}, @t{%f}, @t{%K}, @t{%k} 指定前景色和背景色， @t{%@{}@var{...}@t{%@}} 可用来包含字面转义序列，如提示符中的转"
"义序列。"

#. type: item
#: zsh.texi:27343
#, no-wrap
msgid "@t{-Y} @var{explanation}"
msgstr "@t{-Y} @var{explanation}"

#. type: table
#: zsh.texi:27348
msgid ""
"Identical to @t{-X}, except that the @var{explanation} first undergoes expansion following the usual rules for strings in double quotes.  The expansion will be carried out after any functions are called "
"for the @t{-K} or @t{-y} options, allowing them to set variables."
msgstr "与 @t{-X} 相同，但 @var{explanation} 会首先按照双引号中字符串的常规规则进行扩展。 扩展将在调用 @t{-K} 或 @t{-y} 选项的函数后进行，从而允许它们设置变量。"

#. type: item
#: zsh.texi:27349
#, no-wrap
msgid "@t{-t} @var{continue}"
msgstr "@t{-t} @var{continue}"

#. type: table
#: zsh.texi:27352
msgid "The @var{continue}-string contains a character that specifies which set of completion flags should be used next.  It is useful:"
msgstr "@var{continue}-字符串包含一个字符，用于指定下一步应使用哪一补全标志集。 它非常有用："

#. type: table
#: zsh.texi:27357
msgid "(i) With @t{-T}, or when trying a list of pattern completions, when @t{compctl} would usually continue with ordinary processing after finding matches; this can be suppressed with `@t{-tn}'."
msgstr "(i) 使用 @t{-T}，或尝试模式补全列表时，@t{compctl} 通常会在找到匹配后继续进行普通处理；可以使用 `@t{-tn}' 来抑制这种情况。"

#. type: table
#: zsh.texi:27363
msgid ""
"(ii) With a list of alternatives separated by @t{+}, when @t{compctl} would normally stop when one of the alternatives generates matches.  It can be forced to consider the next set of completions by "
"adding `@t{-t+}' to the flags of the alternative before the `@t{+}'."
msgstr "(ii) 对于用 @t{+} 分隔的备选方案列表，@t{compctl} 通常会在其中一个备选方案产生匹配时停止。 可以在 @t{+} 之前向备选方案标志中添加 `@t{-t+}' ，强制它考虑下一组补全。"

#. type: table
#: zsh.texi:27371
msgid ""
"(iii) In an extended completion list (see below), when @t{compctl} would normally continue until a set of conditions succeeded, then use only the immediately following flags.  With `@t{-t-}', @t{compctl} "
"will continue trying extended completions after the next `@t{-}'; with `@t{-tx}' it will attempt completion with the default flags, in other words those before the `@t{-x}'."
msgstr ""
"(iii) 在扩展补全列表（见下文）中，当 @t{compctl} 通常会持续尝试直到一组条件成功，则只使用紧随其后的标志。 如果使用 `@t{-t-}'，@t{compctl} 将在下一个 `@t{-}' 之后继续尝试扩展补全；如果使用 `@t{-tx}' ，它将"
"尝试使用默认标志补全，换句话说，就是使用 `@t{-x}' 之前的标志补全。"

#. type: item
#: zsh.texi:27372
#, no-wrap
msgid "@t{-J} @var{name}"
msgstr "@t{-J} @var{name}"

#. type: table
#: zsh.texi:27380
msgid ""
"This gives the name of the group the matches should be placed in. Groups are listed and sorted separately; likewise, menu completion will offer the matches in the groups in the order in which the groups "
"were defined. If no group name is explicitly given, the matches are stored in a group named @t{default}. The first time a group name is encountered, a group with that name is created. After that all "
"matches with the same group name are stored in that group."
msgstr ""
"这给出了应将匹配结果归入的组的名称。组将单独列出并排序；同样，菜单补全将按照组的定义顺序提供组中的匹配结果。如果没有明确给出组名，匹配结果将存储在名为 @t{default} 的组中。第一次遇到组名时，就会创建一个具有"
"该名称的组。之后，所有具有相同组名的匹配结果都会存储在该组中。"

#. type: table
#: zsh.texi:27384
msgid "This can be useful with non-exclusive alternative completions.  For example, in"
msgstr "这对非排他性的替代性补全很有用。 例如，在"

#. type: example
#: zsh.texi:27388
#, no-wrap
msgid "compctl -f -J files -t+ + -v -J variables foo\n"
msgstr "compctl -f -J files -t+ + -v -J variables foo\n"

#. type: table
#: zsh.texi:27395
msgid ""
"both files and variables are possible completions, as the @t{-t+} forces both sets of alternatives before and after the @t{+} to be considered at once.  Because of the @t{-J} options, however, all files "
"are listed before all variables."
msgstr "文件和变量都是可能的补全，因为 @t{-t+} 会强制同时考虑 @t{+} 前后的两个备选方案集。 不过，由于有 @t{-J} 选项，所有文件都会列在所有变量之前。"

#. type: item
#: zsh.texi:27396
#, no-wrap
msgid "@t{-V} @var{name}"
msgstr "@t{-V} @var{name}"

#. type: table
#: zsh.texi:27401
msgid ""
"Like @t{-J}, but matches within the group will not be sorted in listings nor in menu completion. These unsorted groups are in a different name space from the sorted ones, so groups defined as @t{-J files} "
"and @t{-V files} are distinct."
msgstr "与 @t{-J} 类似，但组内的匹配结果不会在列表或菜单补全中排序。这些未排序的组与已排序的组处于不同的名称空间，因此定义为 @t{-J files} 和 @t{-V files} 的组是不同的。"

#. type: table
#: zsh.texi:27406
msgid "If given together with the @t{-V} option, makes only consecutive duplicates in the group be removed. Note that groups with and without this flag are in different name spaces."
msgstr "如果与 @t{-V} 选项一起使用，则只删除组中连续的重复内容。请注意，有此标志和无此标志的组处于不同的名称空间。"

#. type: table
#: zsh.texi:27417
msgid ""
"This defines additional matching control specifications that should be used only when testing words for the list of flags this flag appears in. The format of the @var{match-spec} string is described in "
"@ref{Completion Matching Control}."
msgstr "这定义了额外的匹配控制规范，只应在为该标志所在的标志列表测试词语时使用。@var{match-spec} 字符串的格式在 @ref{补全匹配控制} 中描述。"

#. type: node
#: zsh.texi:27421 zsh.texi:27440 zsh.texi:27448 zsh.texi:27568
#, no-wrap
msgid "Extended Completion"
msgstr "扩展补全"

#. type: item
#: zsh.texi:27426
#, no-wrap
msgid "@t{compctl} [ @t{-CDT} ] @var{options} @t{+} @var{options} [ @t{+} ... ] [ @t{+} ] @var{command} ..."
msgstr "@t{compctl} [ @t{-CDT} ] @var{options} @t{+} @var{options} [ @t{+} ... ] [ @t{+} ] @var{command} ..."

#. type: Plain text
#: zsh.texi:27438
msgid ""
"The form with `@t{+}' specifies alternative options. Completion is tried with the options before the first `@t{+}'. If this produces no matches completion is tried with the flags after the `@t{+}' and so "
"on. If there are no flags after the last `@t{+}' and a match has not been found up to that point, default completion is tried.  If the list of flags contains a @t{-t} with a @t{+} character, the next list "
"of flags is used even if the current list produced matches."
msgstr ""
"带 `@t{+}' 的形式指定了其他选项。补全将使用第一个 `@t{+}' 之前的选项。如果没有匹配结果，则使用 `@t{+}' 之后的标志进行补全，依此类推。如果在最后一个 `@t{+}' 之后没有标志，且到此为止仍未找到匹配项，则尝试默"
"认补全。 如果标志列表中包含 @t{-t} 与 @t{+} 字符，即使当前列表产生了匹配，也会使用下一个标志列表。"

#. type: Plain text
#: zsh.texi:27445
msgid "Additional options are available that restrict completion to some part of the command line; this is referred to as `extended completion'."
msgstr "还可以使用其他选项，将补全限制在命令行的某些部分；这被称为 `扩展补全'。"

#. type: item
#: zsh.texi:27452
#, no-wrap
msgid "@t{compctl }[ @t{-CDT} ] @var{options} @t{-x} @var{pattern} @var{options} @t{-} ... @t{-}@t{-}"
msgstr "@t{compctl }[ @t{-CDT} ] @var{options} @t{-x} @var{pattern} @var{options} @t{-} ... @t{-}@t{-}"

#. type: item
#: zsh.texi:27453
#, no-wrap
msgid "@t{@ @ @ @ @ @ @ @ }[ @var{command} ... ]"
msgstr "@t{@ @ @ @ @ @ @ @ }[ @var{command} ... ]"

#. type: Plain text
#: zsh.texi:27467
msgid ""
"The form with `@t{-x}' specifies extended completion for the commands given; as shown, it may be combined with alternative completion using `@t{+}'.  Each @var{pattern} is examined in turn; when a match "
"is found, the corresponding @var{options}, as described in @ref{Option Flags} above, are used to generate possible completions.  If no @var{pattern} matches, the @var{options} given before the @t{-x} are "
"used."
msgstr ""
"带有 `@t{-x}' 的形式指定了所给命令的扩展补全；如图所示，它可以与使用 `@t{+}' 的可替代补全相结合。 每个 @var{pattern} 都会被依次检查；当发现匹配时，相应的 @var{options} （如上文 @ref{选项标志} 所述）将用于"
"生成可能的补全。 如果没有 @var{pattern} 匹配，则使用 @t{-x} 之前给出的 @var{options}。"

#. type: Plain text
#: zsh.texi:27472
msgid "Note that each pattern should be supplied as a single argument and should be quoted to prevent expansion of metacharacters by the shell."
msgstr "请注意，每个模式应作为一个参数提供，并应加上引号，以防止 shell 扩展元字符。"

#. type: Plain text
#: zsh.texi:27483
msgid ""
"A @var{pattern} is built of sub-patterns separated by commas; it matches if at least one of these sub-patterns matches (they are `or'ed). These sub-patterns are in turn composed of other sub-patterns "
"separated by white spaces which match if all of the sub-patterns match (they are `and'ed).  An element of the sub-patterns is of the form `@var{c}@t{[}...@t{][}...@t{]}', where the pairs of brackets may "
"be repeated as often as necessary, and matches if any of the sets of brackets match (an `or').  The example below makes this clearer."
msgstr ""
"一个 @var{pattern} 是由用逗号分隔的子模式组成的；如果这些子模式中至少有一个匹配（它们是 \"或\" 关系的），那么它就匹配。这些子模式又由其他子模式组成，这些子模式用空格分隔，如果所有子模式都匹配（它们是 \"和"
"\" 关系），这些子模式也会匹配。 子模式的一个元素的形式为 `@var{c}@t{[}...@t{][}...@t{]}'，其中的括号对可根据需要多次重复，如果任何一组括号匹配（\"或\"）则匹配。 下面的例子更清楚地说明了这一点。"

#. type: Plain text
#: zsh.texi:27486
msgid "The elements may be any of the following:"
msgstr "这些元素可以是以下任何一种:"

#. type: item
#: zsh.texi:27489
#, no-wrap
msgid "@t{s[}@var{string}@t{]}..."
msgstr "@t{s[}@var{string}@t{]}..."

#. type: table
#: zsh.texi:27493
msgid "Matches if the current word on the command line starts with one of the strings given in brackets.  The @var{string} is not removed and is not part of the completion."
msgstr "如果命令行中的当前单词以括号中给出的字符串之一开头，则匹配该字符串。 @var{string} 不会被删除，也不是补全的一部分。"

#. type: item
#: zsh.texi:27494
#, no-wrap
msgid "@t{S[}@var{string}@t{]}..."
msgstr "@t{S[}@var{string}@t{]}..."

#. type: table
#: zsh.texi:27497
msgid "Like @t{s[}@var{string}@t{]} except that the @var{string} is part of the completion."
msgstr "与 @t{s[}@var{string}@t{]} 类似，只不过 @var{string} 是补全的一部分。"

#. type: item
#: zsh.texi:27498
#, no-wrap
msgid "@t{p[}@var{from}@t{,}@var{to}@t{]}..."
msgstr "@t{p[}@var{from}@t{,}@var{to}@t{]}..."

#. type: table
#: zsh.texi:27504
msgid ""
"Matches if the number of the current word is between one of the @var{from} and @var{to} pairs inclusive. The comma and @var{to} are optional; @var{to} defaults to the same value as @var{from}.  The "
"numbers may be negative: @t{-}@var{n} refers to the @var{n}'th last word on the line."
msgstr "如果当前单词的编号介于 @var{from} 和 @var{to} 之间，则匹配。逗号和 @var{to} 均为可选项；@var{to} 的默认值与 @var{from} 相同。 数字可以是负数： @t{-}@var{n} 指的是该行的最后第 @var{n} 个字。"

#. type: item
#: zsh.texi:27505
#, no-wrap
msgid "@t{c[}@var{offset}@t{,}@var{string}@t{]}..."
msgstr "@t{c[}@var{offset}@t{,}@var{string}@t{]}..."

#. type: table
#: zsh.texi:27509
msgid "Matches if the @var{string} matches the word offset by @var{offset} from the current word position.  Usually @var{offset} will be negative."
msgstr "如果 @var{string} 与从当前字词位置偏移 @var{offset} 的字词匹配，则匹配。 通常 @var{offset} 为负值。"

#. type: item
#: zsh.texi:27510
#, no-wrap
msgid "@t{C[}@var{offset}@t{,}@var{pattern}@t{]}..."
msgstr "@t{C[}@var{offset}@t{,}@var{pattern}@t{]}..."

#. type: table
#: zsh.texi:27512
msgid "Like @t{c} but using pattern matching instead."
msgstr "与 @t{c} 类似，但使用模式匹配。"

#. type: item
#: zsh.texi:27513
#, no-wrap
msgid "@t{w[}@var{index}@t{,}@var{string}@t{]}..."
msgstr "@t{w[}@var{index}@t{,}@var{string}@t{]}..."

#. type: table
#: zsh.texi:27517
msgid "Matches if the word in position @var{index} is equal to the corresponding @var{string}.  Note that the word count is made after any alias expansion."
msgstr "如果位置 @var{index} 中的单词等于相应的 @var{string}，则匹配。 请注意，单词计数是在任何别名扩展之后进行的。"

#. type: item
#: zsh.texi:27518
#, no-wrap
msgid "@t{W[}@var{index}@t{,}@var{pattern}@t{]}..."
msgstr "@t{W[}@var{index}@t{,}@var{pattern}@t{]}..."

#. type: table
#: zsh.texi:27520
msgid "Like @t{w} but using pattern matching instead."
msgstr "与 @t{w} 类似，但使用模式匹配。"

#. type: item
#: zsh.texi:27521
#, no-wrap
msgid "@t{n[}@var{index}@t{,}@var{string}@t{]}..."
msgstr "@t{n[}@var{index}@t{,}@var{string}@t{]}..."

#. type: table
#: zsh.texi:27527
msgid ""
"Matches if the current word contains @var{string}.  Anything up to and including the @var{index}th occurrence of this string will not be considered part of the completion, but the rest will.  @var{index} "
"may be negative to count from the end: in most cases, @var{index} will be 1 or -1.  For example,"
msgstr ""
"如果当前单词包含 @var{string} ，则匹配。 所有东西，直到并包括第 @var{index} 次该字符串的出现，都不会被视为补全的一部分，但其余部分会被视为补全的一部分。 @var{index} 可以是负数，以便从结尾开始计数：在大多数"
"情况下，@var{index} 将是 1 或-1。 例如,"

#. type: example
#: zsh.texi:27531
#, no-wrap
msgid "compctl -s '`users`' -x 'n[1,@@]' -k hosts -- talk\n"
msgstr "compctl -s '`users`' -x 'n[1,@@]' -k hosts -- talk\n"

#. type: table
#: zsh.texi:27538
msgid ""
"will usually complete usernames, but if you insert an @t{@@} after the name, names from the array @var{hosts} (assumed to contain hostnames, though you must make the array yourself) will be completed.  "
"Other commands such as @t{rcp} can be handled similarly."
msgstr "通常会补全用户名，但如果在名称后插入 @t{@@} ，则会补全 @var{hosts} 数组（假定包含主机名，但必须自己创建数组）中的名称。 其他命令（如 @t{rcp}）的处理方法与此类似。"

#. type: item
#: zsh.texi:27539
#, no-wrap
msgid "@t{N[}@var{index}@t{,}@var{string}@t{]}..."
msgstr "@t{N[}@var{index}@t{,}@var{string}@t{]}..."

#. type: table
#: zsh.texi:27544
msgid ""
"Like @t{n} except that the string will be taken as a character class.  Anything up to and including the @var{index}th occurrence of any of the characters in @var{string} will not be considered part of the "
"completion."
msgstr "与 @t{n} 类似，但字符串将被视为一个字符类。 在 @var{string} 中出现的任何字符，直到（包括）第 @var{index} 次出现的字符，都不会被视为补全的一部分。"

#. type: item
#: zsh.texi:27545
#, no-wrap
msgid "@t{m[}@var{min}@t{,}@var{max}@t{]}..."
msgstr "@t{m[}@var{min}@t{,}@var{max}@t{]}..."

#. type: table
#: zsh.texi:27548
msgid "Matches if the total number of words lies between @var{min} and @var{max} inclusive."
msgstr "如果总字数在 @var{min} 和 @var{max} 之间（包括 @var{min} 和 @var{max} 在内），则匹配。"

#. type: item
#: zsh.texi:27549
#, no-wrap
msgid "@t{r[}@var{str1}@t{,}@var{str2}@t{]}..."
msgstr "@t{r[}@var{str1}@t{,}@var{str2}@t{]}..."

#. type: table
#: zsh.texi:27555
msgid ""
"Matches if the cursor is after a word with prefix @var{str1}.  If there is also a word with prefix @var{str2} on the command line after the one matched by @var{str1} it matches only if the cursor is "
"before this word. If the comma and @var{str2} are omitted, it matches if the cursor is after a word with prefix @var{str1}."
msgstr ""
"如果光标位于前缀为 @var{str1} 的单词之后，则匹配该单词。 如果命令行中在 @var{str1} 匹配的单词之后还有前缀为 @var{str2} 的单词，则只有当光标位于该单词之前时才会匹配。如果省略逗号和 @var{str2}，则只有当光标"
"位于前缀为 @var{str1} 的单词之后时才会匹配。"

#. type: item
#: zsh.texi:27556
#, no-wrap
msgid "@t{R[}@var{str1}@t{,}@var{str2}@t{]}..."
msgstr "@t{R[}@var{str1}@t{,}@var{str2}@t{]}..."

#. type: table
#: zsh.texi:27558
msgid "Like @t{r} but using pattern matching instead."
msgstr "与 @t{r} 类似，但使用模式匹配。"

#. type: item
#: zsh.texi:27559
#, no-wrap
msgid "@t{q[}@var{str}@t{]}..."
msgstr "@t{q[}@var{str}@t{]}..."

#. type: table
#: zsh.texi:27564
msgid ""
"Matches the word currently being completed is in single quotes and the @var{str} begins with the letter `s', or if completion is done in double quotes and @var{str} starts with the letter `d', or if "
"completion is done in backticks and @var{str} starts with a `b'."
msgstr "当前补全的单词在单引号中且 @var{str} 以字母  `s'开头，则匹配，或者在双引号中补全且 @var{str} 以字母 `d' 开头，或者在反引号中补全且 @var{str} 以字母 `b' 开头。"

#. type: example
#: zsh.texi:27577
#, no-wrap
msgid ""
"compctl -u -x 's[+] c[-1,-f],s[-f+]' \\ \n"
"  -g '~/Mail/*(:t)' - 's[-f],c[-1,-f]' -f -- mail\n"
msgstr ""
"compctl -u -x 's[+] c[-1,-f],s[-f+]' \\ \n"
"  -g '~/Mail/*(:t)' - 's[-f],c[-1,-f]' -f -- mail\n"

#. type: Plain text
#: zsh.texi:27581
msgid "This is to be interpreted as follows:"
msgstr "对这句话的解释如下:"

#. type: Plain text
#: zsh.texi:27584
msgid "If the current command is @t{mail}, then"
msgstr "如果当前命令是 @t{mail}，那么"

#. type: quotation
#: zsh.texi:27592
msgid ""
"if ((the current word begins with @t{+} and the previous word is @t{-f})  or (the current word begins with @t{-f+})), then complete the non-directory part (the `@t{:t}' glob modifier) of files in the "
"directory @t{~/Mail}; else"
msgstr "如果 ((当前单词以 @t{+} 开头，且前一个单词为 @t{-f}）或（当前单词以 @t{-f+} 开头))，则补全 @t{~/Mail} 目录中文件的非目录部分（ `@t{:t}'  glob 修饰符）；否则"

#. type: quotation
#: zsh.texi:27596
msgid "if the current word begins with @t{-f} or the previous word was @t{-f}, then complete any file; else"
msgstr "如果当前单词以 @t{-f} 开头或前一个单词是 @t{-f}，则补全任何文件；否则"

#. type: quotation
#: zsh.texi:27599
msgid "complete user names."
msgstr "补全用户名。"

#. type: Plain text
#: zsh.texi:27618
msgid ""
"Some optional parts of zsh are in modules, separate from the core of the shell.  Each of these modules may be linked in to the shell at build time, or can be dynamically linked while the shell is running "
"if the installation supports this feature.  Modules are linked at runtime with the @t{zmodload} command, see @ref{Shell Builtin Commands}."
msgstr ""
"zsh 的某些可选部分以模块的形式存在，与 shell 的核心分开。 这些模块可以在构建时链接到 shell 中，或者在 shell 运行时动态链接（如果安装支持此功能）。 使用 @t{zmodload} 命令可在运行时链接模块，参见 @ref{Shell "
"内置命令}。"

#. type: Plain text
#: zsh.texi:27621
msgid "The modules that are bundled with the zsh distribution are:"
msgstr "与 zsh 发行版捆绑在一起的模块有:"

#. type: t{#1}
#: zsh.texi:27625
#, no-wrap
msgid "zsh/attr"
msgstr "zsh/attr"

#. type: table
#: zsh.texi:27627
msgid "Builtins for manipulating extended attributes (xattr)."
msgstr "用于操作扩展属性 (xattr) 的内置程序。"

#. type: t{#1}
#: zsh.texi:27628
#, no-wrap
msgid "zsh/cap"
msgstr "zsh/cap"

#. type: table
#: zsh.texi:27630
msgid "Builtins for manipulating POSIX.1e (POSIX.6) capability (privilege) sets."
msgstr "用于操作 POSIX.1e (POSIX.6) 能力（权限）集的内置程序。"

#. type: t{#1}
#: zsh.texi:27631
#, no-wrap
msgid "zsh/clone"
msgstr "zsh/clone"

#. type: table
#: zsh.texi:27633
msgid "A builtin that can clone a running shell onto another terminal."
msgstr "一个内置程序，可以将一个正在运行的 shell 克隆到另一个终端上。"

#. type: t{#1}
#: zsh.texi:27634
#, no-wrap
msgid "zsh/compctl"
msgstr "zsh/compctl"

#. type: table
#: zsh.texi:27636
msgid "The @t{compctl} builtin for controlling completion."
msgstr "用于控制补全的 @t{compctl} 内置命令。"

#. type: t{#1}
#: zsh.texi:27637
#, no-wrap
msgid "zsh/complete"
msgstr "zsh/complete"

#. type: table
#: zsh.texi:27639
msgid "The basic completion code."
msgstr "基本补全代码。"

#. type: t{#1}
#: zsh.texi:27640
#, no-wrap
msgid "zsh/complist"
msgstr "zsh/complist"

#. type: table
#: zsh.texi:27642
msgid "Completion listing extensions."
msgstr "补全列表扩展。"

#. type: t{#1}
#: zsh.texi:27643
#, no-wrap
msgid "zsh/computil"
msgstr "zsh/computil"

#. type: table
#: zsh.texi:27646
msgid "A module with utility builtins needed for the shell function based completion system."
msgstr "该模块包含基于 shell 函数的补全系统所需的实用内置程序。"

#. type: t{#1}
#: zsh.texi:27647
#, no-wrap
msgid "zsh/curses"
msgstr "zsh/curses"

#. type: table
#: zsh.texi:27649
msgid "curses windowing commands"
msgstr "curses 窗口命令"

#. type: t{#1}
#: zsh.texi:27650
#, no-wrap
msgid "zsh/datetime"
msgstr "zsh/datetime"

#. type: table
#: zsh.texi:27652
msgid "Some date/time commands and parameters."
msgstr "一些日期/时间命令和参数"

#. type: t{#1}
#: zsh.texi:27653
#, no-wrap
msgid "zsh/db/gdbm"
msgstr "zsh/db/gdbm"

#. type: table
#: zsh.texi:27655
msgid "Builtins for managing associative array parameters tied to GDBM databases."
msgstr "用于管理与 GDBM 数据库相关联的关联数组参数的内置程序。"

#. type: t{#1}
#: zsh.texi:27656
#, no-wrap
msgid "zsh/deltochar"
msgstr "zsh/deltochar"

#. type: table
#: zsh.texi:27658
msgid "A ZLE function duplicating EMACS' @t{zap-to-char}."
msgstr "重复 EMACS 的 @t{zap-to-char} 的 ZLE 函数。"

#. type: t{#1}
#: zsh.texi:27659
#, no-wrap
msgid "zsh/example"
msgstr "zsh/example"

#. type: table
#: zsh.texi:27661
msgid "An example of how to write a module."
msgstr "如何编写模块的示例。"

#. type: t{#1}
#: zsh.texi:27662
#, no-wrap
msgid "zsh/files"
msgstr "zsh/files"

#. type: table
#: zsh.texi:27664
msgid "Some basic file manipulation commands as builtins."
msgstr "一些内置的基本文件操作命令。"

#. type: t{#1}
#: zsh.texi:27665
#, no-wrap
msgid "zsh/langinfo"
msgstr "zsh/langinfo"

#. type: table
#: zsh.texi:27667
msgid "Interface to locale information."
msgstr "本地化信息接口。"

#. type: t{#1}
#: zsh.texi:27668
#, no-wrap
msgid "zsh/mapfile"
msgstr "zsh/mapfile"

#. type: table
#: zsh.texi:27670
msgid "Access to external files via a special associative array."
msgstr "通过一个特殊的关联数组访问外部文件。"

#. type: t{#1}
#: zsh.texi:27671
#, no-wrap
msgid "zsh/mathfunc"
msgstr "zsh/mathfunc"

#. type: table
#: zsh.texi:27673
msgid "Standard scientific functions for use in mathematical evaluations."
msgstr "用于数学计算的标准科学函数。"

#. type: t{#1}
#: zsh.texi:27674
#, no-wrap
msgid "zsh/nearcolor"
msgstr "zsh/nearcolor"

#. type: table
#: zsh.texi:27676
msgid "Map colours to the nearest colour in the available palette."
msgstr "将颜色映射到可用调色板中最接近的颜色。"

#. type: t{#1}
#: zsh.texi:27677
#, no-wrap
msgid "zsh/newuser"
msgstr "zsh/newuser"

#. type: table
#: zsh.texi:27679
msgid "Arrange for files for new users to be installed."
msgstr "安排为新用户安装文件。"

#. type: t{#1}
#: zsh.texi:27680
#, no-wrap
msgid "zsh/parameter"
msgstr "zsh/parameter"

#. type: table
#: zsh.texi:27682
msgid "Access to internal hash tables via special associative arrays."
msgstr "通过特殊关联数组访问内部哈希表。"

#. type: t{#1}
#: zsh.texi:27683
#, no-wrap
msgid "zsh/pcre"
msgstr "zsh/pcre"

#. type: table
#: zsh.texi:27685
msgid "Interface to the PCRE library."
msgstr "PCRE 库的接口。"

#. type: t{#1}
#: zsh.texi:27686
#, no-wrap
msgid "zsh/param/private"
msgstr "zsh/param/private"

#. type: table
#: zsh.texi:27688
msgid "Builtins for managing private-scoped parameters in function context."
msgstr "用于在函数上下文中管理私有范围参数的内置函数。"

#. type: t{#1}
#: zsh.texi:27689
#, no-wrap
msgid "zsh/regex"
msgstr "zsh/regex"

#. type: table
#: zsh.texi:27691
msgid "Interface to the POSIX regex library."
msgstr "POSIX regex 库的接口。"

#. type: t{#1}
#: zsh.texi:27692
#, no-wrap
msgid "zsh/sched"
msgstr "zsh/sched"

#. type: table
#: zsh.texi:27694
msgid "A builtin that provides a timed execution facility within the shell."
msgstr "在 shell 中提供定时执行功能的内置程序。"

#. type: t{#1}
#: zsh.texi:27695
#, no-wrap
msgid "zsh/net/socket"
msgstr "zsh/net/socket"

#. type: table
#: zsh.texi:27697
msgid "Manipulation of Unix domain sockets"
msgstr "操纵 Unix 域套接字"

#. type: t{#1}
#: zsh.texi:27698
#, no-wrap
msgid "zsh/stat"
msgstr "zsh/stat"

#. type: table
#: zsh.texi:27700
msgid "A builtin command interface to the @t{stat} system call."
msgstr "@t{stat} 系统调用的内置命令接口。"

#. type: t{#1}
#: zsh.texi:27701
#, no-wrap
msgid "zsh/system"
msgstr "zsh/system"

#. type: table
#: zsh.texi:27703
msgid "A builtin interface to various low-level system features."
msgstr "连接各种底层系统功能的内置接口。"

#. type: t{#1}
#: zsh.texi:27704
#, no-wrap
msgid "zsh/net/tcp"
msgstr "zsh/net/tcp"

#. type: table
#: zsh.texi:27706
msgid "Manipulation of TCP sockets"
msgstr "操作 TCP 套接字"

#. type: t{#1}
#: zsh.texi:27707
#, no-wrap
msgid "zsh/termcap"
msgstr "zsh/termcap"

#. type: table
#: zsh.texi:27709
msgid "Interface to the termcap database."
msgstr "termcap 数据库的接口。"

#. type: t{#1}
#: zsh.texi:27710
#, no-wrap
msgid "zsh/terminfo"
msgstr "zsh/terminfo"

#. type: table
#: zsh.texi:27712
msgid "Interface to the terminfo database."
msgstr "terminfo 数据库的接口。"

#. type: t{#1}
#: zsh.texi:27713
#, no-wrap
msgid "zsh/watch"
msgstr "zsh/watch"

#. type: table
#: zsh.texi:27715
msgid "Reporting of login and logout events."
msgstr "Reporting of login and logout events."

#. type: t{#1}
#: zsh.texi:27716
#, no-wrap
msgid "zsh/zftp"
msgstr "zsh/zftp"

#. type: table
#: zsh.texi:27718
msgid "A builtin FTP client."
msgstr "内置 FTP 客户端。"

#. type: t{#1}
#: zsh.texi:27719
#, no-wrap
msgid "zsh/zle"
msgstr "zsh/zle"

#. type: table
#: zsh.texi:27721
msgid "The Zsh Line Editor, including the @t{bindkey} and @t{vared} builtins."
msgstr "Zsh 行编辑器，包含 @t{bindkey} 和 @t{vared} 内置命令。"

#. type: t{#1}
#: zsh.texi:27722
#, no-wrap
msgid "zsh/zleparameter"
msgstr "zsh/zleparameter"

#. type: table
#: zsh.texi:27724
msgid "Access to internals of the Zsh Line Editor via parameters."
msgstr "通过参数访问 Zsh 行编辑器的内部。"

#. type: t{#1}
#: zsh.texi:27725
#, no-wrap
msgid "zsh/zprof"
msgstr "zsh/zprof"

#. type: table
#: zsh.texi:27727
msgid "A module allowing profiling for shell functions."
msgstr "一个允许对 shell 函数进行性能分析的模块。"

#. type: t{#1}
#: zsh.texi:27728
#, no-wrap
msgid "zsh/zpty"
msgstr "zsh/zpty"

#. type: table
#: zsh.texi:27730
msgid "A builtin for starting a command in a pseudo-terminal."
msgstr "一个内置命令，用于在伪终端中启动一个命令。"

#. type: t{#1}
#: zsh.texi:27731
#, no-wrap
msgid "zsh/zselect"
msgstr "zsh/zselect"

#. type: table
#: zsh.texi:27733
msgid "Block and return when file descriptors are ready."
msgstr "当文件描述符准备就绪时，阻塞并返回。"

#. type: t{#1}
#: zsh.texi:27734
#, no-wrap
msgid "zsh/zutil"
msgstr "zsh/zutil"

#. type: table
#: zsh.texi:27737
msgid "Some utility builtins, e.g. the one for supporting configuration via styles."
msgstr "一些实用内置程序，例如支持通过样式进行配置的内置程序。"

#. type: node
#: zsh.texi:27780 zsh.texi:27782 zsh.texi:27827
#, no-wrap
msgid "The zsh/attr Module"
msgstr "zsh/attr 模块"

#. type: node
#: zsh.texi:27780 zsh.texi:27827 zsh.texi:27829 zsh.texi:27861
#, no-wrap
msgid "The zsh/cap Module"
msgstr "zsh/cap 模块"

#. type: Plain text
#: zsh.texi:27790
msgid "The @t{zsh/attr} module is used for manipulating extended attributes.  The @t{-h} option causes all commands to operate on symbolic links instead of their targets.  The builtins in this module are:"
msgstr "@t{zsh/attr} 模块用于操作扩展属性。 通过 @t{-h} 选项，所有命令都将在符号链接上执行，而不是在目标上执行。 该模块中的内置模块包括:"

#. type: findex
#: zsh.texi:27793
#, no-wrap
msgid "zgetattr"
msgstr "zgetattr"

#. type: cindex
#: zsh.texi:27794
#, no-wrap
msgid "extended attributes, xattr, getting from files"
msgstr "扩展属性, xattr, 从文件中获取"

#. type: item
#: zsh.texi:27795
#, no-wrap
msgid "@t{zgetattr} [ @t{-h} ] @var{filename} @var{attribute} [ @var{parameter} ]"
msgstr "@t{zgetattr} [ @t{-h} ] @var{filename} @var{attribute} [ @var{parameter} ]"

#. type: table
#: zsh.texi:27799
msgid ""
"Get the extended attribute @var{attribute} from the specified @var{filename}. If the optional argument @var{parameter} is given, the attribute is set on that parameter instead of being printed to stdout."
msgstr "从指定的 @var{filename} 获取扩展属性 @var{attribute}。如果给出了可选参数 @var{parameter}，则属性将设置在该参数上，而不是打印到 。"

#. type: findex
#: zsh.texi:27800
#, no-wrap
msgid "zsetattr"
msgstr "zsetattr"

#. type: cindex
#: zsh.texi:27801
#, no-wrap
msgid "extended attributes, xattr, setting on files"
msgstr "扩展属性, xattr, 在文件上的设置"

#. type: item
#: zsh.texi:27802
#, no-wrap
msgid "@t{zsetattr} [ @t{-h} ] @var{filename} @var{attribute} @var{value}"
msgstr "@t{zsetattr} [ @t{-h} ] @var{filename} @var{attribute} @var{value}"

#. type: table
#: zsh.texi:27805
msgid "Set the extended attribute @var{attribute} on the specified @var{filename} to @var{value}."
msgstr "将指定 @var{filename} 上的扩展属性 @var{attribute} 设置为 @var{value}。"

#. type: findex
#: zsh.texi:27806
#, no-wrap
msgid "zdelattr"
msgstr "zdelattr"

#. type: cindex
#: zsh.texi:27807
#, no-wrap
msgid "extended attributes, xattr, removing, deleting"
msgstr "扩展属性, xattr, 移除, 删除"

#. type: item
#: zsh.texi:27808
#, no-wrap
msgid "@t{zdelattr} [ @t{-h} ] @var{filename} @var{attribute}"
msgstr "@t{zdelattr} [ @t{-h} ] @var{filename} @var{attribute}"

#. type: table
#: zsh.texi:27811
msgid "Remove the extended attribute @var{attribute} from the specified @var{filename}."
msgstr "从指定的 @var{filename} 中移除扩展属性 @var{attribute}。"

#. type: findex
#: zsh.texi:27812
#, no-wrap
msgid "zlistattr"
msgstr "zlistattr"

#. type: cindex
#: zsh.texi:27813
#, no-wrap
msgid "extended attributes, xattr, listing"
msgstr "扩展的属性, xattr, 列表"

#. type: item
#: zsh.texi:27814
#, no-wrap
msgid "@t{zlistattr} [ @t{-h} ] @var{filename} [ @var{parameter} ]"
msgstr "@t{zlistattr} [ @t{-h} ] @var{filename} [ @var{parameter} ]"

#. type: table
#: zsh.texi:27818
msgid ""
"List the extended attributes currently set on the specified @var{filename}. If the optional argument @var{parameter} is given, the list of attributes is set on that parameter instead of being printed to "
"stdout."
msgstr "列出当前在指定的 @var{filename} 上设置的扩展属性。如果给出了可选参数 @var{parameter}，属性列表将设置在该参数上，而不是打印到 stdout。"

#. type: Plain text
#: zsh.texi:27827
msgid ""
"@t{zgetattr} and @t{zlistattr} allocate memory dynamically.  If the attribute or list of attributes grows between the allocation and the call to get them, they return 2.  On all other errors, 1 is "
"returned.  This allows the calling function to check for this case and retry."
msgstr "@t{zgetattr} 和 @t{zlistattr} 是动态分配内存的。 如果属性或属性列表在分配和调用以获取之间时增长，它们会返回 2。 如果出现其他错误，则返回 1。 这允许调用函数检查这种情况并重试。"

#. type: node
#: zsh.texi:27827 zsh.texi:27861 zsh.texi:27863 zsh.texi:27928
#, no-wrap
msgid "The zsh/clone Module"
msgstr "zsh/clone 模块"

#. type: Plain text
#: zsh.texi:27837
msgid ""
"The @t{zsh/cap} module is used for manipulating POSIX.1e (POSIX.6) capability sets.  If the operating system does not support this interface, the builtins defined by this module will do nothing.  The "
"builtins in this module are:"
msgstr "@t{zsh/cap} 模块用于操作 POSIX.1e (POSIX.6) 能力集。 如果操作系统不支持该接口，该模块定义的内置命令将不起任何作用。 该模块中的内置命令包括："

#. type: cindex
#: zsh.texi:27841
#, no-wrap
msgid "capabilities, setting"
msgstr "能力, 设置"

#. type: item
#: zsh.texi:27842
#, no-wrap
msgid "@t{cap} [ @var{capabilities} ]"
msgstr "@t{cap} [ @var{capabilities} ]"

#. type: table
#: zsh.texi:27845
msgid "Change the shell's process capability sets to the specified @var{capabilities}, otherwise display the shell's current capabilities."
msgstr "将 shell 的进程能力集更改为指定的 @var{capabilities}，否则显示 shell 的当前能力。"

#. type: cindex
#: zsh.texi:27847
#, no-wrap
msgid "capabilities, getting from files"
msgstr "功能, 从文件中获取"

#. type: item
#: zsh.texi:27848
#, no-wrap
msgid "@t{getcap} @var{filename} ..."
msgstr "@t{getcap} @var{filename} ..."

#. type: table
#: zsh.texi:27851
msgid "This is a built-in implementation of the POSIX standard utility.  It displays the capability sets on each specified @var{filename}."
msgstr "这是 POSIX 标准实用程序的内置实现。 它会显示每个指定 @var{filename} 上的能力集。"

#. type: cindex
#: zsh.texi:27853
#, no-wrap
msgid "capabilities, setting on files"
msgstr "功能, 在文件上设置"

#. type: item
#: zsh.texi:27854
#, no-wrap
msgid "@t{setcap} @var{capabilities} @var{filename} ..."
msgstr "@t{setcap} @var{capabilities} @var{filename} ..."

#. type: table
#: zsh.texi:27858
msgid "This is a built-in implementation of the POSIX standard utility.  It sets the capability sets on each specified @var{filename} to the specified @var{capabilities}."
msgstr "这是 POSIX 标准实用程序的内置实现。 它将每个指定的 @var{filename} 上的能力集设置为指定的 @var{capabilities}。"

#. type: node
#: zsh.texi:27861 zsh.texi:27928 zsh.texi:27930 zsh.texi:27941
#, no-wrap
msgid "The zsh/compctl Module"
msgstr "zsh/compctl 模块"

#. type: Plain text
#: zsh.texi:27868
msgid "The @t{zsh/clone} module makes available one builtin command:"
msgstr "@t{zsh/clone} 模块提供了一条内置命令："

#. type: cindex
#: zsh.texi:27872
#, no-wrap
msgid "shell, cloning"
msgstr "shell, 克隆"

#. type: cindex
#: zsh.texi:27873
#, no-wrap
msgid "cloning the shell"
msgstr "克隆 shell"

#. type: cindex
#: zsh.texi:27874
#, no-wrap
msgid "terminal"
msgstr "终端"

#. type: item
#: zsh.texi:27875
#, no-wrap
msgid "@t{clone} @var{tty}"
msgstr "@t{clone} @var{tty}"

#. type: table
#: zsh.texi:27880
msgid ""
"Creates a forked instance of the current shell, attached to the specified @var{tty}.  In the new shell, the @t{PID}, @t{PPID} and @t{TTY} special parameters are changed appropriately.  @t{$!} is set to "
"zero in the new shell, and to the new shell's PID in the original shell."
msgstr ""
"创建当前 shell 的分叉实例，并连接到指定的 @var{tty}。 在新 shell 中，@t{PID}, @t{PPID} 和 @t{TTY} 特殊参数会相应更改。 在新 shell 中，@t{$!} 设置为 0，而在原 shell 中，@t{$!} 则设置为新 shell 的 PID。"

#. type: table
#: zsh.texi:27884
msgid "The return status of the builtin is zero in both shells if successful, and non-zero on error."
msgstr "如果成功，内置函数在两个 shell 中的返回状态都为 0，如果出错，则返回状态为非 0。"

#. type: table
#: zsh.texi:27888
msgid "The target of @t{clone} should be an unused terminal, such as an unused virtual console or a virtual terminal created by"
msgstr "@t{clone} 的目标应该是一个未使用的终端，例如未使用的虚拟控制台或由下面创建的虚拟终端"

#. type: example
#: zsh.texi:27893
#, no-wrap
msgid ""
"xterm -e sh -c 'trap : INT QUIT TSTP; tty;\n"
"        while :; do sleep 100000000; done'\n"
msgstr ""
"xterm -e sh -c 'trap : INT QUIT TSTP; tty;\n"
"        while :; do sleep 100000000; done'\n"

#. type: table
#: zsh.texi:27901
msgid ""
"Some words of explanation are warranted about this long xterm command line: when doing clone on a pseudo-terminal, some other session (\"session\" meant as a unix session group, or SID) is already owning "
"the terminal. Hence the cloned zsh cannot acquire the pseudo-terminal as a controlling tty. That means two things:"
msgstr "关于这个长长的 xterm 命令行，有必要解释一下：在伪终端上进行克隆时，一些其他会话（\"会话\"指 unix 会话组或 SID）已经拥有了该终端。因此，克隆的 zsh 无法获取伪终端作为控制 tty。这意味着两件事："

#. type: itemize
#: zsh.texi:27909
msgid "the job control signals will go to the sh-started-by-xterm process group (that's why we disable INT QUIT and TSTP with trap; otherwise the while loop could get suspended or killed)"
msgstr "作业控制信号将进入 sh-started-by-xterm 进程组（这就是我们禁用 INT QUIT 和 TSTP 陷阱的原因，否则 while 循环可能会被暂停或删除）。"

#. type: itemize
#: zsh.texi:27912
msgid "the cloned shell will have job control disabled, and the job control keys (control-C, control-\\ and control-Z) will not work."
msgstr "克隆的 shell 将禁用作业控制功能，并且作业控制键（control-C、control-\\ 和 control-Z）将不起作用。"

#. type: table
#: zsh.texi:27916
msgid "This does not apply when cloning to an @emph{unused} vc."
msgstr "这不适用于克隆到 @emph{未使用的} vc。"

#. type: table
#: zsh.texi:27921
msgid "Cloning to a used (and unprepared) terminal will result in two processes reading simultaneously from the same terminal, with input bytes going randomly to either process."
msgstr "克隆到使用过的（和未准备好的）终端会导致两个进程同时从同一终端读取数据，输入字节会随机进入任一进程。"

#. type: table
#: zsh.texi:27925
msgid "@t{clone} is mostly useful as a shell built-in replacement for openvt."
msgstr "@t{clone} 主要是作为 openvt 的 shell 内置替代品。"

#. type: node
#: zsh.texi:27928 zsh.texi:27941 zsh.texi:27943 zsh.texi:27951
#, no-wrap
msgid "The zsh/complete Module"
msgstr "zsh/complete 模块"

#. type: Plain text
#: zsh.texi:27941
msgid ""
"The @t{zsh/compctl} module makes available two builtin commands. @t{compctl}, is the old, deprecated way to control completions for ZLE.  See @ref{Completion Using compctl}.  The other builtin command, "
"@t{compcall} can be used in user-defined completion widgets, see @ref{Completion Widgets}."
msgstr ""
"@t{zsh/compctl} 模块提供了两个内置命令。@t{compctl} 是控制 ZLE 补全的旧式、已废弃的方法。 请参阅 @ref{用 compctl 补全}。 另一条内置命令 @t{compcall} 可用于用户自定义的补全小部件，参见 @ref{补全小部件}。"

#. type: node
#: zsh.texi:27941 zsh.texi:27951 zsh.texi:27953 zsh.texi:28401
#, no-wrap
msgid "The zsh/complist Module"
msgstr "zsh/complist 模块"

#. type: Plain text
#: zsh.texi:27951
msgid "The @t{zsh/complete} module makes available several builtin commands which can be used in user-defined completion widgets, see @ref{Completion Widgets}."
msgstr "@t{zsh/complete} 模块提供了多个内置命令，这些命令可用于用户自定义的补全小部件，参见 @ref{补全小部件}。"

#. type: node
#: zsh.texi:27951 zsh.texi:28401 zsh.texi:28403 zsh.texi:28494
#, no-wrap
msgid "The zsh/computil Module"
msgstr "zsh/computil 模块"

#. type: cindex
#: zsh.texi:27958
#, no-wrap
msgid "completion, coloured listings"
msgstr "补全, 彩色列表"

#. type: cindex
#: zsh.texi:27959
#, no-wrap
msgid "completion, scroll listings"
msgstr "补全, 滚动列表"

#. type: Plain text
#: zsh.texi:27963
msgid ""
"The @t{zsh/complist} module offers three extensions to completion listings: the ability to highlight matches in such a list, the ability to scroll through long lists and a different style of menu "
"completion."
msgstr "@t{zsh/complist} 模块为补全列表提供了三种扩展功能：在此类列表中高亮显示匹配项的功能、滚动浏览长列表的功能以及不同风格的菜单补全功能。"

#. type: subsection
#: zsh.texi:27966
#, no-wrap
msgid "Colored completion listings"
msgstr "彩色补全列表"

#. type: Plain text
#: zsh.texi:27973
msgid ""
"Whenever one of the parameters @t{ZLS_COLORS} or @t{ZLS_COLOURS} is set and the @t{zsh/complist} module is loaded or linked into the shell, completion lists will be colored.  Note, however, that "
"@t{complist} will not automatically be loaded if it is not linked in: on systems with dynamic loading, `@t{zmodload zsh/complist}' is required."
msgstr ""
"只要设置了 @t{ZLS_COLORS} 或 @t{ZLS_COLOURS} 之一，并且 @t{zsh/complist} 模块已加载或链接到 shell 中，补全列表就会进行彩显。 但需要注意的是，如果 @t{complist} 没有被链接到 shell 中，则不会被自动加载：在使"
"用动态加载的系统中，需要使用 `@t{zmodload zsh/complist}' 。"

#. type: vindex
#: zsh.texi:27975
#, no-wrap
msgid "ZLS_COLORS"
msgstr "ZLS_COLORS"

#. type: vindex
#: zsh.texi:27976
#, no-wrap
msgid "ZLS_COLOURS"
msgstr "ZLS_COLOURS"

#. type: Plain text
#: zsh.texi:27985
msgid ""
"The parameters @t{ZLS_COLORS} and @t{ZLS_COLOURS} describe how matches are highlighted.  To turn on highlighting an empty value suffices, in which case all the default values given below will be used.  "
"The format of the value of these parameters is the same as used by the GNU version of the @t{ls} command: a colon-separated list of specifications of the form `@var{name}@t{=}@var{value}'.  The @var{name} "
"may be one of the following strings, most of which specify file types for which the @var{value} will be used.  The strings and their default values are:"
msgstr ""
"参数 @t{ZLS_COLORS} 和 @t{ZLS_COLOURS} 描述了如何高亮匹配。 要打开高亮效果，只需输入空值即可，在这种情况下，将使用下面给出的所有默认值。 这些参数值的格式与 GNU 版本的 @t{ls} 命令相同：一个以冒号分隔的列"
"表，其形式为 `@var{name}@t{=}@var{value}'。 @var{name} 可以是以下字符串之一，其中大部分字符串指定了 @var{value} 将被使用的文件类型。 这些字符串及其默认值是:"

#. type: t{#1}
#: zsh.texi:27988
#, no-wrap
msgid "no 0"
msgstr "no 0"

#. type: table
#: zsh.texi:27990
msgid "for normal text (i.e. when displaying something other than a matched file)"
msgstr "用于普通文本（即显示匹配文件以外的内容时）"

#. type: t{#1}
#: zsh.texi:27991
#, no-wrap
msgid "fi 0"
msgstr "fi 0"

#. type: table
#: zsh.texi:27993
msgid "for regular files"
msgstr "用于常规文件"

#. type: t{#1}
#: zsh.texi:27994
#, no-wrap
msgid "di 32"
msgstr "di 32"

#. type: table
#: zsh.texi:27996
msgid "for directories"
msgstr "用于目录"

#. type: t{#1}
#: zsh.texi:27997
#, no-wrap
msgid "ln 36"
msgstr "ln 36"

#. type: table
#: zsh.texi:28001
msgid "for symbolic links.  If this has the special value @t{target}, symbolic links are dereferenced and the target file used to determine the display format."
msgstr "用于符号链接。 如果具有特殊值 @t{target}，则符号链接将被解引用，并使用目标文件来确定显示格式。"

#. type: t{#1}
#: zsh.texi:28002
#, no-wrap
msgid "pi 31"
msgstr "pi 31"

#. type: table
#: zsh.texi:28004
msgid "for named pipes (FIFOs)"
msgstr "用于命名管道 (FIFOs)"

#. type: t{#1}
#: zsh.texi:28005
#, no-wrap
msgid "so 33"
msgstr "so 33"

#. type: table
#: zsh.texi:28007
msgid "for sockets"
msgstr "用于套接字"

#. type: t{#1}
#: zsh.texi:28008
#, no-wrap
msgid "bd 44;37"
msgstr "bd 44;37"

#. type: table
#: zsh.texi:28010
msgid "for block devices"
msgstr "用于块设备"

#. type: t{#1}
#: zsh.texi:28011
#, no-wrap
msgid "cd 44;37"
msgstr "cd 44;37"

#. type: table
#: zsh.texi:28013
msgid "for character devices"
msgstr "用于字符设备"

#. type: item
#: zsh.texi:28014
#, no-wrap
msgid "@t{or} @var{none}"
msgstr "@t{or} @var{none}"

#. type: table
#: zsh.texi:28016
msgid "for a symlink to nonexistent file (default is the value defined for @t{ln})"
msgstr "用于指向不存在文件的符号链接（默认值为 @t{ln} 中定义的值）"

#. type: item
#: zsh.texi:28017
#, no-wrap
msgid "@t{mi} @var{none}"
msgstr "@t{mi} @var{none}"

#. type: table
#: zsh.texi:28020
msgid "for a non-existent file (default is the value defined for @t{fi}); this code is currently not used"
msgstr "用于不存在的文件（默认值为 @t{fi} 定义的值）；该代码目前未被使用"

#. type: t{#1}
#: zsh.texi:28021
#, no-wrap
msgid "su 37;41"
msgstr "su 37;41"

#. type: table
#: zsh.texi:28023
msgid "for files with setuid bit set"
msgstr "用于设置了 setuid 位的文件"

#. type: t{#1}
#: zsh.texi:28024
#, no-wrap
msgid "sg 30;43"
msgstr "sg 30;43"

#. type: table
#: zsh.texi:28026
msgid "for files with setgid bit set"
msgstr "为设置了 setgid 位的文件"

#. type: t{#1}
#: zsh.texi:28027
#, no-wrap
msgid "tw 30;42"
msgstr "tw 30;42"

#. type: table
#: zsh.texi:28029
msgid "for world writable directories with sticky bit set"
msgstr "用于设置了粘着位的可供所有用户写入的目录"

#. type: t{#1}
#: zsh.texi:28030
#, no-wrap
msgid "ow 34;43"
msgstr "ow 34;43"

#. type: table
#: zsh.texi:28032
msgid "for world writable directories without sticky bit set"
msgstr "用于没有设置粘着位的可供所有用户写入的目录"

#. type: item
#: zsh.texi:28033
#, no-wrap
msgid "@t{sa} @var{none}"
msgstr "@t{sa} @var{none}"

#. type: table
#: zsh.texi:28036
msgid "for files with an associated suffix alias; this is only tested after specific suffixes, as described below"
msgstr "用于带有相关后缀别名的文件；这只在特定后缀后进行测试，如下所述"

#. type: t{#1}
#: zsh.texi:28037
#, no-wrap
msgid "st 37;44"
msgstr "st 37;44"

#. type: table
#: zsh.texi:28039
msgid "for directories with sticky bit set but not world writable"
msgstr "用于已设置粘着位但不是全局可写的目录"

#. type: t{#1}
#: zsh.texi:28040
#, no-wrap
msgid "ex 35"
msgstr "ex 35"

#. type: table
#: zsh.texi:28042
msgid "for executable files"
msgstr "用于可执行文件"

#. type: t{#1}
#: zsh.texi:28043
#, no-wrap
msgid "lc \\e["
msgstr "lc \\e["

#. type: table
#: zsh.texi:28045
msgid "for the left code (see below)"
msgstr "用于左侧代码（见下文）"

#. type: t{#1}
#: zsh.texi:28046
#, no-wrap
msgid "rc m"
msgstr "rc m"

#. type: table
#: zsh.texi:28048
msgid "for the right code"
msgstr "用于右侧代码"

#. type: t{#1}
#: zsh.texi:28049
#, no-wrap
msgid "tc 0"
msgstr "tc 0"

#. type: table
#: zsh.texi:28052
msgid "for the character indicating the file type printed after filenames if the @t{LIST_TYPES} option is set"
msgstr "用于在设置 @t{LIST_TYPES} 选项时在文件名后打印的表示文件类型的字符"

#. type: t{#1}
#: zsh.texi:28053
#, no-wrap
msgid "sp 0"
msgstr "sp 0"

#. type: table
#: zsh.texi:28055
msgid "for the spaces printed after matches to align the next column"
msgstr "用于匹配后打印的空格，以对齐下一列"

#. type: item
#: zsh.texi:28056
#, no-wrap
msgid "@t{ec} @var{none}"
msgstr "@t{ec} @var{none}"

#. type: table
#: zsh.texi:28058
msgid "for the end code"
msgstr "用于结束代码"

#. type: Plain text
#: zsh.texi:28072
msgid ""
"Apart from these strings, the @var{name} may also be an asterisk (`@t{*}') followed by any string. The @var{value} given for such a string will be used for all files whose name ends with the string.  The "
"@var{name} may also be an equals sign (`@t{=}') followed by a pattern; the @t{EXTENDED_GLOB} option will be turned on for evaluation of the pattern.  The @var{value} given for this pattern will be used "
"for all matches (not just filenames) whose display string are matched by the pattern.  Definitions for the form with the leading equal sign take precedence over the values defined for file types, which in "
"turn take precedence over the form with the leading asterisk (file extensions)."
msgstr ""
"除这些字符串外，@var{name} 也可以是星号 (`@t{*}')，后跟任何字符串。为此类字符串给出的 @var{value} 将用于名称以该字符串结尾的所有文件。 @var{name} 也可以是等号 (`@t{=}')，后面跟一个模式；在计算模式时，将启"
"用 @t{EXTENDED_GLOB} 选项。 为该模式提供的 @var{value} 将用于所有显示字符串与该模式匹配的匹配项（不只是文件名）。 带前导等号的形式的定义优先于为文件类型定义的值，而文件类型定义的值又优先于带前导星号的形式"
"（文件扩展名）。"

#. type: Plain text
#: zsh.texi:28086
msgid ""
"The leading-equals form also allows different parts of the displayed strings to be colored differently.  For this, the pattern has to use the `@t{(#b)}' globbing flag and pairs of parentheses surrounding "
"the parts of the strings that are to be colored differently.  In this case the @var{value} may consist of more than one color code separated by equal signs.  The first code will be used for all parts for "
"which no explicit code is specified and the following codes will be used for the parts matched by the sub-patterns in parentheses.  For example, the specification `@t{=(#b)(?)*(?)=0=3=7}' will be used for "
"all matches which are at least two characters long and will use the code `@t{3}' for the first character, `@t{7}' for the last character and `@t{0}' for the rest."
msgstr ""
"前导等于形式还允许对显示字符串的不同部分进行不同着色。 为此，模式必须使用 `@t{(#b)}' globbing 标志和围绕字符串颜色不同的部分的括号对。 在这种情况下，@var{value} 可以包含多个颜色代码，并用等号分隔。 第一个"
"代码将用于所有未指定明确代码的部分，后面的代码将用于与括号中子模式匹配的部分。 例如， `@t{=(#b)(?)*(?)=0=3=7}' 将用于所有匹配(至少两个字符长度的)，第一个字符使用 `@t{3}' 代码，最后一个字符使用 `@t{7}' 代"
"码，其余字符使用 `@t{0}' 代码。"

#. type: Plain text
#: zsh.texi:28095
msgid ""
"All three forms of @var{name} may be preceded by a pattern in parentheses.  If this is given, the @var{value} will be used only for matches in groups whose names are matched by the pattern given in the "
"parentheses.  For example, `@t{(g*)m*=43}' highlights all matches beginning with `@t{m}' in groups whose names begin with `@t{g}' using the color code `@t{43}'.  In case of the `@t{lc}', `@t{rc}', and "
"`@t{ec}' codes, the group pattern is ignored."
msgstr ""
"@var{name} 的三种形式前面都可以加上用括号括起来的模式。 如果给出了该模式，@var{value} 将仅用于名称与括号中给出的模式匹配的组中的匹配。 例如，`@t{(g*)m*=43}' 将使用颜色代码 `@t{43}' 高亮显示名称以 `@t{g}' "
"开头的组中所有以 `@t{m}' 开头的匹配项。 如果使用 `@t{lc}',`@t{rc}',和 `@t{ec}' 代码，组模式将被忽略。"

#. type: Plain text
#: zsh.texi:28103
msgid ""
"Note also that all patterns are tried in the order in which they appear in the parameter value until the first one matches which is then used.  Patterns may be matched against completions, descriptions "
"(possibly with spaces appended for padding), or lines consisting of a completion followed by a description.  For consistent coloring it may be necessary to use more than one pattern or a pattern with "
"backreferences."
msgstr ""
"还需注意的是，所有模式都会按其在参数值中出现的顺序进行尝试，直到第一个匹配的模式被使用为止。 模式可以与补全、描述（可能追加空格作为填充）或由补全和描述组成的行匹配。 为保持着色的一致性，可能需要使用多个模"
"式或带有反向引用的模式。"

#. type: Plain text
#: zsh.texi:28110
msgid ""
"When printing a match, the code prints the value of @t{lc}, the value for the file-type or the last matching specification with a `@t{*}', the value of @t{rc}, the string to display for the match itself, "
"and then the value of @t{ec} if that is defined or the values of @t{lc}, @t{no}, and @t{rc} if @t{ec} is not defined."
msgstr ""
"在打印匹配结果时，代码会打印 @t{lc} 的值、文件类型的值或带有 `@t{*}' 的最后一个匹配规范、@t{rc} 的值、要显示的匹配结果本身的字符串，然后是 @t{ec} 的值（如果已定义）或 @t{lc}、@t{no} 和 @t{rc} 的值（如果未"
"定义 @t{ec}）。"

#. type: Plain text
#: zsh.texi:28120
msgid ""
"The default values are ISO 6429 (ANSI) compliant and can be used on vt100 compatible terminals such as @t{xterm}s.  On monochrome terminals the default values will have no visible effect.  The @t{colors} "
"function from the contribution can be used to get associative arrays containing the codes for ANSI terminals (see @ref{Other Functions}).  For example, after loading @t{colors}, one could use "
"`@t{$color[red]}' to get the code for foreground color red and `@t{$color[bg-green]}' for the code for background color green."
msgstr ""
"默认值符合 ISO 6429（ANSI）标准，可用于 vt100 兼容终端（如 @t{xterm}s）。 在单色终端上，默认值不会产生明显影响。 贡献中的 @t{colors} 函数可用于获取包含 ANSI 终端代码的关联数组（参见 @ref{其它函数}）。 例"
"如，加载 @t{colors} 后，可以使用 `@t{$color[red]}' 为前景色获取红色的代码，使用 `@t{$color[bg-green]}' 为背景色获取绿色的代码。"

#. type: Plain text
#: zsh.texi:28126
msgid ""
"If the completion system invoked by compinit is used, these parameters should not be set directly because the system controls them itself.  Instead, the @t{list-colors} style should be used (see "
"@ref{Completion System Configuration})."
msgstr "如果使用的是由 compinit 调用的补全系统，则不应直接设置这些参数，因为系统会自行控制它们。 相反，应使用 @t{list-colors} 样式（参见 @ref{补全系统配置}）。"

#. type: subsection
#: zsh.texi:28129
#, no-wrap
msgid "Scrolling in completion listings"
msgstr "在补全列表中滚动"

#. type: Plain text
#: zsh.texi:28147
msgid ""
"To enable scrolling through a completion list, the @t{LISTPROMPT} parameter must be set.  Its value will be used as the prompt; if it is the empty string, a default prompt will be used.  The value may "
"contain escapes of the form `@t{%x}'.  It supports the escapes `@t{%B}', `@t{%b}', `@t{%S}', `@t{%s}', `@t{%U}', `@t{%u}', `@t{%F}', `@t{%f}', `@t{%K}', `@t{%k}' and `@t{%@{}@var{...}@t{%@}}' used also in "
"shell prompts as well as three pairs of additional sequences: a `@t{%l}' or `@t{%L}' is replaced by the number of the last line shown and the total number of lines in the form `@var{number}@t{/}"
"@var{total}'; a `@t{%m}' or `@t{%M}' is replaced with the number of the last match shown and the total number of matches; and `@t{%p}' or `@t{%P}' is replaced with `@t{Top}', `@t{Bottom}' or the position "
"of the first line shown in percent of the total number of lines, respectively.  In each of these cases the form with the uppercase letter will be replaced with a string of fixed width, padded to the right "
"with spaces, while the lowercase form will not be padded."
msgstr ""
"要启用滚动浏览补全列表，必须设置 @t{LISTPROMPT} 参数。 其值将用作提示符；如果是空字符串，则使用默认提示符。 该值可包含 `@t{%x}' 形式的转义字符。 它支持转义符 `@t{%B}', `@t{%b}', `@t{%S}', `@t{%s}', "
"`@t{%U}', `@t{%u}', `@t{%F}', `@t{%f}', `@t{%K}', `@t{%k}' 和 `@t{%@{}@var{...}@t{%@}}' 也用于 shell 提示符以及三对附加序列： `@t{%l}' 或 `@t{%L}' 会被最后显示的行数和总行数替换，形式为 `@var{number}@t{/}"
"@var{total}'；`@t{%m}' 或 `@t{%M}' 会被最后显示的匹配行数和总匹配行数替换； `@t{%p}' 或 `@t{%P}' 分别替换为 `@t{Top}'、`@t{Bottom}' 或显示的第一行的位置（占总行数的百分比）。 在上述每种情况下，大写字母形式"
"将被替换为固定宽度的字符串，并在右侧填充空格，而小写字母形式则不填充空格。"

#. type: Plain text
#: zsh.texi:28155
msgid ""
"If the parameter @t{LISTPROMPT} is set, the completion code will not ask if the list should be shown.  Instead it immediately starts displaying the list, stopping after the first screenful, showing the "
"prompt at the bottom, waiting for a keypress after temporarily switching to the @t{listscroll} keymap.  Some of the zle functions have a special meaning while scrolling lists:"
msgstr ""
"如果设置了参数 @t{LISTPROMPT}，补全代码将不会询问是否显示列表。 相反，它会立即开始显示列表，在显示第一屏后停止，在底部显示提示符，在临时切换到 @t{listscroll} 键映射后等待按键。 在滚动列表时，zle 的某些函数"
"具有特殊意义："

#. type: table
#: zsh.texi:28160
msgid "stops listing discarding the key pressed"
msgstr "停止列表，丢弃已按下的键"

#. type: item
#: zsh.texi:28161
#, no-wrap
msgid "@t{accept-line}, @t{down-history}, @t{down-line-or-history}"
msgstr "@t{accept-line}, @t{down-history}, @t{down-line-or-history}"

#. type: itemx
#: zsh.texi:28162
#, no-wrap
msgid "@t{down-line-or-search}, @t{vi-down-line-or-history}"
msgstr "@t{down-line-or-search}, @t{vi-down-line-or-history}"

#. type: table
#: zsh.texi:28164
msgid "scrolls forward one line"
msgstr "向前滚动一行"

#. type: item
#: zsh.texi:28165 zsh.texi:28350
#, no-wrap
msgid "@t{complete-word}, @t{menu-complete}, @t{expand-or-complete}"
msgstr "@t{complete-word}, @t{menu-complete}, @t{expand-or-complete}"

#. type: itemx
#: zsh.texi:28166
#, no-wrap
msgid "@t{expand-or-complete-prefix}, @t{menu-complete-or-expand}"
msgstr "@t{expand-or-complete-prefix}, @t{menu-complete-or-expand}"

#. type: table
#: zsh.texi:28168
msgid "scrolls forward one screenful"
msgstr "向前滚动一屏"

#. type: table
#: zsh.texi:28171
msgid "stop listing but take no other action"
msgstr "停止列表，但不采取其他行动"

#. type: Plain text
#: zsh.texi:28179
msgid ""
"Every other character stops listing and immediately processes the key as usual.  Any key that is not bound in the @t{listscroll} keymap or that is bound to @t{undefined-key} is looked up in the keymap "
"currently selected."
msgstr "其他每个字符都会停止列表，并立即像往常一样处理按键。 任何未在 @t{listscroll} 键盘映射中绑定或绑定到 @t{undefined-key} 的按键都会在当前选定的键盘映射中查找。"

#. type: Plain text
#: zsh.texi:28185
msgid ""
"As for the @t{ZLS_COLORS} and @t{ZLS_COLOURS} parameters, @t{LISTPROMPT} should not be set directly when using the shell function based completion system.  Instead, the @t{list-prompt} style should be "
"used."
msgstr "至于 @t{ZLS_COLORS} 和 @t{ZLS_COLOURS} 参数，在使用基于 shell 函数的补全系统时，不应直接设置 @t{LISTPROMPT}。 相反，应使用 @t{list-prompt} 样式。"

#. type: subsection
#: zsh.texi:28188
#, no-wrap
msgid "Menu selection"
msgstr "菜单选择"

#. type: cindex
#: zsh.texi:28190
#, no-wrap
msgid "completion, selecting by cursor"
msgstr "补全, 用光标选择"

#. type: vindex
#: zsh.texi:28191
#, no-wrap
msgid "MENUSELECT"
msgstr "MENUSELECT"

#. type: tindex
#: zsh.texi:28192
#, no-wrap
msgid "menu-select"
msgstr "menu-select"

#. type: Plain text
#: zsh.texi:28198
msgid ""
"The @t{zsh/complist} module also offers an alternative style of selecting matches from a list, called menu selection, which can be used if the shell is set up to return to the last prompt after showing a "
"completion list (see the @t{ALWAYS_LAST_PROMPT} option in @ref{Options})."
msgstr ""
"@t{zsh/complist} 模块还提供了另一种从列表中选择匹配项的方式，称为菜单选择，如果 shell 设置为在显示补全列表后返回最后（近）一个提示符（参见 @ref{选项} 中的 @t{ALWAYS_LAST_PROMPT} 选项），则可以使用这种方"
"式。"

#. type: Plain text
#: zsh.texi:28204
msgid ""
"Menu selection can be invoked directly by the widget @t{menu-select} defined by this module.  This is a standard ZLE widget that can be bound to a key in the usual way as described in @ref{Zsh Line "
"Editor}."
msgstr "本模块定义的小部件 @t{menu-select} 可直接调用菜单选择。 这是一个标准的 ZLE 小部件，可以按照 @ref{Zsh 行编辑器}中描述的常规方式与按键绑定。"

#. type: Plain text
#: zsh.texi:28214
msgid ""
"Alternatively, the parameter @t{MENUSELECT} can be set to an integer, which gives the minimum number of matches that must be present before menu selection is automatically turned on.  This second method "
"requires that menu completion be started, either directly from a widget such as @t{menu-complete}, or due to one of the options @t{MENU_COMPLETE} or @t{AUTO_MENU} being set.  If @t{MENUSELECT} is set, but "
"is 0, 1 or empty, menu selection will always be started during an ambiguous menu completion."
msgstr ""
"或者，也可以将参数 @t{MENUSELECT} 设置为一个整数，它给出了在菜单选择自动开启之前必须存在的最小匹配数。 第二种方法要求菜单补全必须启动，可以直接从 @t{menu-complete} 等小部件启动，也可以由于设置了 "
"@t{MENU_COMPLETE} 或 @t{AUTO_MENU} 选项之一而启动。 如果设置了 @t{MENUSELECT}，但其值为 0、1 或空，则菜单选择将始终在模糊菜单补全期间启动。"

#. type: Plain text
#: zsh.texi:28220
msgid ""
"When using the completion system based on shell functions, the @t{MENUSELECT} parameter should not be used (like the @t{ZLS_COLORS} and @t{ZLS_COLOURS} parameters described above).  Instead, the @t{menu} "
"style should be used with the @t{select=}@var{...} keyword."
msgstr "在使用基于 shell 函数的补全系统时，不应使用 @t{MENUSELECT} 参数（如上文所述的 @t{ZLS_COLORS} 和 @t{ZLS_COLOURS} 参数）。 相反，应该与 @t{select=}@var{...} 关键字一起使用 @t{menu} 样式。"

#. type: Plain text
#: zsh.texi:28232
msgid ""
"After menu selection is started, the matches will be listed. If there are more matches than fit on the screen, only the first screenful is shown.  The matches to insert into the command line can be "
"selected from this list.  In the list one match is highlighted using the value for @t{ma} from the @t{ZLS_COLORS} or @t{ZLS_COLOURS} parameter.  The default value for this is `@t{7}' which forces the "
"selected match to be highlighted using standout mode on a vt100-compatible terminal.  If neither @t{ZLS_COLORS} nor @t{ZLS_COLOURS} is set, the same terminal control sequence as for the `@t{%S}' escape in "
"prompts is used."
msgstr ""
"菜单选择开始后，将列出匹配结果。如果屏幕上的匹配项较多，则只显示第一屏。 可以从列表中选择要插入命令行的匹配项。 在列表中，将使用 @t{ZLS_COLORS} 或 @t{ZLS_COLOURS} 参数中的 @t{ma} 值突出显示一个匹配项。 默"
"认值为 `@t{7}' ，这将强制在兼容 vt100 的终端上使用突出显示模式突出显示选定的匹配。 如果既未设置 @t{ZLS_COLORS} 也未设置 @t{ZLS_COLOURS}，则会使用与提示符中的 `@t{%S}' 转义相同的终端控制序列。"

#. type: Plain text
#: zsh.texi:28240
msgid ""
"If there are more matches than fit on the screen and the parameter @t{MENUPROMPT} is set, its value will be shown below the matches.  It supports the same escape sequences as @t{LISTPROMPT}, but the "
"number of the match or line shown will be that of the one where the mark is placed.  If its value is the empty string, a default prompt will be used."
msgstr ""
"如果屏幕上的匹配项较多，且参数 @t{MENUPROMPT} 已设置，则其值将显示在匹配项下方。 它支持与 @t{LISTPROMPT} 相同的转义序列，但显示的匹配项或行的编号将是放置标记的匹配项或行的编号。 如果其值为空字符串，将使用"
"默认提示符。"

#. type: Plain text
#: zsh.texi:28248
msgid ""
"The @t{MENUSCROLL} parameter can be used to specify how the list is scrolled.  If the parameter is unset, this is done line by line, if it is set to `@t{0}' (zero), the list will scroll half the number of "
"lines of the screen.  If the value is positive, it gives the number of lines to scroll and if it is negative, the list will be scrolled the number of lines of the screen minus the (absolute) value."
msgstr ""
"@t{MENUSCROLL} 参数可用于指定列表的滚动方式。 如果未设置该参数，将逐行滚动；如果设置为`@t{0}'（零），列表将滚动屏幕行数的一半。 如果参数值为正数，则滚动的行数为正数；如果参数值为负数，则滚动的行数为屏幕行"
"数减去这个值（绝对值）后的行数。"

#. type: Plain text
#: zsh.texi:28255
msgid ""
"As for the @t{ZLS_COLORS}, @t{ZLS_COLOURS} and @t{LISTPROMPT} parameters, neither @t{MENUPROMPT} nor @t{MENUSCROLL} should be set directly when using the shell function based completion system.  Instead, "
"the @t{select-prompt} and @t{select-scroll} styles should be used."
msgstr ""
"至于 @t{ZLS_COLORS}、@t{ZLS_COLOURS} 和 @t{LISTPROMPT} 参数，在使用基于 shell 函数的补全系统时，不应直接设置 @t{MENUPROMPT} 或 @t{MENUSCROLL}。 相反，应使用 @t{select-prompt} 和 @t{select-scroll} 样式。"

#. type: Plain text
#: zsh.texi:28268
msgid ""
"The completion code sometimes decides not to show all of the matches in the list.  These hidden matches are either matches for which the completion function which added them explicitly requested that they "
"not appear in the list (using the @t{-n} option of the @t{compadd} builtin command) or they are matches which duplicate a string already in the list (because they differ only in things like prefixes or "
"suffixes that are not displayed).  In the list used for menu selection, however, even these matches are shown so that it is possible to select them.  To highlight such matches the @t{hi} and @t{du} "
"capabilities in the @t{ZLS_COLORS} and @t{ZLS_COLOURS} parameters are supported for hidden matches of the first and second kind, respectively."
msgstr ""
"补全代码有时会决定不在列表中显示所有匹配项。 这些隐藏的匹配项要么是添加匹配项的补全函数明确要求不在列表中显示的匹配项（使用 @t{compadd} 内置命令的 @t{-n} 选项），要么是与列表中已存在的字符串重复的匹配项"
"（因为它们仅在前缀或后缀等未显示的内容上存在差异）。 不过，在用于菜单选择的列表中，即使是这些匹配也会显示出来，因此可以选择它们。 为了突出显示这类匹配，@t{ZLS_COLORS} 和 @t{ZLS_COLOURS} 参数中的 @t{hi} 和 "
"@t{du} 功能分别支持第一类和第二类隐藏匹配。"

#. type: Plain text
#: zsh.texi:28278
msgid ""
"Selecting matches is done by moving the mark around using the zle movement functions.  When not all matches can be shown on the screen at the same time, the list will scroll up and down when crossing the "
"top or bottom line.  The following zle functions have special meaning during menu selection.  Note that the following always perform the same task within the menu selection map and cannot be replaced by "
"user defined widgets, nor can the set of functions be extended:"
msgstr ""
"通过使用 zle 移动函数移动标记来选择匹配项。 当屏幕上不能同时显示所有匹配时，列表会在越过顶线或底线时上下滚动。 下列 zle 函数在菜单选择时具有特殊意义。 请注意，以下函数在菜单选择映射中始终执行相同的任务，不"
"能被用户定义的小部件取代，也不能扩展函数集："

#. type: item
#: zsh.texi:28281
#, no-wrap
msgid "@t{accept-line}, @t{accept-search}"
msgstr "@t{accept-line}, @t{accept-search}"

#. type: table
#: zsh.texi:28284
msgid "accept the current match and leave menu selection (but do not cause the command line to be accepted)"
msgstr "接受当前匹配并离开菜单选择（但不接受命令行）"

#. type: table
#: zsh.texi:28288
msgid "leaves menu selection and restores the previous contents of the command line"
msgstr "退出菜单选择并恢复之前命令行的内容"

#. type: item
#: zsh.texi:28289
#, no-wrap
msgid "@t{redisplay}, @t{clear-screen}"
msgstr "@t{redisplay}, @t{clear-screen}"

#. type: table
#: zsh.texi:28291
msgid "execute their normal function without leaving menu selection"
msgstr "在不离开菜单选择的情况下执行其正常函数"

#. type: item
#: zsh.texi:28292
#, no-wrap
msgid "@t{accept-and-hold}, @t{accept-and-menu-complete}"
msgstr "@t{accept-and-hold}, @t{accept-and-menu-complete}"

#. type: table
#: zsh.texi:28295
msgid "accept the currently inserted match and continue selection allowing to select the next match to insert into the line"
msgstr "接受当前插入的匹配项，并继续选择，允许选择下一个匹配项插入该行"

#. type: table
#: zsh.texi:28304
msgid ""
"accepts the current match and then tries completion with menu selection again; in the case of files this allows one to select a directory and immediately attempt to complete files in it; if there are no "
"matches, a message is shown and one can use @t{undo} to go back to completion on the previous level, every other key leaves menu selection (including the other zle functions which are otherwise special "
"during menu selection)"
msgstr ""
"接受当前的匹配结果，然后再次尝试用菜单选择来补全；在文件的情况下，这允许选择一个目录并立即尝试补全其中的文件；如果没有匹配结果，则会显示一条信息，可以使用 @t{undo} 返回上一级的补全，其他所有按键都会离开菜"
"单选择（包括菜单选择期间其他特殊的 zle 功能）。"

#. type: table
#: zsh.texi:28308
msgid "removes matches inserted during the menu selection by one of the three functions before"
msgstr "删除在菜单选择过程中由前面三个函数之一插入的匹配项。"

#. type: item
#: zsh.texi:28309
#, no-wrap
msgid "@t{down-history}, @t{down-line-or-history}"
msgstr "@t{down-history}, @t{down-line-or-history}"

#. type: itemx
#: zsh.texi:28310
#, no-wrap
msgid "@t{vi-down-line-or-history},  @t{down-line-or-search}"
msgstr "@t{vi-down-line-or-history},  @t{down-line-or-search}"

#. type: table
#: zsh.texi:28312
msgid "moves the mark one line down"
msgstr "将标记向下移动一行"

#. type: item
#: zsh.texi:28313
#, no-wrap
msgid "@t{up-history}, @t{up-line-or-history}"
msgstr "@t{up-history}, @t{up-line-or-history}"

#. type: itemx
#: zsh.texi:28314
#, no-wrap
msgid "@t{vi-up-line-or-history}, @t{up-line-or-search}"
msgstr "@t{vi-up-line-or-history}, @t{up-line-or-search}"

#. type: table
#: zsh.texi:28316
msgid "moves the mark one line up"
msgstr "将标记向上移动一行"

#. type: item
#: zsh.texi:28317
#, no-wrap
msgid "@t{forward-char}, @t{vi-forward-char}"
msgstr "@t{forward-char}, @t{vi-forward-char}"

#. type: table
#: zsh.texi:28319
msgid "moves the mark one column right"
msgstr "将标记向右移动一列"

#. type: item
#: zsh.texi:28320
#, no-wrap
msgid "@t{backward-char}, @t{vi-backward-char}"
msgstr "@t{backward-char}, @t{vi-backward-char}"

#. type: table
#: zsh.texi:28322
msgid "moves the mark one column left"
msgstr "将标记向左移动一列"

#. type: item
#: zsh.texi:28323
#, no-wrap
msgid "@t{forward-word}, @t{vi-forward-word}"
msgstr "@t{forward-word}, @t{vi-forward-word}"

#. type: itemx
#: zsh.texi:28324
#, no-wrap
msgid "@t{vi-forward-word-end}, @t{emacs-forward-word}"
msgstr "@t{vi-forward-word-end}, @t{emacs-forward-word}"

#. type: table
#: zsh.texi:28326
msgid "moves the mark one screenful down"
msgstr "将标记向下移动一屏"

#. type: item
#: zsh.texi:28327
#, no-wrap
msgid "@t{backward-word}, @t{vi-backward-word}, @t{emacs-backward-word}"
msgstr "@t{backward-word}, @t{vi-backward-word}, @t{emacs-backward-word}"

#. type: table
#: zsh.texi:28329
msgid "moves the mark one screenful up"
msgstr "将标记向上移动一屏"

#. type: item
#: zsh.texi:28330
#, no-wrap
msgid "@t{vi-forward-blank-word}, @t{vi-forward-blank-word-end}"
msgstr "@t{vi-forward-blank-word}, @t{vi-forward-blank-word-end}"

#. type: table
#: zsh.texi:28332
msgid "moves the mark to the first line of the next group of matches"
msgstr "将标记移至下一组匹配的第一行"

#. type: table
#: zsh.texi:28335
msgid "moves the mark to the last line of the previous group of matches"
msgstr "将标记移至前一组匹配的最后一行"

#. type: table
#: zsh.texi:28338
msgid "moves the mark to the first line"
msgstr "将标记移至第一行"

#. type: table
#: zsh.texi:28341
msgid "moves the mark to the last line"
msgstr "将标记移至最后一行"

#. type: item
#: zsh.texi:28342
#, no-wrap
msgid "@t{beginning-of-buffer-or-history}, @t{beginning-of-line}"
msgstr "@t{beginning-of-buffer-or-history}, @t{beginning-of-line}"

#. type: itemx
#: zsh.texi:28343
#, no-wrap
msgid "@t{beginning-of-line-hist}, @t{vi-beginning-of-line}"
msgstr "@t{beginning-of-line-hist}, @t{vi-beginning-of-line}"

#. type: table
#: zsh.texi:28345
msgid "moves the mark to the leftmost column"
msgstr "将标记移到最左边一列"

#. type: item
#: zsh.texi:28346
#, no-wrap
msgid "@t{end-of-buffer-or-history}, @t{end-of-line}"
msgstr "@t{end-of-buffer-or-history}, @t{end-of-line}"

#. type: itemx
#: zsh.texi:28347
#, no-wrap
msgid "@t{end-of-line-hist}, @t{vi-end-of-line}"
msgstr "@t{end-of-line-hist}, @t{vi-end-of-line}"

#. type: table
#: zsh.texi:28349
msgid "moves the mark to the rightmost column"
msgstr "将标记移到最右边一列"

#. type: itemx
#: zsh.texi:28351
#, no-wrap
msgid "@t{expand-or-complete-prefix}, @t{menu-expand-or-complete}"
msgstr "@t{expand-or-complete-prefix}, @t{menu-expand-or-complete}"

#. type: table
#: zsh.texi:28353
msgid "moves the mark to the next match"
msgstr "将标记移动到下一个匹配"

#. type: table
#: zsh.texi:28356
msgid "moves the mark to the previous match"
msgstr "将标记移至上一个匹配"

#. type: table
#: zsh.texi:28366
msgid ""
"this toggles between normal and interactive mode; in interactive mode the keys bound to @t{self-insert} and @t{self-insert-unmeta} insert into the command line as in normal editing mode but without "
"leaving menu selection; after each character completion is tried again and the list changes to contain only the new matches; the completion widgets make the longest unambiguous string be inserted in the "
"command line and @t{undo} and @t{backward-delete-char} go back to the previous set of matches"
msgstr ""
"这将在正常模式和交互模式之间切换；在交互模式下，与 @t{self-insert} 和 @t{self-insert-unmeta} 绑定的按键会像正常编辑模式一样插入命令行，但不会离开菜单选择；每个字符补全后都会再次尝试，列表会更改为只包含新的"
"匹配字符；补全部件会将最长的无歧义字符串插入命令行，而 @t{undo} 和 @t{backward-delete-char} 则会返回到上一组匹配字符串"

#. type: table
#: zsh.texi:28372
msgid "this starts incremental searches in the list of completions displayed; in this mode, @t{accept-line} only leaves incremental search, going back to the normal menu selection mode"
msgstr "这会开始在显示的补全列表中进行增量搜索；在这种模式下，@t{accept-line} 只会离开增量搜索，回到正常的菜单选择模式"

#. type: Plain text
#: zsh.texi:28381
msgid ""
"All movement functions wrap around at the edges; any other zle function not listed leaves menu selection and executes that function.  It is possible to make widgets in the above list do the same by using "
"the form of the widget with a `@t{.}' in front.  For example, the widget `@t{.accept-line}' has the effect of leaving menu selection and accepting the entire command line."
msgstr ""
"所有移动函数都会在边缘回绕；任何其他未列出的 zle 函数都会离开菜单选择并执行该函数。 通过使用前面带有`@t{.}' 的小部件形式，可以使上述列表中的小部件具有相同的功能。 例如，小部件 `@t{.accept-line}' 具有离开菜"
"单选择并接受整个命令行的效果。"

#. type: Plain text
#: zsh.texi:28392
msgid ""
"During this selection the widget uses the keymap @t{menuselect}.  Any key that is not defined in this keymap or that is bound to @t{undefined-key} is looked up in the keymap currently selected.  This is "
"used to ensure that the most important keys used during selection (namely the cursor keys, return, and TAB) have sensible defaults.  However, keys in the @t{menuselect} keymap can be modified directly "
"using the @t{bindkey} builtin command (see @ref{The zsh/zle Module}). For example, to make the return key leave menu selection without accepting the match currently selected one could call"
msgstr ""
"在选择过程中，widget 会使用键映射 @t{menuselect}。 任何未在此键映射中定义或绑定到 @t{undefined-key} 的按键都会在当前选择的键映射中查找。 这样做是为了确保在选择过程中使用的最重要按键（即光标键、回车键和 "
"TAB 键）具有合理的默认值。 不过，可以使用 @t{bindkey} 内置命令直接修改 @t{menuselect} 键映射中的按键（参见 @ref{zsh/zle 模块}）。例如，要使返回键离开菜单选择而不接受当前选择的匹配，可以调用"

#. type: example
#: zsh.texi:28396
#, no-wrap
msgid "bindkey -M menuselect '^M' send-break\n"
msgstr "bindkey -M menuselect '^M' send-break\n"

#. type: Plain text
#: zsh.texi:28401
msgid "after loading the @t{zsh/complist} module."
msgstr "加载 @t{zsh/complist} 模块后。"

#. type: node
#: zsh.texi:28401 zsh.texi:28494 zsh.texi:28496 zsh.texi:28812
#, no-wrap
msgid "The zsh/curses Module"
msgstr "zsh/curses 模块"

#. type: cindex
#: zsh.texi:28407
#, no-wrap
msgid "completion, utility"
msgstr "补全, 实用工具"

#. type: Plain text
#: zsh.texi:28415
msgid ""
"The @t{zsh/computil} module adds several builtin commands that are used by some of the completion functions in the completion system based on shell functions (see @ref{Completion System} ).  Except for "
"@t{compquote} these builtin commands are very specialised and thus not very interesting when writing your own completion functions.  In summary, these builtin commands are:"
msgstr ""
"@t{zsh/computil} 模块为基于 shell 函数的补全系统（参见 @ref{补全系统} ）中的某些补全函数添加了几条内置命令。 除了 @t{compquote} 之外，这些内置命令都非常专业，因此在编写自己的补全函数时并不十分有趣。 总之，"
"这些内置命令包括"

#. type: table
#: zsh.texi:28424
msgid ""
"This is used by the @t{_arguments} function to do the argument and command line parsing.  Like @t{compdescribe} it has an option @t{-i} to do the parsing and initialize some internal state and various "
"options to access the state information to decide what should be completed."
msgstr "@t{_arguments} 函数使用它来进行参数和命令行解析。 与 @t{compdescribe} 一样，它也有一个选项 @t{-i} 来完成解析并初始化一些内部状态，还有各种选项来访问状态信息，以决定应补全哪些内容。"

#. type: table
#: zsh.texi:28435
msgid ""
"This is used by the @t{_describe} function to build the displays for the matches and to get the strings to add as matches with their options.  On the first call one of the options @t{-i} or @t{-I} should "
"be supplied as the first argument.  In the first case, display strings without the descriptions will be generated, in the second case, the string used to separate the matches from their descriptions must "
"be given as the second argument and the descriptions (if any) will be shown.  All other arguments are like the definition arguments to @t{_describe} itself."
msgstr ""
"@t{_describe} 函数使用它来构建匹配的显示，并获取要添加为匹配项的字符串及其选项。 第一次调用时，应将 @t{-i} 或 @t{-I} 选项之一作为第一个参数提供。 在第一种情况下，将生成不带说明的显示字符串；在第二种情况"
"下，必须将用于分隔匹配字符串和说明的字符串作为第二个参数，然后显示说明（如果有的话）。 所有其他参数与 @t{_describe} 本身的定义参数相同。"

#. type: table
#: zsh.texi:28445
msgid ""
"Once @t{compdescribe} has been called with either the @t{-i} or the @t{-I} option, it can be repeatedly called with the @t{-g} option and the names of four parameters as its arguments.  This will step "
"through the different sets of matches and store the value of @t{compstate[list]} in the first scalar, the options for @t{compadd} in the second array, the matches in the third array, and the strings to be "
"displayed in the completion listing in the fourth array.  The arrays may then be directly given to @t{compadd} to register the matches with the completion code."
msgstr ""
"使用 @t{-i} 或 @t{-I} 选项调用 @t{compdescribe} 后，可以使用 @t{-g} 选项和四个参数的名称作为参数反复调用。 这将逐步处理不同的匹配集，并在第一个标量中存储 @t{compstate[list]} 的值，在第二个数组中存储 "
"@t{compadd} 的选项，在第三个数组中存储匹配结果，在第四个数组中存储要在补全列表中显示的字符串。 然后可以直接将这些数组交给 @t{compadd}，以便将匹配结果注册到补全代码中。"

#. type: table
#: zsh.texi:28457
msgid ""
"Used by the @t{_path_files} function to optimize complex recursive filename generation (globbing).  It does three things.  With the @t{-p} and @t{-P} options it builds the glob patterns to use, including "
"the paths already handled and trying to optimize the patterns with respect to the prefix and suffix from the line and the match specification currently used.  The @t{-i} option does the directory tests "
"for the @t{ignore-parents} style and the @t{-r} option tests if a component for some of the matches are equal to the string on the line and removes all other matches if that is true."
msgstr ""
"用于 @t{_path_files} 函数,以优化复杂递归文件名的生成（globbing）。 它会做三件事。 使用 @t{-p} 和 @t{-P} 选项，它会构建要使用的 glob 模式，包括已经处理过的路径，并尝试根据行中的前缀和后缀以及当前使用的匹配"
"规范优化模式。 @t{-i} 选项会对 @t{ignore-parents} 样式进行目录测试，而 @t{-r} 选项则会测试某些匹配项的组件是否等于行中的字符串，如果为真，则会移除所有其他匹配项。"

#. type: table
#: zsh.texi:28465
msgid ""
"Used by the @t{_tags} function to implement the internals of the @t{group-order} style.  This only takes its arguments as names of completion groups and creates the groups for it (all six types: sorted "
"and unsorted, both without removing duplicates, with removing all duplicates and with removing consecutive duplicates)."
msgstr "由 @t{_tags} 函数使用，用于实现 @t{group-order} 样式的内部。 它只接收作为补全分组名称的参数，并为其创建分组（所有六种类型：排序和不排序，均不去除重复、去除全部重复和去除连续重复）。"

#. type: item
#: zsh.texi:28467
#, no-wrap
msgid "@t{compquote} [ @t{-p} ] @var{names} ..."
msgstr "@t{compquote} [ @t{-p} ] @var{names} ..."

#. type: table
#: zsh.texi:28478
msgid ""
"There may be reasons to write completion functions that have to add the matches using the @t{-Q} option to @t{compadd} and perform quoting themselves.  Instead of interpreting the first character of the "
"@t{all_quotes} key of the @t{compstate} special association and using the @t{q} flag for parameter expansions, one can use this builtin command.  The arguments are the names of scalar or array parameters "
"and the values of these parameters are quoted as needed for the innermost quoting level.  If the @t{-p} option is given, quoting is done as if there is some prefix before the values of the parameters, so "
"that a leading equal sign will not be quoted."
msgstr ""
"编写补全函数时可能会有一些原因，必须使用 @t{-Q} 选项将匹配结果添加到 @t{compadd} 并自行执行引用（加引号）。 与其解释 @t{compstate} 特殊关联数组的 @t{all_quotes} 键的第一个字符，并使用 @t{q} 标志进行参数扩"
"展，不如使用这条内置命令。 参数是标量或数组参数的名称，这些参数的值根据需要为最内层的加引号。 如果给定了 @t{-p} 选项，会加上引号，就像参数值前有一些前缀，因此前导等号不会加引号。"

#. type: table
#: zsh.texi:28481
msgid "The return status is non-zero in case of an error and zero otherwise."
msgstr "如果出现错误，返回状态为非零，否则为零。"

#. type: table
#: zsh.texi:28487
msgid "These implement the internals of the tags mechanism."
msgstr "它们实现了标记机制的内部功能。"

#. type: table
#: zsh.texi:28491
msgid "Like @t{comparguments}, but for the @t{_values} function."
msgstr "与 @t{comparguments} 类似，但用于 @t{_values} 函数。"

#. type: node
#: zsh.texi:28494 zsh.texi:28812 zsh.texi:28814 zsh.texi:28919
#, no-wrap
msgid "The zsh/datetime Module"
msgstr "zsh/datetime 模块"

#. type: Plain text
#: zsh.texi:28502
msgid "The @t{zsh/curses} module makes available one builtin command and various parameters."
msgstr "@t{zsh/curses} 模块提供了一条内置命令和各种参数。"

#. type: subsection
#: zsh.texi:28505
#, no-wrap
msgid "Builtin"
msgstr "内置程序"

#. type: findex
#: zsh.texi:28510
#, no-wrap
msgid "zcurses"
msgstr "zcurses"

#. type: cindex
#: zsh.texi:28511
#, no-wrap
msgid "windows, curses"
msgstr "窗口, curses"

#. type: item
#: zsh.texi:28512
#, no-wrap
msgid "@t{zcurses} @t{init}"
msgstr "@t{zcurses} @t{init}"

#. type: itemx
#: zsh.texi:28513
#, no-wrap
msgid "@t{zcurses} @t{end}"
msgstr "@t{zcurses} @t{end}"

#. type: itemx
#: zsh.texi:28514
#, no-wrap
msgid "@t{zcurses} @t{addwin} @var{targetwin} @var{nlines} @var{ncols} @var{begin_y} @var{begin_x} [ @var{parentwin} ]"
msgstr "@t{zcurses} @t{addwin} @var{targetwin} @var{nlines} @var{ncols} @var{begin_y} @var{begin_x} [ @var{parentwin} ]"

#. type: itemx
#: zsh.texi:28515
#, no-wrap
msgid "@t{zcurses} @t{delwin} @var{targetwin}"
msgstr "@t{zcurses} @t{delwin} @var{targetwin}"

#. type: itemx
#: zsh.texi:28516
#, no-wrap
msgid "@t{zcurses} @t{refresh} [ @var{targetwin} ... ]"
msgstr "@t{zcurses} @t{refresh} [ @var{targetwin} ... ]"

#. type: itemx
#: zsh.texi:28517
#, no-wrap
msgid "@t{zcurses} @t{touch} @var{targetwin} ..."
msgstr "@t{zcurses} @t{touch} @var{targetwin} ..."

#. type: itemx
#: zsh.texi:28518
#, no-wrap
msgid "@t{zcurses} @t{move} @var{targetwin} @var{new_y} @var{new_x}"
msgstr "@t{zcurses} @t{move} @var{targetwin} @var{new_y} @var{new_x}"

#. type: itemx
#: zsh.texi:28519
#, no-wrap
msgid "@t{zcurses} @t{clear} @var{targetwin} [ @t{redraw} | @t{eol} | @t{bot} ]"
msgstr "@t{zcurses} @t{clear} @var{targetwin} [ @t{redraw} | @t{eol} | @t{bot} ]"

#. type: itemx
#: zsh.texi:28520
#, no-wrap
msgid "@t{zcurses} @t{position} @var{targetwin} @var{array}"
msgstr "@t{zcurses} @t{position} @var{targetwin} @var{array}"

#. type: itemx
#: zsh.texi:28521
#, no-wrap
msgid "@t{zcurses} @t{char} @var{targetwin} @var{character}"
msgstr "@t{zcurses} @t{char} @var{targetwin} @var{character}"

#. type: itemx
#: zsh.texi:28522
#, no-wrap
msgid "@t{zcurses} @t{string} @var{targetwin} @var{string}"
msgstr "@t{zcurses} @t{string} @var{targetwin} @var{string}"

#. type: itemx
#: zsh.texi:28523
#, no-wrap
msgid "@t{zcurses} @t{border} @var{targetwin} @var{border}"
msgstr "@t{zcurses} @t{border} @var{targetwin} @var{border}"

#. type: itemx
#: zsh.texi:28524
#, no-wrap
msgid "@t{zcurses} @t{attr} @var{targetwin} [ [@t{+}|@t{-}]@var{attribute} | @var{fg_col}@t{/}@var{bg_col} ] [...]"
msgstr "@t{zcurses} @t{attr} @var{targetwin} [ [@t{+}|@t{-}]@var{attribute} | @var{fg_col}@t{/}@var{bg_col} ] [...]"

#. type: itemx
#: zsh.texi:28525
#, no-wrap
msgid "@t{zcurses} @t{bg} @var{targetwin} [ [@t{+}|@t{-}]@var{attribute} | @var{fg_col}@t{/}@var{bg_col} | @t{@@}@var{char} ] [...]"
msgstr "@t{zcurses} @t{bg} @var{targetwin} [ [@t{+}|@t{-}]@var{attribute} | @var{fg_col}@t{/}@var{bg_col} | @t{@@}@var{char} ] [...]"

#. type: itemx
#: zsh.texi:28526
#, no-wrap
msgid "@t{zcurses} @t{scroll} @var{targetwin} [ @t{on} | @t{off} | [@t{+}|@t{-}]@var{lines} ]"
msgstr "@t{zcurses} @t{scroll} @var{targetwin} [ @t{on} | @t{off} | [@t{+}|@t{-}]@var{lines} ]"

#. type: itemx
#: zsh.texi:28527
#, no-wrap
msgid "@t{zcurses} @t{input} @var{targetwin} [ @var{param} [ @var{kparam} [ @var{mparam} ] ] ]"
msgstr "@t{zcurses} @t{input} @var{targetwin} [ @var{param} [ @var{kparam} [ @var{mparam} ] ] ]"

#. type: itemx
#: zsh.texi:28528
#, no-wrap
msgid "@t{zcurses} @t{mouse} [ @t{delay} @var{num} | [@t{+}|@t{-}]@t{motion} ]"
msgstr "@t{zcurses} @t{mouse} [ @t{delay} @var{num} | [@t{+}|@t{-}]@t{motion} ]"

#. type: itemx
#: zsh.texi:28529
#, no-wrap
msgid "@t{zcurses} @t{timeout} @var{targetwin} @var{intval}"
msgstr "@t{zcurses} @t{timeout} @var{targetwin} @var{intval}"

#. type: itemx
#: zsh.texi:28530
#, no-wrap
msgid "@t{zcurses} @t{querychar} @var{targetwin} [ @var{param} ]"
msgstr "@t{zcurses} @t{querychar} @var{targetwin} [ @var{param} ]"

#. type: itemx
#: zsh.texi:28531
#, no-wrap
msgid "@t{zcurses} @t{resize} @var{height} @var{width} [ @t{endwin} | @t{nosave} | @t{endwin_nosave} ]"
msgstr "@t{zcurses} @t{resize} @var{height} @var{width} [ @t{endwin} | @t{nosave} | @t{endwin_nosave} ]"

#. type: table
#: zsh.texi:28536
msgid ""
"Manipulate curses windows.  All uses of this command should be bracketed by `@t{zcurses init}' to initialise use of curses, and `@t{zcurses end}' to end it; omitting `@t{zcurses end}' can cause the "
"terminal to be in an unwanted state."
msgstr ""
"操作 curses 窗口。 所有使用该命令的操作都应在括号中加上 `@t{zcurses init}' ，以初始化 curses 的使用，以及 `@t{zcurses end}' ，以结束 curses 的使用；省略 `@t{zcurses end}' 可能会导致终端处于不需要的状态。"

#. type: table
#: zsh.texi:28545
msgid ""
"The subcommand @t{addwin} creates a window with @var{nlines} lines and @var{ncols} columns.  Its upper left corner will be placed at row @var{begin_y} and column @var{begin_x} of the screen.  "
"@var{targetwin} is a string and refers to the name of a window that is not currently assigned.  Note in particular the curses convention that vertical values appear before horizontal values."
msgstr ""
"子命令 @t{addwin} 将创建一个具有 @var{nlines} 行和 @var{ncols} 列的窗口。 窗口的左上角将位于屏幕的 @var{begin_y} 行和 @var{begin_x} 列。 @var{targetwin} 是一个字符串，指向当前未分配的窗口名称。 需要特别注"
"意的是，curses 约定垂直数值显示在水平数值之前。"

#. type: table
#: zsh.texi:28553
msgid ""
"If @t{addwin} is given an existing window as the final argument, the new window is created as a subwindow of @var{parentwin}.  This differs from an ordinary new window in that the memory of the window "
"contents is shared with the parent's memory.  Subwindows must be deleted before their parent.  Note that the coordinates of subwindows are relative to the screen, not the parent, as with other windows."
msgstr ""
"如果 @t{addwin} 的最终参数是一个现有窗口，那么新窗口将作为 @var{parentwin} 的子窗口创建。 这与普通新建窗口的不同之处在于，窗口内容的内存与父窗口的内存共享。 子窗口必须先于父窗口删除。 请注意，子窗口的坐标"
"是相对于屏幕而非父窗口的，这一点与其他窗口相同。"

#. type: table
#: zsh.texi:28558
msgid ""
"Use the subcommand @t{delwin} to delete a window created with @t{addwin}.  Note that @t{end} does @emph{not} implicitly delete windows, and that @t{delwin} does not erase the screen image of the window."
msgstr "使用子命令 @t{delwin} 删除用 @t{addwin} 创建的窗口。 请注意，@t{end} @emph{不会} 隐式删除窗口，而且 @t{delwin} 不会擦除窗口的屏幕图像。"

#. type: table
#: zsh.texi:28563
msgid "The window corresponding to the full visible screen is called @t{stdscr}; it always exists after `@t{zcurses init}' and cannot be delete with @t{delwin}."
msgstr "与完整可见屏幕相对应的窗口称为 @t{stdscr}；它始终存在于 `@t{zcurses init}' 之后，且无法通过 @t{delwin} 删除。"

#. type: table
#: zsh.texi:28570
msgid ""
"The subcommand @t{refresh} will refresh window @var{targetwin}; this is necessary to make any pending changes (such as characters you have prepared for output with @t{char}) visible on the screen.  "
"@t{refresh} without an argument causes the screen to be cleared and redrawn.  If multiple windows are given, the screen is updated once at the end."
msgstr ""
"子命令 @t{refresh} 将刷新窗口 @var{targetwin}；这对于在屏幕上显示任何待处理的更改（例如使用 @t{char} 准备输出的字符）是必要的。 不带参数的 @t{refresh} 会清空并重新绘制屏幕。 如果给定了多个窗口，屏幕会在最"
"后更新一次。"

#. type: table
#: zsh.texi:28575
msgid ""
"The subcommand @t{touch} marks the @var{targetwin}s listed as changed.  This is necessary before @t{refresh}ing windows if a window that was in front of another window (which may be @t{stdscr}) is deleted."
msgstr "子命令 @t{touch} 会将列出的 @var{targetwin} 标记为已更改。 如果删除了位于另一个窗口（可能是 @t{stdscr}）前面的窗口，则在 @t{refresh} 操作窗口前必须执行此操作。"

#. type: table
#: zsh.texi:28581
msgid ""
"The subcommand @t{move} moves the cursor position in @var{targetwin} to new coordinates @var{new_y} and @var{new_x}.  Note that the subcommand @t{string} (but not the subcommand @t{char}) advances the "
"cursor position over the characters added."
msgstr "子命令 @t{move} 会将 @var{targetwin} 中的光标位置移动到新坐标 @var{new_y} 和 @var{new_x} 上。 需要注意的是，子命令 @t{string}（但不包括子命令 @t{char}）会将光标位置移动到添加的字符上。"

#. type: table
#: zsh.texi:28591
msgid ""
"The subcommand @t{clear} erases the contents of @var{targetwin}.  One (and no more than one) of three options may be specified.  With the option @t{redraw}, in addition the next @t{refresh} of "
"@var{targetwin} will cause the screen to be cleared and repainted.  With the option @t{eol}, @var{targetwin} is only cleared to the end of the current cursor line.  With the option @t{bot}, "
"@var{targetwin} is cleared to the end of the window, i.e everything to the right and below the cursor is cleared."
msgstr ""
"子命令 @t{clear} 会清除 @var{targetwin} 中的内容。 可以指定三个选项中的一个（最多一个）。 如果使用选项 @t{redraw}，则 @var{targetwin} 的下一次 @t{refresh} 将导致屏幕被清除并重新绘制。 如果使用选项 "
"@t{eol}，@var{targetwin} 只清除到当前光标行的末尾。 如果使用选项 @t{bot}，@var{targetwin} 会被清除到窗口的末尾，即到光标右侧和下方的所有内容都会被清除。"

#. type: table
#: zsh.texi:28596
msgid "The subcommand @t{position} writes various positions associated with @var{targetwin} into the array named @var{array}.  These are, in order:"
msgstr "子命令 @t{position} 会将与 @var{targetwin} 相关的各种位置写入名为 @var{array} 的数组中。 这些位置依次是:"

#. type: table
#: zsh.texi:28600
msgid "The y and x coordinates of the cursor relative to the top left of @var{targetwin}"
msgstr "光标相对于 @var{targetwin} 左上角的 y 和 x 坐标"

#. type: table
#: zsh.texi:28603
msgid "The y and x coordinates of the top left of @var{targetwin} on the screen"
msgstr "屏幕上 @var{targetwin} 左上角的 y 和 x 坐标"

#. type: table
#: zsh.texi:28605
msgid "The size of @var{targetwin} in y and x dimensions."
msgstr "@var{targetwin} 在 y 和 x 维度上的大小。"

#. type: table
#: zsh.texi:28610
msgid "Outputting characters and strings are achieved by @t{char} and @t{string} respectively."
msgstr "字符和字符串的输出分别由 @t{char} 和 @t{string} 实现。"

#. type: table
#: zsh.texi:28616
msgid ""
"To draw a border around window @var{targetwin}, use @t{border}.  Note that the border is not subsequently handled specially: in other words, the border is simply a set of characters output at the edge of "
"the window.  Hence it can be overwritten, can scroll off the window, etc."
msgstr "要在 @var{targetwin} 窗口周围绘制边框，请使用 @t{border}。 请注意，边框随后不会被特殊处理：换句话说，边框只是在窗口边缘输出的一组字符。 因此，它可以被覆盖，也可以从窗口滚动出去，等等。"

#. type: table
#: zsh.texi:28624
msgid ""
"The subcommand @t{attr} will set @var{targetwin}'s attributes or foreground/background color pair for any successive character output.  Each @var{attribute} given on the line may be prepended by a @t{+} "
"to set or a @t{-} to unset that attribute; @t{+} is assumed if absent.  The attributes supported are @t{blink}, @t{bold}, @t{dim}, @t{reverse}, @t{standout}, and @t{underline}."
msgstr ""
"子命令 @t{attr} 将为任何连续输出的字符设置 @var{targetwin} 的属性或前景/背景颜色对。 行中给出的每个 @var{attribute} 都可以用 @t{+} 作为前缀来设置或用 @t{-} 作前缀来取消设置；如果没有前缀，则默认为 @t{+}。 "
"支持的属性有 @t{blink}、@t{bold}、@t{dim}、@t{reverse}、@t{standout} 和 @t{underline}。"

#. type: table
#: zsh.texi:28636
msgid ""
"Each @var{fg_col}@t{/}@var{bg_col} attribute (to be read as `@var{fg_col} on @var{bg_col}') sets the foreground and background color for character output.  The color @t{default} is sometimes available (in "
"particular if the library is ncurses), specifying the foreground or background color with which the terminal started.  The color pair @t{default/default} is always available. To use more than the 8 named "
"colors (red, green, etc.) construct the @var{fg_col}@t{/}@var{bg_col} pairs where @var{fg_col} and @var{bg_col} are decimal integers, e.g @t{128/200}.  The maximum color value is 254 if the terminal "
"supports 256 colors."
msgstr ""
"每个 @var{fg_col}@t{/}@var{bg_col} 属性（可理解为 `@var{fg_col} on @var{bg_col}'）都设置了字符输出的前景色和背景色。 有时也可以使用颜色 @t{default}（特别是当库为 ncurses 时），指定终端启动时的前景色或背景"
"色。 颜色对 @t{default/default} 始终可用。要使用多于 8 种指定颜色（红色、绿色等），请构建 @var{fg_col}@t{/}@var{bg_col} 对，其中 @var{fg_col} 和 @var{bg_col} 均为十进制整数，例如 @t{128/200}。 如果终端支"
"持 256 种颜色，则最大颜色值为 254。"

#. type: table
#: zsh.texi:28647
msgid ""
"@t{bg} overrides the color and other attributes of all characters in the window.  Its usual use is to set the background initially, but it will overwrite the attributes of any characters at the time when "
"it is called.  In addition to the arguments allowed with @t{attr}, an argument @t{@@}@var{char} specifies a character to be shown in otherwise blank areas of the window.  Owing to limitations of curses "
"this cannot be a multibyte character (use of ASCII characters only is recommended).  As the specified set of attributes override the existing background, turning attributes off in the arguments is not "
"useful, though this does not cause an error."
msgstr ""
"@t{bg} 会覆盖窗口中所有字符的颜色和其他属性。 它通常用于设置初始背景，但在调用时会覆盖任何字符的属性。 除了 @t{attr} 允许的参数外，参数 @t{@@}@var{char} 还可以指定要在窗口空白区域显示的字符。 由于curses的"
"限制，这个字符不能是多字节字符（建议只使用ASCII字符）。 由于指定的属性集会覆盖现有的背景，因此在参数中关闭属性并无用处，但不会导致错误。"

#. type: table
#: zsh.texi:28657
msgid ""
"The subcommand @t{scroll} can be used with @t{on} or @t{off} to enabled or disable scrolling of a window when the cursor would otherwise move below the window due to typing or output.  It can also be used "
"with a positive or negative integer to scroll the window up or down the given number of lines without changing the current cursor position (which therefore appears to move in the opposite direction "
"relative to the window).  In the second case, if scrolling is @t{off} it is temporarily turned @t{on} to allow the window to be scrolled."
msgstr ""
"子命令 @t{scroll} 可以与 @t{on} 或 @t{off} 一起使用，当光标因输入或输出而移动到窗口下方时，可以启用或禁用窗口滚动。 它还可以与一个正整数或负整数一起使用，在不改变当前光标位置的情况下向上或向下滚动指定行数"
"的窗口（因此，光标相对于窗口的移动方向看起来是相反的）。 在第二种情况下，如果滚动是 @t{off}，则会暂时转为 @t{on}，以允许窗口滚动。"

#. type: table
#: zsh.texi:28663
msgid ""
"The subcommand @t{input} reads a single character from the window without echoing it back.  If @var{param} is supplied the character is assigned to the parameter @var{param}, else it is assigned to the "
"parameter @t{REPLY}."
msgstr "子命令 @t{input} 从窗口读取一个字符，但不回传。 如果提供了 @var{param}，则字符会被赋值给参数 @var{param}，否则会赋值给参数 @t{REPLY}。"

#. type: table
#: zsh.texi:28674
msgid ""
"If both @var{param} and @var{kparam} are supplied, the key is read in `keypad' mode.  In this mode special keys such as function keys and arrow keys return the name of the key in the parameter "
"@var{kparam}.  The key names are the macros defined in the @t{curses.h} or @t{ncurses.h} with the prefix `@t{KEY_}' removed; see also the description of the parameter @t{zcurses_keycodes} below.  Other "
"keys cause a value to be set in @var{param} as before.  On a successful return only one of @var{param} or @var{kparam} contains a non-empty string; the other is set to an empty string."
msgstr ""
"如果同时提供 @var{param} 和 @var{kparam}，按键将以 `keypad' 模式读取。 在这种模式下，特殊按键（如功能键和方向键）会返回参数 @var{kparam} 中的按键名称。 按键名称是 @t{curses.h} 或 @t{ncurses.h} 中定义的宏，"
"去掉了前缀 `@t{KEY_}' ；另请参阅下面参数 @t{zcurses_keycodes} 的描述。 其他键值会像之前一样在 @var{param} 中设置一个值。 成功返回时，只有 @var{param} 或 @var{kparam} 中的一个包含非空字符串，另一个将被设置"
"为空字符串。"

#. type: table
#: zsh.texi:28684
msgid ""
"If @var{mparam} is also supplied, @t{input} attempts to handle mouse input.  This is only available with the ncurses library; mouse handling can be detected by checking for the exit status of `@t{zcurses "
"mouse}' with no arguments.  If a mouse button is clicked (or double- or triple-clicked, or pressed or released with a configurable delay from being clicked) then @var{kparam} is set to the string "
"@t{MOUSE}, and @var{mparam} is set to an array consisting of the following elements:"
msgstr ""
"如果同时提供 @var{mparam}，@t{input} 将尝试处理鼠标输入。 只有在使用 ncurses 库时才能使用；可以通过不带参数检查 `@t{zcurses mouse}' 的退出状态来检测鼠标处理。 如果鼠标按键被点击（或双击或三击，或按下或释放"
"时有可配置的延迟），@var{kparam} 将被设置为字符串 @t{MOUSE}，@var{mparam} 将被设置为由以下元素组成的数组："

#. type: table
#: zsh.texi:28688
msgid "An identifier to discriminate different input devices; this is only rarely useful."
msgstr "用于区分不同输入设备的标识符；这种标识符很少有用。"

#. type: table
#: zsh.texi:28693
msgid ""
"The x, y and z coordinates of the mouse click relative to the full screen, as three elements in that order (i.e. the y coordinate is, unusually, after the x coordinate).  The z coordinate is only "
"available for a few unusual input devices and is otherwise set to zero."
msgstr "鼠标点击时相对于全屏的 x、y 和 z 坐标，这三个元素按顺序排列（即 y 坐标不同寻常地位于 x 坐标之后）。 z 坐标只适用于少数特殊的输入设备，否则将设为零。"

#. type: table
#: zsh.texi:28698
msgid ""
"Any events that occurred as separate items; usually there will be just one.  An event consists of @t{PRESSED}, @t{RELEASED}, @t{CLICKED}, @t{DOUBLE_CLICKED} or @t{TRIPLE_CLICKED} followed immediately (in "
"the same element) by the number of the button."
msgstr "作为单独项目发生的任何事件；通常只有一个。 一个事件包括 @t{PRESSED}, @t{RELEASED}, @t{CLICKED}, @t{DOUBLE_CLICKED} 或 @t{TRIPLE_CLICKED} ，紧接着（在同一元素中）是按钮的编号。"

#. type: table
#: zsh.texi:28700
msgid "If the shift key was pressed, the string @t{SHIFT}."
msgstr "如果按下了 shift 键，则字符串 @t{SHIFT}。"

#. type: table
#: zsh.texi:28702
msgid "If the control key was pressed, the string @t{CTRL}."
msgstr "如果按下的是 control 键，则字符串 @t{CTRL}。"

#. type: table
#: zsh.texi:28704
msgid "If the alt key was pressed, the string @t{ALT}."
msgstr "如果按下了 alt 键，则字符串 @t{ALT}。"

#. type: table
#: zsh.texi:28712
msgid ""
"Not all mouse events may be passed through to the terminal window; most terminal emulators handle some mouse events themselves.  Note that the ncurses manual implies that using input both with and without "
"mouse handling may cause the mouse cursor to appear and disappear."
msgstr "并非所有鼠标事件都会传递到终端窗口；大多数终端模拟器都会自行处理某些鼠标事件。 请注意，ncurses 手册暗示，在有鼠标处理和没有鼠标处理的情况下使用输入时，都可能导致鼠标光标出现和消失。"

#. type: table
#: zsh.texi:28726
msgid ""
"The subcommand @t{mouse} can be used to configure the use of the mouse.  There is no window argument; mouse options are global.  `@t{zcurses mouse}' with no arguments returns status 0 if mouse handling is "
"possible, else status 1.  Otherwise, the possible arguments (which may be combined on the same command line) are as follows.  @t{delay} @var{num} sets the maximum delay in milliseconds between press and "
"release events to be considered as a click; the value 0 disables click resolution, and the default is one sixth of a second.  @t{motion} proceeded by an optional `@t{+}' (the default) or @t{-} turns on or "
"off reporting of mouse motion in addition to clicks, presses and releases, which are always reported.  However, it appears reports for mouse motion are not currently implemented."
msgstr ""
"子命令 @t{mouse} 可用于配置鼠标的使用。 没有窗口参数，鼠标选项是全局的。 如果可以处理鼠标，不带参数的`@t{zcurses mouse}' 返回状态 0，否则返回状态 1。 否则，可能的参数（可以在同一命令行中组合）如下。  "
"@t{delay} @var{num} 以毫秒为单位设置鼠标按下和松开之间的最大延迟时间，该延迟时间将被视为一次点击；值 0 将禁用点击解析，默认值为六分之一秒。 @t{motion}后接一个可选的 `@t{+}' （默认）或 @t{-} ，用于打开或关"
"闭除始终报告的点击、按下和释放之外的鼠标动作报告。 不过，目前似乎还没有实现对鼠标动作的报告。"

#. type: table
#: zsh.texi:28736
msgid ""
"The subcommand @t{timeout} specifies a timeout value for input from @var{targetwin}.  If @var{intval} is negative, `@t{zcurses input}' waits indefinitely for a character to be typed; this is the default.  "
"If @var{intval} is zero, `@t{zcurses input}' returns immediately; if there is typeahead it is returned, else no input is done and status 1 is returned.  If @var{intval} is positive, `@t{zcurses input}' "
"waits @var{intval} milliseconds for input and if there is none at the end of that period returns status 1."
msgstr ""
"子命令 @t{timeout} 指定了从 @var{targetwin} 输入的超时值。 如果 @var{intval} 为负值， `@t{zcurses input}' 将无限期等待输入字符；这是默认情况。 如果 @var{intval} 为零，`@t{zcurses input}' 立即返回；如果有预"
"输入数据，则返回该数据；否则不进行输入，并返回状态码1。 如果 @var{intval} 为正值，`@t{zcurses input}' 会等待 @var{intval} 毫秒，如果等待时间结束时没有输入，则返回状态 1。"

#. type: table
#: zsh.texi:28746
msgid ""
"The subcommand @t{querychar} queries the character at the current cursor position.  The return values are stored in the array named @var{param} if supplied, else in the array @t{reply}.  The first value "
"is the character (which may be a multibyte character if the system supports them); the second is the color pair in the usual @var{fg_col}@t{/}@var{bg_col} notation, or @t{0} if color is not supported.  "
"Any attributes other than color that apply to the character, as set with the subcommand @t{attr}, appear as additional elements."
msgstr ""
"子命令 @t{querychar} 用于查询当前光标位置的字符。 如果提供了返回值，则将其存储在名为 @var{param} 的数组中，否则将其存储在 @t{reply} 数组中。 第一个值是字符（如果系统支持多字节字符，则可以是多字节字符）；第"
"二个值是颜色对，采用通常的 @var{fg_col}@t{/}@var{bg_col} 符号，如果不支持颜色，则为 @t{0}。 除颜色外，任何适用于字符的属性（如子命令 @t{attr} 所设置）都会作为附加元素出现。"

#. type: table
#: zsh.texi:28762
msgid ""
"The subcommand @t{resize} resizes @t{stdscr} and all windows to given dimensions (windows that stick out from the new dimensions are resized down). The underlying curses extension (@t{resize_term call}) "
"can be unavailable. To verify, zeroes can be used for @var{height} and @var{width}. If the result of the subcommand is @t{0}, resize_term is available (@t{2} otherwise). Tests show that resizing can be "
"normally accomplished by calling @t{zcurses end} and @t{zcurses refresh}. The @t{resize} subcommand is provided for versatility. Multiple system configurations have been checked and @t{zcurses end} and "
"@t{zcurses refresh} are still needed for correct terminal state after resize. To invoke them with @t{resize}, use @var{endwin} argument.  Using @var{nosave} argument will cause new terminal state to not "
"be saved internally by @t{zcurses}. This is also provided for versatility and should normally be not needed."
msgstr ""
"子命令 @t{resize} 会将 @t{stdscr} 和所有窗口的大小调整到给定尺寸（超出新尺寸的窗口会被缩小）。底层的 curses 扩展（@t{resize_term 调用}）可能不可用。为了验证，可以在 @var{height} 和 @var{width} 中使用零。如"
"果子命令的结果为 @t{0}，则 resize_term 可用（否则为 @t{2}）。测试表明，调整大小通常可以通过调用 @t{zcurses end} 和 @t{zcurses refresh} 来完成。提供 @t{resize} 子命令是为了实现多功能性。在检查了多系统配置"
"后，仍需要 @t{zcurses end} 和 @t{zcurses refresh} ,在调整大小后获得正确的终端状态。要通过 @t{resize} 调用它们，请使用 @var{endwin} 参数。 使用 @var{nosave} 参数将导致 @t{zcurses} 内部不保存新的终端状态。这"
"也是为多功能性而提供的，一般情况下不需要。"

#. type: t{#1}
#: zsh.texi:28772 zsh.texi:28773
#, no-wrap
msgid "ZCURSES_COLORS"
msgstr "ZCURSES_COLORS"

#. type: table
#: zsh.texi:28777
msgid "Readonly integer.  The maximum number of colors the terminal supports.  This value is initialised by the curses library and is not available until the first time @t{zcurses init} is run."
msgstr "只读整数。 终端支持的最大颜色数。 该值由 curses 库初始化，在首次运行 @t{zcurses init} 之前不可用。"

#. type: t{#1}
#: zsh.texi:28778 zsh.texi:28779
#, no-wrap
msgid "ZCURSES_COLOR_PAIRS"
msgstr "ZCURSES_COLOR_PAIRS"

#. type: table
#: zsh.texi:28786
msgid ""
"Readonly integer.  The maximum number of color pairs @var{fg_col}@t{/}@var{bg_col} that may be defined in `@t{zcurses attr}' commands; note this limit applies to all color pairs that have been used "
"whether or not they are currently active.  This value is initialised by the curses library and is not available until the first time @t{zcurses init} is run."
msgstr ""
"只读整数。 `@t{zcurses attr}' 命令中可定义的颜色对 @var{fg_col}@t{/}@var{bg_col} 的最大数量；注意该限制适用于所有已使用过的颜色对，无论其当前是否处于活动状态。 该值由 curses 库初始化，在首次运行 "
"@t{zcurses init} 之前不可用。"

#. type: t{#1}
#: zsh.texi:28787 zsh.texi:28788
#, no-wrap
msgid "zcurses_attrs"
msgstr "zcurses_attrs"

#. type: table
#: zsh.texi:28791
msgid "Readonly array.  The attributes supported by @t{zsh/curses}; available as soon as the module is loaded."
msgstr "只读数组。 @t{zsh/curses} 支持的属性；模块加载后立即可用。"

#. type: t{#1}
#: zsh.texi:28792 zsh.texi:28793
#, no-wrap
msgid "zcurses_colors"
msgstr "zcurses_colors"

#. type: table
#: zsh.texi:28796
msgid "Readonly array.  The colors supported by @t{zsh/curses}; available as soon as the module is loaded."
msgstr "只读数组。 @t{zsh/curses} 支持的颜色；模块加载后立即可用。"

#. type: t{#1}
#: zsh.texi:28797 zsh.texi:28798
#, no-wrap
msgid "zcurses_keycodes"
msgstr "zcurses_keycodes"

#. type: table
#: zsh.texi:28803
msgid ""
"Readonly array.  The values that may be returned in the second parameter supplied to `@t{zcurses input}' in the order in which they are defined internally by curses.  Not all function keys are listed, "
"only @t{F0}; curses reserves space for @t{F0} up to @t{F63}."
msgstr "只读数组。 在 `@t{zcurses input}' 的第二个参数中,可能返回一系列值，这些值按照curses内部定义的顺序排列。 并非所有功能键都会列出，只有 @t{F0}；curses 为 @t{F0} 至 @t{F63} 保留了空间。"

#. type: t{#1}
#: zsh.texi:28804 zsh.texi:28805
#, no-wrap
msgid "zcurses_windows"
msgstr "zcurses_windows"

#. type: table
#: zsh.texi:28809
msgid "Readonly array.  The current list of windows, i.e. all windows that have been created with `@t{zcurses addwin}' and not removed with `@t{zcurses delwin}'."
msgstr "只读数组。 当前窗口列表，即所有使用`@t{zcurses addwin}' 创建、未使用 `@t{zcurses delwin}' 删除的窗口。"

#. type: node
#: zsh.texi:28812 zsh.texi:28919 zsh.texi:28921 zsh.texi:28994
#, no-wrap
msgid "The zsh/db/gdbm Module"
msgstr "zsh/db/gdbm 模块"

#. type: Plain text
#: zsh.texi:28819
msgid "The @t{zsh/datetime} module makes available one builtin command:"
msgstr "@t{zsh/datetime} 模块提供了一条内置命令："

#. type: findex
#: zsh.texi:28822
#, no-wrap
msgid "strftime"
msgstr "strftime"

#. type: cindex
#: zsh.texi:28823
#, no-wrap
msgid "date string, printing"
msgstr "日期字符串, 打印"

#. type: item
#: zsh.texi:28824
#, no-wrap
msgid "@t{strftime} [ @t{-s} @var{scalar} | @t{-n} ] @var{format} [ @var{epochtime} [ @var{nanoseconds} ] ]"
msgstr "@t{strftime} [ @t{-s} @var{scalar} | @t{-n} ] @var{format} [ @var{epochtime} [ @var{nanoseconds} ] ]"

#. type: itemx
#: zsh.texi:28825
#, no-wrap
msgid "@t{strftime} @t{-r} [ @t{-q} ] [ @t{-s} @var{scalar} | @t{-n} ] @var{format} @var{timestring}"
msgstr "@t{strftime} @t{-r} [ @t{-q} ] [ @t{-s} @var{scalar} | @t{-n} ] @var{format} @var{timestring}"

#. type: table
#: zsh.texi:28833
msgid ""
"Output the date in the @var{format} specified.  With no @var{epochtime}, the current system date/time is used; optionally, @var{epochtime} may be used to specify the number of seconds since the epoch, and "
"@var{nanoseconds} may additionally be used to specify the number of nanoseconds past the second (otherwise that number is assumed to be 0).  See strftime(3) for details.  The zsh extensions described in "
"@ref{Prompt Expansion} are also available."
msgstr ""
"以指定的 @var{format} 格式输出日期。 如果没有 @var{epochtime}，则使用当前的系统日期/时间；可以选择使用 @var{epochtime} 指定从纪元开始的秒数，还可以使用 @var{nanoseconds} 指定秒后的纳秒数（否则该数字被假定"
"为 0）。 详情请参阅 strftime(3)。 还可以使用 @ref{提示符扩展} 中描述的 zsh 扩展。"

#. type: table
#: zsh.texi:28838
msgid "Suppress printing a newline after the formatted string."
msgstr "抑制在格式化字符串后打印换行符。"

#. type: table
#: zsh.texi:28842
msgid "Run quietly; suppress printing of all error messages described below.  Errors for invalid @var{epochtime} values are always printed."
msgstr "静音运行；禁止打印以下所有错误信息。 对于无效的 @var{epochtime} 值，错误信息始终会被打印。"

#. type: table
#: zsh.texi:28850
msgid ""
"With the option @t{-r} (reverse), use @var{format} to parse the input string @var{timestring} and output the number of seconds since the epoch at which the time occurred.  The parsing is implemented by "
"the system function @t{strptime}; see strptime(3).  This means that zsh format extensions are not available, but for reverse lookup they are not required."
msgstr ""
"通过选项 @t{-r}（反向），使用 @var{format} 解析输入字符串 @var{timestring} 并输出自纪元起的秒数。 解析由系统函数 @t{strptime} 实现；请参阅 strptime(3)。 这意味着无法使用 zsh 格式扩展，但反向查找时不需要这"
"些扩展。"

#. type: table
#: zsh.texi:28856
msgid ""
"In most implementations of @t{strftime} any timezone in the @var{timestring} is ignored and the local timezone declared by the @t{TZ} environment variable is used; other parameters are set to zero if not "
"present."
msgstr "在 @t{strftime} 的大多数实现中，@var{timestring} 中的任何时区都会被忽略，而使用 @t{TZ} 环境变量声明的本地时区；其他参数如果不存在，则设置为 0。"

#. type: table
#: zsh.texi:28862
msgid ""
"If @var{timestring} does not match @var{format} the command returns status 1 and prints an error message.  If @var{timestring} matches @var{format} but not all characters in @var{timestring} were used, "
"the conversion succeeds but also prints an error message."
msgstr "如果 @var{timestring} 与 @var{format} 不匹配，命令将返回状态 1 并打印错误信息。 如果 @var{timestring} 与 @var{format} 匹配，但未使用 @var{timestring} 中的所有字符，则转换成功，但也会打印错误信息。"

#. type: table
#: zsh.texi:28866
msgid "If either of the system functions @t{strptime} or @t{mktime} is not available, status 2 is returned and an error message is printed."
msgstr "如果系统函数 @t{strptime} 或 @t{mktime} 不可用，则返回状态 2 并打印错误信息。"

#. type: item
#: zsh.texi:28867
#, no-wrap
msgid "@t{-s} @var{scalar}"
msgstr "@t{-s} @var{scalar}"

#. type: table
#: zsh.texi:28870
msgid "Assign the date string (or epoch time in seconds if @t{-r} is given) to @var{scalar} instead of printing it."
msgstr "将日期字符串（或以秒为单位的纪元(epoch)时间，如果给定了 @t{-r}）赋值给 @var{scalar}，而不是打印出来。"

#. type: table
#: zsh.texi:28877
msgid "Note that depending on the system's declared integral time type, @t{strftime} may produce incorrect results for epoch times greater than 2147483647 which corresponds to 2038-01-19 03:14:07 +0000."
msgstr "请注意，根据系统声明的整型时间类型，@t{strftime} 可能会在纪元时间大于 2147483647（相当于 2038-01-19 03:14:07 +0000 ）时产生错误结果。"

#. type: Plain text
#: zsh.texi:28883
msgid "The @t{zsh/datetime} module makes available several parameters; all are readonly:"
msgstr "@t{zsh/datetime} 模块提供了多个参数；所有参数都是只读参数："

#. type: t{#1}
#: zsh.texi:28886 zsh.texi:28887
#, no-wrap
msgid "EPOCHREALTIME"
msgstr "EPOCHREALTIME"

#. type: table
#: zsh.texi:28893
msgid ""
"A floating point value representing the number of seconds since the epoch.  The notional accuracy is to nanoseconds if the @t{clock_gettime} call is available and to microseconds otherwise, but in "
"practice the range of double precision floating point and shell scheduling latencies may be significant effects."
msgstr "一个浮点数值，代表自纪元(epoch)开始的秒数。 如果 @t{clock_gettime} 调用可用，则名义精度为纳秒，否则为微秒，但在实际应用中，双精度浮点范围和 shell 调度延迟可能会产生重大影响。"

#. type: t{#1}
#: zsh.texi:28894 zsh.texi:28895
#, no-wrap
msgid "EPOCHSECONDS"
msgstr "EPOCHSECONDS"

#. type: table
#: zsh.texi:28898
msgid "An integer value representing the number of seconds since the epoch."
msgstr "一个整数值，表示自 epoch 开始的秒数。"

#. type: t{#1}
#: zsh.texi:28899 zsh.texi:28900
#, no-wrap
msgid "epochtime"
msgstr "epochtime"

#. type: table
#: zsh.texi:28907
msgid ""
"An array value containing the number of seconds since the epoch in the first element and the remainder of the time since the epoch in nanoseconds in the second element.  To ensure the two elements are "
"consistent the array should be copied or otherwise referenced as a single substitution before the values are used.  The following idiom may be used:"
msgstr ""
"一个数组值，第一个元素包含自纪元(epoch)以来的秒数，第二个元素包含自纪元以来的剩余(remainder)时间（纳秒）。 为确保两个元素的一致性，在使用数值之前，应将数组复制或以其他方式引用为一个单一的替代值。 可以使用"
"以下成语："

#. type: example
#: zsh.texi:28913
#, no-wrap
msgid ""
"for secs nsecs in $epochtime; do\n"
"  ...\n"
"done\n"
msgstr ""
"for secs nsecs in $epochtime; do\n"
"  ...\n"
"done\n"

#. type: node
#: zsh.texi:28919 zsh.texi:28994 zsh.texi:28996 zsh.texi:29018
#, no-wrap
msgid "The zsh/deltochar Module"
msgstr "zsh/deltochar 模块"

#. type: Plain text
#: zsh.texi:28930
msgid ""
"The @t{zsh/db/gdbm} module is used to create \"tied\" associative arrays that interface to database files.  If the GDBM interface is not available, the builtins defined by this module will report an "
"error.  This module is also intended as a prototype for creating additional database interfaces, so the @t{ztie} builtin may move to a more generic module in the future."
msgstr ""
"@t{zsh/db/gdbm} 模块用于创建与数据库文件接口的 \"绑定 \"关联数组。 如果 GDBM 接口不可用，本模块定义的内置程序将报错。 本模块也是用于创建其他数据库接口的原型，因此 @t{ztie} 内置函数将来可能会移到更通用的模"
"块。"

#. type: Plain text
#: zsh.texi:28933
msgid "The builtins in this module are:"
msgstr "该模块中的内置程序包括:"

#. type: findex
#: zsh.texi:28936
#, no-wrap
msgid "ztie"
msgstr "ztie"

#. type: cindex
#: zsh.texi:28937
#, no-wrap
msgid "database tied array, creating"
msgstr "数据库绑定数组, 创建"

#. type: item
#: zsh.texi:28938
#, no-wrap
msgid "@t{ztie -d db/gdbm -f} @var{filename} [ @t{-r} ] @var{arrayname}"
msgstr "@t{ztie -d db/gdbm -f} @var{filename} [ @t{-r} ] @var{arrayname}"

#. type: table
#: zsh.texi:28943
msgid ""
"Open the GDBM database identified by @var{filename} and, if successful, create the associative array @var{arrayname} linked to the file.  To create a local tied array, the parameter must first be "
"declared, so commands similar to the following would be executed inside a function scope:"
msgstr "打开由 @var{filename} 标识的 GDBM 数据库，如果成功，则创建与文件关联的关联数组 @var{arrayname}。 要创建本地绑定数组，必须先声明参数，因此类似下面的命令将在函数作用域内执行："

#. type: example
#: zsh.texi:28948
#, no-wrap
msgid ""
"local -A sampledb\n"
"ztie -d db/gdbm -f sample.gdbm sampledb\n"
msgstr ""
"local -A sampledb\n"
"ztie -d db/gdbm -f sample.gdbm sampledb\n"

#. type: table
#: zsh.texi:28956
msgid ""
"The @t{-r} option opens the database file for reading only, creating a parameter with the readonly attribute.  Without this option, using `@t{ztie}' on a file for which the user does not have write "
"permission is an error.  If writable, the database is opened synchronously so fields changed in @var{arrayname} are immediately written to @var{filename}."
msgstr ""
"@t{-r} 选项打开的数据库文件只能读取，并创建一个带有只读属性的参数。 如果不使用该选项，在用户没有写权限的文件上使用 `@t{ztie}' 将导致错误。 如果数据库是可写的，则会同步打开，因此 @var{arrayname} 中更改的字"
"段会立即写入 @var{filename}。"

#. type: table
#: zsh.texi:28961
msgid "Changes to the file modes @var{filename} after it has been opened do not alter the state of @var{arrayname}, but `@t{typeset -r} @var{arrayname}' works as expected."
msgstr "打开文件后,对文件模式 @var{filename} 的更改,不会改变 @var{arrayname} 的状态，但是 `@t{typeset -r} @var{arrayname}' 如预期一样工作。"

#. type: findex
#: zsh.texi:28962
#, no-wrap
msgid "zuntie"
msgstr "zuntie"

#. type: cindex
#: zsh.texi:28963
#, no-wrap
msgid "database tied array, destroying"
msgstr "绑定到数据库的数组, 摧毁"

#. type: item
#: zsh.texi:28964
#, no-wrap
msgid "@t{zuntie} [ @t{-u} ] @var{arrayname} ..."
msgstr "@t{zuntie} [ @t{-u} ] @var{arrayname} ..."

#. type: table
#: zsh.texi:28968
msgid "Close the GDBM database associated with each @var{arrayname} and then unset the parameter.  The @t{-u} option forces an unset of parameters made readonly with `@t{ztie -r}'."
msgstr "关闭与每个 @var{arrayname} 关联的 GDBM 数据库，然后取消设置参数。 @t{-u} 选项会强制取消设置用 `@t{ztie -r}' 设为只读的参数。"

#. type: table
#: zsh.texi:28974
msgid ""
"This happens automatically if the parameter is explicitly unset or its local scope (function) ends.  Note that a readonly parameter may not be explicitly unset, so the only way to unset a global parameter "
"created with `@t{ztie -r}' is to use `@t{zuntie -u}'."
msgstr "如果参数被显式取消设置(unset)或其本地作用域（函数）结束，则会自动发生。 请注意，只读参数不能显式取消设置，因此取消设置使用 `@t{ztie -r}' 创建的全局参数的唯一方法是使用 `@t{zuntie -u}'。"

#. type: findex
#: zsh.texi:28975
#, no-wrap
msgid "zgdbmpath"
msgstr "zgdbmpath"

#. type: cindex
#: zsh.texi:28976
#, no-wrap
msgid "database file path, reading"
msgstr "数据库文件路径, 读取"

#. type: item
#: zsh.texi:28977
#, no-wrap
msgid "@t{zgdbmpath} @var{parametername}"
msgstr "@t{zgdbmpath} @var{parametername}"

#. type: table
#: zsh.texi:28980
msgid "Put path to database file assigned to @var{parametername} into @t{REPLY} scalar."
msgstr "将分配给 @var{parametername} 的数据库文件路径放入 @t{REPLY} 标量。"

#. type: t{#1}
#: zsh.texi:28981 zsh.texi:28983
#, no-wrap
msgid "zgdbm_tied"
msgstr "zgdbm_tied"

#. type: cindex
#: zsh.texi:28982
#, no-wrap
msgid "database tied arrays, enumerating"
msgstr "数据库绑定的数组, 枚举"

#. type: table
#: zsh.texi:28985
msgid "Array holding names of all tied parameters."
msgstr "包含所有绑定参数名称的数组。"

#. type: Plain text
#: zsh.texi:28994
msgid ""
"The fields of an associative array tied to GDBM are neither cached nor otherwise stored in memory, they are read from or written to the database on each reference.  Thus, for example, the values in a "
"readonly array may be changed by a second writer of the same database file."
msgstr "与 GDBM 绑定的关联数组的字段既不会被缓存，也不会以其他方式存储在内存中，而是在每次引用时从数据库中读取或写入。 因此，例如，同一数据库文件的第二个写入者可能会更改只读数组中的值。"

#. type: node
#: zsh.texi:28994 zsh.texi:29018 zsh.texi:29020 zsh.texi:29041
#, no-wrap
msgid "The zsh/example Module"
msgstr "zsh/example 模块"

#. type: Plain text
#: zsh.texi:29001
msgid "The @t{zsh/deltochar} module makes available two ZLE functions:"
msgstr "@t{zsh/deltochar} 模块提供了两个 ZLE 函数："

#. type: t{#1}
#: zsh.texi:29004 zsh.texi:29005
#, no-wrap
msgid "delete-to-char"
msgstr "delete-to-char"

#. type: table
#: zsh.texi:29010
msgid ""
"Read a character from the keyboard, and delete from the cursor position up to and including the next (or, with repeat count @var{n}, the @var{n}th) instance of that character.  Negative repeat counts mean "
"delete backwards."
msgstr "从键盘读取一个字符，然后从光标位置开始删除，直至并包括该字符的下一个（或,带有重复次数 @var{n} 时，第 @var{n} 个）实例。 负重复次数表示向后(backword)删除。"

#. type: t{#1}
#: zsh.texi:29011 zsh.texi:29012
#, no-wrap
msgid "zap-to-char"
msgstr "zap-to-char"

#. type: table
#: zsh.texi:29015
msgid "This behaves like @t{delete-to-char}, except that the final occurrence of the character itself is not deleted."
msgstr "其行为与 @t{delete-to-char}类似，只是不会删除最后出现的字符本身。"

#. type: node
#: zsh.texi:29018 zsh.texi:29041 zsh.texi:29043 zsh.texi:29264
#, no-wrap
msgid "The zsh/files Module"
msgstr "zsh/files 模块"

#. type: Plain text
#: zsh.texi:29025
msgid "The @t{zsh/example} module makes available one builtin command:"
msgstr "@t{zsh/example} 模块提供了一条内置命令："

#. type: findex
#: zsh.texi:29028
#, no-wrap
msgid "example"
msgstr "example"

#. type: cindex
#: zsh.texi:29029
#, no-wrap
msgid "modules, example"
msgstr "模块, example"

#. type: cindex
#: zsh.texi:29030
#, no-wrap
msgid "modules, writing"
msgstr "模块, 编写"

#. type: cindex
#: zsh.texi:29031
#, no-wrap
msgid "writing modules"
msgstr "编写模块"

#. type: item
#: zsh.texi:29032
#, no-wrap
msgid "@t{example} [ @t{-flags} ] [ @var{args} ... ]"
msgstr "@t{example} [ @t{-flags} ] [ @var{args} ... ]"

#. type: table
#: zsh.texi:29034
msgid "Displays the flags and arguments it is invoked with."
msgstr "显示调用时的标志和参数。"

#. type: Plain text
#: zsh.texi:29041
msgid "The purpose of the module is to serve as an example of how to write a module."
msgstr "该模块的目的是作为如何编写模块的范例。"

#. type: node
#: zsh.texi:29041 zsh.texi:29264 zsh.texi:29266 zsh.texi:29309
#, no-wrap
msgid "The zsh/langinfo Module"
msgstr "zsh/langinfo 模块"

#. type: cindex
#: zsh.texi:29047
#, no-wrap
msgid "files, manipulating"
msgstr "文件, 操作"

#. type: Plain text
#: zsh.texi:29053
msgid ""
"The @t{zsh/files} module makes available some common commands for file manipulation as builtins; these commands are probably not needed for many normal situations but can be useful in emergency recovery "
"situations with constrained resources.  The commands do not implement all features now required by relevant standards committees."
msgstr "@t{zsh/files} 模块提供了一些用于文件操作的内置常用命令；这些命令在许多正常情况下可能并不需要，但在资源有限的紧急恢复情况下可能很有用。 这些命令并未实现相关标准委员会目前要求的所有功能。"

#. type: Plain text
#: zsh.texi:29059
msgid ""
"For all commands, a variant beginning @t{zf_} is also available and loaded automatically.  Using the features capability of zmodload will let you load only those names you want.  Note that it's possible "
"to load only the builtins with zsh-specific names using the following command:"
msgstr "对于所有命令，以 @t{zf_} 开头的变量也是可用的，并会自动加载。 使用 zmodload 的特性功能可以让你只加载你想要的名称。 请注意，使用以下命令可以只加载具有 zsh 特定名称的内置程序："

#. type: example
#: zsh.texi:29063
#, no-wrap
msgid "zmodload -m -F zsh/files b:zf_\\*\n"
msgstr "zmodload -m -F zsh/files b:zf_\\*\n"

#. type: Plain text
#: zsh.texi:29067
msgid "The commands loaded by default are:"
msgstr "默认加载的命令有:"

#. type: findex
#: zsh.texi:29070
#, no-wrap
msgid "chgrp"
msgstr "chgrp"

#. type: item
#: zsh.texi:29071
#, no-wrap
msgid "@t{chgrp} [ @t{-hRs} ] @var{group} @var{filename} ..."
msgstr "@t{chgrp} [ @t{-hRs} ] @var{group} @var{filename} ..."

#. type: table
#: zsh.texi:29074
msgid "Changes group of files specified.  This is equivalent to @t{chown} with a @var{user-spec} argument of `@t{:}@var{group}'."
msgstr "更改指定文件的组。 这等同于 @t{chown}，其 @var{user-spec} 参数为 `@t{:}@var{group}'。"

#. type: findex
#: zsh.texi:29075
#, no-wrap
msgid "chmod"
msgstr "chmod"

#. type: item
#: zsh.texi:29076
#, no-wrap
msgid "@t{chmod} [ @t{-Rs} ] @var{mode} @var{filename} ..."
msgstr "@t{chmod} [ @t{-Rs} ] @var{mode} @var{filename} ..."

#. type: table
#: zsh.texi:29078
msgid "Changes mode of files specified."
msgstr "更改指定文件的模式。"

#. type: table
#: zsh.texi:29081
msgid "The specified @var{mode} must be in octal."
msgstr "指定的 @var{mode} 必须是八进制。"

#. type: table
#: zsh.texi:29086
msgid "The @t{-R} option causes @t{chmod} to recursively descend into directories, changing the mode of all files in the directory after changing the mode of the directory itself."
msgstr "@t{-R} 选项会使 @t{chmod} 向下递归到目录，在改变目录本身的模式后，再改变目录中所有文件的模式。"

#. type: table
#: zsh.texi:29097
msgid ""
"The @t{-s} option is a zsh extension to @t{chmod} functionality.  It enables paranoid behaviour, intended to avoid security problems involving a @t{chmod} being tricked into affecting files other than the "
"ones intended.  It will refuse to follow symbolic links, so that (for example)  @value{dsbq}@t{chmod 600 /tmp/foo/passwd}@value{dsq} can't accidentally chmod @t{/etc/passwd} if @t{/tmp/foo} happens to be "
"a link to @t{/etc}.  It will also check where it is after leaving directories, so that a recursive chmod of a deep directory tree can't end up recursively chmoding @t{/usr} as a result of directories "
"being moved up the tree."
msgstr ""
"@t{-s} 选项是 zsh 对 @t{chmod} 功能的扩展。 它启用了偏执行为，旨在避免因 @t{chmod} 被欺骗而影响其他文件的安全问题。 它会拒绝跟踪符号链接，因此（例如）如果 @t{/tmp/foo} 恰好是 @t{/etc} 的链接， @value{dsbq}"
"@t{chmod 600 /tmp/foo/passwd}@value{dsq} 就不会意外 chmod @t{/etc/passwd} 。 它还会检查离开目录后的位置，这样深目录树的递归 chmod 就不会因为目录向上移动而对 @t{/usr} 进行递归 chmod。"

#. type: findex
#: zsh.texi:29098
#, no-wrap
msgid "chown"
msgstr "chown"

#. type: item
#: zsh.texi:29099
#, no-wrap
msgid "@t{chown} [ @t{-hRs} ] @var{user-spec} @var{filename} ..."
msgstr "@t{chown} [ @t{-hRs} ] @var{user-spec} @var{filename} ..."

#. type: table
#: zsh.texi:29101
msgid "Changes ownership and group of files specified."
msgstr "更改指定文件的所有权和群组。"

#. type: table
#: zsh.texi:29104
msgid "The @var{user-spec} can be in four forms:"
msgstr "@var{user-spec} 可以有四种形式："

#. type: var{#1}
#: zsh.texi:29107
#, no-wrap
msgid "user"
msgstr "user"

#. type: table
#: zsh.texi:29109 zsh.texi:29111
msgid "change owner to @var{user}; do not change group"
msgstr "将所有者更改为 @var{user}；不更改组"

#. type: item
#: zsh.texi:29109
#, no-wrap
msgid "@var{user}@t{::}"
msgstr "@var{user}@t{::}"

#. type: item
#: zsh.texi:29111
#, no-wrap
msgid "@var{user}@t{:}"
msgstr "@var{user}@t{:}"

#. type: table
#: zsh.texi:29113
msgid "change owner to @var{user}; change group to @var{user}'s primary group"
msgstr "将所有者更改为 @var{user}；将组更改为 @var{user} 的主组"

#. type: item
#: zsh.texi:29113
#, no-wrap
msgid "@var{user}@t{:}@var{group}"
msgstr "@var{user}@t{:}@var{group}"

#. type: table
#: zsh.texi:29115
msgid "change owner to @var{user}; change group to @var{group}"
msgstr "将所有者更改为 @var{user}；将组更改为 @var{group}"

#. type: item
#: zsh.texi:29115
#, no-wrap
msgid "@t{:}@var{group}"
msgstr "@t{:}@var{group}"

#. type: table
#: zsh.texi:29117
msgid "do not change owner; change group to @var{group}"
msgstr "不要更改所有者；将组更改为 @var{group}"

#. type: table
#: zsh.texi:29124
msgid ""
"In each case, the `@t{:}' may instead be a `@t{.}'.  The rule is that if there is a `@t{:}' then the separator is `@t{:}', otherwise if there is a `@t{.}' then the separator is `@t{.}', otherwise there is "
"no separator."
msgstr "在每种情况下， `@t{:}' 都可能是 `@t{.}'。 规则是，如果有一个  `@t{:}' ，那么分隔符就是 `@t{:}'，否则，如果有一个 `@t{.}'，那么分隔符就是 `@t{.}'，否则就没有分隔符。"

#. type: table
#: zsh.texi:29129
msgid ""
"Each of @var{user} and @var{group} may be either a username (or group name, as appropriate) or a decimal user ID (group ID).  Interpretation as a name takes precedence, if there is an all-numeric username "
"(or group name)."
msgstr "每个 @var{user} 和 @var{group} 都可以是用户名（或组名，视情况而定）或十进制用户 ID（组 ID）。 如果存在全数字用户名（或组名），则优先解释为名称。"

#. type: table
#: zsh.texi:29133
msgid "If the target is a symbolic link, the @t{-h} option causes @t{chown} to set the ownership of the link instead of its target."
msgstr "如果目标是符号链接，@t{-h}选项会导致 @t{chown} 设置链接的所有权，而不是目标。"

#. type: table
#: zsh.texi:29138
msgid "The @t{-R} option causes @t{chown} to recursively descend into directories, changing the ownership of all files in the directory after changing the ownership of the directory itself."
msgstr "@t{-R} 选项会使 @t{chown} 向下递归到目录中，在更改目录本身的所有权后，再更改目录中所有文件的所有权。"

#. type: table
#: zsh.texi:29149
msgid ""
"The @t{-s} option is a zsh extension to @t{chown} functionality.  It enables paranoid behaviour, intended to avoid security problems involving a @t{chown} being tricked into affecting files other than the "
"ones intended.  It will refuse to follow symbolic links, so that (for example)  @value{dsbq}@t{chown luser /tmp/foo/passwd}@value{dsq} can't accidentally chown @t{/etc/passwd} if @t{/tmp/foo} happens to "
"be a link to @t{/etc}.  It will also check where it is after leaving directories, so that a recursive chown of a deep directory tree can't end up recursively chowning @t{/usr} as a result of directories "
"being moved up the tree."
msgstr ""
"@t{-s} 选项是 zsh 对 @t{chown} 功能的扩展。 它启用了偏执行为，旨在避免因 @t{chown} 被欺骗而影响其他文件的安全问题。 它会拒绝跟踪符号链接，因此（例如），如果 @t{/tmp/foo} 恰好是 @t{/etc} 的链接， "
"@value{dsbq}@t{chown luser /tmp/foo/passwd}@value{dsq} 就不会意外地 chown @t{/etc/passwd}。 它还会检查离开目录后的位置，这样在对深目录树进行递归 chown 时，就不会因为目录被上移而对 @t{/usr} 进行递归 chown。"

#. type: findex
#: zsh.texi:29150
#, no-wrap
msgid "ln"
msgstr "在下面"

#. type: item
#: zsh.texi:29151
#, no-wrap
msgid "@t{ln} [ @t{-dfhins} ] @var{filename} @var{dest}"
msgstr "@t{ln} [ @t{-dfhins} ] @var{filename} @var{dest}"

#. type: itemx
#: zsh.texi:29152
#, no-wrap
msgid "@t{ln} [ @t{-dfhins} ] @var{filename} ... @var{dir}"
msgstr "@t{ln} [ @t{-dfhins} ] @var{filename} ... @var{dir}"

#. type: table
#: zsh.texi:29158
msgid ""
"Creates hard (or, with @t{-s}, symbolic) links.  In the first form, the specified @var{dest}ination is created, as a link to the specified @var{filename}.  In the second form, each of the @var{filename}s "
"is taken in turn, and linked to a pathname in the specified @var{dir}ectory that has the same last pathname component."
msgstr ""
"创建硬链接（或使用 @t{-s} 创建符号链接）。 第一种形式是创建指定 @var{dest} 目标，作为指向指定 @var{filename} 的链接。 在第二种形式中，每个 @var{filename}s 将依次链接到指定 @var{dir} 目录中具有相同最后路径"
"名组件的路径名。"

#. type: table
#: zsh.texi:29165
msgid ""
"Normally, @t{ln} will not attempt to create hard links to directories.  This check can be overridden using the @t{-d} option.  Typically only the super-user can actually succeed in creating hard links to "
"directories.  This does not apply to symbolic links in any case."
msgstr "通常情况下，@t{ln} 不会尝试创建指向目录的硬链接。 可以使用 @t{-d} 选项覆盖这一检查。 通常只有超级用户才能成功创建指向目录的硬链接。 这在任何情况下都不适用于符号链接。"

#. type: table
#: zsh.texi:29171
msgid ""
"By default, existing files cannot be replaced by links.  The @t{-i} option causes the user to be queried about replacing existing files.  The @t{-f} option causes existing files to be silently deleted, "
"without querying.  @t{-f} takes precedence."
msgstr "默认情况下，现有文件不能被链接替换。 @t{-i} 选项会询问用户是否替换现有文件。 而 @t{-f} 选项则会默默删除现有文件，无需询问。 @t{-f} 优先。"

#. type: table
#: zsh.texi:29182
msgid ""
"The @t{-h} and @t{-n} options are identical and both exist for compatibility; either one indicates that if the target is a symlink then it should not be dereferenced.  Typically this is used in "
"combination with @t{-sf} so that if an existing link points to a directory then it will be removed, instead of followed.  If this option is used with multiple filenames and the target is a symbolic link "
"pointing to a directory then the result is an error."
msgstr ""
"@t{-h} 和 @t{-n} 选项完全相同，都是为了兼容性而存在；其中任何一个都表示，如果目标是一个符号链接，则不应解引用。 通常情况下，该选项与 @t{-sf} 结合使用，这样一来，如果现有链接指向一个目录，则该链接将被移除，"
"而不是被跟踪。 如果该选项与多个文件名一起使用，且目标是指向目录的符号链接，则结果会出错。"

#. type: findex
#: zsh.texi:29183
#, no-wrap
msgid "mkdir"
msgstr "mkdir"

#. type: item
#: zsh.texi:29184
#, no-wrap
msgid "@t{mkdir} [ @t{-p} ] [ @t{-m} @var{mode} ] @var{dir} ..."
msgstr "@t{mkdir} [ @t{-p} ] [ @t{-m} @var{mode} ] @var{dir} ..."

#. type: table
#: zsh.texi:29191
msgid ""
"Creates directories.  With the @t{-p} option, non-existing parent directories are first created if necessary, and there will be no complaint if the directory already exists.  The @t{-m} option can be used "
"to specify (in octal) a set of file permissions for the created directories, otherwise mode 777 modified by the current @t{umask} (see umask(2)) is used."
msgstr ""
"创建目录。 使用 @t{-p} 选项时，如果有必要，会首先创建不存在的父目录，如果目录已经存在，则不会有任何抱怨。 可以使用 @t{-m} 选项为创建的目录指定一组文件权限（八进制），否则将使用经当前 @t{umask} 修改的 777 "
"模式（参见 umask(2) ）。"

#. type: findex
#: zsh.texi:29192
#, no-wrap
msgid "mv"
msgstr "mv"

#. type: item
#: zsh.texi:29193
#, no-wrap
msgid "@t{mv} [ @t{-fi} ] @var{filename} @var{dest}"
msgstr "@t{mv} [ @t{-fi} ] @var{filename} @var{dest}"

#. type: itemx
#: zsh.texi:29194
#, no-wrap
msgid "@t{mv} [ @t{-fi} ] @var{filename} ... @var{dir}"
msgstr "@t{mv} [ @t{-fi} ] @var{filename} ... @var{dir}"

#. type: table
#: zsh.texi:29200
msgid ""
"Moves files.  In the first form, the specified @var{filename} is moved to the specified @var{dest}ination.  In the second form, each of the @var{filename}s is taken in turn, and moved to a pathname in the "
"specified @var{dir}ectory that has the same last pathname component."
msgstr "移动文件。 第一种形式是将指定的 @var{filename} 移动到指定的 @var{dest} 目的地。 第二种形式是依次将每个 @var{filename}s 移动到指定 @var{dir} 目录中具有相同最后路径名组件的路径名中。"

#. type: table
#: zsh.texi:29208
msgid ""
"By default, the user will be queried before replacing any file that the user cannot write to, but writable files will be silently removed.  The @t{-i} option causes the user to be queried about replacing "
"any existing files.  The @t{-f} option causes any existing files to be silently deleted, without querying.  @t{-f} takes precedence."
msgstr ""
"默认情况下，在替换任何用户无法写入的文件前都会询问用户，但可写入的文件会被静默删除。 @t{-i} 选项会在替换任何现有文件时询问用户。 而 @t{-f} 选项则会在不询问用户的情况下默默删除任何现有文件。 @t{-f} 优先。"

#. type: table
#: zsh.texi:29214
msgid ""
"Note that this @t{mv} will not move files across devices.  Historical versions of @t{mv}, when actual renaming is impossible, fall back on copying and removing files; if this behaviour is desired, use "
"@t{cp} and @t{rm} manually.  This may change in a future version."
msgstr "请注意，此 @t{mv} 不会跨设备移动文件。 历史版本的 @t{mv} 在无法进行实际重命名时，会退回到复制和删除文件的方式；如果需要这种行为，请手动使用 @t{cp} 和 @t{rm}。 未来版本可能会对此进行修改。"

#. type: findex
#: zsh.texi:29215
#, no-wrap
msgid "rm"
msgstr "rm"

#. type: item
#: zsh.texi:29216
#, no-wrap
msgid "@t{rm} [ @t{-dfiRrs} ] @var{filename} ..."
msgstr "@t{rm} [ @t{-dfiRrs} ] @var{filename} ..."

#. type: table
#: zsh.texi:29218
msgid "Removes files and directories specified."
msgstr "删除指定的文件和目录。"

#. type: table
#: zsh.texi:29226
msgid ""
"Normally, @t{rm} will not remove directories (except with the @t{-R} or @t{-r} options).  The @t{-d} option causes @t{rm} to try removing directories with @t{unlink} (see unlink(2)), the same method used "
"for files.  Typically only the super-user can actually succeed in unlinking directories in this way.  @t{-d} takes precedence over @t{-R} and @t{-r}."
msgstr ""
"通常情况下，@t{rm} 不会删除目录（使用 @t{-R} 或 @t{-r} 选项时除外）。 @t{-d} 选项会让 @t{rm} 尝试使用 @t{unlink}（参见 unlink(2)）删除目录，这与删除文件的方法相同。 通常只有超级用户才能通过这种方法成功删除"
"目录。 @t{-d} 优先于 @t{-R} 和 @t{-r}。"

#. type: table
#: zsh.texi:29235
msgid ""
"By default, the user will be queried before removing any file that the user cannot write to, but writable files will be silently removed.  The @t{-i} option causes the user to be queried about removing "
"any files.  The @t{-f} option causes files to be silently deleted, without querying, and suppresses all error indications.  @t{-f} takes precedence."
msgstr "默认情况下，删除任何用户无法写入的文件前都会询问用户，但可写入的文件会被静默删除。 @t{-i} 选项会在删除任何文件时询问用户。 @t{-f}选项会导致静默删除文件，无需询问，并抑制所有错误提示。 @t{-f} 优先。"

#. type: table
#: zsh.texi:29240
msgid "The @t{-R} and @t{-r} options cause @t{rm} to recursively descend into directories, deleting all files in the directory before removing the directory with the @t{rmdir} system call (see rmdir(2))."
msgstr "@t{-R} 和 @t{-r} 选项会使 @t{rm} 以递归方式进入目录，删除目录中的所有文件，然后再使用 @t{rmdir} 系统调用删除目录（参见 rmdir(2)）。"

#. type: table
#: zsh.texi:29251
msgid ""
"The @t{-s} option is a zsh extension to @t{rm} functionality.  It enables paranoid behaviour, intended to avoid common security problems involving a root-run @t{rm} being tricked into removing files other "
"than the ones intended.  It will refuse to follow symbolic links, so that (for example)  @value{dsbq}@t{rm /tmp/foo/passwd}@value{dsq} can't accidentally remove @t{/etc/passwd} if @t{/tmp/foo} happens to "
"be a link to @t{/etc}.  It will also check where it is after leaving directories, so that a recursive removal of a deep directory tree can't end up recursively removing @t{/usr} as a result of directories "
"being moved up the tree."
msgstr ""
"@t{-s} 选项是 zsh 对 @t{rm} 功能的扩展。 它启用了偏执行为，旨在避免常见的安全问题，即 root 运行的 @t{rm} 会被诱骗删除预期之外的文件。 它会拒绝跟踪符号链接，因此（例如）如果 @t{/tmp/foo} 恰好是 @t{/etc} 的"
"链接，@value{dsbq}@t{rm /tmp/foo/passwd}@value{dsq} 就不会意外删除 @t{/etc/passwd} 。 它还会检查离开目录后的位置，这样在递归删除深目录树时，就不会因为目录被上移而递归删除 @t{/usr}。"

#. type: findex
#: zsh.texi:29252
#, no-wrap
msgid "rmdir"
msgstr "rmdir"

#. type: item
#: zsh.texi:29253
#, no-wrap
msgid "@t{rmdir} @var{dir} ..."
msgstr "@t{rmdir} @var{dir} ..."

#. type: table
#: zsh.texi:29255
msgid "Removes empty directories specified."
msgstr "删除指定的空目录。"

#. type: t{#1}
#: zsh.texi:29256 zsh.texi:29257 zsh.texi:30605
#, no-wrap
msgid "sync"
msgstr "sync"

#. type: table
#: zsh.texi:29261
msgid "Calls the system call of the same name (see sync(2)), which flushes dirty buffers to disk.  It might return before the I/O has actually been completed."
msgstr "调用同名系统调用（参见 sync(2)），将脏缓冲区刷新到磁盘。 它可能会在 I/O 实际完成之前返回。"

#. type: node
#: zsh.texi:29264 zsh.texi:29309 zsh.texi:29311 zsh.texi:29381
#, no-wrap
msgid "The zsh/mapfile Module"
msgstr "zsh/mapfile 模块"

#. type: Plain text
#: zsh.texi:29271
msgid "The @t{zsh/langinfo} module makes available one parameter:"
msgstr "@t{zsh/langinfo} 模块提供了一个参数："

#. type: t{#1}
#: zsh.texi:29274 zsh.texi:29275
#, no-wrap
msgid "langinfo"
msgstr "langinfo"

#. type: table
#: zsh.texi:29278
msgid "An associative array that maps langinfo elements to their values."
msgstr "关联数组，用于将 langinfo 元素映射到其值。"

#. type: table
#: zsh.texi:29281
msgid "Your implementation may support a number of the following keys:"
msgstr "您的实现可能支持以下多个键(keys)："

#. type: table
#: zsh.texi:29304
msgid ""
"@t{CODESET}, @t{D_T_FMT}, @t{D_FMT}, @t{T_FMT}, @t{RADIXCHAR}, @t{THOUSEP}, @t{YESEXPR}, @t{NOEXPR}, @t{CRNCYSTR}, @t{ABDAY_@{1..7@}}, @t{DAY_@{1..7@}}, @t{ABMON_@{1..12@}}, @t{MON_@{1..12@}}, "
"@t{T_FMT_AMPM}, @t{AM_STR}, @t{PM_STR}, @t{ERA}, @t{ERA_D_FMT}, @t{ERA_D_T_FMT}, @t{ERA_T_FMT}, @t{ALT_DIGITS}"
msgstr ""
"@t{CODESET}, @t{D_T_FMT}, @t{D_FMT}, @t{T_FMT}, @t{RADIXCHAR}, @t{THOUSEP}, @t{YESEXPR}, @t{NOEXPR}, @t{CRNCYSTR}, @t{ABDAY_@{1..7@}}, @t{DAY_@{1..7@}}, @t{ABMON_@{1..12@}}, @t{MON_@{1..12@}}, "
"@t{T_FMT_AMPM}, @t{AM_STR}, @t{PM_STR}, @t{ERA}, @t{ERA_D_FMT}, @t{ERA_D_T_FMT}, @t{ERA_T_FMT}, @t{ALT_DIGITS}"

#. type: node
#: zsh.texi:29309 zsh.texi:29381 zsh.texi:29383 zsh.texi:29499
#, no-wrap
msgid "The zsh/mathfunc Module"
msgstr "zsh/mathfunc 模块"

#. type: cindex
#: zsh.texi:29315
#, no-wrap
msgid "parameter, file access via"
msgstr "参数, 文件访问通过"

#. type: Plain text
#: zsh.texi:29318
msgid "The @t{zsh/mapfile} module provides one special associative array parameter of the same name."
msgstr "@t{zsh/mapfile} 模块提供了一个同名的特殊关联数组参数。"

#. type: t{#1}
#: zsh.texi:29321 zsh.texi:29322
#, no-wrap
msgid "mapfile"
msgstr "mapfile"

#. type: table
#: zsh.texi:29330
msgid ""
"This associative array takes as keys the names of files; the resulting value is the content of the file.  The value is treated identically to any other text coming from a parameter.  The value may also be "
"assigned to, in which case the file in question is written (whether or not it originally existed); or an element may be unset, which will delete the file in question.  For example, `@t{vared "
"'mapfile[myfile]'}' works as expected, editing the file `@t{myfile}'."
msgstr ""
"这个关联数组的键是文件名，结果值是文件的内容。 该值的处理方式与来自参数的任何其他文本相同。 该值也可以被赋值，在这种情况下，相关文件将被写入（无论其是否原本存在）；或者一个元素可以被取消设置，这将删除相关"
"文件。 例如，`@t{vared 'mapfile[myfile]'}' 就会如预期般编辑文件 `@t{myfile}'。"

#. type: table
#: zsh.texi:29338
msgid ""
"When the array is accessed as a whole, the keys are the names of files in the current directory, and the values are empty (to save a huge overhead in memory).  Thus @t{$@{(k)mapfile@}} has the same effect "
"as the glob operator @t{*(D)}, since files beginning with a dot are not special.  Care must be taken with expressions such as @t{rm $@{(k)mapfile@}}, which will delete every file in the current directory "
"without the usual `@t{rm *}' test."
msgstr ""
"当作为一个整体访问数组时，键是当前目录下的文件名，而值是空的（以节省大量内存开销）。 因此 @t{$@{(k)mapfile@}} 与 glob 操作符 @t{*(D)} 的效果相同，因为以点开头的文件并不特殊。 在使用 @t{rm $@{(k)mapfile@}} "
"这样的表达式时必须小心，因为它将删除当前目录下的所有文件，而无需进行通常的 `@t{rm *}' 测试。"

#. type: table
#: zsh.texi:29342
msgid "The parameter @t{mapfile} may be made read-only; in that case, files referenced may not be written or deleted."
msgstr "参数 @t{mapfile} 可以设置为只读；在这种情况下，不能写入或删除引用的文件。"

#. type: table
#: zsh.texi:29352
msgid ""
"A file may conveniently be read into an array as one line per element with the form `@var{array}@t{=(\"$@{(f@@)mapfile[}@var{filename}@t{]@}\")}'.  The double quotes and the `@t{@@}' are necessary to "
"prevent empty lines from being removed.  Note that if the file ends with a newline, the shell will split on the final newline, generating an additional empty field; this can be suppressed by using "
"`@var{array}@t{=(\"$@{(f@@)$@{mapfile[}@var{filename}@t{]%$'\\n'@}@}\")}'."
msgstr ""
"文件可以方便地以每行一个元素的形式读入数组，其形式为 `@var{array}@t{=(\"$@{(f@@)mapfile[}@var{filename}@t{]@}\")}'。 双引号和 `@t{@@}' 是防止删除空行所必需的。 需要注意的是，如果文件以换行结束，shell 会在"
"最后一个换行处分隔，产生一个额外的空字段；可以使用 `@var{array}@t{=(\"$@{(f@@)$@{mapfile[}@var{filename}@t{]%$'\\n'@}@}\")}' 来抑制这种情况。"

#. type: subsection
#: zsh.texi:29357
#, no-wrap
msgid "Limitations"
msgstr "局限性"

#. type: Plain text
#: zsh.texi:29370
msgid ""
"Although reading and writing of the file in question is efficiently handled, zsh's internal memory management may be arbitrarily baroque; however, @t{mapfile} is usually very much more efficient than "
"anything involving a loop.  Note in particular that the whole contents of the file will always reside physically in memory when accessed (possibly multiple times, due to standard parameter substitution "
"operations).  In particular, this means handling of sufficiently long files (greater than the machine's swap space, or than the range of the pointer type) will be incorrect."
msgstr ""
"虽然读写文件的效率很高，zsh 的内部内存管理也可能很随意，但 @t{mapfile} 通常比任何涉及循环的操作都要高效。 需要特别注意的是，文件的全部内容在被访问时（由于标准参数替换操作，可能会被多次访问）都会实际存在于"
"内存中。 这尤其意味着处理足够长的文件（大于机器的交换空间或超出指针类型的范围）将是不正确的。"

#. type: Plain text
#: zsh.texi:29375
msgid "No errors are printed or flagged for non-existent, unreadable, or unwritable files, as the parameter mechanism is too low in the shell execution hierarchy to make this convenient."
msgstr "对于不存在、不可读或不可写的文件，不会打印或标志错误，因为参数机制在 shell 执行层次结构中的位置太低，不方便这样做。"

#. type: Plain text
#: zsh.texi:29381
msgid "It is unfortunate that the mechanism for loading modules does not yet allow the user to specify the name of the shell parameter to be given the special behaviour."
msgstr "遗憾的是，加载模块的机制还不允许用户指定 shell 参数名称来赋予特殊行为的。"

#. type: node
#: zsh.texi:29381 zsh.texi:29499 zsh.texi:29501 zsh.texi:29545
#, no-wrap
msgid "The zsh/nearcolor Module"
msgstr "zsh/nearcolor 模块"

#. type: cindex
#: zsh.texi:29387
#, no-wrap
msgid "functions, mathematical"
msgstr "函数, 数学"

#. type: cindex
#: zsh.texi:29388
#, no-wrap
msgid "mathematical functions"
msgstr "数学函数"

#. type: Plain text
#: zsh.texi:29393
msgid "The @t{zsh/mathfunc} module provides standard mathematical functions for use when evaluating mathematical formulae.  The syntax agrees with normal C and FORTRAN conventions, for example,"
msgstr "@t{zsh/mathfunc} 模块为数学公式求值提供了标准数学函数。 其语法与 C 和 FORTRAN 的常规语法一致，例如,"

#. type: example
#: zsh.texi:29397
#, no-wrap
msgid "(( f = sin(0.3) ))\n"
msgstr "(( f = sin(0.3) ))\n"

#. type: Plain text
#: zsh.texi:29401
msgid "assigns the sine of 0.3 to the parameter f."
msgstr "将 0.3 的正弦值赋值给参数 f。"

#. type: Plain text
#: zsh.texi:29410
msgid ""
"Most functions take floating point arguments and return a floating point value.  However, any necessary conversions from or to integer type will be performed automatically by the shell.  Apart from "
"@t{atan} with a second argument and the @t{abs}, @t{int} and @t{float} functions, all functions behave as noted in the manual page for the corresponding C function, except that any arguments out of range "
"for the function in question will be detected by the shell and an error reported."
msgstr ""
"大多数函数使用浮点参数并返回浮点数值。 不过，任何必要的整数类型转换都将由 shell 自动执行。 除了带有第二个参数的 @t{atan}，以及 @t{abs}、@t{int} 和 @t{float} 函数外，所有函数的行为都与相应 C 语言函数手册中"
"的说明相同，但任何超出函数范围的参数都会被 shell 检测到并报错。"

#. type: Plain text
#: zsh.texi:29421
msgid ""
"The following functions take a single floating point argument: @t{acos}, @t{acosh}, @t{asin}, @t{asinh}, @t{atan}, @t{atanh}, @t{cbrt}, @t{ceil}, @t{cos}, @t{cosh}, @t{erf}, @t{erfc}, @t{exp}, @t{expm1}, "
"@t{fabs}, @t{floor}, @t{gamma}, @t{j0}, @t{j1}, @t{lgamma}, @t{log}, @t{log10}, @t{log1p}, @t{log2}, @t{logb}, @t{sin}, @t{sinh}, @t{sqrt}, @t{tan}, @t{tanh}, @t{y0}, @t{y1}.  The @t{atan} function can "
"optionally take a second argument, in which case it behaves like the C function @t{atan2}.  The @t{ilogb} function takes a single floating point argument, but returns an integer."
msgstr ""
"以下函数只接受一个浮点参数： @t{acos}, @t{acosh}, @t{asin}, @t{asinh}, @t{atan}, @t{atanh}, @t{cbrt}, @t{ceil}, @t{cos}, @t{cosh}, @t{erf}, @t{erfc}, @t{exp}, @t{expm1}, @t{fabs}, @t{floor}, @t{gamma}, "
"@t{j0}, @t{j1}, @t{lgamma}, @t{log}, @t{log10}, @t{log1p}, @t{log2}, @t{logb}, @t{sin}, @t{sinh}, @t{sqrt}, @t{tan}, @t{tanh}, @t{y0}, @t{y1}。 @t{atan} 函数可以接受可选的第二个参数，在这种情况下，它的行为"
"类似于 C 语言函数 @t{atan2}。 @t{ilogb} 函数接收一个浮点参数，但返回一个整数。"

#. type: Plain text
#: zsh.texi:29428
msgid ""
"The function @t{signgam} takes no arguments, and returns an integer, which is the C variable of the same name, as described in gamma(3).  Note that it is therefore only useful immediately after a call to "
"@t{gamma} or @t{lgamma}.  Note also that `@t{signgam()}' and `@t{signgam}' are distinct expressions."
msgstr "函数 @t{signgam} 不带参数，返回一个整数，即 gamma(3) 中描述的同名 C 变量。 请注意，该函数只有在调用 @t{gamma} 或 @t{lgamma} 之后才有用。 还要注意， `@t{signgam()}' 和 `@t{signgam}' 是不同的表达式。"

#. type: Plain text
#: zsh.texi:29433
msgid "The functions @t{min}, @t{max}, and @t{sum} are defined not in this module but in the @t{zmathfunc} autoloadable function, described in @ref{Mathematical Functions}."
msgstr "函数 @t{min}、@t{max} 和 @t{sum} 不是在本模块中定义的，而是在 @ref{数学函数} 中描述的 @t{zmathfunc} 可自动加载函数中定义的。"

#. type: Plain text
#: zsh.texi:29437
msgid "The following functions take two floating point arguments: @t{copysign}, @t{fmod}, @t{hypot}, @t{nextafter}."
msgstr "以下函数使用两个浮点参数： @t{copysign}、@t{fmod}、@t{hypot}、@t{nextafter}。"

#. type: Plain text
#: zsh.texi:29441
msgid "The following take an integer first argument and a floating point second argument: @t{jn}, @t{yn}."
msgstr "以下函数的第一个参数为整数，第二个参数为浮点数： @t{jn}、@t{yn}。"

#. type: Plain text
#: zsh.texi:29445
msgid "The following take a floating point first argument and an integer second argument: @t{ldexp}, @t{scalb}."
msgstr "以下函数的第一个参数为浮点数，第二个参数为整数： @t{ldexp}, @t{scalb}."

#. type: Plain text
#: zsh.texi:29451
msgid ""
"The function @t{abs} does not convert the type of its single argument; it returns the absolute value of either a floating point number or an integer.  The functions @t{float} and @t{int} convert their "
"arguments into a floating point or integer value (by truncation) respectively."
msgstr "函数 @t{abs} 并不转换其单一参数的类型，而是返回浮点数或整数的绝对值。 函数 @t{float} 和 @t{int} 分别将参数转换为浮点数或整数（通过截断）。"

#. type: Plain text
#: zsh.texi:29455
msgid "Note that the C @t{pow} function is available in ordinary math evaluation as the `@t{**}' operator and is not provided here."
msgstr "请注意，C的 @t{pow} 函数在普通数学运算中可作为 `@t{**}' 运算符使用，此处不再提供。"

#. type: Plain text
#: zsh.texi:29460
msgid ""
"The function @t{rand48} is available if your system's mathematical library has the function @t{erand48(3)}.  It returns a pseudo-random floating point number between 0 and 1.  It takes a single string "
"optional argument."
msgstr "如果系统的数学库中有 @t{erand48(3)}，则函数 @t{rand48} 可用。 它返回一个介于 0 和 1 之间的伪随机浮点数。它接受一个字符串作为可选参数。"

#. type: Plain text
#: zsh.texi:29466
msgid "If the argument is not present, the random number seed is initialised by three calls to the @t{rand(3)} function --- this produces the same random numbers as the next three values of @t{$RANDOM}."
msgstr "如果不存在该参数，随机数种子将通过三次调用 @t{rand(3)} 函数来初始化 --- 这将产生与 @t{$RANDOM} 接下来三个值相同的随机数。"

#. type: Plain text
#: zsh.texi:29478
msgid ""
"If the argument is present, it gives the name of a scalar parameter where the current random number seed will be stored.  On the first call, the value must contain at least twelve hexadecimal digits (the "
"remainder of the string is ignored), or the seed will be initialised in the same manner as for a call to @t{rand48} with no argument.  Subsequent calls to @t{rand48}(@var{param}) will then maintain the "
"seed in the parameter @var{param} as a string of twelve hexadecimal digits, with no base signifier.  The random number sequences for different parameters are completely independent, and are also "
"independent from that used by calls to @t{rand48} with no argument."
msgstr ""
"如果存在该参数，它将给出一个标量参数的名称，当前随机数种子将存储在该参数中。 第一次调用时，该值必须至少包含 12 个十六进制数字（字符串的其余部分将被忽略），否则种子将以与调用 @t{rand48} (不带参数)时相同的方"
"式初始化。 随后调用 @t{rand48}(@var{param})时，参数 @var{param} 中的种子将保持为一个包含十二位十六进制数字的字符串，不含基数符号。 不同参数的随机数序列是完全独立的，也独立于不带参数的 @t{rand48} 调用所使用"
"的随机数序列。"

#. type: Plain text
#: zsh.texi:29481
msgid "For example, consider"
msgstr "例如，考虑"

#. type: example
#: zsh.texi:29487
#, no-wrap
msgid ""
"print $(( rand48(seed) ))\n"
"print $(( rand48() ))\n"
"print $(( rand48(seed) ))\n"
msgstr ""
"print $(( rand48(seed) ))\n"
"print $(( rand48() ))\n"
"print $(( rand48(seed) ))\n"

#. type: Plain text
#: zsh.texi:29499
msgid ""
"Assuming @t{$seed} does not exist, it will be initialised by the first call.  In the second call, the default seed is initialised; note, however, that because of the properties of @t{rand()} there is a "
"correlation between the seeds used for the two initialisations, so for more secure uses, you should generate your own 12-byte seed.  The third call returns to the same sequence of random numbers used in "
"the first call, unaffected by the intervening @t{rand48()}."
msgstr ""
"假设 @t{$seed} 不存在，第一次调用将初始化它。 在第二次调用中，将初始化默认种子；但请注意，由于 @t{rand()} 的属性，两次初始化使用的种子之间存在关联，因此为了更安全地使用，应自己生成 12 字节的种子。 第三次调"
"用将返回第一次调用中使用的随机数序列，不受中间 @t{rand48()} 的影响。"

#. type: node
#: zsh.texi:29499 zsh.texi:29545 zsh.texi:29547 zsh.texi:29601
#, no-wrap
msgid "The zsh/newuser Module"
msgstr "zsh/newuser 模块"

#. type: Plain text
#: zsh.texi:29512
msgid ""
"The @t{zsh/nearcolor} module replaces colours specified as hex triplets with the nearest colour in the 88 or 256 colour palettes that are widely used by terminal emulators.  By default, 24-bit true colour "
"escape codes are generated when colours are specified using hex triplets.  These are not supported by all terminals.  The purpose of this module is to make it easier to define colour preferences in a form "
"that can work across a range of terminal emulators."
msgstr ""
"@t{zsh/nearcolor} 模块会用终端模拟器广泛使用的 88 或 256 色调色板中最接近的颜色替换以十六进制三连字符指定的颜色。 默认情况下，使用十六进制三连字符指定颜色时，会生成 24 位真彩色转义码。 但并非所有终端都支持"
"这些代码。 本模块的目的是让用户能更方便地定义颜色偏好，并能在各种终端模拟器中使用。"

#. type: Plain text
#: zsh.texi:29521
msgid ""
"Aside from the default colour, the ANSI standard for terminal escape codes provides for eight colours. The bright attribute brings this to sixteen. These basic colours are commonly used in terminal "
"applications due to being widely supported. Expanded 88 and 256 colour palettes are also common and, while the first sixteen colours vary somewhat between terminals and configurations, these add a "
"generally consistent and predictable set of colours."
msgstr ""
"除默认颜色外，ANSI 终端转义代码标准还规定了八种颜色。亮色属性将其增加到 16 种。这些基本颜色由于得到广泛支持，在终端应用程序中得到普遍使用。扩展的 88 色和 256 色调色板也很常见，虽然前 16 种颜色在不同终端和"
"配置之间存在一定差异，但它们提供了一套基本一致且可预测的颜色。"

#. type: Plain text
#: zsh.texi:29528
msgid ""
"In order to use the @t{zsh/nearcolor} module, it only needs to be loaded. Thereafter, whenever a colour is specified using a hex triplet, it will be compared against each of the available colours and the "
"closest will be selected. The first sixteen colours are never matched in this process due to being unpredictable."
msgstr "要使用 @t{zsh/nearcolor} 模块，只需加载该模块即可。此后，每当使用十六进制三元组指定颜色时，都会将其与每个可用颜色进行比较，并选择最接近的颜色。由于无法预测，前 16 种颜色在此过程中永远不会匹配。"

#. type: Plain text
#: zsh.texi:29534
msgid ""
"It isn't possible to reliably detect support for true colour in the terminal emulator. It is therefore recommended to be selective in loading the @t{zsh/nearcolor} module. For example, the following "
"checks the @t{COLORTERM} environment variable:"
msgstr "在终端模拟器中无法可靠地检测对真彩色的支持。因此，建议有选择性地加载 @t{zsh/nearcolor} 模块。例如，下面的代码会检查 @t{COLORTERM} 环境变量："

#. type: example
#: zsh.texi:29538
#, no-wrap
msgid "[[ $COLORTERM = *(24bit|truecolor)* ]] || zmodload zsh/nearcolor\n"
msgstr "[[ $COLORTERM = *(24bit|truecolor)* ]] || zmodload zsh/nearcolor\n"

#. type: Plain text
#: zsh.texi:29545
msgid "Note that some terminals accept the true color escape codes but map them internally to a more limited palette in a similar manner to the @t{zsh/nearcolor} module."
msgstr "请注意，有些终端接受真彩色转义码，但内部会将其映射到更有限的调色板上，其方式与 @t{zsh/nearcolor} 模块类似。"

#. type: node
#: zsh.texi:29545 zsh.texi:29601 zsh.texi:29603 zsh.texi:29883
#, no-wrap
msgid "The zsh/parameter Module"
msgstr "zsh/parameter 模块"

#. type: Plain text
#: zsh.texi:29558
msgid ""
"The @t{zsh/newuser} module is loaded at boot if it is available, the @t{RCS} option is set, and the @t{PRIVILEGED} option is not set (all three are true by default).  This takes place immediately after "
"commands in the global @t{zshenv} file (typically @t{/etc/zshenv}), if any, have been executed.  If the module is not available it is silently ignored by the shell; the module may safely be removed from "
"@t{$MODULE_PATH} by the administrator if it is not required."
msgstr ""
"如果 @t{zsh/newuser} 模块可用、@t{RCS} 选项已设置、@t{PRIVILEGED} 选项未设置（默认情况下三者均为 true），则会在启动时加载该模块。 如果全局 @t{zshenv} 文件（通常为 @t{/etc/zshenv}）中有命令，则在执行完这些"
"命令后立即启动。 如果模块不可用，shell 会静默忽略；如果不需要该模块，管理员可以安全地将其从 @t{$MODULE_PATH} 中删除。"

#. type: Plain text
#: zsh.texi:29566
msgid ""
"On loading, the module tests if any of the start-up files @t{.zshenv}, @t{.zprofile}, @t{.zshrc} or @t{.zlogin} exist in the directory given by the environment variable @t{ZDOTDIR}, or the user's home "
"directory if that is not set.  The test is not performed and the module halts processing if the shell was in an emulation mode (i.e. had been invoked as some other shell than zsh)."
msgstr ""
"加载时，模块会测试 @t{.zshenv}、@t{.zprofile}、@t{.zshrc} 或 @t{.zlogin} 中的启动文件是否存在于环境变量 @t{ZDOTDIR} 指定的目录中，如果未设置环境变量 @t{ZDOTDIR} 则测试用户的主目录。 如果 shell 处于仿真模式"
"（即以其他 shell 而非 zsh 的身份调用），则不会执行测试，模块会停止处理。"

#. type: Plain text
#: zsh.texi:29578
msgid ""
"If none of the start-up files were found, the module then looks for the file @t{newuser} first in a sitewide directory, usually the parent directory of the @t{site-functions} directory, and if that is not "
"found the module searches in a version-specific directory, usually the parent of the @t{functions} directory containing version-specific functions.  (These directories can be configured when zsh is built "
"using the @t{--enable-site-scriptdir=}@var{dir} and @t{--enable-scriptdir=}@var{dir} flags to @t{configure}, respectively; the defaults are @var{prefix}@t{/share/zsh} and @var{prefix}@t{/share/zsh/"
"$ZSH_VERSION} where the default @var{prefix} is @t{/usr/local}.)"
msgstr ""
"如果没有找到任何启动文件，模块会首先在全站目录（通常是 @t{site-functions} 目录的父目录）中查找 @t{newuser} 文件，如果没有找到，模块会在特定版本目录（通常是包含特定版本函数的 @t{functions} 目录的父目录）中"
"查找。 (在构建 zsh 时，可以分别使用 @t{configure} 的 @t{--enable-site-scriptdir=}@var{dir} 和 @t{--enable-scriptdir=}@var{dir} 标志来配置这些目录； 默认值为@var{prefix}@t{/share/zsh} 和 @var{prefix}@t{/"
"share/zsh/$ZSH_VERSION} ，其中默认 @var{prefix} 为 @t{/usr/local}。 )"

#. type: Plain text
#: zsh.texi:29583
msgid ""
"If the file @t{newuser} is found, it is then sourced in the same manner as a start-up file.  The file is expected to contain code to install start-up files for the user, however any valid shell code will "
"be executed."
msgstr "如果找到 @t{newuser} 文件，则会以与启动文件相同的方式引入该文件。 该文件预计将包含为用户安装启动文件的代码，但任何有效的 shell 代码都将被执行。"

#. type: Plain text
#: zsh.texi:29586
msgid "The @t{zsh/newuser} module is then unconditionally unloaded."
msgstr "随后 @t{zsh/newuser} 模块将无条件卸载。"

#. type: Plain text
#: zsh.texi:29592
msgid ""
"Note that it is possible to achieve exactly the same effect as the @t{zsh/newuser} module by adding code to @t{/etc/zshenv}.  The module exists simply to allow the shell to make arrangements for new users "
"without the need for intervention by package maintainers and system administrators."
msgstr "请注意，通过在 @t{/etc/zshenv} 中添加代码，可以实现与 @t{zsh/newuser} 模块完全相同的效果。 该模块的存在仅仅是为了让 shell 在不需要软件包维护者和系统管理员干预的情况下安排新用户。"

#. type: Plain text
#: zsh.texi:29601
msgid ""
"The script supplied with the module invokes the shell function @t{zsh-newuser-install}.  This may be invoked directly by the user even if the @t{zsh/newuser} module is disabled.  Note, however, that if "
"the module is not installed the function will not be installed either.  The function is documented in @ref{User Configuration Functions}."
msgstr ""
"与模块一起提供的脚本会调用 shell 函数 @t{zsh-newuser-install}。 即使 @t{zsh/newuser} 模块被禁用，用户也可以直接调用该函数。 但请注意，如果模块未安装，函数也不会安装。 该函数在 @ref{用户配置函数} 中有详细说"
"明。"

#. type: node
#: zsh.texi:29601 zsh.texi:29883 zsh.texi:29885 zsh.texi:29989
#, no-wrap
msgid "The zsh/pcre Module"
msgstr "zsh/pcre 模块"

#. type: Plain text
#: zsh.texi:29610
msgid "The @t{zsh/parameter} module gives access to some of the internal hash tables used by the shell by defining some special parameters."
msgstr "@t{zsh/parameter} 模块通过定义一些特殊参数来访问 shell 使用的某些内部哈希表。"

#. type: table
#: zsh.texi:29622
msgid ""
"The keys for this associative array are the names of the options that can be set and unset using the @t{setopt} and @t{unsetopt} builtins. The value of each key is either the string @t{on} if the option "
"is currently set, or the string @t{off} if the option is unset.  Setting a key to one of these strings is like setting or unsetting the option, respectively. Unsetting a key in this array is like setting "
"it to the value @t{off}."
msgstr ""
"这个关联数组的键是可使用 @t{setopt} 和 @t{unsetopt} 内置函数设置和取消设置的选项名称。如果选项当前已设置，则每个键的值都是 @t{on} 字符串；如果选项未设置，则每个键的值都是 @t{off} 字符串。 将键值设置为其中"
"一个字符串，就相当于设置或取消设置该选项。取消设置数组中的某个键，就相当于将其设置为 @t{off} 值。"

#. type: table
#: zsh.texi:29632
msgid ""
"This array gives access to the command hash table. The keys are the names of external commands, the values are the pathnames of the files that would be executed when the command would be invoked. Setting "
"a key in this array defines a new entry in this table in the same way as with the @t{hash} builtin. Unsetting a key as in `@t{unset \"commands[foo]\"}' removes the entry for the given key from the command "
"hash table."
msgstr ""
"该数组用于访问命令哈希表。键是外部命令的名称，值是调用该命令时将执行的文件的路径名。在此数组中设置键，将在此表中定义一个新条目，方法与 @t{hash} 内置函数相同。取消设置键，如 `@t{unset \"commands[foo]\"}'，"
"则从命令哈希表中删除给定键的条目。"

#. type: table
#: zsh.texi:29639
msgid ""
"This associative array maps names of enabled functions to their definitions. Setting a key in it is like defining a function with the name given by the key and the body given by the value. Unsetting a key "
"removes the definition for the function named by the key."
msgstr "这个关联数组将已启用函数的名称映射到其定义。在其中设置一个键，就等于定义了一个名称由键给出、主体由值给出的函数。取消键值设置则会删除键值所指定函数的定义。"

#. type: t{#1}
#: zsh.texi:29640 zsh.texi:29641
#, no-wrap
msgid "dis_functions"
msgstr "dis_functions"

#. type: table
#: zsh.texi:29643
msgid "Like @t{functions} but for disabled functions."
msgstr "与 @t{functions} 类似，但用于禁用函数。"

#. type: t{#1}
#: zsh.texi:29644 zsh.texi:29645
#, no-wrap
msgid "functions_source"
msgstr "functions_source"

#. type: table
#: zsh.texi:29648
msgid "This readonly associative array maps names of enabled functions to the name of the file containing the source of the function."
msgstr "这个只读关联数组将已启用函数的名称映射到包含函数源代码的文件名。"

#. type: table
#: zsh.texi:29654
msgid ""
"For an autoloaded function that has already been loaded, or marked for autoload with an absolute path, or that has had its path resolved with `@t{functions -r}', this is the file found for autoloading, "
"resolved to an absolute path."
msgstr "对于已加载的自动加载函数，或用绝对路径已标记为自动加载的函数，或已使用 `@t{functions -r}' 解析其路径的函数，这是找到的自动加载的文件，解析为绝对路径。"

#. type: table
#: zsh.texi:29659
msgid "For a function defined within the body of a script or sourced file, this is the name of that file.  In this case, this is the exact path originally used to that file, which may be a relative path."
msgstr "对于在脚本或源文件正文中定义的函数，这是文件的名称。 在这种情况下，这是该文件最初使用的确切路径，也可以是相对路径。"

#. type: table
#: zsh.texi:29666
msgid ""
"For any other function, including any defined at an interactive prompt or an autoload function whose path has not yet been resolved, this is the empty string.  However, the hash element is reported as "
"defined just so long as the function is present: the keys to this hash are the same as those to @t{$functions}."
msgstr "对于任何其他函数，包括在交互式提示符下定义的函数或路径尚未解析的自动加载函数，该值为空字符串。 不过，只要函数存在，哈希元素就会被报告为已定义：该哈希的键s与 @t{$functions} 的键s相同。"

#. type: t{#1}
#: zsh.texi:29667 zsh.texi:29668
#, no-wrap
msgid "dis_functions_source"
msgstr "dis_functions_source"

#. type: table
#: zsh.texi:29670
msgid "Like @t{functions_source} but for disabled functions."
msgstr "与 @t{functions_source} 类似，但用于禁用的函数。"

#. type: table
#: zsh.texi:29678
msgid ""
"This associative array gives information about the builtin commands currently enabled. The keys are the names of the builtin commands and the values are either `@t{undefined}' for builtin commands that "
"will automatically be loaded from a module if invoked or `@t{defined}' for builtin commands that are already loaded."
msgstr "这个关联数组提供了当前已启用的内置命令的信息。键是内置命令的名称，值是 `@t{undefined}'（如果调用，将自动从模块加载的内置命令）或 `@t{defined}' （已经加载的内置命令）。"

#. type: t{#1}
#: zsh.texi:29679 zsh.texi:29680
#, no-wrap
msgid "dis_builtins"
msgstr "dis_builtins"

#. type: table
#: zsh.texi:29682
msgid "Like @t{builtins} but for disabled builtin commands."
msgstr "与 @t{builtins} 类似，但用于禁用的内置命令。"

#. type: t{#1}
#: zsh.texi:29683 zsh.texi:29684
#, no-wrap
msgid "reswords"
msgstr "reswords"

#. type: table
#: zsh.texi:29686
msgid "This array contains the enabled reserved words."
msgstr "该数组包含已启用的保留字。"

#. type: t{#1}
#: zsh.texi:29687 zsh.texi:29688
#, no-wrap
msgid "dis_reswords"
msgstr "dis_reswords"

#. type: table
#: zsh.texi:29690
msgid "Like @t{reswords} but for disabled reserved words."
msgstr "与 @t{reswords} 类似，但用于禁用的保留字。"

#. type: t{#1}
#: zsh.texi:29691 zsh.texi:29692
#, no-wrap
msgid "patchars"
msgstr "patchars"

#. type: table
#: zsh.texi:29694
msgid "This array contains the enabled pattern characters."
msgstr "该数组包含启用的模式字符。"

#. type: t{#1}
#: zsh.texi:29695 zsh.texi:29696
#, no-wrap
msgid "dis_patchars"
msgstr "dis_patchars"

#. type: table
#: zsh.texi:29698
msgid "Like @t{patchars} but for disabled pattern characters."
msgstr "与 @t{patchars} 类似，但用于禁用的模式字符。"

#. type: t{#1}
#: zsh.texi:29699 zsh.texi:29700 zsh.texi:35791
#, no-wrap
msgid "aliases"
msgstr "aliases"

#. type: table
#: zsh.texi:29703
msgid "This maps the names of the regular aliases currently enabled to their expansions."
msgstr "这将当前启用的常规别名的名称映射到其扩展。"

#. type: t{#1}
#: zsh.texi:29704 zsh.texi:29705
#, no-wrap
msgid "dis_aliases"
msgstr "dis_aliases"

#. type: table
#: zsh.texi:29707
msgid "Like @t{aliases} but for disabled regular aliases."
msgstr "与 @t{aliases} 类似，但禁用了常规别名。"

#. type: t{#1}
#: zsh.texi:29708 zsh.texi:29709
#, no-wrap
msgid "galiases"
msgstr "galiases"

#. type: table
#: zsh.texi:29711
msgid "Like @t{aliases}, but for global aliases."
msgstr "类似 @t{aliases}，但用于全局别名。"

#. type: t{#1}
#: zsh.texi:29712 zsh.texi:29713
#, no-wrap
msgid "dis_galiases"
msgstr "dis_galiases"

#. type: table
#: zsh.texi:29715
msgid "Like @t{galiases} but for disabled global aliases."
msgstr "与 @t{galiases} 类似，但禁用了全局别名。"

#. type: t{#1}
#: zsh.texi:29716 zsh.texi:29717
#, no-wrap
msgid "saliases"
msgstr "saliases"

#. type: table
#: zsh.texi:29719
msgid "Like @t{raliases}, but for suffix aliases."
msgstr "与 @t{raliases} 类似，但用于后缀别名。"

#. type: t{#1}
#: zsh.texi:29720 zsh.texi:29721
#, no-wrap
msgid "dis_saliases"
msgstr "dis_saliases"

#. type: table
#: zsh.texi:29723
msgid "Like @t{saliases} but for disabled suffix aliases."
msgstr "与 @t{saliases} 类似，只是禁用了后缀别名。"

#. type: table
#: zsh.texi:29732
msgid ""
"The keys in this associative array are the names of the parameters currently defined. The values are strings describing the type of the parameter, in the same format used by the @t{t} parameter flag, see "
"@ref{Parameter Expansion} .  Setting or unsetting keys in this array is not possible."
msgstr "这个关联数组的键是当前定义的参数名称。值是描述参数类型的字符串，格式与 @t{t} 参数标志相同，参见 @ref{参数扩展} 。 无法设置或取消设置数组中的键。"

#. type: table
#: zsh.texi:29740
msgid ""
"An associative array giving information about modules. The keys are the names of the modules loaded, registered to be autoloaded, or aliased. The value says which state the named module is in and is one "
"of the strings `@t{loaded}', `@t{autoloaded}', or `@t{alias:}@var{name}', where @var{name} is the name the module is aliased to."
msgstr ""
"提供模块信息的关联数组。键是已加载、已注册为自动加载或已有别名的模块名称。值表示被命名模块所处的状态，是字符串`@t{loaded}', `@t{autoloaded}' 或 `@t{alias:}@var{name}' 之一，其中 @var{name} 是模块的别名。"

#. type: table
#: zsh.texi:29743
msgid "Setting or unsetting keys in this array is not possible."
msgstr "无法设置或取消设置该数组中的键。"

#. type: t{#1}
#: zsh.texi:29744 zsh.texi:29745
#, no-wrap
msgid "dirstack"
msgstr "dirstack"

#. type: table
#: zsh.texi:29749
msgid "A normal array holding the elements of the directory stack. Note that the output of the @t{dirs} builtin command includes one more directory, the current working directory."
msgstr "一个包含目录栈元素的普通数组。请注意，@t{dirs} 内置命令的输出还包括一个目录，即当前工作目录。"

#. type: table
#: zsh.texi:29756
msgid ""
"This associative array maps history event numbers to the full history lines.  Although it is presented as an associative array, the array of all values (@t{$@{history[@@]@}}) is guaranteed to be returned "
"in order from most recent to oldest history event, that is, by decreasing history event number."
msgstr ""
"该关联数组将历史事件编号映射到完整的历史行。 虽然它是以关联数组的形式呈现，但所有值的数组（@t{$@{history[@@]@}}）保证按照从最近的历史事件到最古老的历史事件的顺序返回，即按照历史事件编号递减的方式返回。"

#. type: t{#1}
#: zsh.texi:29757 zsh.texi:29758
#, no-wrap
msgid "historywords"
msgstr "historywords"

#. type: table
#: zsh.texi:29761
msgid "A special array containing the words stored in the history.  These also appear in most to least recent order."
msgstr "一个特殊数组，包含存储在历史记录中的单词。 这些词也是按从最近到最久远的顺序排列的。"

#. type: t{#1}
#: zsh.texi:29762 zsh.texi:29763
#, no-wrap
msgid "jobdirs"
msgstr "jobdirs"

#. type: table
#: zsh.texi:29766
msgid "This associative array maps job numbers to the directories from which the job was started (which may not be the current directory of the job)."
msgstr "这个关联数组将作业编号映射到作业启动的目录（可能不是作业的当前目录）。"

#. type: table
#: zsh.texi:29772
msgid ""
"The keys of the associative arrays are usually valid job numbers, and these are the values output with, for example, @t{$@{(k)jobdirs@}}.  Non-numeric job references may be used when looking up a value; "
"for example, @t{$@{jobdirs[%+]@}} refers to the current job."
msgstr "关联数组的键通常是有效的作业编号，这些是,例如 @t{$@{(k)jobdirs@}} 输出的值。 在查找值时，可以使用非数字作业引用；例如，@t{$@{jobdirs[%+]@}} 指的是当前作业。"

#. type: table
#: zsh.texi:29775 zsh.texi:29787 zsh.texi:29807
msgid "See the @t{jobs} builtin for how job information is provided in a subshell."
msgstr "有关如何在子 shell 中提供作业信息，请参阅 @t{jobs} 内置函数。"

#. type: t{#1}
#: zsh.texi:29776 zsh.texi:29777
#, no-wrap
msgid "jobtexts"
msgstr "jobtexts"

#. type: table
#: zsh.texi:29780
msgid "This associative array maps job numbers to the texts of the command lines that were used to start the jobs."
msgstr "这个关联数组将作业编号映射到用于启动作业的命令行文本。"

#. type: table
#: zsh.texi:29784 zsh.texi:29804
msgid "Handling of the keys of the associative array is as described for @t{jobdirs} above."
msgstr "对关联数组键的处理与上文 @t{jobdirs} 的描述相同。"

#. type: t{#1}
#: zsh.texi:29788 zsh.texi:29789
#, no-wrap
msgid "jobstates"
msgstr "jobstates"

#. type: table
#: zsh.texi:29800
msgid ""
"This associative array gives information about the states of the jobs currently known. The keys are the job numbers and the values are strings of the form `@var{job-state}@t{:}@var{mark}@t{:}@var{pid}@t{=}"
"@var{state}...'. The @var{job-state} gives the state the whole job is currently in, one of `@t{running}', `@t{suspended}', or `@t{done}'. The @var{mark} is `@t{+}' for the current job, `@t{-}' for the "
"previous job and empty otherwise. This is followed by one `@t{:}@var{pid}@t{=}@var{state}' for every process in the job. The @var{pid}s are, of course, the process IDs and the @var{state} describes the "
"state of that process."
msgstr ""
"这个关联数组提供了当前已知作业的状态信息。键是作业编号，值是格式为  `@var{job-state}@t{:}@var{mark}@t{:}@var{pid}@t{=}@var{state}...' 的字符串。@var{job-state}给出了整个作业当前所处的状态，即 "
"`@t{running}', `@t{suspended}' 或 `@t{done}'。@var{mark} 中的 `@t{+}' 表示当前作业，`@t{-}' 表示上一个作业，否则为空。随后，作业中的每个进程都会有一个 `@t{:}@var{pid}@t{=}@var{state}'。@var{pid}s 当然是进"
"程 ID，而 @var{state} 则描述该进程的状态。"

#. type: t{#1}
#: zsh.texi:29808 zsh.texi:29809
#, no-wrap
msgid "nameddirs"
msgstr "nameddirs"

#. type: table
#: zsh.texi:29812
msgid "This associative array maps the names of named directories to the pathnames they stand for."
msgstr "这个关联数组将命名目录的名称映射到它们所代表的路径名。"

#. type: t{#1}
#: zsh.texi:29813 zsh.texi:29814
#, no-wrap
msgid "userdirs"
msgstr "userdirs"

#. type: table
#: zsh.texi:29817
msgid "This associative array maps user names to the pathnames of their home directories."
msgstr "这个关联数组将用户名映射到其主目录的路径名。"

#. type: t{#1}
#: zsh.texi:29818 zsh.texi:29819
#, no-wrap
msgid "usergroups"
msgstr "usergroups"

#. type: table
#: zsh.texi:29823
msgid "This associative array maps names of system groups of which the current user is a member to the corresponding group identifiers.  The contents are the same as the groups output by the @t{id} command."
msgstr "该关联数组将当前用户所属的系统组名称映射到相应的组标识符。 其内容与 @t{id} 命令输出的组相同。"

#. type: t{#1}
#: zsh.texi:29824 zsh.texi:29825
#, no-wrap
msgid "funcfiletrace"
msgstr "funcfiletrace"

#. type: table
#: zsh.texi:29834
msgid ""
"This array contains the absolute line numbers and corresponding file names for the point where the current function, sourced file, or (if @t{EVAL_LINENO} is set) @t{eval} command was called.  The array is "
"of the same length as @t{funcsourcetrace} and @t{functrace}, but differs from @t{funcsourcetrace} in that the line and file are the point of call, not the point of definition, and differs from "
"@t{functrace} in that all values are absolute line numbers in files, rather than relative to the start of a function, if any."
msgstr ""
"该数组包含当前函数、引入的文件或（如果设置了 @t{EVAL_LINENO}）@t{eval} 命令被调用时的绝对行号和相应文件名。 该数组的长度与 @t{funcsourcetrace} 和 @t{functrace} 相同，但与 @t{funcsourcetrace} 不同的是，行号"
"和文件是调用点，而不是定义点；与 @t{functrace} 不同的是，所有值都是文件中的绝对行号，而不是相对于函数（如果有）起始位置的行号。"

#. type: t{#1}
#: zsh.texi:29835 zsh.texi:29836
#, no-wrap
msgid "funcsourcetrace"
msgstr "funcsourcetrace"

#. type: table
#: zsh.texi:29844
msgid ""
"This array contains the file names and line numbers of the points where the functions, sourced files, and (if @t{EVAL_LINENO} is set)  @t{eval} commands currently being executed were defined.  The line "
"number is the line where the `@t{function} @var{name}' or `@var{name} @t{()}' started.  In the case of an autoloaded function the line number is reported as zero.  The format of each element is "
"@var{filename}@t{:}@var{lineno}."
msgstr ""
"该数组包含定义当前执行的函数、引入的文件和（如果设置了 @t{EVAL_LINENO}）@t{eval} 命令的文件名和行号。 行号指 `@t{function} @var{name}' 或`@var{name} @t{()}' 的起始行。 在自动加载函数的情况下，行号报告为"
"零。 每个元素的格式为  @var{filename}@t{:}@var{lineno}。"

#. type: table
#: zsh.texi:29852
msgid ""
"For functions autoloaded from a file in native zsh format, where only the body of the function occurs in the file, or for files that have been executed by the @t{source} or `@t{.}' builtins, the trace "
"information is shown as @var{filename}@t{:}@var{0}, since the entire file is the definition.  The source file name is resolved to an absolute path when the function is loaded or the path to it otherwise "
"resolved."
msgstr ""
"对于从原生 zsh 格式文件中自动加载的函数（文件中只有函数的主体），或者通过 @t{source} 或 `@t{.}' 内置函数执行的文件，跟踪信息将显示为  @var{filename}@t{:}@var{0}，因为整个文件都是定义文件。 在加载函数时，源"
"文件名会解析为绝对路径，否则就解析为其路径。"

#. type: table
#: zsh.texi:29856
msgid "Most users will be interested in the information in the @t{funcfiletrace} array instead."
msgstr "大多数用户会对 @t{funcfiletrace} 数组中的信息感兴趣。"

#. type: t{#1}
#: zsh.texi:29857 zsh.texi:29858
#, no-wrap
msgid "funcstack"
msgstr "funcstack"

#. type: table
#: zsh.texi:29863
msgid ""
"This array contains the names of the functions, sourced files, and (if @t{EVAL_LINENO} is set) @t{eval} commands. currently being executed. The first element is the name of the function using the "
"parameter."
msgstr "该数组包含当前正在执行的函数、引入的文件和（如果设置了 @t{EVAL_LINENO}） @t{eval} 命令的名称。第一个元素是使用参数的函数的名称。"

#. type: table
#: zsh.texi:29872
msgid ""
"The standard shell array @t{zsh_eval_context} can be used to determine the type of shell construct being executed at each depth: note, however, that is in the opposite order, with the most recent item "
"last, and it is more detailed, for example including an entry for @t{toplevel}, the main shell code being executed either interactively or from a script, which is not present in @t{$funcstack}."
msgstr ""
"标准 shell 数组 @t{zsh_eval_context} 可用来确定在每个深度中执行的 shell 结构类型：但要注意的是，该数组的顺序正好相反，最新的项目在最后，而且更加详细，例如包含了 @t{toplevel} 的条目，即交互式或脚本中执行的"
"主要 shell 代码，而 @t{$funcstack} 中并不包含这些代码。"

#. type: t{#1}
#: zsh.texi:29873 zsh.texi:29874
#, no-wrap
msgid "functrace"
msgstr "functrace"

#. type: table
#: zsh.texi:29880
msgid ""
"This array contains the names and line numbers of the callers corresponding to the functions currently being executed.  The format of each element is @var{name}@t{:}@var{lineno}.  Callers are also shown "
"for sourced files; the caller is the point where the @t{source} or `@t{.}' command was executed."
msgstr "该数组包含与当前正在执行的函数相对应的调用者的名称和行号。 每个元素的格式为 @var{name}@t{:}@var{lineno}。 对于引入的文件，也会显示调用者；调用者是执行 @t{source} 或 `@t{.}' 命令的位置。"

#. type: node
#: zsh.texi:29883 zsh.texi:29989 zsh.texi:29991 zsh.texi:30108
#, no-wrap
msgid "The zsh/param/private Module"
msgstr "zsh/param/private 模块"

#. type: cindex
#: zsh.texi:29889
#, no-wrap
msgid "regular expressions, perl-compatible"
msgstr "正则表达式, perl 兼容的"

#. type: Plain text
#: zsh.texi:29891
msgid "The @t{zsh/pcre} module makes some commands available as builtins:"
msgstr "@t{zsh/pcre} 模块提供了一些内置命令："

#. type: findex
#: zsh.texi:29894
#, no-wrap
msgid "pcre_compile"
msgstr "pcre_compile"

#. type: item
#: zsh.texi:29895
#, no-wrap
msgid "@t{pcre_compile} [ @t{-aimxs} ] @var{PCRE}"
msgstr "@t{pcre_compile} [ @t{-aimxs} ] @var{PCRE}"

#. type: table
#: zsh.texi:29897
msgid "Compiles a perl-compatible regular expression."
msgstr "编译与 perl 兼容的正则表达式。"

#. type: table
#: zsh.texi:29907
msgid ""
"Option @t{-a} will force the pattern to be anchored.  Option @t{-i} will compile a case-insensitive pattern.  Option @t{-m} will compile a multi-line pattern; that is, @t{^} and @t{$} will match newlines "
"within the pattern.  Option @t{-x} will compile an extended pattern, wherein whitespace and @t{#} comments are ignored.  Option @t{-s} makes the dot metacharacter match all characters, including those "
"that indicate newline."
msgstr ""
"选项 @t{-a} 将强制锚定模式。 选项 @t{-i} 将编译不区分大小写的模式。 选项 @t{-m} 将编译多行模式，即 @t{^} 和 @t{$} 将匹配模式内的换行符。 选项 @t{-x} 将编译扩展模式，其中空白和 @t{#} 注释将被忽略。 选项 "
"@t{-s} 使点元字符匹配所有字符，包括表示换行的字符。"

#. type: t{#1}
#: zsh.texi:29908 zsh.texi:29909
#, no-wrap
msgid "pcre_study"
msgstr "pcre_study"

#. type: table
#: zsh.texi:29912
msgid "Studies the previously-compiled PCRE which may result in faster matching."
msgstr "研究先前编译的 PCRE，这可能会加快匹配速度。"

#. type: findex
#: zsh.texi:29913
#, no-wrap
msgid "pcre_match"
msgstr "pcre_match"

#. type: item
#: zsh.texi:29914
#, no-wrap
msgid "@t{pcre_match} [ @t{-v} @var{var} ] [ @t{-a} @var{arr} ] [ @t{-n} @var{offset} ] [ @t{-b} ] @var{string}"
msgstr "@t{pcre_match} [ @t{-v} @var{var} ] [ @t{-a} @var{arr} ] [ @t{-n} @var{offset} ] [ @t{-b} ] @var{string}"

#. type: table
#: zsh.texi:29917
msgid "Returns successfully if @t{string} matches the previously-compiled PCRE."
msgstr "如果 @t{string} 与之前编译的 PCRE 匹配，则成功返回。"

#. type: table
#: zsh.texi:29941
msgid ""
"Upon successful match, if the expression captures substrings within parentheses, @t{pcre_match} will set the array @t{match} to those substrings, unless the @t{-a} option is given, in which case it will "
"set the array @var{arr}.  Similarly, the variable @t{MATCH} will be set to the entire matched portion of the string, unless the @t{-v} option is given, in which case the variable @var{var} will be set.  "
"No variables are altered if there is no successful match.  A @t{-n} option starts searching for a match from the byte @var{offset} position in @var{string}.  If the @t{-b} option is given, the variable "
"@t{ZPCRE_OP} will be set to an offset pair string, representing the byte offset positions of the entire matched portion within the @var{string}.  For example, a @t{ZPCRE_OP} set to \"32 45\" indicates "
"that the matched portion began on byte offset 32 and ended on byte offset 44.  Here, byte offset position 45 is the position directly after the matched portion.  Keep in mind that the byte position isn't "
"necessarily the same as the character position when UTF-8 characters are involved.  Consequently, the byte offset positions are only to be relied on in the context of using them for subsequent searches on "
"@var{string}, using an offset position as an argument to the @t{-n} option.  This is mostly used to implement the \"find all non-overlapping matches\" functionality."
msgstr ""
"匹配成功后，如果表达式捕获了括号内的子字符串，@t{pcre_match} 将数组 @t{match} 设置为这些子字符串，除非给出 @t{-a} 选项，这样的情况下，将设置数组 @var{arr}。 同样，变量 @t{MATCH} 将被设置为字符串的整个匹配"
"部分，除非给出 @t{-v} 选项，在这种情况下，变量 @var{var} 将被设置。 如果没有成功匹配，则不会更改变量。 @t{-n} 选项从 @var{string} 中的 @var{offset} 字节位置开始搜索匹配。 如果给出 @t{-b} 选项，变量 "
"@t{ZPCRE_OP} 将被设置为偏移对(offset pair)字符串，代表 @var{string} 中整个匹配部分的字节偏移位置。 例如，设置为 \"32 45\" 的 @t{ZPCRE_OP} 表示匹配部分从字节偏移位置 32 开始，到字节偏移位置 44 结束。 在这"
"里，字节偏移位置 45 是直接位于匹配部分之后的位置。 请注意，在涉及 UTF-8 字符时，字节位置并不一定与字符位置相同。 因此，字节偏移位置只能用于 @var{string} 的后续搜索，将偏移位置作为 @t{-n} 选项的参数。 这主"
"要用于实现 \"查找所有非重叠匹配 \" 功能。"

#. type: table
#: zsh.texi:29944
msgid "A simple example of \"find all non-overlapping matches\":"
msgstr "\"查找所有非重叠匹配项 \" 的一个简单示例："

#. type: example
#: zsh.texi:29957
#, no-wrap
msgid ""
"string=\"The following zip codes: 78884 90210 99513\"\n"
"pcre_compile -m \"\\d@{5@}\"\n"
"accum=()\n"
"pcre_match -b -- $string\n"
"while [[ $? -eq 0 ]] do\n"
"    b=($=ZPCRE_OP)\n"
"    accum+=$MATCH\n"
"    pcre_match -b -n $b[2] -- $string\n"
"done\n"
"print -l $accum\n"
msgstr ""
"string=\"The following zip codes: 78884 90210 99513\"\n"
"pcre_compile -m \"\\d@{5@}\"\n"
"accum=()\n"
"pcre_match -b -- $string\n"
"while [[ $? -eq 0 ]] do\n"
"    b=($=ZPCRE_OP)\n"
"    accum+=$MATCH\n"
"    pcre_match -b -n $b[2] -- $string\n"
"done\n"
"print -l $accum\n"

#. type: Plain text
#: zsh.texi:29963
msgid "The @t{zsh/pcre} module makes available the following test condition:"
msgstr "@t{zsh/pcre} 模块提供了以下测试条件："

#. type: findex
#: zsh.texi:29966
#, no-wrap
msgid "pcre-match"
msgstr "pcre-match"

#. type: item
#: zsh.texi:29967
#, no-wrap
msgid "@var{expr} @t{-pcre-match} @var{pcre}"
msgstr "@var{expr} @t{-pcre-match} @var{pcre}"

#. type: table
#: zsh.texi:29969
msgid "Matches a string against a perl-compatible regular expression."
msgstr "将字符串与 perl 兼容的正则表达式匹配。"

#. type: example
#: zsh.texi:29977
#, no-wrap
msgid ""
"[[ \"$text\" -pcre-match ^d+$ ]] &&\n"
"print text variable contains only \"d's\".\n"
msgstr ""
"[[ \"$text\" -pcre-match ^d+$ ]] &&\n"
"print text variable contains only \"d's\".\n"

#. type: table
#: zsh.texi:29986
msgid ""
"If the @t{REMATCH_PCRE} option is set, the @t{=~} operator is equivalent to @t{-pcre-match}, and the @t{NO_CASE_MATCH} option may be used.  Note that @t{NO_CASE_MATCH} never applies to the @t{pcre_match} "
"builtin, instead use the @t{-i} switch of @t{pcre_compile}."
msgstr ""
"如果设置了 @t{REMATCH_PCRE} 选项，则 @t{=~} 操作符等同于 @t{-pcre-match}，并且可以使用 @t{NO_CASE_MATCH} 选项。 请注意，@t{NO_CASE_MATCH} 并不适用于 @t{pcre_match} 内置函数，请使用 @t{pcre_compile} 的 @t{-"
"i} 开关。"

#. type: node
#: zsh.texi:29989 zsh.texi:30108 zsh.texi:30110 zsh.texi:30164
#, no-wrap
msgid "The zsh/regex Module"
msgstr "zsh/regex 模块"

#. type: Plain text
#: zsh.texi:29998
msgid "The @t{zsh/param/private} module is used to create parameters whose scope is limited to the current function body, and @emph{not} to other functions called by the current function."
msgstr "@t{zsh/param/private} 模块用于创建参数，其作用域仅限于当前函数体，而@emph{不是}当前函数调用的其他函数。"

#. type: Plain text
#: zsh.texi:30001
msgid "This module provides a single autoloaded builtin:"
msgstr "该模块提供一个自动加载的内置命令："

#. type: findex
#: zsh.texi:30003
#, no-wrap
msgid "private"
msgstr "private"

#. type: cindex
#: zsh.texi:30004
#, no-wrap
msgid "private parameter, creating"
msgstr "私有参数, 创建"

#. type: item
#: zsh.texi:30005
#, no-wrap
msgid "@t{private} [ @{@t{+}|@t{-}@}@t{AHUahlmrtux} ] [ @{@t{+}|@t{-}@}@t{EFLRZi} [ @var{n} ] ] [ @var{name}[@t{=}@var{value}] ... ]"
msgstr "@t{private} [ @{@t{+}|@t{-}@}@t{AHUahlmrtux} ] [ @{@t{+}|@t{-}@}@t{EFLRZi} [ @var{n} ] ] [ @var{name}[@t{=}@var{value}] ... ]"

#. type: table
#: zsh.texi:30009
msgid "The @t{private} builtin accepts all the same options and arguments as @t{local} (@ref{Shell Builtin Commands}) except for the `@t{-}@t{T}' option.  Tied parameters may not be made private."
msgstr "除了 `@t{-}@t{T}' 选项，@t{private} 内置命令接受与 @t{local}（@ref{Shell 内置命令}）相同的选项和参数。 绑定的参数不能被私有化。"

#. type: table
#: zsh.texi:30014
msgid "The `@t{-}@t{p}' option is presently a no-op because the state of private parameters cannot reliably be reloaded.  This also applies to printing private parameters with `@t{typeset -p}'."
msgstr "目前， `@t{-}@t{p}' 选项是无效的，因为私有参数的状态无法可靠地重新加载。 这也适用于使用 `@t{typeset -p}' 打印私有参数。"

#. type: table
#: zsh.texi:30022
msgid ""
"If used at the top level (outside a function scope), @t{private} creates a normal parameter in the same manner as @t{declare} or @t{typeset}.  A warning about this is printed if @t{WARN_CREATE_GLOBAL} is "
"set (@ref{Options}).  Used inside a function scope, @t{private} creates a local parameter similar to one declared with @t{local}, except having special properties noted below."
msgstr ""
"如果在顶层（函数作用域之外）使用，@t{private} 将以与 @t{declare} 或 @t{typeset} 相同的方式创建一个普通参数。 如果设置了 @t{WARN_CREATE_GLOBAL}（@ref{选项}），系统将对此发出警告。 在函数作用域内使用 "
"@t{private}，会创建一个与 @t{local} 声明的参数类似的本地参数，但具有以下特殊属性。"

#. type: table
#: zsh.texi:30029
msgid ""
"Special parameters which expose or manipulate internal shell state, such as @t{ARGC}, @t{argv}, @t{COLUMNS}, @t{LINES}, @t{UID}, @t{EUID}, @t{IFS}, @t{PROMPT}, @t{RANDOM}, @t{SECONDS}, etc., cannot be "
"made private unless the `@t{-}@t{h}' option is used to hide the special meaning of the parameter.  This may change in the future."
msgstr ""
"暴露或操作 shell 内部状态的特殊参数，例如 @t{ARGC}, @t{argv}, @t{COLUMNS}, @t{LINES}, @t{UID}, @t{EUID}, @t{IFS}, @t{PROMPT}, @t{RANDOM}, @t{SECONDS}等，除非使用了 `@t{-}@t{h}' 选项来隐藏参数的特殊含义，否"
"则不能将其设置为私有。 这种情况将来可能会改变。"

#. type: Plain text
#: zsh.texi:30041
msgid ""
"As with other @t{typeset} equivalents, @t{private} is both a builtin and a reserved word, so arrays may be assigned with parenthesized word list @var{name}@t{=(}@var{value}...@t{)} syntax.  However, the "
"reserved word `@t{private}' is not available until @t{zsh/param/private} is loaded, so care must be taken with order of execution and parsing for function definitions which use @t{private}.  To compensate "
"for this, the module also adds the option `@t{-P}' to the `@t{local}' builtin to declare private parameters."
msgstr ""
"与其他 @t{typeset} 类似，@t{private} 既是内置程序，也是保留字，因此可以使用括号内的词列表 @var{name}@t{=(}@var{value}...@t{)} 语法为数组赋值。 但是，在 @t{zsh/param/private} 加载之前，保留字 `@t{private}' "
"是不可用的，因此必须注意使用 @t{private} 的函数定义的执行和解析顺序。 为了弥补这一不足，本模块还为内置的 `@t{local}' 添加了 `@t{-P}' 选项，用于声明私有参数。"

#. type: Plain text
#: zsh.texi:30045
msgid "For example, this construction fails if @t{zsh/param/private} has not yet been loaded when `@t{bad_declaration}' is defined:"
msgstr "例如，如果在定义 `@t{bad_declaration}' 时 @t{zsh/param/private} 尚未加载，则此构造将失败："

#. type: example
#: zsh.texi:30050
#, no-wrap
msgid ""
"bad_declaration() @{\n"
"  zmodload zsh/param/private\n"
"  private array=( one two three )\n"
"@}\n"
msgstr ""
"bad_declaration() @{\n"
"  zmodload zsh/param/private\n"
"  private array=( one two three )\n"
"@}\n"

#. type: Plain text
#: zsh.texi:30055
msgid "This construction works because @t{local} is already a keyword, and the module is loaded before the statement is executed:"
msgstr "这种结构之所以有效，是因为 @t{local} 已经是一个关键字，而且在执行语句之前模块已经加载："

#. type: example
#: zsh.texi:30060
#, no-wrap
msgid ""
"good_declaration() @{\n"
"  zmodload zsh/param/private\n"
"  local -P array=( one two three )\n"
"@}\n"
msgstr ""
"good_declaration() @{\n"
"  zmodload zsh/param/private\n"
"  local -P array=( one two three )\n"
"@}\n"

#. type: Plain text
#: zsh.texi:30064
msgid "The following is usable in scripts but may have trouble with @t{autoload}:"
msgstr "以下内容可在脚本中使用，但在使用 @t{autoload} 时可能会有问题："

#. type: example
#: zsh.texi:30069
#, no-wrap
msgid ""
"zmodload zsh/param/private\n"
"iffy_declaration() @{\n"
"  private array=( one two three )\n"
"@}\n"
msgstr ""
"zmodload zsh/param/private\n"
"iffy_declaration() @{\n"
"  private array=( one two three )\n"
"@}\n"

#. type: Plain text
#: zsh.texi:30074
msgid "The @t{private} builtin may always be used with scalar assignments and for declarations without assignments."
msgstr "@t{private} 内置函数始终可用于标量赋值和不带赋值的声明。"

#. type: Plain text
#: zsh.texi:30077
msgid "Parameters declared with @t{private} have the following properties:"
msgstr "用 @t{private} 声明的参数具有以下属性："

#. type: itemize
#: zsh.texi:30083
msgid "Within the function body where it is declared, the parameter behaves as a local, except as noted above for tied or special parameters."
msgstr "在声明该参数的函数体中，该参数的行为与本地参数相同，但如上所述的绑定参数或特殊参数除外。"

#. type: itemize
#: zsh.texi:30087
msgid "The type of a parameter declared private cannot be changed in the scope where it was declared, even if the parameter is unset.  Thus an array cannot be assigned to a private scalar, etc."
msgstr "声明为私有的参数的类型不能在声明该参数的作用域中更改，即使该参数未被设置。 因此，数组不能赋值给私有标量等。"

#. type: itemize
#: zsh.texi:30094
msgid ""
"Within any other function called by the declaring function, the private parameter does @emph{NOT} hide other parameters of the same name, so for example a global parameter of the same name is visible and "
"may be assigned or unset.  This includes calls to anonymous functions, although that may also change in the future.  However, the private name may not be created outside the local scope when it was not "
"previously declared."
msgstr ""
"在声明函数调用的任何其他函数中，私有参数 @emph{不会} 隐藏同名的其他参数，例如，同名的全局参数是可见的，可以被赋值或取消赋值。 这也包括对匿名函数的调用，不过这种情况将来可能会改变。 不过，如果之前未声明私有"
"名称，则不得在本地作用域之外创建私有名称。"

#. type: itemize
#: zsh.texi:30098
msgid "An exported private remains in the environment of inner scopes but appears unset for the current shell in those scopes.  Generally, exporting private parameters should be avoided."
msgstr "导出的私有参数会保留在内部作用域的环境中，但对于这些作用域中的当前 shell 而言，则显示为未设置。 一般来说，应避免导出私有参数。"

#. type: Plain text
#: zsh.texi:30108
msgid ""
"Note that this differs from the static scope defined by compiled languages derived from C, in that the a new call to the same function creates a new scope, i.e., the parameter is still associated with the "
"call stack rather than with the function definition.  It differs from ksh `@t{typeset -S}' because the syntax used to define the function has no bearing on whether the parameter scope is respected."
msgstr ""
"请注意，这不同于由 C 语言派生的编译语言所定义的静态作用域，在那里，对同一函数的新调用会创建一个新的作用域，也就是说，参数仍然与调用栈相关联，而不是与函数定义相关联。 它与 ksh 的 `@t{typeset -S}' 不同，因为"
"定义函数所用的语法与参数作用域是否受到尊重没有关系。"

#. type: node
#: zsh.texi:30108 zsh.texi:30164 zsh.texi:30166 zsh.texi:30245
#, no-wrap
msgid "The zsh/sched Module"
msgstr "zsh/sched 模块"

#. type: cindex
#: zsh.texi:30114
#, no-wrap
msgid "regular expressions"
msgstr "正则表达示"

#. type: cindex
#: zsh.texi:30115
#, no-wrap
msgid "regex"
msgstr "regex"

#. type: Plain text
#: zsh.texi:30117
msgid "The @t{zsh/regex} module makes available the following test condition:"
msgstr "@t{zsh/regex} 模块提供了以下测试条件："

#. type: findex
#: zsh.texi:30120
#, no-wrap
msgid "regex-match"
msgstr "regex-match"

#. type: item
#: zsh.texi:30121
#, no-wrap
msgid "@var{expr} @t{-regex-match} @var{regex}"
msgstr "@var{expr} @t{-regex-match} @var{regex}"

#. type: table
#: zsh.texi:30128
msgid ""
"Matches a string against a POSIX extended regular expression.  On successful match, matched portion of the string will normally be placed in the @t{MATCH} variable.  If there are any capturing parentheses "
"within the regex, then the @t{match} array variable will contain those.  If the match is not successful, then the variables will not be altered."
msgstr "根据 POSIX 扩展正则表达式匹配字符串。 匹配成功后，字符串的匹配部分通常会放入 @t{MATCH} 变量。 如果正则表达式中有捕获括号，那么 @t{match} 数组变量中将包含捕获。 如果匹配不成功，则不会更改变量。"

#. type: example
#: zsh.texi:30136
#, no-wrap
msgid ""
"[[ alphabetical -regex-match ^a([^a]+)a([^a]+)a ]] &&\n"
"print -l $MATCH X $match\n"
msgstr ""
"[[ alphabetical -regex-match ^a([^a]+)a([^a]+)a ]] &&\n"
"print -l $MATCH X $match\n"

#. type: table
#: zsh.texi:30142
msgid "If the option @t{REMATCH_PCRE} is not set, then the @t{=~} operator will automatically load this module as needed and will invoke the @t{-regex-match} operator."
msgstr "如果未设置 @t{REMATCH_PCRE} 选项，那么 @t{=~} 操作符将根据需要自动加载此模块，并调用 @t{-regex-match} 操作符。"

#. type: table
#: zsh.texi:30146
msgid "If @t{BASH_REMATCH} is set, then the array @t{BASH_REMATCH} will be set instead of @t{MATCH} and @t{match}."
msgstr "如果设置了 @t{BASH_REMATCH}，那么数组 @t{BASH_REMATCH} 将被设置，而不是 @t{MATCH} 和 @t{match}。"

#. type: table
#: zsh.texi:30151
msgid ""
"Note that the @t{zsh/regex} module logic relies on the host system. The same @var{expr} and @var{regex} pair could produce different results on different platforms if a @var{regex} with non-standard "
"syntax is given."
msgstr "请注意，@t{zsh/regex} 模块的逻辑依赖于主机系统。如果给出的 @var{regex} 使用了非标准语法，相同的 @var{expr} 和 @var{regex} 对可能会在不同平台上产生不同的结果。"

#. type: table
#: zsh.texi:30157
msgid ""
"For example, no syntax for matching a word boundary is defined in the POSIX extended regular expression standard. GNU @t{libc} and BSD @t{libc} both provide such syntaxes as extensions (@t{\\b} and @t{[[:"
"<:]]}/@t{[[:>:]]} respectively), but neither of these syntaxes is supported by both of these implementations."
msgstr "例如，POSIX 扩展正则表达式标准中没有定义匹配单词边界的语法。GNU @t{libc} 和 BSD @t{libc} 都提供了此类语法作为扩展（分别为 @t{\\b} 和 @t{[[:<:]]}/@t{[[:>:]]} ），但这两种实现都不支持这些语法。"

#. type: table
#: zsh.texi:30161
msgid "Refer to the regcomp(3) and re_format(7) manual pages on your system for locally-supported syntax."
msgstr "有关本地支持的语法，请参阅系统上的 regcomp(3) 和 re_format(7) 手册。"

#. type: node
#: zsh.texi:30164 zsh.texi:30245 zsh.texi:30247 zsh.texi:30342
#, no-wrap
msgid "The zsh/net/socket Module"
msgstr "zsh/net/socket 模块"

#. type: Plain text
#: zsh.texi:30172
msgid "The @t{zsh/sched} module makes available one builtin command and one parameter."
msgstr "@t{zsh/sched} 模块提供一条内置命令和一个参数。"

#. type: cindex
#: zsh.texi:30176
#, no-wrap
msgid "timed execution"
msgstr "定时执行(timed execution)"

#. type: cindex
#: zsh.texi:30177
#, no-wrap
msgid "execution, timed"
msgstr "执行, 定时"

#. type: item
#: zsh.texi:30178
#, no-wrap
msgid "@t{sched} [@t{-o}] [@t{+}]@var{hh}@t{:}@var{mm}[@t{:}@var{ss}] @var{command} ..."
msgstr "@t{sched} [@t{-o}] [@t{+}]@var{hh}@t{:}@var{mm}[@t{:}@var{ss}] @var{command} ..."

#. type: itemx
#: zsh.texi:30179
#, no-wrap
msgid "@t{sched} [@t{-o}] [@t{+}]@var{seconds} @var{command} ..."
msgstr "@t{sched} [@t{-o}] [@t{+}]@var{seconds} @var{command} ..."

#. type: itemx
#: zsh.texi:30180
#, no-wrap
msgid "@t{sched} [ @t{-}@var{item} ]"
msgstr "@t{sched} [ @t{-}@var{item} ]"

#. type: table
#: zsh.texi:30189
msgid ""
"Make an entry in the scheduled list of commands to execute.  The time may be specified in either absolute or relative time, and either as hours, minutes and (optionally) seconds separated by a colon, or "
"seconds alone.  An absolute number of seconds indicates the time since the epoch (1970/01/01 00:00); this is useful in combination with the features in the @t{zsh/datetime} module, see @ref{The zsh/"
"datetime Module}."
msgstr ""
"在计划执行的命令列表中加入一个条目。 时间可以指定为绝对时间或相对时间，也可以指定为用冒号分隔的小时、分钟和秒（可选），或仅指定为秒。 绝对秒数表示自 epoch（1970/01/01 00:00）以来的时间；与 @t{zsh/"
"datetime} 模块中的功能结合使用非常有用，参见 @ref{zsh/datetime 模块}。"

#. type: table
#: zsh.texi:30194
msgid "With no arguments, prints the list of scheduled commands.  If the scheduled command has the @t{-o} flag set, this is shown at the start of the command."
msgstr "在没有参数的情况下，打印计划命令列表。 如果计划命令设置了 @t{-o} 标志，则会在命令开始时显示。"

#. type: table
#: zsh.texi:30200
msgid ""
"With the argument `@t{-}@var{item}', removes the given item from the list.  The numbering of the list is continuous and entries are in time order, so the numbering can change when entries are added or "
"deleted."
msgstr "使用参数 `@t{-}@var{item}'，从列表中删除给定条目。 列表的编号是连续的，条目按时间顺序排列，因此在添加或删除条目时，编号可能会发生变化。"

#. type: table
#: zsh.texi:30210
msgid ""
"Commands are executed either immediately before a prompt, or while the shell's line editor is waiting for input.  In the latter case it is useful to be able to produce output that does not interfere with "
"the line being edited.  Providing the option @t{-o} causes the shell to clear the command line before the event and redraw it afterwards.  This should be used with any scheduled event that produces "
"visible output to the terminal; it is not needed, for example, with output that updates a terminal emulator's title bar."
msgstr ""
"命令要么在提示符前立即执行，要么在 shell 的行编辑器等待输入时执行。 在后一种情况下，最好能产生不影响正在编辑的行的输出。 提供 @t{-o} 选项会使 shell 在事件发生前清除命令行，并在事件发生后重新绘制命令行。 该"
"选项适用于任何向终端产生可见输出的计划事件；例如，不需要用于更新终端模拟器标题栏的输出。"

#. type: table
#: zsh.texi:30216
msgid ""
"To effect changes to the editor buffer when an event executes, use the `@t{zle}' command with no arguments to test whether the editor is active, and if it is, then use `@t{zle }@var{widget}' to access the "
"editor via the named @var{widget}."
msgstr "要在事件执行时更改编辑器缓冲区，可使用不带参数的 `@t{zle}' 命令测试编辑器是否激活，如果激活，则使用 `@t{zle }@var{widget}' 通过指定的 @var{widget} 访问编辑器。"

#. type: table
#: zsh.texi:30221
msgid "The @t{sched} builtin is not made available by default when the shell starts in a mode emulating another shell.  It can be made available with the command `@t{zmodload -F zsh/sched b:sched}'."
msgstr "当 shell 以模拟其他 shell 的模式启动时，@t{sched} 内置函数默认不可用。 可以通过命令 `@t{zmodload -F zsh/sched b:sched}' 来使它可用。"

#. type: table
#: zsh.texi:30237
msgid ""
"A readonly array corresponding to the events scheduled by the @t{sched} builtin.  The indices of the array correspond to the numbers shown when @t{sched} is run with no arguments (provided that the "
"@t{KSH_ARRAYS} option is not set).  The value of the array consists of the scheduled time in seconds since the epoch (see @ref{The zsh/datetime Module} for facilities for using this number), followed by a "
"colon, followed by any options (which may be empty but will be preceded by a `@t{-}' otherwise), followed by a colon, followed by the command to be executed."
msgstr ""
"一个只读数组，对应 @t{sched} 内置程序所调度的事件。 数组的索引与不带参数运行 @t{sched} 时显示的数字相对应（前提是未设置 @t{KSH_ARRAYS} 选项）。 数组的值包括以秒为单位的从 epoch 开始的计划时间（请参阅 "
"@ref{zsh/datetime 模块} 以了解使用该数字的方法），之后是冒号，之后是任何选项（选项可以为空，但必须在选项前加上 `@t{-}' ），之后是冒号，之后是要执行的命令。"

#. type: table
#: zsh.texi:30242
msgid "The @t{sched} builtin should be used for manipulating the events.  Note that this will have an immediate effect on the contents of the array, so that indices may become invalid."
msgstr "应使用 @t{sched} 内置函数来操作事件。 请注意，这将对数组内容产生直接影响，因此索引可能会失效。"

#. type: node
#: zsh.texi:30245 zsh.texi:30342 zsh.texi:30344 zsh.texi:30526
#, no-wrap
msgid "The zsh/stat Module"
msgstr "zsh/stat 模块"

#. type: Plain text
#: zsh.texi:30252
msgid "The @t{zsh/net/socket} module makes available one builtin command:"
msgstr "@t{zsh/net/socket} 模块提供了一条内置命令："

#. type: cindex
#: zsh.texi:30257
#, no-wrap
msgid "sockets, Unix domain"
msgstr "套接字, Unix 域"

#. type: item
#: zsh.texi:30258
#, no-wrap
msgid "@t{zsocket} [ @t{-altv} ] [ @t{-d} @var{fd} ] [ @var{args} ]"
msgstr "@t{zsocket} [ @t{-altv} ] [ @t{-d} @var{fd} ] [ @var{args} ]"

#. type: table
#: zsh.texi:30261
msgid "@t{zsocket} is implemented as a builtin to allow full use of shell command line editing, file I/O, and job control mechanisms."
msgstr "@t{zsocket} 是作为内置命令实现的，可以充分利用 shell 命令行编辑、文件 I/O 和作业控制机制。"

#. type: subsection
#: zsh.texi:30266 zsh.texi:30924
#, no-wrap
msgid "Outbound Connections"
msgstr "出站连接"

#. type: cindex
#: zsh.texi:30268
#, no-wrap
msgid "sockets, outbound Unix domain"
msgstr "套接字，Unix 域出站"

#. type: item
#: zsh.texi:30272
#, no-wrap
msgid "@t{zsocket} [ @t{-v} ] [ @t{-d} @var{fd} ] @var{filename}"
msgstr "@t{zsocket} [ @t{-v} ] [ @t{-d} @var{fd} ] @var{filename}"

#. type: table
#: zsh.texi:30277
msgid ""
"Open a new Unix domain connection to @var{filename}.  The shell parameter @t{REPLY} will be set to the file descriptor associated with that connection.  Currently, only stream connections are supported."
msgstr "为 @var{filename} 打开一个新的 Unix 域连接。 shell 参数 @t{REPLY} 将被设置为与该连接相关联的文件描述符。 目前只支持流连接。"

#. type: table
#: zsh.texi:30282 zsh.texi:30315 zsh.texi:30331 zsh.texi:30940 zsh.texi:30964 zsh.texi:30980
msgid "If @t{-d} is specified, its argument will be taken as the target file descriptor for the connection."
msgstr "如果指定了 @t{-d}，其参数将作为连接的目标文件描述符。"

#. type: table
#: zsh.texi:30285 zsh.texi:30318 zsh.texi:30339 zsh.texi:30943 zsh.texi:30967 zsh.texi:30988 zsh.texi:31014
msgid "In order to elicit more verbose output, use @t{-v}."
msgstr "为了获得更详细的输出，请使用 @t{-v}。"

#. type: table
#: zsh.texi:30289
msgid "File descriptors can be closed with normal shell syntax when no longer needed, for example:"
msgstr "例如，当不再需要文件描述符时，可以使用正常的 shell 语法关闭文件描述符："

#. type: example
#: zsh.texi:30293
#, no-wrap
msgid "exec @{REPLY@}>&-\n"
msgstr "exec @{REPLY@}>&-\n"

#. type: subsection
#: zsh.texi:30299 zsh.texi:30948
#, no-wrap
msgid "Inbound Connections"
msgstr "入站连接"

#. type: cindex
#: zsh.texi:30301
#, no-wrap
msgid "sockets, inbound Unix domain"
msgstr "套接字, Unix 域入站"

#. type: item
#: zsh.texi:30305
#, no-wrap
msgid "@t{zsocket} @t{-l} [ @t{-v} ] [ @t{-d} @var{fd} ] @var{filename}"
msgstr "@t{zsocket} @t{-l} [ @t{-v} ] [ @t{-d} @var{fd} ] @var{filename}"

#. type: table
#: zsh.texi:30310
msgid ""
"@t{zsocket -l} will open a socket listening on @var{filename}.  The shell parameter @t{REPLY} will be set to the file descriptor associated with that listener.  The file descriptor remains open in "
"subshells and forked external executables."
msgstr "@t{zsocket -l} 将打开一个监听 @var{filename} 的套接字。 shell 参数 @t{REPLY} 将被设置为与该监听器关联的文件描述符。 该文件描述符在子 shell 和分叉的外部可执行文件中保持打开状态。"

#. type: item
#: zsh.texi:30319
#, no-wrap
msgid "@t{zsocket} @t{-a} [ @t{-tv} ] [ @t{-d} @var{targetfd} ] @var{listenfd}"
msgstr "@t{zsocket} @t{-a} [ @t{-tv} ] [ @t{-d} @var{targetfd} ] @var{listenfd}"

#. type: table
#: zsh.texi:30326
msgid ""
"@t{zsocket -a} will accept an incoming connection to the socket associated with @var{listenfd}.  The shell parameter @t{REPLY} will be set to the file descriptor associated with the inbound connection.  "
"The file descriptor remains open in subshells and forked external executables."
msgstr "@t{zsocket -a} 将接受与 @var{listenfd} 关联的套接字的入站连接。 shell 参数 @t{REPLY} 将被设置为与入站连接相关的文件描述符。 该文件描述符将在子 shell 和分叉的外部可执行文件中保持打开状态。"

#. type: table
#: zsh.texi:30336
msgid "If @t{-t} is specified, @t{zsocket} will return if no incoming connection is pending.  Otherwise it will wait for one."
msgstr "如果指定了 @t{-t}，@t{zsocket} 将在没有新的连入连接时返回。 否则将等待连接。"

#. type: node
#: zsh.texi:30342 zsh.texi:30526 zsh.texi:30528 zsh.texi:30847
#, no-wrap
msgid "The zsh/system Module"
msgstr "zsh/system 模块"

#. type: Plain text
#: zsh.texi:30350
msgid "The @t{zsh/stat} module makes available one builtin command under two possible names:"
msgstr "@t{zsh/stat} 模块以两种可能的名称提供一条内置命令："

#. type: findex
#: zsh.texi:30353
#, no-wrap
msgid "zstat"
msgstr "zstat"

#. type: cindex
#: zsh.texi:30355
#, no-wrap
msgid "files, listing"
msgstr "文件, 列表"

#. type: cindex
#: zsh.texi:30356
#, no-wrap
msgid "files, examining"
msgstr "文件, 测试"

#. type: item
#: zsh.texi:30358
#, no-wrap
msgid "@t{zstat }[ @t{-gnNolLtTrs} ] [ @t{-f} @var{fd} ] [ @t{-H} @var{hash} ] [ @t{-A} @var{array} ] [ @t{-F} @var{fmt} ]"
msgstr "@t{zstat }[ @t{-gnNolLtTrs} ] [ @t{-f} @var{fd} ] [ @t{-H} @var{hash} ] [ @t{-A} @var{array} ] [ @t{-F} @var{fmt} ]"

#. type: itemx
#: zsh.texi:30359
#, no-wrap
msgid "@t{@ @ @ @ @ @ }[ @t{+}@var{element} ] [ @var{file} ... ]"
msgstr "@t{@ @ @ @ @ @ }[ @t{+}@var{element} ] [ @var{file} ... ]"

#. type: itemx
#: zsh.texi:30360
#, no-wrap
msgid "@t{stat} @var{...}"
msgstr "@t{stat} @var{...}"

#. type: table
#: zsh.texi:30367
msgid ""
"The command acts as a front end to the @t{stat} system call (see stat(2)).  The same command is provided with two names; as the name @t{stat} is often used by an external command it is recommended that "
"only the @t{zstat} form of the command is used.  This can be arranged by loading the module with the command `@t{zmodload -F zsh/stat b:zstat}'."
msgstr ""
"该命令是 @t{stat} 系统调用（参见 stat(2)）的前端。 同一命令有两个名称；由于 @t{stat} 经常被外部命令使用，建议只使用 @t{zstat} 形式的命令。 这可以通过使用 `@t{zmodload -F zsh/stat b:zstat}' 命令加载模块来实"
"现。"

#. type: table
#: zsh.texi:30375
msgid ""
"If the @t{stat} call fails, the appropriate system error message printed and status 1 is returned.  The fields of @t{struct stat} give information about the files provided as arguments to the command.  In "
"addition to those available from the @t{stat} call, an extra element `@t{link}' is provided.  These elements are:"
msgstr ""
"如果 @t{stat} 调用失败，将打印相应的系统错误信息并返回状态 1。 @t{struct stat} 的字段提供了作为命令参数提供的文件信息。 除了 @t{stat} 调用提供的信息外，还提供了一个额外的元素 `@t{link}' 。 这些元素是:"

#. type: t{#1}
#: zsh.texi:30378
#, no-wrap
msgid "device"
msgstr "device"

#. type: table
#: zsh.texi:30380
msgid "The number of the device on which the file resides."
msgstr "文件所在设备的编号。"

#. type: t{#1}
#: zsh.texi:30381
#, no-wrap
msgid "inode"
msgstr "inode"

#. type: table
#: zsh.texi:30383
msgid "The unique number of the file on this device (`@emph{inode}' number)."
msgstr "该设备上文件的唯一编号（`@emph{inode}' 编号）。"

#. type: t{#1}
#: zsh.texi:30384
#, no-wrap
msgid "mode"
msgstr "mode"

#. type: table
#: zsh.texi:30389
msgid ""
"The mode of the file; that is, the file's type and access permissions.  With the @t{-s} option, this will be returned as a string corresponding to the first column in the display of the @t{ls -l} command."
msgstr "文件的模式，即文件的类型和访问权限。 使用 @t{-s} 选项后，将以字符串形式返回，与 @t{ls -l} 命令显示的第一列相对应。"

#. type: t{#1}
#: zsh.texi:30390
#, no-wrap
msgid "nlink"
msgstr "nlink"

#. type: table
#: zsh.texi:30392
msgid "The number of hard links to the file."
msgstr "文件的硬链接数量。"

#. type: t{#1}
#: zsh.texi:30393
#, no-wrap
msgid "uid"
msgstr "uid"

#. type: table
#: zsh.texi:30396
msgid "The user ID of the owner of the file.  With the @t{-s} option, this is displayed as a user name."
msgstr "文件所有者的用户 ID。 如果使用 @t{-s} 选项，则显示为用户名。"

#. type: t{#1}
#: zsh.texi:30397
#, no-wrap
msgid "gid"
msgstr "gid"

#. type: table
#: zsh.texi:30400
msgid "The group ID of the file.  With the @t{-s} option, this is displayed as a group name."
msgstr "文件的组 ID。 如果使用 @t{-s} 选项，则显示为组名。"

#. type: t{#1}
#: zsh.texi:30401
#, no-wrap
msgid "rdev"
msgstr "rdev"

#. type: table
#: zsh.texi:30403
msgid "The raw device number.  This is only useful for special devices."
msgstr "原始设备编号。 这只对特殊设备有用。"

#. type: t{#1}
#: zsh.texi:30404
#, no-wrap
msgid "size"
msgstr "size"

#. type: table
#: zsh.texi:30406
msgid "The size of the file in bytes."
msgstr "文件的大小（字节）。"

#. type: t{#1}
#: zsh.texi:30407
#, no-wrap
msgid "atime"
msgstr "atime"

#. type: t{#1}
#: zsh.texi:30408
#, no-wrap
msgid "mtime"
msgstr "mtime"

#. type: t{#1}
#: zsh.texi:30409
#, no-wrap
msgid "ctime"
msgstr "ctime"

#. type: table
#: zsh.texi:30416
msgid ""
"The last access, modification and inode change times of the file, respectively, as the number of seconds since midnight GMT on 1st January, 1970.  With the @t{-s} option, these are printed as strings for "
"the local time zone; the format can be altered with the @t{-F} option, and with the @t{-g} option the times are in GMT."
msgstr ""
"文件的最后访问时间、修改时间和 inode 更改时间，分别为格林尼治标准时间 1970 年 1 月 1 日午夜后的秒数。 使用 @t{-s} 选项时，这些时间将以当地时区的字符串形式打印；使用 @t{-F} 选项可更改格式；使用 @t{-g} 选项"
"时，时间以格林尼治标准时间。"

#. type: t{#1}
#: zsh.texi:30417
#, no-wrap
msgid "blksize"
msgstr "blksize"

#. type: table
#: zsh.texi:30420
msgid "The number of bytes in one allocation block on the device on which the file resides."
msgstr "文件所在设备上一个分配块的字节数。"

#. type: t{#1}
#: zsh.texi:30421
#, no-wrap
msgid "block"
msgstr "block"

#. type: table
#: zsh.texi:30423
msgid "The number of disk blocks used by the file."
msgstr "文件使用的磁盘块数。"

#. type: t{#1}
#: zsh.texi:30424
#, no-wrap
msgid "link"
msgstr "link"

#. type: table
#: zsh.texi:30429
msgid ""
"If the file is a link and the @t{-L} option is in effect, this contains the name of the file linked to, otherwise it is empty.  Note that if this element is selected (@value{dsbq}@t{zstat +link}"
"@value{dsq})  then the @t{-L} option is automatically used."
msgstr "如果文件是链接文件，且 @t{-L} 选项有效，这将包含链接文件的名称，否则为空。 请注意，如果选择了该元素 (@value{dsbq}@t{zstat +link}@value{dsq}) ，则会自动使用 @t{-L} 选项。"

#. type: table
#: zsh.texi:30437
msgid ""
"A particular element may be selected by including its name preceded by a `@t{+}' in the option list; only one element is allowed.  The element may be shortened to any unique set of leading characters.  "
"Otherwise, all elements will be shown for all files."
msgstr "在选项列表中，可以通过在元素名称前加上 `@t{+}' 来选择特定元素；只允许选择一个元素。 该元素可以缩短为任意一组唯一的前导字符。 否则，将显示所有文件的所有元素。"

#. type: table
#: zsh.texi:30440 zsh.texi:33068 zsh.texi:33628 zsh.texi:41129
msgid "Options:"
msgstr "选项:"

#. type: table
#: zsh.texi:30453
msgid ""
"Instead of displaying the results on standard output, assign them to an @var{array}, one @t{struct stat} element per array element for each file in order.  In this case neither the name of the element nor "
"the name of the files appears in @var{array} unless the @t{-t} or @t{-n} options were given, respectively.  If @t{-t} is given, the element name appears as a prefix to the appropriate array element; if "
"@t{-n} is given, the file name appears as a separate array element preceding all the others.  Other formatting options are respected."
msgstr ""
"与其将结果显示在标准输出上，不如将其分配到 @var{array} 中，每个数组元素按顺序为每个文件分配一个 @t{struct stat} 元素。 在这种情况下，除非分别给出 @t{-t} 或 @t{-n} 选项，否则元素名称和文件名称都不会出现在 "
"@var{array} 中。 如果给定了 @t{-t}，元素名将作为前缀出现在相应的数组元素中；如果给定了 @t{-n}，文件名将作为单独的数组元素出现在所有其他元素之前。 其他格式化选项也会得到遵守。"

#. type: item
#: zsh.texi:30454
#, no-wrap
msgid "@t{-H} @var{hash}"
msgstr "@t{-H} @var{hash}"

#. type: table
#: zsh.texi:30458
msgid ""
"Similar to @t{-A}, but instead assign the values to @var{hash}.  The keys are the elements listed above.  If the @t{-n} option is provided then the name of the file is included in the hash with key "
"@t{name}."
msgstr "与 @t{-A} 类似，但会将值赋给 @var{hash}。 键是上面列出的元素。 如果提供 @t{-n} 选项，文件名将包含在哈希中，键值为 @t{name}。"

#. type: item
#: zsh.texi:30459
#, no-wrap
msgid "@t{-f} @var{fd}"
msgstr "@t{-f} @var{fd}"

#. type: table
#: zsh.texi:30462
msgid "Use the file on file descriptor @var{fd} instead of named files; no list of file names is allowed in this case."
msgstr "使用文件描述符 @var{fd} 上的文件，而不是命名文件；在这种情况下，不允许使用文件名列表。"

#. type: item
#: zsh.texi:30463
#, no-wrap
msgid "@t{-F} @var{fmt}"
msgstr "@t{-F} @var{fmt}"

#. type: table
#: zsh.texi:30471
msgid ""
"Supplies a @t{strftime} (see strftime(3)) string for the formatting of the time elements.  The format string supports all of the zsh extensions described in @ref{Prompt Expansion}.  In particular, @t{-F "
"%s.%N} can be used to show timestamps with nanosecond precision if supported by the system.  The @t{-s} option is implied."
msgstr ""
"提供用于格式化时间元素的 @t{strftime}（参见 strftime(3)）字符串。 格式字符串支持 @ref{提示符扩展} 中描述的所有 zsh 扩展。 特别是 @t{-F %s.%N}，如果系统支持，可用于显示纳秒精度的时间戳。 @t{-s} 选项是隐含"
"的。"

#. type: table
#: zsh.texi:30475
msgid "Show the time elements in the GMT time zone.  The @t{-s} option is implied."
msgstr "显示 GMT 时区的时间元素。 @t{-s} 选项是隐含的。"

#. type: table
#: zsh.texi:30480
msgid "List the names of the type elements (to standard output or an array as appropriate) and return immediately; arguments, and options other than @t{-A}, are ignored."
msgstr "列出类型元素的名称（视情况输出到标准输出或数组）并立即返回；忽略参数和 @t{-A} 以外的选项。"

#. type: table
#: zsh.texi:30488
msgid ""
"Perform an @t{lstat} (see lstat(2)) rather than a @t{stat} system call.  In this case, if the file is a link, information about the link itself rather than the target file is returned.  This option is "
"required to make the @t{link} element useful.  It's important to note that this is the exact opposite from ls(1), etc."
msgstr ""
"执行 @t{lstat}（见 lstat(2)）而不是 @t{stat} 系统调用。 在这种情况下，如果文件是链接，返回的是链接本身的信息，而不是目标文件的信息。 要使 @t{link} 元素发挥作用，就必须使用该选项。 需要注意的是，这与 ls(1) "
"等完全相反。"

#. type: table
#: zsh.texi:30493
msgid "Always show the names of files.  Usually these are only shown when output is to standard output and there is more than one file in the list."
msgstr "始终显示文件名。 通常只有在输出到标准输出且列表中有多过一个文件时才会显示这些文件名。"

#. type: table
#: zsh.texi:30496
msgid "Never show the names of files."
msgstr "从不显示文件名。"

#. type: table
#: zsh.texi:30503
msgid ""
"If a raw file mode is printed, show it in octal, which is more useful for human consumption than the default of decimal.  A leading zero will be printed in this case.  Note that this does not affect "
"whether a raw or formatted file mode is shown, which is controlled by the @t{-r} and @t{-s} options, nor whether a mode is shown at all."
msgstr ""
"如果打印的是原始文件模式，则以八进制显示，因为八进制比默认的十进制更适合人类使用。 在这种情况下，将打印一个前导零。 请注意，这并不影响显示原始文件模式还是格式化文件模式（由 @t{-r} 和 @t{-s} 选项控制），也"
"不影响是否显示任何模式。"

#. type: table
#: zsh.texi:30508
msgid "Print raw data (the default format) alongside string data (the @t{-s} format); the string data appears in parentheses after the raw data."
msgstr "打印原始数据（默认格式）和字符串数据（@t{-s} 格式）；字符串数据显示在原始数据后的括号内。"

#. type: table
#: zsh.texi:30513
msgid "Print @t{mode}, @t{uid}, @t{gid} and the three time elements as strings instead of numbers.  In each case the format is like that of @t{ls -l}."
msgstr "将 @t{mode}、@t{uid}、@t{gid} 和三个时间元素打印为字符串而非数字。 每种情况下的格式都与 @t{ls -l} 相同。"

#. type: table
#: zsh.texi:30518
msgid "Always show the type names for the elements of @t{struct stat}.  Usually these are only shown when output is to standard output and no individual element has been selected."
msgstr "始终显示 @t{struct stat} 元素的类型名称。 通常只有在输出到标准输出且未选择单个元素时才会显示。"

#. type: table
#: zsh.texi:30521
msgid "Never show the type names of the @t{struct stat} elements."
msgstr "从不显示 @t{struct stat} 元素的类型名称。"

#. type: node
#: zsh.texi:30526 zsh.texi:30847 zsh.texi:30849 zsh.texi:31068
#, no-wrap
msgid "The zsh/net/tcp Module"
msgstr "zsh/net/tcp 模块"

#. type: Plain text
#: zsh.texi:30534
msgid "The @t{zsh/system} module makes available various builtin commands and parameters."
msgstr "@t{zsh/system} 模块提供各种内置命令和参数。"

#. type: subsection
#: zsh.texi:30537
#, no-wrap
msgid "Builtins"
msgstr "内置命令"

#. type: findex
#: zsh.texi:30542
#, no-wrap
msgid "syserror"
msgstr "syserror"

#. type: item
#: zsh.texi:30543
#, no-wrap
msgid "@t{syserror} [ @t{-e} @var{errvar} ] [ @t{-p} @var{prefix} ] [ @var{errno} | @var{errname} ]"
msgstr "@t{syserror} [ @t{-e} @var{errvar} ] [ @t{-p} @var{prefix} ] [ @var{errno} | @var{errname} ]"

#. type: table
#: zsh.texi:30546
msgid "This command prints out the error message associated with @var{errno}, a system error number, followed by a newline to standard error."
msgstr "该命令将打印出与 @var{errno} 相关的错误信息、系统错误编号，并在标准错误后面加换行符。"

#. type: table
#: zsh.texi:30551
msgid "Instead of the error number, a name @var{errname}, for example @t{ENOENT}, may be used.  The set of names is the same as the contents of the array @t{errnos}, see below."
msgstr "可以使用名称 @var{errname} 代替错误编号，例如 @t{ENOENT}。 名称集与数组 @t{errnos} 的内容相同，见下文。"

#. type: table
#: zsh.texi:30555
msgid "If the string @var{prefix} is given, it is printed in front of the error message, with no intervening space."
msgstr "如果给出 @var{prefix} 字符串，则会将其打印在错误信息的前面，中间不留空格。"

#. type: table
#: zsh.texi:30559
msgid "If @var{errvar} is supplied, the entire message, without a newline, is assigned to the parameter names @var{errvar} and nothing is output."
msgstr "如果提供了 @var{errvar}，则整个信息（不带换行符）都会分配给参数名 @var{errvar}，不会输出任何内容。"

#. type: table
#: zsh.texi:30566
msgid ""
"A return status of 0 indicates the message was successfully printed (although it may not be useful if the error number was out of the system's range), a return status of 1 indicates an error in the "
"parameters, and a return status of 2 indicates the error name was not recognised (no message is printed for this)."
msgstr "返回状态为 0 表示信息已成功打印（但如果错误编号超出系统范围，则可能没有用处），返回状态为 1 表示参数出错，返回状态为 2 表示无法识别错误名称（不会打印任何信息）。"

#. type: findex
#: zsh.texi:30567
#, no-wrap
msgid "sysopen"
msgstr "sysopen"

#. type: item
#: zsh.texi:30569
#, no-wrap
msgid "@t{sysopen} [ @t{-arw} ] [ @t{-m} @var{permissions} ] [ @t{-o} @var{options} ]"
msgstr "@t{sysopen} [ @t{-arw} ] [ @t{-m} @var{permissions} ] [ @t{-o} @var{options} ]"

#. type: itemx
#: zsh.texi:30570
#, no-wrap
msgid "@t{@ @ @ @ @ @ @ @ }@t{-u} @var{fd} @var{file}"
msgstr "@t{@ @ @ @ @ @ @ @ }@t{-u} @var{fd} @var{file}"

#. type: table
#: zsh.texi:30578
msgid ""
"This command opens a file. The @t{-r}, @t{-w} and @t{-a} flags indicate whether the file should be opened for reading, writing and appending, respectively. The @t{-m} option allows the initial permissions "
"to use when creating a file to be specified in octal form.  The file descriptor is specified with @t{-u}. Either an explicit file descriptor in the range 0 to 9 can be specified or a variable name can be "
"given to which the file descriptor number will be assigned."
msgstr ""
"该命令用于打开文件。@t{-r}、@t{-w} 和 @t{-a} 标志分别表示文件是否应被打开用于读取、写入和追加。@t{-m} 选项允许以八进制形式在创建文件时使用的指定的初始权限。 文件描述符用 @t{-u} 指定。既可以指定一个范围在 "
"0 到 9 之间的明确文件描述符，也可以指定一个变量名来分配文件描述符编号。"

#. type: table
#: zsh.texi:30583
msgid ""
"The @t{-o} option allows various system specific options to be specified as a comma-separated list. The following is a list of possible options. Note that, depending on the system, some may not be "
"available."
msgstr "@t{-o} 选项允许以逗号分隔的列表形式指定各种系统特定选项。以下是可能的选项列表。请注意，根据系统的不同，有些选项可能不可用。"

#. type: t{#1}
#: zsh.texi:30584
#, no-wrap
msgid "cloexec"
msgstr "cloexec"

#. type: table
#: zsh.texi:30588
msgid "mark file to be closed when other programs are executed (else the file descriptor remains open in subshells and forked external executables)"
msgstr "在执行其他程序时标记文件已关闭（否则文件描述符在子 shell 和分叉的外部可执行文件中仍处于打开状态）"

#. type: t{#1}
#: zsh.texi:30589
#, no-wrap
msgid "create"
msgstr "create"

#. type: t{#1}
#: zsh.texi:30590
#, no-wrap
msgid "creat"
msgstr "creat"

#. type: table
#: zsh.texi:30592
msgid "create file if it does not exist"
msgstr "如果不存在，则创建文件"

#. type: t{#1}
#: zsh.texi:30593
#, no-wrap
msgid "excl"
msgstr "excl"

#. type: table
#: zsh.texi:30595
msgid "create file, error if it already exists"
msgstr "创建文件, 如果文件已存在则出错"

#. type: t{#1}
#: zsh.texi:30596
#, no-wrap
msgid "noatime"
msgstr "noatime"

#. type: table
#: zsh.texi:30598
msgid "suppress updating of the file atime"
msgstr "抑制文件的 atime 更新"

#. type: t{#1}
#: zsh.texi:30599
#, no-wrap
msgid "nofollow"
msgstr "nofollow"

#. type: table
#: zsh.texi:30601
msgid "fail if @var{file} is a symbolic link"
msgstr "如果 @var{file} 是符号链接则失败"

#. type: t{#1}
#: zsh.texi:30602
#, no-wrap
msgid "nonblock"
msgstr "nonblock"

#. type: table
#: zsh.texi:30604
msgid "the file is opened in nonblocking mode"
msgstr "文件以非阻塞模式打开"

#. type: table
#: zsh.texi:30607
msgid "request that writes wait until data has been physically written"
msgstr "要求写入时等待数据已被实际写入"

#. type: t{#1}
#: zsh.texi:30608
#, no-wrap
msgid "truncate"
msgstr "truncate"

#. type: t{#1}
#: zsh.texi:30609
#, no-wrap
msgid "trunc"
msgstr "trunc"

#. type: table
#: zsh.texi:30611
msgid "truncate file to size 0"
msgstr "将文件截断为 0 大小"

#. type: table
#: zsh.texi:30616
msgid "To close the file, use one of the following:"
msgstr "要关闭文件，请使用以下方法之一："

#. type: example
#: zsh.texi:30621
#, no-wrap
msgid ""
"@t{exec @{}@var{fd}@t{@}<&-}\n"
"@t{exec @{}@var{fd}@t{@}>&-}\n"
msgstr ""
"@t{exec @{}@var{fd}@t{@}<&-}\n"
"@t{exec @{}@var{fd}@t{@}>&-}\n"

#. type: findex
#: zsh.texi:30623
#, no-wrap
msgid "sysread"
msgstr "sysread"

#. type: item
#: zsh.texi:30625
#, no-wrap
msgid "@t{sysread }[ @t{-c} @var{countvar} ] [ @t{-i} @var{infd} ] [ @t{-o} @var{outfd} ]"
msgstr "@t{sysread }[ @t{-c} @var{countvar} ] [ @t{-i} @var{infd} ] [ @t{-o} @var{outfd} ]"

#. type: itemx
#: zsh.texi:30626
#, no-wrap
msgid "@t{@ @ @ @ @ @ @ @ }[ @t{-s} @var{bufsize} ] [ @t{-t} @var{timeout} ] [ @var{param} ]"
msgstr "@t{@ @ @ @ @ @ @ @ }[ @t{-s} @var{bufsize} ] [ @t{-t} @var{timeout} ] [ @var{param} ]"

#. type: table
#: zsh.texi:30631
msgid ""
"Perform a single system read from file descriptor @var{infd}, or zero if that is not given.  The result of the read is stored in @var{param} or @t{REPLY} if that is not given.  If @var{countvar} is given, "
"the number of bytes read is assigned to the parameter named by @var{countvar}."
msgstr ""
"从文件描述符 @var{infd} 执行单次系统读取，如果未指定，则为零。 读取结果存储在 @var{param} 中，如果未给出，则存储在 @t{REPLY} 中。 如果给定了 @var{countvar}，读取的字节数将分配给 @var{countvar} 命名的参数。"

#. type: table
#: zsh.texi:30636
msgid "The maximum number of bytes read is @var{bufsize} or 8192 if that is not given, however the command returns as soon as any number of bytes was successfully read."
msgstr "读取的最大字节数为 @var{bufsize}，如果没有给出，则为 8192，但只要成功读取任何字节数，命令就会返回。"

#. type: table
#: zsh.texi:30642
msgid ""
"If @var{timeout} is given, it specifies a timeout in seconds, which may be zero to poll the file descriptor.  This is handled by the @t{poll} system call if available, otherwise the @t{select} system call "
"if available."
msgstr "如果给出 @var{timeout}，则指定了以秒为单位的超时时间，在轮询文件描述符时，超时时间可以为零。 如果可用，则由 @t{poll} 系统调用处理，否则由 @t{select} 系统调用处理。"

#. type: table
#: zsh.texi:30653
msgid ""
"If @var{outfd} is given, an attempt is made to write all the bytes just read to the file descriptor @var{outfd}.  If this fails, because of a system error other than @t{EINTR} or because of an internal "
"zsh error during an interrupt, the bytes read but not written are stored in the parameter named by @var{param} if supplied (no default is used in this case), and the number of bytes read but not written "
"is stored in the parameter named by @var{countvar} if that is supplied.  If it was successful, @var{countvar} contains the full number of bytes transferred, as usual, and @var{param} is not set."
msgstr ""
"如果给定了 @var{outfd}，则会尝试将刚刚读取的所有字节写入文件描述符 @var{outfd}。 如果由于 @t{EINTR} 以外的系统错误或中断期间的 zsh 内部错误而失败，读取但未写入的字节会存储在 @var{param} 指定的参数（如果提"
"供了该参数，这时不使用默认值）中，读取但未写入的字节数会存储在 @var{countvar} 指定的参数（如果提供了该参数）中。 如果成功，@var{countvar} 会像往常一样包含传输的全部字节数，而 @var{param} 则不会被设置。"

#. type: table
#: zsh.texi:30658
msgid "The error @t{EINTR} (interrupted system call) is handled internally so that shell interrupts are transparent to the caller.  Any other error causes a return."
msgstr "错误 @t{EINTR} (中断的系统调用）是内部处理的，因此 shell 中断对调用者是透明的。 任何其他错误都会导致返回。"

#. type: table
#: zsh.texi:30661
msgid "The possible return statuses are"
msgstr "可能的返回状态有"

#. type: table
#: zsh.texi:30665
msgid "At least one byte of data was successfully read and, if appropriate, written."
msgstr "成功读取至少一个字节的数据，并酌情写入。"

#. type: item
#: zsh.texi:30666
#, no-wrap
msgid "1"
msgstr "1"

#. type: table
#: zsh.texi:30669
msgid "There was an error in the parameters to the command.  This is the only error for which a message is printed to standard error."
msgstr "命令参数有误。 这是唯一会将信息打印到标准错误中的错误。"

#. type: t{#1}
#: zsh.texi:30670 zsh.texi:37006 zsh.texi:38807
#, no-wrap
msgid "2"
msgstr "2"

#. type: table
#: zsh.texi:30673
msgid "There was an error on the read, or on polling the input file descriptor for a timeout.  The parameter @t{ERRNO} gives the error."
msgstr "读取或轮询输入文件描述符超时时出现错误。 参数 @t{ERRNO} 提供了错误信息。"

#. type: item
#: zsh.texi:30674
#, no-wrap
msgid "3"
msgstr "3"

#. type: table
#: zsh.texi:30677
msgid "Data were successfully read, but there was an error writing them to @var{outfd}.  The parameter @t{ERRNO} gives the error."
msgstr "已成功读取数据，但向 @var{outfd} 中写入数据时出现错误。 参数 @t{ERRNO} 提供了错误信息。"

#. type: item
#: zsh.texi:30678
#, no-wrap
msgid "4"
msgstr "4"

#. type: table
#: zsh.texi:30681
msgid "The attempt to read timed out.  Note this does not set @t{ERRNO} as this is not a system error."
msgstr "尝试读取超时。 注意这不会设置 @t{ERRNO}，因为这不是系统错误。"

#. type: item
#: zsh.texi:30682
#, no-wrap
msgid "5"
msgstr "5"

#. type: table
#: zsh.texi:30686
msgid "No system error occurred, but zero bytes were read.  This usually indicates end of file.  The parameters are set according to the usual rules; no write to @var{outfd} is attempted."
msgstr "未发生系统错误，但读取的字节数为零。 这通常表示文件已结束。 参数根据常规规则设置；不会尝试向 @var{outfd} 写入任何内容。"

#. type: item
#: zsh.texi:30689
#, no-wrap
msgid "@t{sysseek} [ @t{-u} @var{fd} ] [ @t{-w} @t{start}|@t{end}|@t{current} ] @var{offset}"
msgstr "@t{sysseek} [ @t{-u} @var{fd} ] [ @t{-w} @t{start}|@t{end}|@t{current} ] @var{offset}"

#. type: table
#: zsh.texi:30696
msgid ""
"The current file position at which future reads and writes will take place is adjusted to the specified byte offset. The @var{offset} is evaluated as a math expression. The @t{-u} option allows the file "
"descriptor to be specified. By default the offset is specified relative to the start or the file but, with the @t{-w} option, it is possible to specify that the offset should be relative to the current "
"position or the end of the file."
msgstr ""
"未来读写的当前文件位置将调整为指定的字节偏移量。@var{offset} 将以数学表达式的形式求值。@t{-u} 选项允许指定文件描述符。默认情况下，偏移量是相对于文件的起点，但通过 @t{-w} 选项，可以指定偏移量应相对于当前位"
"置或文件的终点。"

#. type: item
#: zsh.texi:30697
#, no-wrap
msgid "@t{syswrite} [ @t{-c} @var{countvar} ] [ @t{-o} @var{outfd} ] @var{data}"
msgstr "@t{syswrite} [ @t{-c} @var{countvar} ] [ @t{-o} @var{outfd} ] @var{data}"

#. type: table
#: zsh.texi:30702
msgid ""
"The data (a single string of bytes) are written to the file descriptor @var{outfd}, or 1 if that is not given, using the @t{write} system call.  Multiple write operations may be used if the first does not "
"write all the data."
msgstr "数据（字节的单个字符串）将通过 @t{write} 系统调用写入文件描述符 @var{outfd}，如果没有给出，则是 1。 如果第一个写入操作没有写入所有数据，可以使用多个写入操作。"

#. type: table
#: zsh.texi:30707
msgid "If @var{countvar} is given, the number of byte written is stored in the parameter named by @var{countvar}; this may not be the full length of @var{data} if an error occurred."
msgstr "如果给出 @var{countvar}，写入的字节数将存储在 @var{countvar} 命名参数中；如果发生错误，这可能不是 @var{data} 的全长。"

#. type: table
#: zsh.texi:30714
msgid ""
"The error @t{EINTR} (interrupted system call) is handled internally by retrying; otherwise an error causes the command to return.  For example, if the file descriptor is set to non-blocking output, an "
"error @t{EAGAIN} (on some systems, @t{EWOULDBLOCK}) may result in the command returning early."
msgstr ""
"@t{EINTR} 错误（系统调用中断）会通过重试进行内部处理。(系统调用中断）会通过重试进行内部处理，否则错误会导致命令返回。 例如，如果文件描述符设置为非阻塞输出，错误 @t{EAGAIN}（在某些系统中为 @t{EWOULDBLOCK}）"
"可能导致命令提前返回。"

#. type: table
#: zsh.texi:30720
msgid ""
"The return status may be 0 for success, 1 for an error in the parameters to the command, or 2 for an error on the write; no error message is printed in the last case, but the parameter @t{ERRNO} will "
"reflect the error that occurred."
msgstr "返回状态可能是 0 以表示成功，1 表示命令参数出错，或 2 表示写入错误；最后一种情况不打印错误信息，但参数 @t{ERRNO} 将反映发生的错误。"

#. type: item
#: zsh.texi:30721
#, no-wrap
msgid "@t{zsystem flock} [ @t{-t} @var{timeout} ] [ @t{-i} @var{interval} ] [ @t{-f} @var{var} ] [@t{-er}] @var{file}"
msgstr "@t{zsystem flock} [ @t{-t} @var{timeout} ] [ @t{-i} @var{interval} ] [ @t{-f} @var{var} ] [@t{-er}] @var{file}"

#. type: itemx
#: zsh.texi:30722
#, no-wrap
msgid "@t{zsystem flock -u} @var{fd_expr}"
msgstr "@t{zsystem flock -u} @var{fd_expr}"

#. type: table
#: zsh.texi:30728
msgid ""
"The builtin @t{zsystem}'s subcommand @t{flock} performs advisory file locking (via the fcntl(2) system call) over the entire contents of the given file.  This form of locking requires the processes "
"accessing the file to cooperate; its most obvious use is between two instances of the shell itself."
msgstr ""
"内置的 @t{zsystem} 的子命令 @t{flock} 会对给定文件的全部内容执行咨询式文件锁定（advisory file locking）（通过 fcntl(2) 系统调用）。 这种形式的锁定要求访问文件的进程相互配合；其最明显的用途是在 shell 本身的"
"两个实例之间使用。"

#. type: table
#: zsh.texi:30740
msgid ""
"In the first form the named @var{file}, which must already exist, is locked by opening a file descriptor to the file and applying a lock to the file descriptor.  The lock terminates when the shell process "
"that created the lock exits; it is therefore often convenient to create file locks within subshells, since the lock is automatically released when the subshell exits.  Note that use of the @t{print} "
"builtin with the @t{-u} option will, as a side effect, release the lock, as will redirection to the file in the shell holding the lock.  To work around this use a subshell, e.g. `@t{(print message) >> }"
"@var{file}'.  Status 0 is returned if the lock succeeds, else status 1."
msgstr ""
"在第一种形式中，名为 @var{file} 的文件必须已经存在，通过为该文件打开文件描述符并为文件描述符加锁来锁定该文件。 当创建锁的 shell 进程退出时，锁就会终止；因此，在子 shell 中创建文件锁通常很方便，因为子 "
"shell 退出时，锁会自动释放。 需要注意的是，使用 @t{print} 内置程序和 @t{-u} 选项的副作用是释放锁，就像重定向到持有锁的 shell 中的文件一样。 要解决这个问题，可以使用子 shell，例如`@t{(print message) >> }"
"@var{file}'。 如果锁定成功，则返回状态 0，否则返回状态 1。"

#. type: table
#: zsh.texi:30750
msgid ""
"In the second form the file descriptor given by the arithmetic expression @var{fd_expr} is closed, releasing a lock.  The file descriptor can be queried by using the `@t{-f} @var{var}' form during the "
"lock; on a successful lock, the shell variable @var{var} is set to the file descriptor used for locking.  The lock will be released if the file descriptor is closed by any other means, for example using "
"`@t{exec @{}@var{var}@t{@}>&-}'; however, the form described here performs a safety check that the file descriptor is in use for file locking."
msgstr ""
"在第二种形式中，算术表达式 @var{fd_expr} 给出的文件描述符被关闭，释放了锁。 在锁定过程中，可以使用 `@t{-f} @var{var}' 形式查询文件描述符；锁定成功后，shell 变量 @var{var} 将被设置为锁定时使用的文件描述"
"符。 如果以其他方式关闭文件描述符，例如使用 `@t{exec @{}@var{var}@t{@}>&-}' ，锁将被释放；不过，这里描述的形式会执行安全检查，确保文件描述符用于文件锁定。"

#. type: table
#: zsh.texi:30760
msgid ""
"By default the shell waits indefinitely for the lock to succeed.  The option @t{-t} @var{timeout} specifies a timeout for the lock in seconds; fractional seconds are allowed.  During this period, the "
"shell will attempt to lock the file every @var{interval} seconds if the @t{-i} @var{interval} option is given, otherwise once a second.  (This @var{interval} is shortened before the last attempt if "
"needed, so that the shell waits only until the @var{timeout} and not longer.)  If the attempt times out, status 2 is returned."
msgstr ""
"默认情况下，shell 会无限期等待锁定成功。 选项 @t{-t} @var{timeout}  以秒为单位指定锁定的超时时间；允许使用小数秒。 在此期间，如果使用 @t{-i} @var{interval} 选项，shell 将每隔 @var{interval} 秒尝试锁定文件"
"一次，否则每秒锁定一次。 (如果需要，这个 @var{interval} 会在最后一次尝试前缩短，这样 shell 就只能等待 @var{timeout} 而不是更长的时间）。 如果尝试超时，将返回状态 2。"

#. type: table
#: zsh.texi:30765
msgid "(Note: @var{timeout} is limited to 2^30-1 seconds (about 34 years), and @var{interval} to 0.999 * LONG_MAX microseconds (only about 35 minutes on 32-bit systems).)"
msgstr "(注意 @var{timeout} 限制为 2^30-1 秒（约 34 年），@var{interval} 限制为 0.999 * LONG_MAX 微秒（在 32 位系统上仅约 35 分钟）)。"

#. type: table
#: zsh.texi:30770
msgid "If the option @t{-e} is given, the file descriptor for the lock is preserved when the shell uses @t{exec} to start a new process; otherwise it is closed at that point and the lock released."
msgstr "如果给定了选项 @t{-e}，当 shell 使用 @t{exec} 启动新进程时，锁的文件描述符将被保留；否则，它将在此时关闭并释放锁。"

#. type: table
#: zsh.texi:30775
msgid "If the option @t{-r} is given, the lock is only for reading, otherwise it is for reading and writing.  The file descriptor is opened accordingly."
msgstr "如果给出选项 @t{-r}，锁只用于读取，否则用于读写。 文件描述符也会相应打开。"

#. type: item
#: zsh.texi:30776
#, no-wrap
msgid "@t{zsystem supports} @var{subcommand}"
msgstr "@t{zsystem supports} @var{subcommand}"

#. type: table
#: zsh.texi:30785
msgid ""
"The builtin @t{zsystem}'s subcommand @t{supports} tests whether a given subcommand is supported.  It returns status 0 if so, else status 1.  It operates silently unless there was a syntax error (i.e. the "
"wrong number of arguments), in which case status 255 is returned.  Status 1 can indicate one of two things: @var{subcommand} is known but not supported by the current operating system, or @var{subcommand} "
"is not known (possibly because this is an older version of the shell before it was implemented)."
msgstr ""
"内置 @t{zsystem} 的子命令 @t{supports} 会测试给定的子命令是否受支持。 如果支持，则返回状态 0，否则返回状态 1。这将静默操作，除非出现语法错误（即参数个数错误），这时将返回状态 255。 状态 1 表示以下两种情况"
"之一： @var{subcommand} 已知但当前操作系统不支持，或者 @var{subcommand} 未知（可能是因为这是一个尚未实现该命令的旧版 shell）。"

#. type: subsection
#: zsh.texi:30790
#, no-wrap
msgid "Math Functions"
msgstr "数学函数"

#. type: t{#1}
#: zsh.texi:30795
#, no-wrap
msgid "systell(@var{fd})"
msgstr "systell(@var{fd})"

#. type: table
#: zsh.texi:30798
msgid "The systell math function returns the current file position for the file descriptor passed as an argument."
msgstr "systell 数学函数返回作为参数传递的文件描述符的当前文件位置。"

#. type: t{#1}
#: zsh.texi:30808 zsh.texi:30809
#, no-wrap
msgid "errnos"
msgstr "errnos"

#. type: table
#: zsh.texi:30816
msgid ""
"A readonly array of the names of errors defined on the system.  These are typically macros defined in C by including the system header file @t{errno.h}.  The index of each name (assuming the option "
"@t{KSH_ARRAYS} is unset) corresponds to the error number.  Error numbers @var{num} before the last known error which have no name are given the name @t{E}@var{num} in the array."
msgstr ""
"系统中定义的错误名称的只读数组。 这些通常是通过包含系统头文件 @t{errno.h} 在 C 语言中定义的宏。 每个名称的索引（假设选项 @t{KSH_ARRAYS} 未设置）与错误编号相对应。 在最后一个已知错误之前没有名称的错误编号 "
"@var{num} 将在数组中命名为 @t{E}@var{num}。"

#. type: table
#: zsh.texi:30820
msgid "Note that aliases for errors are not handled; only the canonical name is used."
msgstr "请注意，错误的别名不会被处理，只会使用规范名称。"

#. type: t{#1}
#: zsh.texi:30821 zsh.texi:30822
#, no-wrap
msgid "sysparams"
msgstr "sysparams"

#. type: table
#: zsh.texi:30824
msgid "A readonly associative array.  The keys are:"
msgstr "一个只读关联数组。 键是"

#. type: t{#1}
#: zsh.texi:30827
#, no-wrap
msgid "pid"
msgstr "pid"

#. type: vindex
#: zsh.texi:30828
#, no-wrap
msgid "pid, sysparams"
msgstr "pid, sysparams"

#. type: table
#: zsh.texi:30831
msgid "Returns the process ID of the current process, even in subshells.  Compare @t{$$}, which returns the process ID of the main shell process."
msgstr "返回当前进程的进程 ID，即使在子 shell 中也是如此。 相比之下，@t{$$} 返回的是主 shell 进程的进程 ID。"

#. type: t{#1}
#: zsh.texi:30832
#, no-wrap
msgid "ppid"
msgstr "ppid"

#. type: vindex
#: zsh.texi:30833
#, no-wrap
msgid "ppid, sysparams"
msgstr "ppid, sysparams"

#. type: table
#: zsh.texi:30837
msgid "Returns the current process ID of the parent of the current process, even in subshells.  Compare @t{$PPID}, which returns the process ID of the initial parent of the main shell process."
msgstr "返回当前进程的父进程 ID，即使在子 shell 中也是如此。 比较 @t{$PPID}，它返回的是主 shell 进程初始父进程的进程 ID。"

#. type: t{#1}
#: zsh.texi:30838
#, no-wrap
msgid "procsubstpid"
msgstr "procsubstpid"

#. type: table
#: zsh.texi:30842
msgid "Returns the process ID of the last process started for process substitution, i.e. the @t{<(}@var{...}@t{)} and @t{>(}@var{...}@t{)} expansions."
msgstr "返回进程替换时最后启动的进程的进程 ID，即  @t{<(}@var{...}@t{)}  和 @t{>(}@var{...}@t{)} 扩展。"

#. type: node
#: zsh.texi:30847 zsh.texi:31068 zsh.texi:31070 zsh.texi:31098
#, no-wrap
msgid "The zsh/termcap Module"
msgstr "zsh/termcap 模块"

#. type: Plain text
#: zsh.texi:30854
msgid "The @t{zsh/net/tcp} module makes available one builtin command:"
msgstr "@t{zsh/net/tcp} 模块提供了一条内置命令："

#. type: cindex
#: zsh.texi:30858
#, no-wrap
msgid "TCP"
msgstr "TCP"

#. type: cindex
#: zsh.texi:30859
#, no-wrap
msgid "sockets, TCP"
msgstr "套接字, TCP"

#. type: item
#: zsh.texi:30860
#, no-wrap
msgid "@t{ztcp} [ @t{-acflLtv} ] [ @t{-d} @var{fd} ] [ @var{args} ]"
msgstr "@t{ztcp} [ @t{-acflLtv} ] [ @t{-d} @var{fd} ] [ @var{args} ]"

#. type: table
#: zsh.texi:30863
msgid "@t{ztcp} is implemented as a builtin to allow full use of shell command line editing, file I/O, and job control mechanisms."
msgstr "@t{ztcp} 是作为内置命令实现的，可以充分利用 shell 命令行编辑、文件 I/O 和作业控制机制。"

#. type: table
#: zsh.texi:30867
msgid "If @t{ztcp} is run with no options, it will output the contents of its session table."
msgstr "如果 @t{ztcp} 不带任何选项，它将输出会话表的内容。"

#. type: table
#: zsh.texi:30874
msgid ""
"If it is run with only the option @t{-L}, it will output the contents of the session table in a format suitable for automatic parsing.  The option is ignored if given with a command to open or close a "
"session.  The output consists of a set of lines, one per session, each containing the following elements separated by spaces:"
msgstr "如果运行时只使用 @t{-L} 选项，则会以适合自动解析的格式输出会话表内容。 如果与打开或关闭会话的命令一起使用，则忽略该选项。 输出由一系列行组成，每个会话一行，每行包含以下内容，以空格分隔："

#. type: item
#: zsh.texi:30877
#, no-wrap
msgid "File descriptor"
msgstr "文件描述符"

#. type: table
#: zsh.texi:30881
msgid ""
"The file descriptor in use for the connection.  For normal inbound (@t{I})  and outbound (@t{O}) connections this may be read and written by the usual shell mechanisms.  However, it should only be close "
"with `@t{ztcp -c}'."
msgstr "连接使用的文件描述符。 对于正常的入站（@t{I}）和出站（@t{O}）连接，可以通过常用的 shell 机制读写该文件描述符。 不过，只能使用 `@t{ztcp -c}' 关闭。"

#. type: item
#: zsh.texi:30882
#, no-wrap
msgid "Connection type"
msgstr "连接类型"

#. type: table
#: zsh.texi:30884
msgid "A letter indicating how the session was created:"
msgstr "一个字母，说明会话是如何创建的："

#. type: t{#1}
#: zsh.texi:30887
#, no-wrap
msgid "Z"
msgstr "Z"

#. type: table
#: zsh.texi:30889
msgid "A session created with the @t{zftp} command."
msgstr "使用 @t{zftp} 命令创建的会话。"

#. type: table
#: zsh.texi:30892
msgid "A connection opened for listening with `@t{ztcp -l}'."
msgstr "使用 `@t{ztcp -l}' 打开的侦听连接。"

#. type: table
#: zsh.texi:30895
msgid "An inbound connection accepted with `@t{ztcp -a}'."
msgstr "使用 `@t{ztcp -a}' 接受的入站连接。"

#. type: table
#: zsh.texi:30898
msgid "An outbound connection created with `@t{ztcp} @var{host} @var{...}'."
msgstr "使用  `@t{ztcp} @var{host} @var{...}' 创建的出站连接。"

#. type: item
#: zsh.texi:30903
#, no-wrap
msgid "The local host"
msgstr "本地主机"

#. type: table
#: zsh.texi:30906
msgid "This is usually set to an all-zero IP address as the address of the localhost is irrelevant."
msgstr "由于本地主机地址无关紧要，因此通常将其设置为全为零的 IP 地址。"

#. type: item
#: zsh.texi:30907
#, no-wrap
msgid "The local port"
msgstr "本地端口"

#. type: table
#: zsh.texi:30909
msgid "This is likely to be zero unless the connection is for listening."
msgstr "除非连接用于侦听，否则可能为零。"

#. type: item
#: zsh.texi:30910
#, no-wrap
msgid "The remote host"
msgstr "远程主机"

#. type: table
#: zsh.texi:30914
msgid "This is the fully qualified domain name of the peer, if available, else an IP address.  It is an all-zero IP address for a session opened for listening."
msgstr "如果有的话，这是对等体的完全合格域名，否则就是 IP 地址。 对于用于监听的会话，IP 地址全为零。"

#. type: item
#: zsh.texi:30915
#, no-wrap
msgid "The remote port"
msgstr "远程端口"

#. type: table
#: zsh.texi:30917
msgid "This is zero for a connection opened for listening."
msgstr "这对于一个用于监听的连接来说是零。"

#. type: cindex
#: zsh.texi:30926
#, no-wrap
msgid "sockets, outbound TCP"
msgstr "套接字, 传出 TCP"

#. type: item
#: zsh.texi:30930
#, no-wrap
msgid "@t{ztcp} [ @t{-v} ] [ @t{-d} @var{fd} ] @var{host} [ @var{port} ]"
msgstr "套接字、传入 TCP"

#. type: table
#: zsh.texi:30936
msgid ""
"Open a new TCP connection to @var{host}.  If the @var{port} is omitted, it will default to port 23.  The connection will be added to the session table and the shell parameter @t{REPLY} will be set to the "
"file descriptor associated with that connection."
msgstr "打开与 @var{host} 的新 TCP 连接。 如果省略了 @var{port}，则默认端口为 23。 该连接将被添加到会话表中，shell 参数 @t{REPLY} 将被设置为与该连接关联的文件描述符。"

#. type: cindex
#: zsh.texi:30950
#, no-wrap
msgid "sockets, inbound TCP"
msgstr "套接字, 传入 TCP"

#. type: item
#: zsh.texi:30954
#, no-wrap
msgid "@t{ztcp} @t{-l} [ @t{-v} ] [ @t{-d} @var{fd} ] @var{port}"
msgstr "@t{ztcp} @t{-l} [ @t{-v} ] [ @t{-d} @var{fd} ] @var{port}"

#. type: table
#: zsh.texi:30960
msgid ""
"@t{ztcp -l} will open a socket listening on TCP @var{port}.  The socket will be added to the session table and the shell parameter @t{REPLY} will be set to the file descriptor associated with that "
"listener."
msgstr "@t{ztcp -l} 将在 TCP @var{port} 上打开一个监听套接字。 该套接字将被添加到会话表中，shell 参数 @t{REPLY} 将被设置为与该监听器相关的文件描述符。"

#. type: item
#: zsh.texi:30968
#, no-wrap
msgid "@t{ztcp} @t{-a} [ @t{-tv} ] [ @t{-d} @var{targetfd} ] @var{listenfd}"
msgstr "@t{ztcp} @t{-a} [ @t{-tv} ] [ @t{-d} @var{targetfd} ] @var{listenfd}"

#. type: table
#: zsh.texi:30975
msgid ""
"@t{ztcp -a} will accept an incoming connection to the port associated with @var{listenfd}.  The connection will be added to the session table and the shell parameter @t{REPLY} will be set to the file "
"descriptor associated with the inbound connection."
msgstr "@t{ztcp -a} 将接受与 @var{listenfd} 关联端口的传入连接。 连接将被添加到会话表，shell 参数 @t{REPLY} 将被设置为与入站连接相关的文件描述符。"

#. type: table
#: zsh.texi:30985
msgid "If @t{-t} is specified, @t{ztcp} will return if no incoming connection is pending.  Otherwise it will wait for one."
msgstr "如果指定了 @t{-t}，@t{ztcp} 将在没有入站连接的情况下返回。 否则将等待连接。"

#. type: subsection
#: zsh.texi:30993
#, no-wrap
msgid "Closing Connections"
msgstr "关闭连接"

#. type: cindex
#: zsh.texi:30995
#, no-wrap
msgid "sockets, closing TCP"
msgstr "套接字, 关闭 TCP"

#. type: item
#: zsh.texi:30999
#, no-wrap
msgid "@t{ztcp} @t{-cf} [ @t{-v} ] [ @var{fd} ]"
msgstr "@t{ztcp} @t{-cf} [ @t{-v} ] [ @var{fd} ]"

#. type: itemx
#: zsh.texi:31000
#, no-wrap
msgid "@t{ztcp} @t{-c} [ @t{-v} ] [ @var{fd} ]"
msgstr "@t{ztcp} @t{-c} [ @t{-v} ] [ @var{fd} ]"

#. type: table
#: zsh.texi:31005
msgid "@t{ztcp -c} will close the socket associated with @var{fd}.  The socket will be removed from the session table.  If @var{fd} is not specified, @t{ztcp} will close everything in the session table."
msgstr "@t{ztcp -c} 将关闭与 @var{fd} 关联的套接字。 该套接字将从会话表中删除。 如果未指定 @var{fd}，@t{ztcp} 将关闭会话表中的所有内容。"

#. type: table
#: zsh.texi:31011
msgid "Normally, sockets registered by zftp (see @ref{The zsh/zftp Module} ) cannot be closed this way.  In order to force such a socket closed, use @t{-f}."
msgstr "通常情况下，zftp（参见 @ref{zsh/zftp 模块}）注册的套接字不能以这种方式关闭。 要强制关闭此类套接字，请使用 @t{-f}。"

#. type: cindex
#: zsh.texi:31021
#, no-wrap
msgid "TCP, example"
msgstr "TCP, 例子"

#. type: Plain text
#: zsh.texi:31024
msgid "Here is how to create a TCP connection between two instances of zsh.  We need to pick an unassigned port; here we use the randomly chosen 5123."
msgstr "下面介绍如何在两个 zsh 实例之间创建 TCP 连接。 我们需要选择一个未指定的端口；这里我们使用随机选择的 5123。"

#. type: Plain text
#: zsh.texi:31027
msgid "On @t{host1},"
msgstr "在 @t{host1} 上,"

#. type: example
#: zsh.texi:31033
#, no-wrap
msgid ""
"zmodload zsh/net/tcp\n"
"ztcp -l 5123\n"
"listenfd=$REPLY\n"
"ztcp -a $listenfd\n"
"fd=$REPLY\n"
msgstr ""
"zmodload zsh/net/tcp\n"
"ztcp -l 5123\n"
"listenfd=$REPLY\n"
"ztcp -a $listenfd\n"
"fd=$REPLY\n"

#. type: Plain text
#: zsh.texi:31035
msgid "The second from last command blocks until there is an incoming connection."
msgstr "倒数第二个命令会阻塞，直到有连接进入。"

#. type: Plain text
#: zsh.texi:31039
msgid "Now create a connection from @t{host2} (which may, of course, be the same machine):"
msgstr "现在从 @t{host2}（当然可能是同一台机器）创建一个连接："

#. type: example
#: zsh.texi:31043
#, no-wrap
msgid ""
"zmodload zsh/net/tcp\n"
"ztcp host1 5123\n"
"fd=$REPLY\n"
msgstr ""
"zmodload zsh/net/tcp\n"
"ztcp host1 5123\n"
"fd=$REPLY\n"

#. type: Plain text
#: zsh.texi:31048
msgid "Now on each host, @t{$fd} contains a file descriptor for talking to the other.  For example, on @t{host1}:"
msgstr "现在，在每台主机上，@t{$fd} 都包含一个文件描述符，用于与另一台主机对话。 例如，在 @t{host1} 上："

#. type: example
#: zsh.texi:31050
#, no-wrap
msgid "print This is a message >&$fd\n"
msgstr "print This is a message >&$fd\n"

#. type: Plain text
#: zsh.texi:31052
msgid "and on @t{host2}:"
msgstr "在 @t{host2} 上:"

#. type: example
#: zsh.texi:31054
#, no-wrap
msgid "read -r line <&$fd; print -r - $line\n"
msgstr "read -r line <&$fd; print -r - $line\n"

#. type: Plain text
#: zsh.texi:31056
msgid "prints `@t{This is a message}'."
msgstr "prints `@t{This is a message}'."

#. type: Plain text
#: zsh.texi:31059
msgid "To tidy up, on @t{host1}:"
msgstr "在 @t{host1} 上进行整理："

#. type: example
#: zsh.texi:31062
#, no-wrap
msgid ""
"ztcp -c $listenfd\n"
"ztcp -c $fd\n"
msgstr ""
"ztcp -c $listenfd\n"
"ztcp -c $fd\n"

#. type: Plain text
#: zsh.texi:31064
msgid "and on @t{host2}"
msgstr "在 @t{host2} 上"

#. type: example
#: zsh.texi:31066
#, no-wrap
msgid "ztcp -c $fd\n"
msgstr "ztcp -c $fd\n"

#. type: node
#: zsh.texi:31068 zsh.texi:31098 zsh.texi:31100 zsh.texi:31128
#, no-wrap
msgid "The zsh/terminfo Module"
msgstr "zsh/terminfo 模块"

#. type: Plain text
#: zsh.texi:31075
msgid "The @t{zsh/termcap} module makes available one builtin command:"
msgstr "@t{zsh/termcap} 模块提供了一条内置命令："

#. type: cindex
#: zsh.texi:31079
#, no-wrap
msgid "termcap value, printing"
msgstr "termcap 值, 打印"

#. type: item
#: zsh.texi:31080
#, no-wrap
msgid "@t{echotc} @var{cap} [ @var{arg} ... ]"
msgstr "@t{echotc} @var{cap} [ @var{arg} ... ]"

#. type: table
#: zsh.texi:31083
msgid "Output the termcap value corresponding to the capability @var{cap}, with optional arguments."
msgstr "输出与能力 @var{cap} 相对应的 termcap 值，参数可选。"

#. type: Plain text
#: zsh.texi:31088
msgid "The @t{zsh/termcap} module makes available one parameter:"
msgstr "@t{zsh/termcap} 模块提供了一个参数："

#. type: t{#1}
#: zsh.texi:31091 zsh.texi:31092
#, no-wrap
msgid "termcap"
msgstr "termcap"

#. type: table
#: zsh.texi:31095
msgid "An associative array that maps termcap capability codes to their values."
msgstr "关联数组，用于将 termcap 能力代码映射到其值。"

#. type: node
#: zsh.texi:31098 zsh.texi:31128 zsh.texi:31130 zsh.texi:31291
#, no-wrap
msgid "The zsh/watch Module"
msgstr "zsh/watch 模块"

#. type: Plain text
#: zsh.texi:31105
msgid "The @t{zsh/terminfo} module makes available one builtin command:"
msgstr "@t{zsh/terminfo} 模块提供了一条内置命令："

#. type: cindex
#: zsh.texi:31109
#, no-wrap
msgid "terminfo value, printing"
msgstr "terminfo 值, 打印"

#. type: item
#: zsh.texi:31110
#, no-wrap
msgid "@t{echoti} @var{cap} [ @var{arg} ]"
msgstr "@t{echoti} @var{cap} [ @var{arg} ]"

#. type: table
#: zsh.texi:31113
msgid "Output the terminfo value corresponding to the capability @var{cap}, instantiated with @var{arg} if applicable."
msgstr "输出与能力 @var{cap} 相对应的 terminfo 值，如果适用，则使用 @var{arg} 进行实例化。"

#. type: Plain text
#: zsh.texi:31118
msgid "The @t{zsh/terminfo} module makes available one parameter:"
msgstr "@t{zsh/terminfo} 模块提供一个参数："

#. type: t{#1}
#: zsh.texi:31121 zsh.texi:31122
#, no-wrap
msgid "terminfo"
msgstr "terminfo"

#. type: table
#: zsh.texi:31125
msgid "An associative array that maps terminfo capability names to their values."
msgstr "关联数组，用于将 terminfo 能力名称映射到其值。"

#. type: node
#: zsh.texi:31128 zsh.texi:31291 zsh.texi:31293 zsh.texi:31845
#, no-wrap
msgid "The zsh/zftp Module"
msgstr "zsh/zftp 模块"

#. type: Plain text
#: zsh.texi:31136
msgid "The @t{zsh/watch} module can be used to report when specific users log in or out. This is controlled via the following parameters."
msgstr "@t{zsh/watch} 模块可用于报告特定用户何时登录或退出。可通过以下参数进行控制。"

#. type: t{#1}
#: zsh.texi:31139 zsh.texi:31140
#, no-wrap
msgid "LOGCHECK"
msgstr "LOGCHECK"

#. type: table
#: zsh.texi:31143
msgid "The interval in seconds between checks for login/logout activity using the @t{watch} parameter."
msgstr "使用 @t{watch} 参数检查登录/注销活动的间隔时间（以秒为单位）。"

#. type: vindex
#: zsh.texi:31144
#, no-wrap
msgid "watch"
msgstr "watch"

#. type: vindex
#: zsh.texi:31145
#, no-wrap
msgid "WATCH"
msgstr "WATCH"

#. type: item
#: zsh.texi:31146
#, no-wrap
msgid "@t{watch} <S> <Z> (@t{WATCH} <S>)"
msgstr "@t{watch} <S> <Z> (@t{WATCH} <S>)"

#. type: table
#: zsh.texi:31148
msgid "An array (colon-separated list) of login/logout events to report."
msgstr "要报告的登录/注销事件数组（以冒号分隔的列表）。"

#. type: table
#: zsh.texi:31153
msgid "If it contains the single word `@t{all}', then all login/logout events are reported.  If it contains the single word `@t{notme}', then all events are reported as with `@t{all}' except @t{$USERNAME}."
msgstr "如果包含单词 `@t{all}'，则报告所有登录/注销事件。 如果包含单词 `@t{notme}'，与 `@t{notme}' 相同，但报告除 @t{$USERNAME} 以外的所有事件。"

#. type: table
#: zsh.texi:31164
msgid ""
"An entry in this list may consist of a username, an `@t{@@}' followed by a remote hostname, and a `@t{%}' followed by a line (tty).  Any of these may be a pattern (be sure to quote this during the "
"assignment to @t{watch} so that it does not immediately perform file generation); the setting of the @t{EXTENDED_GLOB} option is respected.  Any or all of these components may be present in an entry; if a "
"login/logout event matches all of them, it is reported."
msgstr ""
"该列表中的条目可以由用户名、 `@t{@@}' 、远程主机名、`@t{%}'、线路（tty）组成。 其中任何一个都可以是一个模式（在赋值给 @t{watch} 时请务必加引号，以免立即生成文件）；@t{EXTENDED_GLOB} 选项的设置将受到尊重。 "
"一个条目中可能包含上述任何或所有组件；如果登录/注销事件与所有组件都匹配，则会被报告。"

#. type: table
#: zsh.texi:31167
msgid "For example, with the @t{EXTENDED_GLOB} option set, the following:"
msgstr "例如，如果设置了 @t{EXTENDED_GLOB} 选项，就会出现以下情况："

#. type: example
#: zsh.texi:31171
#, no-wrap
msgid "watch=('^(pws|barts)')\n"
msgstr "watch=('^(pws|barts)')\n"

#. type: table
#: zsh.texi:31176
msgid "causes reports for activity associated with any user other than @t{pws} or @t{barts}."
msgstr "会导致报告与 @t{pws} 或 @t{barts} 以外的任何用户相关的活动。"

#. type: t{#1}
#: zsh.texi:31177 zsh.texi:31178
#, no-wrap
msgid "WATCHFMT"
msgstr "WATCHFMT"

#. type: table
#: zsh.texi:31182
msgid "The format of login/logout reports if the @t{watch} parameter is set.  Default is `@t{%n has %a %l from %m}'.  Recognizes the following escape sequences:"
msgstr "如果设置了 @t{watch} 参数，登录/注销报告的格式。 默认格式为 `@t{%n has %a %l from %m}'。 可识别以下转义序列："

#. type: table
#: zsh.texi:31187
msgid "The name of the user that logged in/out."
msgstr "登录/退出的用户名。"

#. type: t{#1}
#: zsh.texi:31188 zsh.texi:37064 zsh.texi:37157
#, no-wrap
msgid "%a"
msgstr "%a"

#. type: table
#: zsh.texi:31190
msgid "The observed action, i.e. \"logged on\" or \"logged off\"."
msgstr "观察到的操作，即 \"登录 \"或 \"注销\"。"

#. type: table
#: zsh.texi:31193
msgid "The line (tty) the user is logged in on."
msgstr "用户登录的线路（tty）。"

#. type: table
#: zsh.texi:31196
msgid "The full hostname of the remote host."
msgstr "远程主机的完整主机名。"

#. type: table
#: zsh.texi:31201
msgid "The hostname up to the first `@t{.}'.  If only the IP address is available or the utmp field contains the name of an X-windows display, the whole name is printed."
msgstr "主机名，直至第一个 `@t{.}'。 如果只有 IP 地址或 utmp 字段包含 X-windows 显示器的名称，则打印整个名称。"

#. type: table
#: zsh.texi:31207
msgid "@emph{NOTE:} The `@t{%m}' and `@t{%M}' escapes will work only if there is a host name field in the utmp on your machine.  Otherwise they are treated as ordinary strings."
msgstr "@emph{注意:} `@t{%m}' 和 `@t{%M}' 转义符只有在您的计算机的 utmp 中存在主机名字段时才起作用。 否则，它们将被视为普通字符串。"

#. type: item
#: zsh.texi:31208
#, no-wrap
msgid "@t{%F@{}@var{color}@t{@}} (@t{%f})"
msgstr "@t{%F@{}@var{color}@t{@}} (@t{%f})"

#. type: table
#: zsh.texi:31210
msgid "Start (stop) using a different foreground color."
msgstr "开始（停止）使用不同的前景色。"

#. type: item
#: zsh.texi:31211
#, no-wrap
msgid "@t{%K@{}@var{color}@t{@}} (@t{%k})"
msgstr "@t{%K@{}@var{color}@t{@}} (@t{%k})"

#. type: table
#: zsh.texi:31213
msgid "Start (stop) using a different background color."
msgstr "开始（停止）使用不同的背景颜色。"

#. type: table
#: zsh.texi:31226
msgid "The time, in 12-hour, am/pm format."
msgstr "时间，12 小时制，上午/下午格式。"

#. type: table
#: zsh.texi:31229
msgid "The time, in 24-hour format."
msgstr "时间，24 小时制。"

#. type: table
#: zsh.texi:31232
msgid "The date in `@var{day}@t{-}@var{dd}' format."
msgstr "日期，格式为 `@var{day}@t{-}@var{dd}' 。"

#. type: table
#: zsh.texi:31235
msgid "The date in `@var{mm}@t{/}@var{dd}@t{/}@var{yy}' format."
msgstr "日期，格式为 `@var{mm}@t{/}@var{dd}@t{/}@var{yy}' 。"

#. type: table
#: zsh.texi:31238
msgid "The date in `@var{yy}@t{-}@var{mm}@t{-}@var{dd}' format."
msgstr "日期，格式为 `@var{yy}@t{-}@var{mm}@t{-}@var{dd}'。"

#. type: table
#: zsh.texi:31243
msgid "The date formatted as @var{string} using the @t{strftime} function, with zsh extensions as described by @ref{Prompt Expansion}."
msgstr "使用 @t{strftime} 函数，以@ref{提示符扩展} 中描述的 zsh 扩展，将日期格式化为 @var{string}。"

#. type: item
#: zsh.texi:31244
#, no-wrap
msgid "@t{%(}@var{x}@t{:}@var{true-text}@t{:}@var{false-text}@t{)}"
msgstr "@t{%(}@var{x}@t{:}@var{true-text}@t{:}@var{false-text}@t{)}"

#. type: table
#: zsh.texi:31252
msgid ""
"Specifies a ternary expression.  The character following the @var{x} is arbitrary; the same character is used to separate the text for the \"true\" result from that for the \"false\" result.  Both the "
"separator and the right parenthesis may be escaped with a backslash.  Ternary expressions may be nested."
msgstr "指定一个三元表达式。@var{x} 后面的字符是任意的；同样的字符用于分隔 \"true \" 结果和 \"false \"结果。 分隔符和右括号都可以用反斜线转义。 三元表达式可以嵌套。"

#. type: table
#: zsh.texi:31261
msgid ""
"The test character @var{x} may be any one of `@t{l}', `@t{n}', `@t{m}' or `@t{M}', which indicate a `true' result if the corresponding escape sequence would return a non-empty value; or it may be `@t{a}', "
"which indicates a `true' result if the watched user has logged in, or `false' if he has logged out.  Other characters evaluate to neither true nor false; the entire expression is omitted in this case."
msgstr ""
"测试字符 @var{x} 可以是 `@t{l}', `@t{n}', `@t{m}' 或 `@t{M}' 中的任意一个，如果相应的转义序列会返回一个非空值，则表示结果为 `true' ；也可以是`@t{a}'，如果被监视用户已登录，则表示结果为 `true' ；如果已注"
"销，则表示结果为 `false' 。 其他字符的结果既不是 true 也不是 false；在这种情况下，整个表达式将被省略。"

#. type: table
#: zsh.texi:31270
msgid ""
"If the result is `true', then the @var{true-text} is formatted according to the rules above and printed, and the @var{false-text} is skipped.  If `false', the @var{true-text} is skipped and the @var{false-"
"text} is formatted and printed.  Either or both of the branches may be empty, but both separators must be present in any case."
msgstr ""
"如果结果为 `true'，则 @var{true-text} 将根据上述规则进行格式化并打印，@var{false-text} 将被跳过。 如果结果为 `false'，则跳过 @var{true-text}，格式化并打印 @var{false-text}。 任一分支或两个分支都可以为空，"
"但无论如何，两个分隔符都必须存在。"

#. type: Plain text
#: zsh.texi:31278
msgid "Furthermore, the @t{zsh/watch} module makes available one builtin command:"
msgstr "此外，@t{zsh/watch} 模块还提供了一条内置命令："

#. type: t{#1}
#: zsh.texi:31281 zsh.texi:31285
#, no-wrap
msgid "log"
msgstr "log"

#. type: vindex
#: zsh.texi:31282
#, no-wrap
msgid "watch, use of"
msgstr "watch, use of"

#. type: cindex
#: zsh.texi:31283
#, no-wrap
msgid "watching users"
msgstr "观察用户"

#. type: cindex
#: zsh.texi:31284
#, no-wrap
msgid "users, watching"
msgstr "用户, 观察"

#. type: table
#: zsh.texi:31288
msgid "List all users currently logged in who are affected by the current setting of the @t{watch} parameter."
msgstr "列出受 @t{watch} 参数当前设置影响的所有当前登录用户。"

#. type: node
#: zsh.texi:31291 zsh.texi:31845 zsh.texi:31847 zsh.texi:31854
#, no-wrap
msgid "The zsh/zle Module"
msgstr "zsh/zle 模块"

#. type: Plain text
#: zsh.texi:31298
msgid "The @t{zsh/zftp} module makes available one builtin command:"
msgstr "@t{zsh/zftp} 模块提供了一条内置命令："

#. type: cindex
#: zsh.texi:31302
#, no-wrap
msgid "FTP"
msgstr "FTP"

#. type: cindex
#: zsh.texi:31303
#, no-wrap
msgid "files, transferring"
msgstr "文件, 传输"

#. type: item
#: zsh.texi:31304
#, no-wrap
msgid "@t{zftp} @var{subcommand} [ @var{args} ]"
msgstr "@t{zftp} @var{subcommand} [ @var{args} ]"

#. type: table
#: zsh.texi:31312
msgid ""
"The @t{zsh/zftp} module is a client for FTP (file transfer protocol).  It is implemented as a builtin to allow full use of shell command line editing, file I/O, and job control mechanisms.  Often, users "
"will access it via shell functions providing a more powerful interface; a set is provided with the @t{zsh} distribution and is described in @ref{Zftp Function System}.  However, the @t{zftp} command is "
"entirely usable in its own right."
msgstr ""
"@t{zsh/zftp} 模块是 FTP（文件传输协议）的客户端。 它以内置命令方式实现，可充分利用 shell 命令行编辑、文件输入/输出和作业控制机制。 通常情况下，用户会通过 shell 函数访问该模块，而 shell 函数提供了更强大的接"
"口；@t{zsh} 发行版中提供了一套函数，@ref{Zftp 函数系统}中对其进行了描述。 不过，@t{zftp} 命令本身完全可用。"

#. type: table
#: zsh.texi:31319
msgid ""
"All commands consist of the command name @t{zftp} followed by the name of a subcommand.  These are listed below.  The return status of each subcommand is supposed to reflect the success or failure of the "
"remote operation.  See a description of the variable @t{ZFTP_VERBOSE} for more information on how responses from the server may be printed."
msgstr "所有命令都由命令名 @t{zftp} 和子命令名组成。 下面列出了这些子命令。 每个子命令的返回状态都应反映远程操作的成功或失败。 有关如何打印服务器响应的更多信息，请参阅变量 @t{ZFTP_VERBOSE} 的说明。"

#. type: subsection
#: zsh.texi:31324
#, no-wrap
msgid "Subcommands"
msgstr "子命令"

#. type: cindex
#: zsh.texi:31326
#, no-wrap
msgid "zftp, subcommands"
msgstr "zftp, 子命令"

#. type: cindex
#: zsh.texi:31330
#, no-wrap
msgid "FTP, starting a session"
msgstr "FTP, 开始一个会话"

#. type: item
#: zsh.texi:31331
#, no-wrap
msgid "@t{open} @var{host}[@t{:}@var{port}] [ @var{user} [ @var{password} [ @var{account} ] ] ]"
msgstr "@t{open} @var{host}[@t{:}@var{port}] [ @var{user} [ @var{password} [ @var{account} ] ] ]"

#. type: table
#: zsh.texi:31338
msgid ""
"Open a new FTP session to @var{host}, which may be the name of a TCP/IP connected host or an IP number in the standard dot notation.  If the argument is in the form @var{host}@t{:}@var{port}, open a "
"connection to TCP port @var{port} instead of the standard FTP port 21.  This may be the name of a TCP service or a number: see the description of @t{ZFTP_PORT} below for more information."
msgstr ""
"打开连接到 @var{host} 的新 FTP 会话，@var{host} 可以是 TCP/IP 连接主机的名称，也可以是标准点号形式的 IP 号。 如果参数格式为 @var{host}@t{:}@var{port}，则将打开连接到 TCP 端口 @var{port} 而不是标准 FTP 端"
"口 21。 该端口可以是 TCP 服务的名称或数字：更多信息请参阅下文对 @t{ZFTP_PORT} 的描述。"

#. type: table
#: zsh.texi:31344
msgid ""
"If IPv6 addresses in colon format are used, the @var{host} should be surrounded by quoted square brackets to distinguish it from the @var{port}, for example @t{'[fe80::203:baff:fe02:8b56]'}.  For "
"consistency this is allowed with all forms of @var{host}."
msgstr "如果使用冒号格式的 IPv6 地址，@var{host} 应该用带引号的方括号括起来，以区别于 @var{port}，例如 @t{'[fe80::203:baff:fe02:8b56]'}。 为了保持一致性，所有形式的 @var{host} 都允许使用这种方式。"

#. type: table
#: zsh.texi:31350
msgid ""
"Remaining arguments are passed to the @t{login} subcommand.  Note that if no arguments beyond @var{host} are supplied, @t{open} will @emph{not} automatically call @t{login}.  If no arguments at all are "
"supplied, @t{open} will use the parameters set by the @t{params} subcommand."
msgstr "其余参数将传递给 @t{login} 子命令。 请注意，如果没有提供 @var{host} 以外的参数，@t{open} 将 @emph{不会} 自动调用 @t{login}。 如果没有提供任何参数，@t{open} 将使用 @t{params} 子命令设置的参数。"

#. type: table
#: zsh.texi:31355
msgid "After a successful open, the shell variables @t{ZFTP_HOST}, @t{ZFTP_PORT}, @t{ZFTP_IP} and @t{ZFTP_SYSTEM} are available; see `Variables' below."
msgstr "成功打开后，shell 变量 @t{ZFTP_HOST}、@t{ZFTP_PORT}、@t{ZFTP_IP} 和 @t{ZFTP_SYSTEM} 将可用；请参阅下面的 `变量'。"

#. type: item
#: zsh.texi:31356
#, no-wrap
msgid "@t{login} [ @var{name} [ @var{password} [ @var{account} ] ] ]"
msgstr "@t{login} [ @var{name} [ @var{password} [ @var{account} ] ] ]"

#. type: itemx
#: zsh.texi:31357
#, no-wrap
msgid "@t{user} [ @var{name} [ @var{password} [ @var{account} ] ] ]"
msgstr "@t{user} [ @var{name} [ @var{password} [ @var{account} ] ] ]"

#. type: table
#: zsh.texi:31364
msgid ""
"Login the user @var{name} with parameters @var{password} and @var{account}.  Any of the parameters can be omitted, and will be read from standard input if needed (@var{name} is always needed).  If "
"standard input is a terminal, a prompt for each one will be printed on standard error and @var{password} will not be echoed.  If any of the parameters are not used, a warning message is printed."
msgstr ""
"使用参数 @var{password} 和 @var{account} 登录用户 @var{name}。 任何参数都可以省略，如果需要，将从标准输入中读取（@var{name} 始终需要）。 如果标准输入是终端，则会在标准错误中为每个参数打印出提示符，而 "
"@var{password} 不会被回显。 如果未使用任何参数，系统将打印一条警告信息。"

#. type: table
#: zsh.texi:31369
msgid "After a successful login, the shell variables @t{ZFTP_USER}, @t{ZFTP_ACCOUNT} and @t{ZFTP_PWD} are available; see `Variables' below."
msgstr "登录成功后，shell 变量 @t{ZFTP_USER}、@t{ZFTP_ACCOUNT} 和 @t{ZFTP_PWD} 可用；请参阅下面的 `变量'。"

#. type: table
#: zsh.texi:31373
msgid "This command may be re-issued when a user is already logged in, and the server will first be reinitialized for a new user."
msgstr "当用户已经登录时，可以再次发出该命令，服务器将首先为新用户重新初始化。"

#. type: item
#: zsh.texi:31374
#, no-wrap
msgid "@t{params} [ @var{host} [ @var{user} [ @var{password} [ @var{account} ] ] ] ]"
msgstr "@t{params} [ @var{host} [ @var{user} [ @var{password} [ @var{account} ] ] ] ]"

#. type: itemx
#: zsh.texi:31375
#, no-wrap
msgid "@t{params} @t{-}"
msgstr "@t{params} @t{-}"

#. type: table
#: zsh.texi:31381
msgid ""
"Store the given parameters for a later @t{open} command with no arguments.  Only those given on the command line will be remembered.  If no arguments are given, the parameters currently set are printed, "
"although the password will appear as a line of stars; the return status is one if no parameters were set, zero otherwise."
msgstr ""
"存储给定参数，以备以后执行不带参数的 @t{open} 命令时使用。 只有命令行中给出的参数才会被记住。 如果没有给定参数，将打印当前设置的参数，但密码将以一行星号显示；如果没有设置参数，返回状态为 1，否则为 0。"

#. type: table
#: zsh.texi:31393
msgid ""
"Any of the parameters may be specified as a `@t{?}', which may need to be quoted to protect it from shell expansion.  In this case, the appropriate parameter will be read from stdin as with the @t{login} "
"subcommand, including special handling of @var{password}.  If the `@t{?}' is followed by a string, that is used as the prompt for reading the parameter instead of the default message (any necessary "
"punctuation and whitespace should be included at the end of the prompt).  The first letter of the parameter (only) may be quoted with a `@t{\\}'; hence an argument @t{\"\\\\$word\"} guarantees that the "
"string from the shell parameter @t{$word} will be treated literally, whether or not it begins with a `@t{?}'."
msgstr ""
"任何参数都可以指定为 `@t{?}'，可能需要加引号以防止 shell 扩展。 在这种情况下，将像使用 @t{login} 子命令一样从 stdin 读取相应的参数，包括对 @var{password} 的特殊处理。 如果 `@t{?}' 后面跟了一个字符串，该字"
"符串将被用作读取参数的提示符，而不是默认信息（任何必要的标点符号和空白都应包含在提示符末尾）。 参数的第一个字母（仅）可以用 `@t{\\}' 加引号；因此参数 @t{\"\\\\$word\"} 将保证来自 shell 参数 @t{$word} 的字"
"符串将按字面意思处理，无论其是否以 `@t{?}' 开头。"

#. type: table
#: zsh.texi:31398
msgid "If instead a single `@t{-}' is given, the existing parameters, if any, are deleted.  In that case, calling @t{open} with no arguments will cause an error."
msgstr "如果只给出一个 `@t{-}'，现有参数（如果有）将被删除。 在这种情况下，调用不带参数的 @t{open} 将导致错误。"

#. type: table
#: zsh.texi:31402
msgid "The list of parameters is not deleted after a @t{close}, however it will be deleted if the @t{zsh/zftp} module is unloaded."
msgstr "在 @t{close} 之后，参数列表不会被删除，但如果 @t{zsh/zftp} 模块被卸载，它将被删除。"

#. type: example
#: zsh.texi:31409
#, no-wrap
msgid "zftp params ftp.elsewhere.xx juser '?Password for juser: '\n"
msgstr "zftp params ftp.elsewhere.xx juser '?Password for juser: '\n"

#. type: table
#: zsh.texi:31414
msgid "will store the host @t{ftp.elsewhere.xx} and the user @t{juser} and then prompt the user for the corresponding password with the given prompt."
msgstr "将存储主机 @t{ftp.elsewhere.xx} 和用户 @t{juser}，然后用给定的提示符提示用户输入相应的密码。"

#. type: table
#: zsh.texi:31423
msgid ""
"Test the connection; if the server has reported that it has closed the connection (maybe due to a timeout), return status 2; if no connection was open anyway, return status 1; else return status 0.  The "
"@t{test} subcommand is silent, apart from messages printed by the @t{$ZFTP_VERBOSE} mechanism, or error messages if the connection closes.  There is no network overhead for this test."
msgstr ""
"测试连接；如果服务器报告已关闭连接（可能是由于超时），则返回状态 2；如果没有打开连接，则返回状态 1；否则返回状态 0。 除了 @t{$ZFTP_VERBOSE} 机制打印的信息或连接关闭时的错误信息外，@t{test} 子命令是静默"
"(silent)的。 该测试没有网络开销。"

#. type: table
#: zsh.texi:31429
msgid "The test is only supported on systems with either the @t{select(2)} or @t{poll(2)} system calls; otherwise the message `@t{not supported on this system}' is printed instead."
msgstr "只有使用 @t{select(2)} 或 @t{poll(2)} 系统调用的系统才支持该测试，否则将打印 `@t{not supported on this system}' 信息。"

#. type: table
#: zsh.texi:31433
msgid "The @t{test} subcommand will automatically be called at the start of any other subcommand for the current session when a connection is open."
msgstr "当连接打开时，@t{test} 子命令将在当前会话的任何其他子命令开始时自动调用。"

#. type: item
#: zsh.texi:31434
#, no-wrap
msgid "@t{cd} @var{directory}"
msgstr "@t{cd} @var{directory}"

#. type: table
#: zsh.texi:31437
msgid "Change the remote directory to @var{directory}.  Also alters the shell variable @t{ZFTP_PWD}."
msgstr "将远程目录更改为 @var{directory}。 同时更改 shell 变量 @t{ZFTP_PWD}。"

#. type: t{#1}
#: zsh.texi:31438
#, no-wrap
msgid "cdup"
msgstr "cdup"

#. type: table
#: zsh.texi:31441
msgid "Change the remote directory to the one higher in the directory tree.  Note that @t{cd ..} will also work correctly on non-UNIX systems."
msgstr "将远程目录更改为目录树中高一级的目录。 请注意，@t{cd ..}在非 UNIX 系统上也能正常工作。"

#. type: item
#: zsh.texi:31442
#, no-wrap
msgid "@t{dir} [ @var{arg} ... ]"
msgstr "@t{dir} [ @var{arg} ... ]"

#. type: table
#: zsh.texi:31448
msgid ""
"Give a (verbose) listing of the remote directory.  The @var{arg}s are passed directly to the server. The command's behaviour is implementation dependent, but a UNIX server will typically interpret "
"@var{arg}s as arguments to the @t{ls} command and with no arguments return the result of `@t{ls -l}'. The directory is listed to standard output."
msgstr ""
"提供远程目录的（详细）列表。 @var{arg}s 直接传递给服务器。该命令的行为取决于实现情况，但 UNIX 服务器通常会将 @var{arg}s 解释为 @t{ls} 命令的参数，如果没有参数，则返回 `@t{ls -l}' 的结果。目录会以标准输出的"
"方式列出。"

#. type: item
#: zsh.texi:31449
#, no-wrap
msgid "@t{ls} [ @var{arg} ... ]"
msgstr "@t{ls} [ @var{arg} ... ]"

#. type: table
#: zsh.texi:31454
msgid ""
"Give a (short) listing of the remote directory.  With no @var{arg}, produces a raw list of the files in the directory, one per line.  Otherwise, up to vagaries of the server implementation, behaves "
"similar to @t{dir}."
msgstr "提供远程目录的（简短）列表。 在没有 @var{arg} 的情况下，会生成该目录下文件的原始列表，每行一个。 否则会受服务器实现的影响，表现与 @t{dir} 类似。"

#. type: item
#: zsh.texi:31455
#, no-wrap
msgid "@t{type} [ @var{type} ]"
msgstr "@t{type} [ @var{type} ]"

#. type: table
#: zsh.texi:31459
msgid ""
"Change the type for the transfer to @var{type}, or print the current type if @var{type} is absent.  The allowed values are `@t{A}' (ASCII), `@t{I}' (Image, i.e. binary), or `@t{B}' (a synonym for `@t{I}')."
msgstr "将传输类型更改为 @var{type}，如果没有 @var{type} 则打印当前类型。 允许的值有： `@t{A}' (ASCII), `@t{I}' （图像，即二进制）或 `@t{B}'（`@t{I}' 的同义词）。"

#. type: table
#: zsh.texi:31465
msgid ""
"The FTP default for a transfer is ASCII.  However, if @t{zftp} finds that the remote host is a UNIX machine with 8-bit byes, it will automatically switch to using binary for file transfers upon @t{open}.  "
"This can subsequently be overridden."
msgstr "FTP 的默认传输方式是 ASCII。 不过，如果 @t{zftp} 发现远程主机是使用 8 位字节的 UNIX 机器，它将在 @t{open} 时自动切换为使用二进制传输文件。 这一点随后可以被覆盖。"

#. type: table
#: zsh.texi:31469
msgid "The transfer type is only passed to the remote host when a data connection is established; this command involves no network overhead."
msgstr "传输类型只会在建立数据连接时传递给远程主机；该命令不涉及网络开销。"

#. type: t{#1}
#: zsh.texi:31470
#, no-wrap
msgid "ascii"
msgstr "ascii"

#. type: table
#: zsh.texi:31472
msgid "The same as @t{type A}."
msgstr "与 @t{type A} 相同。"

#. type: t{#1}
#: zsh.texi:31473
#, no-wrap
msgid "binary"
msgstr "binary"

#. type: table
#: zsh.texi:31475
msgid "The same as @t{type I}."
msgstr "与 @t{type I} 相同。"

#. type: item
#: zsh.texi:31476
#, no-wrap
msgid "@t{mode} [ @t{S} | @t{B} ]"
msgstr "@t{mode} [ @t{S} | @t{B} ]"

#. type: table
#: zsh.texi:31479
msgid "Set the mode type to stream (@t{S}) or block (@t{B}).  Stream mode is the default; block mode is not widely supported."
msgstr "将模式类型设置为流（@t{S}）或块（@t{B}）。 流模式是默认模式；块模式不被广泛支持。"

#. type: item
#: zsh.texi:31480
#, no-wrap
msgid "@t{remote} @var{file} ..."
msgstr "@t{remote} @var{file} ..."

#. type: itemx
#: zsh.texi:31481
#, no-wrap
msgid "@t{local} [ @var{file} ... ]"
msgstr "@t{local} [ @var{file} ... ]"

#. type: table
#: zsh.texi:31491
msgid ""
"Print the size and last modification time of the remote or local files.  If there is more than one item on the list, the name of the file is printed first.  The first number is the file size, the second "
"is the last modification time of the file in the format @t{CCYYMMDDhhmmSS} consisting of year, month, date, hour, minutes and seconds in GMT.  Note that this format, including the length, is guaranteed, "
"so that time strings can be directly compared via the @t{[[} builtin's @t{<} and @t{>} operators, even if they are too long to be represented as integers."
msgstr ""
"打印远程或本地文件的大小和最后修改时间。 如果列表中有多个项目，则首先打印文件名。 第一个数字是文件大小，第二个数字是文件的最后修改时间，格式为 @t{CCYYMMDDhhmmSS}，由格林尼治标准时间内的年、月、日、时、分、"
"秒组成。 请注意，这种格式（包括长度）是有保证的，因此时间字符串可以通过 @t{[[} 内置命令的 @t{<} 和 @t{>} 操作符直接进行比较，即使它们太长而无法用整数表示。"

#. type: table
#: zsh.texi:31496
msgid "Not all servers support the commands for retrieving this information.  In that case, the @t{remote} command will print nothing and return status 2, compared with status 1 for a file not found."
msgstr "并非所有服务器都支持检索此信息的命令。 在这种情况下，@t{remote} 命令将不打印任何内容，并返回状态 2，而未找到文件则返回状态 1。"

#. type: table
#: zsh.texi:31502
msgid ""
"The @t{local} command (but not @t{remote}) may be used with no arguments, in which case the information comes from examining file descriptor zero.  This is the same file as seen by a @t{put} command with "
"no further redirection."
msgstr "@t{local} 命令（但不包括 @t{remote}）可以不带参数，在这种情况下，信息来自于检查文件描述符 0。 这与 @t{put} 命令看到的文件相同，没有进一步的重定向。"

#. type: item
#: zsh.texi:31503
#, no-wrap
msgid "@t{get} @var{file} ..."
msgstr "@t{get} @var{file} ..."

#. type: table
#: zsh.texi:31506
msgid "Retrieve all @var{file}s from the server, concatenating them and sending them to standard output."
msgstr "从服务器读取所有 @var{file}s，将它们连接起来并发送到标准输出。"

#. type: item
#: zsh.texi:31507
#, no-wrap
msgid "@t{put} @var{file} ..."
msgstr "@t{put} @var{file} ..."

#. type: table
#: zsh.texi:31510
msgid "For each @var{file}, read a file from standard input and send that to the remote host with the given name."
msgstr "对于每个 @var{file}，从标准输入中读取一个文件，并以给定的名称将其发送到远程主机。"

#. type: item
#: zsh.texi:31511
#, no-wrap
msgid "@t{append} @var{file} ..."
msgstr "@t{append} @var{file} ..."

#. type: table
#: zsh.texi:31514
msgid "As @t{put}, but if the remote @var{file} already exists, data is appended to it instead of overwriting it."
msgstr "与 @t{put}相同，但如果远程 @var{file} 已经存在，数据将被附加到其中，而不是覆盖。"

#. type: item
#: zsh.texi:31515
#, no-wrap
msgid "@t{getat} @var{file} @var{point}"
msgstr "@t{getat} @var{file} @var{point}"

#. type: itemx
#: zsh.texi:31516
#, no-wrap
msgid "@t{putat} @var{file} @var{point}"
msgstr "@t{putat} @var{file} @var{point}"

#. type: itemx
#: zsh.texi:31517
#, no-wrap
msgid "@t{appendat} @var{file} @var{point}"
msgstr "@t{appendat} @var{file} @var{point}"

#. type: table
#: zsh.texi:31523
msgid ""
"Versions of @t{get}, @t{put} and @t{append} which will start the transfer at the given @var{point} in the remote @var{file}.  This is useful for appending to an incomplete local file.  However, note that "
"this ability is not universally supported by servers (and is not quite the behaviour specified by the standard)."
msgstr ""
"@t{get}、@t{put} 和 @t{append} 的版本，将在远程 @var{file} 中给定的 @var{point} 处开始传输。 这对附加到不完整的本地文件非常有用。 但请注意，服务器并不普遍支持这种功能（而且也不完全符合标准规定的行为）。"

#. type: item
#: zsh.texi:31524
#, no-wrap
msgid "@t{delete} @var{file} ..."
msgstr "@t{delete} @var{file} ..."

#. type: table
#: zsh.texi:31526
msgid "Delete the list of files on the server."
msgstr "删除服务器上的文件列表。"

#. type: item
#: zsh.texi:31527
#, no-wrap
msgid "@t{mkdir} @var{directory}"
msgstr "@t{mkdir} @var{directory}"

#. type: table
#: zsh.texi:31529
msgid "Create a new directory @var{directory} on the server."
msgstr "在服务器上创建一个新目录 @var{directory}。"

#. type: item
#: zsh.texi:31530
#, no-wrap
msgid "@t{rmdir} @var{directory}"
msgstr "@t{rmdir} @var{directory}"

#. type: table
#: zsh.texi:31532
msgid "Delete the directory @var{directory} on the server."
msgstr "删除服务器上的 @var{directory} 目录。"

#. type: item
#: zsh.texi:31533
#, no-wrap
msgid "@t{rename} @var{old-name} @var{new-name}"
msgstr "@t{rename} @var{old-name} @var{new-name}"

#. type: table
#: zsh.texi:31535
msgid "Rename file @var{old-name} to @var{new-name} on the server."
msgstr "将服务器上的文件 @var{old-name} 重命名为 @var{new-name}。"

#. type: item
#: zsh.texi:31536
#, no-wrap
msgid "@t{site} @var{arg} ..."
msgstr "@t{site} @var{arg} ..."

#. type: table
#: zsh.texi:31539
msgid "Send a host-specific command to the server.  You will probably only need this if instructed by the server to use it."
msgstr "向服务器发送特定于主机的命令。只有在服务器指示使用时，您才可能需要它。"

#. type: item
#: zsh.texi:31540
#, no-wrap
msgid "@t{quote} @var{arg} ..."
msgstr "@t{quote} @var{arg} ..."

#. type: table
#: zsh.texi:31547
msgid ""
"Send the raw FTP command sequence to the server.  You should be familiar with the FTP command set as defined in RFC959 before doing this.  Useful commands may include @t{STAT} and @t{HELP}.  Note also the "
"mechanism for returning messages as described for the variable @t{ZFTP_VERBOSE} below, in particular that all messages from the control connection are sent to standard error."
msgstr ""
"向服务器发送原始 FTP 命令序列。 在此之前，您应该熟悉 RFC959 中定义的 FTP 命令集。 有用的命令可能包括 @t{STAT} 和 @t{HELP}。 请注意下面为变量 @t{ZFTP_VERBOSE} 所描述的返回信息的机制，特别是所有来自控制连接"
"的信息都会被发送到标准错误中。"

#. type: t{#1}
#: zsh.texi:31548
#, no-wrap
msgid "close"
msgstr "close"

#. type: t{#1}
#: zsh.texi:31549
#, no-wrap
msgid "quit"
msgstr "quit"

#. type: table
#: zsh.texi:31553
msgid ""
"Close the current data connection.  This unsets the shell parameters @t{ZFTP_HOST}, @t{ZFTP_PORT}, @t{ZFTP_IP}, @t{ZFTP_SYSTEM}, @t{ZFTP_USER}, @t{ZFTP_ACCOUNT}, @t{ZFTP_PWD}, @t{ZFTP_TYPE} and "
"@t{ZFTP_MODE}."
msgstr "关闭当前数据连接。 这将取消设置 shell 参数 @t{ZFTP_HOST}, @t{ZFTP_PORT}, @t{ZFTP_IP}, @t{ZFTP_SYSTEM}, @t{ZFTP_USER}, @t{ZFTP_ACCOUNT}, @t{ZFTP_PWD}, @t{ZFTP_TYPE} 和 @t{ZFTP_MODE}."

#. type: item
#: zsh.texi:31554
#, no-wrap
msgid "@t{session} [ @var{sessname} ]"
msgstr "@t{session} [ @var{sessname} ]"

#. type: table
#: zsh.texi:31560
msgid ""
"Allows multiple FTP sessions to be used at once.  The name of the session is an arbitrary string of characters; the default session is called `@t{default}'.  If this command is called without an argument, "
"it will list all the current sessions; with an argument, it will either switch to the existing session called @var{sessname}, or create a new session of that name."
msgstr ""
"允许同时使用多个 FTP 会话。 会话名称是任意字符串；默认会话名称为 `@t{default}'。 如果调用该命令时不带参数，则会列出所有当前会话；如果带参数，则会切换到名为 @var{sessname} 的现有会话，或创建一个与该名称相同"
"的新会话。"

#. type: table
#: zsh.texi:31569
msgid ""
"Each session remembers the status of the connection, the set of connection-specific shell parameters (the same set as are unset when a connection closes, as given in the description of @t{close}), and any "
"user parameters specified with the @t{params} subcommand.  Changing to a previous session restores those values; changing to a new session initialises them in the same way as if @t{zftp} had just been "
"loaded.  The name of the current session is given by the parameter @t{ZFTP_SESSION}."
msgstr ""
"每个会话都会记住连接的状态、特定于连接的 shell 参数集（与 @t{close} 说明中提到的连接关闭时取消设置的参数集相同），以及使用 @t{params} 子命令指定的任何用户参数。 如果切换到之前的会话，则会恢复这些值；如果切"
"换到新会话，则会以与 @t{zftp} 刚加载时相同的方式初始化这些值。 当前会话的名称由参数 @t{ZFTP_SESSION} 提供。"

#. type: item
#: zsh.texi:31570
#, no-wrap
msgid "@t{rmsession} [ @var{sessname} ]"
msgstr "@t{rmsession} [ @var{sessname} ]"

#. type: table
#: zsh.texi:31579
msgid ""
"Delete a session; if a name is not given, the current session is deleted.  If the current session is deleted, the earliest existing session becomes the new current session, otherwise the current session "
"is not changed.  If the session being deleted is the only one, a new session called `@t{default}' is created and becomes the current session; note that this is a new session even if the session being "
"deleted is also called `@t{default}'. It is recommended that sessions not be deleted while background commands which use @t{zftp} are still active."
msgstr ""
"删除会话；如果没有给出名称，则删除当前会话。 如果当前会话被删除，最早存在的会话将成为新的当前会话，否则当前会话不会改变。 如果被删除的会话是唯一的会话，则会创建一个名为 `@t{default}' 的新会话，并成为当前会"
"话；请注意，即使被删除的会话也名为 `@t{default}'，这也是一个新会话。建议在使用 @t{zftp} 的后台命令仍处于活动状态时不要删除会话。"

#. type: cindex
#: zsh.texi:31586
#, no-wrap
msgid "zftp, parameters"
msgstr "zftp, 参数"

#. type: Plain text
#: zsh.texi:31589
msgid "The following shell parameters are used by @t{zftp}.  Currently none of them are special."
msgstr "@t{zftp} 使用以下 shell 参数。 目前它们都不是特殊参数。"

#. type: t{#1}
#: zsh.texi:31592 zsh.texi:31593
#, no-wrap
msgid "ZFTP_TMOUT"
msgstr "ZFTP_TMOUT"

#. type: table
#: zsh.texi:31600
msgid ""
"Integer.  The time in seconds to wait for a network operation to complete before returning an error.  If this is not set when the module is loaded, it will be given the default value 60.  A value of zero "
"turns off timeouts.  If a timeout occurs on the control connection it will be closed.  Use a larger value if this occurs too frequently."
msgstr "整数。 返回错误前等待网络操作完成的时间（以秒为单位）。 如果模块加载时未设置，则默认值为 60。 如果值为 0，则关闭超时。 如果控制连接时出现超时，将关闭该连接。 如果超时太频繁，请使用较大的值。"

#. type: t{#1}
#: zsh.texi:31601 zsh.texi:31602
#, no-wrap
msgid "ZFTP_IP"
msgstr "ZFTP_IP"

#. type: table
#: zsh.texi:31604
msgid "Readonly.  The IP address of the current connection in dot notation."
msgstr "只读。 当前连接的 IP 地址，用点号表示。"

#. type: t{#1}
#: zsh.texi:31605 zsh.texi:31606
#, no-wrap
msgid "ZFTP_HOST"
msgstr "ZFTP_HOST"

#. type: table
#: zsh.texi:31611
msgid ""
"Readonly.  The hostname of the current remote server.  If the host was opened as an IP number, @t{ZFTP_HOST} contains that instead; this saves the overhead for a name lookup, as IP numbers are most "
"commonly used when a nameserver is unavailable."
msgstr "只读。 当前远程服务器的主机名。 如果主机是以 IP 地址打开的，@t{ZFTP_HOST} 将包含 IP 地址；这样可以节省名称查询的开销，IP 地址在名称服务器不可用时最常用。"

#. type: t{#1}
#: zsh.texi:31612 zsh.texi:31613
#, no-wrap
msgid "ZFTP_PORT"
msgstr "ZFTP_PORT"

#. type: table
#: zsh.texi:31617
msgid "Readonly.  The number of the remote TCP port to which the connection is open (even if the port was originally specified as a named service).  Usually this is the standard FTP port, 21."
msgstr "只读。 连接已打开的远程 TCP 端口的编号（即使该端口最初被指定为已命名的服务）。 通常是标准 FTP 端口 21。"

#. type: table
#: zsh.texi:31624
msgid ""
"In the unlikely event that your system does not have the appropriate conversion functions, this appears in network byte order.  If your system is little-endian, the port then consists of two swapped bytes "
"and the standard port will be reported as 5376.  In that case, numeric ports passed to @t{zftp open} will also need to be in this format."
msgstr ""
"如果您的系统不具备相应的转换功能，则会以网络字节顺序显示。 如果您的系统是 little-endian 格式，那么端口将由两个交换字节组成，标准端口将被报告为 5376。 在这种情况下，传给 @t{zftp open} 的数字端口也需要使用这"
"种格式。"

#. type: t{#1}
#: zsh.texi:31625 zsh.texi:31626
#, no-wrap
msgid "ZFTP_SYSTEM"
msgstr "ZFTP_SYSTEM"

#. type: table
#: zsh.texi:31631
msgid ""
"Readonly.  The system type string returned by the server in response to an FTP @t{SYST} request.  The most interesting case is a string beginning @t{\"UNIX Type: L8\"}, which ensures maximum compatibility "
"with a local UNIX host."
msgstr "只读。 服务器响应 FTP @t{SYST} 请求时返回的系统类型字符串。 最有趣的情况是以 @t{\"UNIX Type: L8\"} 开头的字符串，以确保与本地 UNIX 主机最大程度兼容。"

#. type: t{#1}
#: zsh.texi:31632 zsh.texi:31633
#, no-wrap
msgid "ZFTP_TYPE"
msgstr "ZFTP_TYPE"

#. type: table
#: zsh.texi:31636
msgid "Readonly.  The type to be used for data transfers , either `@t{A}' or `@t{I}'.  Use the @t{type} subcommand to change this."
msgstr "只读。 用于数据传输的类型，可以是 `@t{A}' 或 `@t{I}' 。 使用 @t{type} 子命令可以更改。"

#. type: t{#1}
#: zsh.texi:31637 zsh.texi:31638
#, no-wrap
msgid "ZFTP_USER"
msgstr "ZFTP_USER"

#. type: table
#: zsh.texi:31640
msgid "Readonly.  The username currently logged in, if any."
msgstr "只读。 当前登录的用户名（如果有）。"

#. type: t{#1}
#: zsh.texi:31641 zsh.texi:31642
#, no-wrap
msgid "ZFTP_ACCOUNT"
msgstr "ZFTP_ACCOUNT"

#. type: table
#: zsh.texi:31645
msgid "Readonly.  The account name of the current user, if any.  Most servers do not require an account name."
msgstr "只读。 当前用户的账户名（如果有）。 大多数服务器不需要账户名。"

#. type: t{#1}
#: zsh.texi:31646 zsh.texi:31647
#, no-wrap
msgid "ZFTP_PWD"
msgstr "ZFTP_PWD"

#. type: table
#: zsh.texi:31649
msgid "Readonly.  The current directory on the server."
msgstr "只读。 服务器上的当前目录。"

#. type: t{#1}
#: zsh.texi:31650 zsh.texi:31651
#, no-wrap
msgid "ZFTP_CODE"
msgstr "ZFTP_CODE"

#. type: table
#: zsh.texi:31655
msgid "Readonly.  The three digit code of the last FTP reply from the server as a string.  This can still be read after the connection is closed, and is not changed when the current session changes."
msgstr "只读。 服务器最后一次 FTP 回复的三位数代码字符串。 连接关闭后仍可读取，当前会话发生变化时也不会更改。"

#. type: t{#1}
#: zsh.texi:31656 zsh.texi:31657
#, no-wrap
msgid "ZFTP_REPLY"
msgstr "ZFTP_REPLY"

#. type: table
#: zsh.texi:31661
msgid "Readonly.  The last line of the last reply sent by the server.  This can still be read after the connection is closed, and is not changed when the current session changes."
msgstr "只读。 服务器发送的最后一次回复的最后一行。 连接关闭后仍可读取，当前会话发生变化时也不会更改。"

#. type: t{#1}
#: zsh.texi:31662 zsh.texi:31663
#, no-wrap
msgid "ZFTP_SESSION"
msgstr "ZFTP_SESSION"

#. type: table
#: zsh.texi:31666
msgid "Readonly.  The name of the current FTP session; see the description of the @t{session} subcommand."
msgstr "只读。 当前 FTP 会话的名称；请参阅 @t{session} 子命令的说明。"

#. type: t{#1}
#: zsh.texi:31667 zsh.texi:31668
#, no-wrap
msgid "ZFTP_PREFS"
msgstr "ZFTP_PREFS"

#. type: table
#: zsh.texi:31671
msgid "A string of preferences for altering aspects of @t{zftp}'s behaviour.  Each preference is a single character.  The following are defined:"
msgstr "用于更改 @t{zftp} 行为的首选项字符串。每个首选项都是单个字符。 定义如下"

#. type: table
#: zsh.texi:31679
msgid ""
"Passive: attempt to make the remote server initiate data transfers.  This is slightly more efficient than sendport mode.  If the letter @t{S} occurs later in the string, @t{zftp} will use sendport mode if "
"passive mode is not available."
msgstr "被动(Passive)：尝试让远程服务器启动数据传输。 这种模式的效率略高于发送端口模式(sendport)。 如果字符串中之后出现字母 @t{S}，@t{zftp} 将在被动模式不可用时使用发送端口模式。"

#. type: table
#: zsh.texi:31684
msgid "Sendport: initiate transfers by the FTP @t{PORT} command.  If this occurs before any @t{P} in the string, passive mode will never be attempted."
msgstr "Sendport: 通过 FTP @t{PORT} 命令初始化传输。 如果该命令出现在字符串中的 @t{P} 之前，则永远不会尝试被动模式。"

#. type: table
#: zsh.texi:31691
msgid ""
"Dumb: use only the bare minimum of FTP commands.  This prevents the variables @t{ZFTP_SYSTEM} and @t{ZFTP_PWD} from being set, and will mean all connections default to ASCII type.  It may prevent "
"@t{ZFTP_SIZE} from being set during a transfer if the server does not send it anyway (many servers do)."
msgstr ""
"只使用最基本的 FTP 命令。 这将阻止变量 @t{ZFTP_SYSTEM} 和 @t{ZFTP_PWD} 被设置，并意味着所有连接都默认为 ASCII 类型。 在传输过程中，如果服务器不发送 @t{ZFTP_SIZE}（许多服务器都会发送），则可能会阻止设置 "
"@t{ZFTP_SIZE}。"

#. type: table
#: zsh.texi:31698
msgid "If @t{ZFTP_PREFS} is not set when @t{zftp} is loaded, it will be set to a default of `@t{PS}', i.e. use passive mode if available, otherwise fall back to sendport mode."
msgstr "如果 @t{ZFTP_PREFS} 在 @t{zftp} 加载时未设置，则将默认设置为 `@t{PS}'，即在可用时使用被动模式，否则退回到发送端口模式。"

#. type: t{#1}
#: zsh.texi:31699 zsh.texi:31700
#, no-wrap
msgid "ZFTP_VERBOSE"
msgstr "ZFTP_VERBOSE"

#. type: table
#: zsh.texi:31707
msgid ""
"A string of digits between 0 and 5 inclusive, specifying which responses from the server should be printed.  All responses go to standard error.  If any of the numbers 1 to 5 appear in the string, raw "
"responses from the server with reply codes beginning with that digit will be printed to standard error.  The first digit of the three digit reply code is defined by RFC959 to correspond to:"
msgstr ""
"由 0 到 5（含 5）之间的数字组成的字符串，用于指定应打印哪些来自服务器的响应。所有响应都将转入标准错误。 如果字符串中出现 1 至 5 中的任何一个数字，则以该数字开头的回复代码的服务器原始回复将被打印到标准错误"
"中。 根据 RFC959 的定义，三位回复代码的第一位对应于:"

#. type: table
#: zsh.texi:31712
msgid "A positive preliminary reply."
msgstr "肯定的初步答复。"

#. type: table
#: zsh.texi:31715
msgid "A positive completion reply."
msgstr "肯定的补全回复。"

#. type: table
#: zsh.texi:31718
msgid "A positive intermediate reply."
msgstr "肯定的中间回复。"

#. type: table
#: zsh.texi:31721
msgid "A transient negative completion reply."
msgstr "瞬时否定补全回复。"

#. type: table
#: zsh.texi:31724
msgid "A permanent negative completion reply."
msgstr "永久性的否定补全回复。"

#. type: table
#: zsh.texi:31732
msgid ""
"It should be noted that, for unknown reasons, the reply `Service not available', which forces termination of a connection, is classified as 421, i.e. `transient negative', an interesting interpretation of "
"the word `transient'."
msgstr "值得注意的是，由于不明原因，强制终止连接的回复 `Service not available' 被归类为 421，即 `瞬时否定' (`transient negative')，这是对 `瞬时' (`transient')一词的有趣解释。"

#. type: table
#: zsh.texi:31740
msgid ""
"The code 0 is special: it indicates that all but the last line of multiline replies read from the server will be printed to standard error in a processed format.  By convention, servers use this mechanism "
"for sending information for the user to read.  The appropriate reply code, if it matches the same response, takes priority."
msgstr ""
"代码 0 比较特殊：它表示从服务器读取的多行回复中，除最后一行外的所有内容都将以处理过的格式打印到标准错误中。 按照惯例，服务器使用这种机制发送信息供用户阅读。 适当的回复代码,如果与相同的回复相匹配，则优先使"
"用。"

#. type: table
#: zsh.texi:31746
msgid ""
"If @t{ZFTP_VERBOSE} is not set when @t{zftp} is loaded, it will be set to the default value @t{450}, i.e., messages destined for the user and all errors will be printed.  A null string is valid and "
"specifies that no messages should be printed."
msgstr "如果在加载 @t{zftp} 时未设置 @t{ZFTP_VERBOSE}，则会将其设置为默认值 @t{450}，即打印给用户的信息和所有错误信息。空字符串有效，表示不打印任何信息。"

#. type: cindex
#: zsh.texi:31753
#, no-wrap
msgid "zftp, functions"
msgstr "zftp, 函数"

#. type: findex
#: zsh.texi:31757
#, no-wrap
msgid "zftp_chpwd, specification"
msgstr "zftp_chpwd, 规范"

#. type: t{#1}
#: zsh.texi:31758 zsh.texi:35225
#, no-wrap
msgid "zftp_chpwd"
msgstr "zftp_chpwd"

#. type: table
#: zsh.texi:31763
msgid ""
"If this function is set by the user, it is called every time the directory changes on the server, including when a user is logged in, or when a connection is closed.  In the last case, @t{$ZFTP_PWD} will "
"be unset; otherwise it will reflect the new directory."
msgstr "如果用户设置了该函数，那么每次服务器上的目录发生变化时，包括用户登录或连接关闭时，都会调用该函数。 在最后一种情况下，@t{$ZFTP_PWD} 将被取消设置，否则它将反映新的目录。"

#. type: findex
#: zsh.texi:31764
#, no-wrap
msgid "zftp_progress, specification"
msgstr "zftp_progress, 规范"

#. type: t{#1}
#: zsh.texi:31765 zsh.texi:35248
#, no-wrap
msgid "zftp_progress"
msgstr "zftp_progress"

#. type: table
#: zsh.texi:31772
msgid ""
"If this function is set by the user, it will be called during a @t{get}, @t{put} or @t{append} operation each time sufficient data has been received from the host.  During a @t{get}, the data is sent to "
"standard output, so it is vital that this function should write to standard error or directly to the terminal, @emph{not} to standard output."
msgstr ""
"如果用户设置了该函数，那么在 @t{get}、@t{put} 或 @t{append} 操作中，每次从主机接收到足够的数据时，都会调用该函数。 在 @t{get} 操作中，数据会被发送到标准输出，因此该函数必须写入标准错误或直接写入终端，"
"@emph{而不是} 写入标准输出。"

#. type: table
#: zsh.texi:31776
msgid "When it is called with a transfer in progress, the following additional shell parameters are set:"
msgstr "在传输过程中调用它时，会设置以下附加 shell 参数："

#. type: t{#1}
#: zsh.texi:31779 zsh.texi:31780
#, no-wrap
msgid "ZFTP_FILE"
msgstr "ZFTP_FILE"

#. type: table
#: zsh.texi:31782
msgid "The name of the remote file being transferred from or to."
msgstr "正在传输的远程文件的名称。"

#. type: t{#1}
#: zsh.texi:31783 zsh.texi:31784
#, no-wrap
msgid "ZFTP_TRANSFER"
msgstr "ZFTP_TRANSFER"

#. type: table
#: zsh.texi:31786
msgid "A @t{G} for a @t{get} operation and a @t{P} for a @t{put} operation."
msgstr "一个 @t{G} 表示 @t{get} 操作，一个 @t{P} 表示 @t{put} 操作。"

#. type: t{#1}
#: zsh.texi:31787 zsh.texi:31788
#, no-wrap
msgid "ZFTP_SIZE"
msgstr "ZFTP_SIZE"

#. type: table
#: zsh.texi:31795
msgid ""
"The total size of the complete file being transferred: the same as the first value provided by the @t{remote} and @t{local} subcommands for a particular file.  If the server cannot supply this value for a "
"remote file being retrieved, it will not be set.  If input is from a pipe the value may be incorrect and correspond simply to a full pipe buffer."
msgstr ""
"正在传输的完整文件的总大小：与 @t{remote} 和 @t{local} 子命令为特定文件提供的第一个值相同。 如果服务器无法为正在检索的远程文件提供该值，则不会设置该值。 如果输入来自管道，则该值可能不正确，而仅对应于一个满"
"的管道缓冲区。"

#. type: t{#1}
#: zsh.texi:31796 zsh.texi:31797
#, no-wrap
msgid "ZFTP_COUNT"
msgstr "ZFTP_COUNT"

#. type: table
#: zsh.texi:31800
msgid "The amount of data so far transferred; a number between zero and @t{$ZFTP_SIZE}, if that is set.  This number is always available."
msgstr "目前已传输的数据量；介于 0 和 @t{$ZFTP_SIZE} 之间的数字(如果设置了 @t{$ZFTP_SIZE}）。该数字始终可用。"

#. type: table
#: zsh.texi:31810
msgid ""
"The function is initially called with @t{ZFTP_TRANSFER} set appropriately and @t{ZFTP_COUNT} set to zero.  After the transfer is finished, the function will be called one more time with @t{ZFTP_TRANSFER} "
"set to @t{GF} or @t{PF}, in case it wishes to tidy up.  It is otherwise never called twice with the same value of @t{ZFTP_COUNT}."
msgstr ""
"调用该函数时，首先会适当设置 @t{ZFTP_TRANSFER}，并将 @t{ZFTP_COUNT} 设置为零。 传输完成后，如果函数希望进行整理，则会再次调用 @t{ZFTP_TRANSFER} 并将其设置为 @t{GF} 或 @t{PF}。 在其他情况下，该函数不会以 "
"@t{ZFTP_COUNT} 的相同值被调用两次。"

#. type: table
#: zsh.texi:31815
msgid "Sometimes the progress meter may cause disruption.  It is up to the user to decide whether the function should be defined and to use @t{unfunction} when necessary."
msgstr "有时，进度表可能会造成干扰。 用户可自行决定是否应定义该函数，并在必要时使用 @t{unfunction}。"

#. type: subsection
#: zsh.texi:31820
#, no-wrap
msgid "Problems"
msgstr "问题"

#. type: cindex
#: zsh.texi:31822
#, no-wrap
msgid "zftp, problems"
msgstr "zftp, 问题"

#. type: Plain text
#: zsh.texi:31831
msgid ""
"A connection may not be opened in the left hand side of a pipe as this occurs in a subshell and the file information is not updated in the main shell.  In the case of type or mode changes or closing the "
"connection in a subshell, the information is returned but variables are not updated until the next call to @t{zftp}.  Other status changes in subshells will not be reflected by changes to the variables "
"(but should be otherwise harmless)."
msgstr ""
"不得在管道左侧打开连接，因为这发生在子 shell 中，文件信息不会在主 shell 中更新。 如果类型或模式发生变化，或者在子 shell 中关闭连接，信息会返回，但变量不会更新，直到下一次调用 @t{zftp} 时才会更新。 子 "
"shell 中的其他状态变化不会通过变量的变化反映出来（但在其他方面应该是无害的）。"

#. type: Plain text
#: zsh.texi:31838
msgid ""
"Deleting sessions while a @t{zftp} command is active in the background can have unexpected effects, even if it does not use the session being deleted.  This is because all shell subprocesses share "
"information on the state of all connections, and deleting a session changes the ordering of that information."
msgstr "当 @t{zftp} 命令在后台活动时删除会话，即使没有使用被删除的会话，也会产生意想不到的效果。 这是因为所有 shell 子进程都共享所有连接的状态信息，而删除会话会改变这些信息的排序。"

#. type: Plain text
#: zsh.texi:31845
msgid ""
"On some operating systems, the control connection is not valid after a fork(), so that operations in subshells, on the left hand side of a pipeline, or in the background are not possible, as they should "
"be.  This is presumably a bug in the operating system."
msgstr "在某些操作系统上，fork()后控制连接无效，因此子 shell、管道左侧或后台中的操作无法正常进行。 这可能是操作系统的一个错误。"

#. type: node
#: zsh.texi:31845 zsh.texi:31854 zsh.texi:31856 zsh.texi:31888
#, no-wrap
msgid "The zsh/zleparameter Module"
msgstr "zsh/zleparameter 模块"

#. type: Plain text
#: zsh.texi:31854
msgid "The @t{zsh/zle} module contains the Zsh Line Editor.  See @ref{Zsh Line Editor}."
msgstr "@t{zsh/zle} 模块包含 Zsh 行编辑器。 参见 @ref{Zsh 行编辑器}。"

#. type: node
#: zsh.texi:31854 zsh.texi:31888 zsh.texi:31890 zsh.texi:31959
#, no-wrap
msgid "The zsh/zprof Module"
msgstr "zsh/zprof 模块"

#. type: Plain text
#: zsh.texi:31864
msgid "The @t{zsh/zleparameter} module defines two special parameters that can be used to access internal information of the Zsh Line Editor (see @ref{Zsh Line Editor})."
msgstr "@t{zsh/zleparameter} 模块定义了两个特殊参数，可用于访问 Zsh 行编辑器的内部信息（参见 @ref{Zsh 行编辑器}）。"

#. type: table
#: zsh.texi:31870
msgid "This array contains the names of the keymaps currently defined."
msgstr "该数组包含当前定义的键映射名称。"

#. type: table
#: zsh.texi:31885
msgid ""
"This associative array contains one entry per widget. The name of the widget is the key and the value gives information about the widget. It is either the string `@t{builtin}' for builtin widgets, a "
"string of the form `@t{user:}@var{name}' for user-defined widgets, where @var{name} is the name of the shell function implementing the widget, a string of the form `@t{completion:}@var{type}@t{:}"
"@var{name}' for completion widgets, or a null value if the widget is not yet fully defined.  In the penultimate case, @var{type} is the name of the builtin widget the completion widget imitates in its "
"behavior and @var{name} is the name of the shell function implementing the completion widget."
msgstr ""
"这个关联数组包含每个小部件的一个条目。小部件的名称是键，值则给出了小部件的相关信息。对于内置小部件，它可以是字符串 `@t{builtin}' ；对于用户自定义的小部件，它可以是形式为 `@t{user:}@var{name}' 的字符串，其"
"中 @var{name} 是实现小部件的 shell 函数的名称；对于补全小部件，它可以是形式为 `@t{completion:}@var{type}@t{:}@var{name}' 的字符串；如果小部件尚未完全定义，它可以是空值。 在倒数第二种情况下，@var{type} 是补"
"全小部件模仿的内置小部件的名称，@var{name} 是实现补全小部件的 shell 函数的名称。"

#. type: node
#: zsh.texi:31888 zsh.texi:31959 zsh.texi:31961 zsh.texi:32064
#, no-wrap
msgid "The zsh/zpty Module"
msgstr "zsh/zpty 模块"

#. type: cindex
#: zsh.texi:31894
#, no-wrap
msgid "functions, profiling"
msgstr "函数, 性能分析"

#. type: Plain text
#: zsh.texi:31899
msgid ""
"When loaded, the @t{zsh/zprof} causes shell functions to be profiled.  The profiling results can be obtained with the @t{zprof} builtin command made available by this module.  There is no way to turn "
"profiling off other than unloading the module."
msgstr "加载 @t{zsh/zprof} 后，将对 shell 函数进行剖析。 可以使用本模块提供的 @t{zprof} 内置命令获取剖析结果。 除卸载模块外，无法关闭剖析。"

#. type: item
#: zsh.texi:31903
#, no-wrap
msgid "@t{zprof} [ @t{-c} ]"
msgstr "@t{zprof} [ @t{-c} ]"

#. type: table
#: zsh.texi:31907
msgid "Without the @t{-c} option, @t{zprof} lists profiling results to standard output.  The format is comparable to that of commands like @t{gprof}."
msgstr "如果不使用 @t{-c} 选项，@t{zprof} 会将剖析结果列到标准输出中。 格式与 @t{gprof} 等命令类似。"

#. type: table
#: zsh.texi:31922
msgid ""
"At the top there is a summary listing all functions that were called at least once.  This summary is sorted in decreasing order of the amount of time spent in each.  The lines contain the number of the "
"function in order, which is used in other parts of the list in suffixes of the form `@t{[}@var{num}@t{]}', then the number of calls made to the function.  The next three columns list the time in "
"milliseconds spent in the function and its descendants, the average time in milliseconds spent in the function and its descendants per call and the percentage of time spent in all shell functions used in "
"this function and its descendants.  The following three columns give the same information, but counting only the time spent in the function itself.  The final column shows the name of the function."
msgstr ""
"顶部有一个摘要，列出了至少被调用一次的所有函数。 该摘要按每个函数所用时间的递减顺序排列。 各行依次包含函数的编号（在列表的其他部分中使用后缀 `@t{[}@var{num}@t{]}' 形式），然后是函数的调用次数。 接下来的三"
"列列出了该函数及其后代函数的耗时（以毫秒为单位）、该函数及其后代函数每次调用的平均耗时（以毫秒为单位）以及该函数及其后代函数使用的所有 shell 函数的耗时百分比。 下面三列提供了相同的信息，但只计算函数本身所"
"用的时间。 最后一列显示函数名称。"

#. type: table
#: zsh.texi:31934
msgid ""
"After the summary, detailed information about every function that was invoked is listed, sorted in decreasing order of the amount of time spent in each function and its descendants.  Each of these entries "
"consists of descriptions for the functions that called the function described, the function itself, and the functions that were called from it.  The description for the function itself has the same format "
"as in the summary (and shows the same information).  The other lines don't show the number of the function at the beginning and have their function named indented to make it easier to distinguish the line "
"showing the function described in the section from the surrounding lines."
msgstr ""
"在摘要之后，列出了调用的每个函数的详细信息，并按每个函数及其子函数所用时间的递减顺序排列。 每个条目都包括调用所述函数的函数、函数本身以及从函数调用的函数的描述。 函数本身的描述格式与摘要中的格式相同（显示"
"的信息也相同）。 其他行开头不显示函数的编号，并将其函数名称缩进，以便于从周围的行中区分出显示本节所述函数的行。"

#. type: table
#: zsh.texi:31944
msgid ""
"The information shown in this case is almost the same as in the summary, but only refers to the call hierarchy being displayed.  For example, for a calling function the column showing the total running "
"time lists the time spent in the described function and its descendants only for the times when it was called from that particular calling function.  Likewise, for a called function, this columns lists "
"the total time spent in the called function and its descendants only for the times when it was called from the function described."
msgstr ""
"这种情况下显示的信息与摘要中的信息几乎相同，但只涉及所显示的调用层次结构。 例如，对于调用函数，显示总运行时间的列仅列出从该特定调用函数调用描述的函数及其子函数时所花费的时间。 同样，对于被调用函数，该列列"
"出了在被调用函数及其后代函数中总共花费的时间，仅针对从所描述的函数中调用它时的时间。"

#. type: table
#: zsh.texi:31949
msgid "Also in this case, the column showing the number of calls to a function also shows a slash and then the total number of invocations made to the called function."
msgstr "在这种情况下，显示函数调用次数的列还会显示一条斜线，然后是被调用函数的总调用次数。"

#. type: table
#: zsh.texi:31956
msgid ""
"As long as the @t{zsh/zprof} module is loaded, profiling will be done and multiple invocations of the @t{zprof} builtin command will show the times and numbers of calls since the module was loaded.  With "
"the @t{-c} option, the @t{zprof} builtin command will reset its internal counters and will not show the listing."
msgstr "只要 @t{zsh/zprof} 模块已加载，就会进行剖析，多次调用 @t{zprof} 内置命令将显示模块加载后的调用时间和次数。 使用 @t{-c} 选项后，@t{zprof} 内置命令将重置内部计数器，不再显示列表。"

#. type: node
#: zsh.texi:31959 zsh.texi:32064 zsh.texi:32066 zsh.texi:32146
#, no-wrap
msgid "The zsh/zselect Module"
msgstr "zsh/zselect 模块"

#. type: Plain text
#: zsh.texi:31966
msgid "The @t{zsh/zpty} module offers one builtin:"
msgstr "@t{zsh/zpty} 模块提供了一个内置程序："

#. type: item
#: zsh.texi:31970
#, no-wrap
msgid "@t{zpty} [ @t{-e} ] [ @t{-b} ] @var{name} [ @var{arg} ... ]"
msgstr "@t{zpty} [ @t{-e} ] [ @t{-b} ] @var{name} [ @var{arg} ... ]"

#. type: table
#: zsh.texi:31977
msgid ""
"The arguments following @var{name} are concatenated with spaces between, then executed as a command, as if passed to the @t{eval} builtin.  The command runs under a newly assigned pseudo-terminal; this is "
"useful for running commands non-interactively which expect an interactive environment.  The @var{name} is not part of the command, but is used to refer to this command in later calls to @t{zpty}."
msgstr ""
"@var{name} 后面的参数会用空格连接起来，然后作为一条命令执行，就像传递给 @t{eval} 内置函数一样。 命令将在新分配的伪终端下运行；这对于运行那些期望在交互式环境下运行的非交互式命令非常有用。 @var{name} 并非命"
"令的一部分，而是用于在以后调用 @t{zpty} 时引用该命令。"

#. type: table
#: zsh.texi:31981
msgid "With the @t{-e} option, the pseudo-terminal is set up so that input characters are echoed."
msgstr "使用 @t{-e} 选项时，伪终端会设置为使输入字符产生回显。"

#. type: table
#: zsh.texi:31985
msgid "With the @t{-b} option, input to and output from the pseudo-terminal are made non-blocking."
msgstr "如果使用 @t{-b} 选项，伪终端的输入和输出都将是非阻塞的。"

#. type: table
#: zsh.texi:31993
msgid ""
"The shell parameter @t{REPLY} is set to the file descriptor assigned to the master side of the pseudo-terminal.  This allows the terminal to be monitored with ZLE descriptor handlers (see @ref{Zle "
"Builtins}) or manipulated with @t{sysread} and @t{syswrite} (see @ref{The zsh/system Module}).  @emph{Warning}: Use of @t{sysread} and @t{syswrite} is @emph{not} recommended; use @t{zpty -r} and @t{zpty -"
"w} unless you know exactly what you are doing."
msgstr ""
"shell 参数 @t{REPLY} 被设置为分配给伪终端主控端的文件描述符。 这样就可以使用 ZLE 描述符处理程序监控终端（参见 @ref{Zle 内置命令}），或使用 @t{sysread} 和 @t{syswrite} 操作终端（参见 @ref{zsh/system 模"
"块}）。 @emph{警告}： 不建议使用 @t{sysread} 和 @t{syswrite}；除非您非常清楚自己在做什么，否则请使用 @t{zpty -r} 和 @t{zpty -w}。"

#. type: item
#: zsh.texi:31994
#, no-wrap
msgid "@t{zpty} @t{-d} [ @var{name} ... ]"
msgstr "@t{zpty} @t{-d} [ @var{name} ... ]"

#. type: table
#: zsh.texi:31999
msgid ""
"The second form, with the @t{-d} option, is used to delete commands previously started, by supplying a list of their @var{name}s.  If no @var{name} is given, all commands are deleted.  Deleting a command "
"causes the HUP signal to be sent to the corresponding process."
msgstr "第二种形式带有 @t{-d} 选项，通过提供 @var{name}s 的列表来删除之前启动的命令。 如果没有给出 @var{name}，则删除所有命令。 删除命令会导致向相应进程发送 HUP 信号。"

#. type: item
#: zsh.texi:32000
#, no-wrap
msgid "@t{zpty} @t{-w} [ @t{-n} ] @var{name} [ @var{string} ... ]"
msgstr "@t{zpty} @t{-w} [ @t{-n} ] @var{name} [ @var{string} ... ]"

#. type: table
#: zsh.texi:32004
msgid "The @t{-w} option can be used to send the to command @var{name} the given @var{string}s as input (separated by spaces).  If the @t{-n} option is @emph{not} given, a newline is added at the end."
msgstr "@t{-w} 选项可用于将给定的 @var{string} 作为输入发送到命令 @var{name}。如果 @emph{未} 给出 @t{-n} 选项，则在末尾添加一个换行符。"

#. type: table
#: zsh.texi:32010
msgid ""
"If no @var{string} is provided, the standard input is copied to the pseudo-terminal; this may stop before copying the full input if the pseudo-terminal is non-blocking.  The exact input is always copied: "
"the @t{-n} option is not applied."
msgstr "如果没有提供 @var{string}，标准输入会被复制到伪终端；如果伪终端是非阻塞的，可能会在复制完整输入之前停止。 精确输入总是被复制：@t{-n} 选项不适用。"

#. type: table
#: zsh.texi:32015
msgid "Note that the command under the pseudo-terminal sees this input as if it were typed, so beware when sending special tty driver characters such as word-erase, line-kill, and end-of-file."
msgstr "请注意，伪终端下的命令会将这些输入视为键入的输入，因此在发送特殊的 tty 驱动程序字符（如字擦除、行删除和文件结束）时要小心。"

#. type: item
#: zsh.texi:32016
#, no-wrap
msgid "@t{zpty} @t{-r} [ @t{-mt} ] @var{name} [ @var{param} [ @var{pattern} ] ]"
msgstr "@t{zpty} @t{-r} [ @t{-mt} ] @var{name} [ @var{param} [ @var{pattern} ] ]"

#. type: table
#: zsh.texi:32023
msgid ""
"The @t{-r} option can be used to read the output of the command @var{name}.  With only a @var{name} argument, the output read is copied to the standard output.  Unless the pseudo-terminal is non-blocking, "
"copying continues until the command under the pseudo-terminal exits; when non-blocking, only as much output as is immediately available is copied.  The return status is zero if any output is copied."
msgstr ""
"@t{-r} 选项可用于读取 @var{name} 命令的输出。 如果只有 @var{name} 参数，读取的输出将被复制到标准输出。 除非伪终端是非阻塞的，否则复制将持续到伪终端下的命令退出为止；如果是非阻塞的，则只复制立即可用的输"
"出。 如果有任何输出被复制，返回状态为零。"

#. type: table
#: zsh.texi:32029
msgid ""
"When also given a @var{param} argument, at most one line is read and stored in the parameter named @var{param}.  Less than a full line may be read if the pseudo-terminal is non-blocking.  The return "
"status is zero if at least one character is stored in @var{param}."
msgstr "如果同时给出 @var{param} 参数，则最多读取一行并存储在名为 @var{param} 的参数中。 如果伪终端是非阻塞的，则可以读取少于一行的内容。 如果 @var{param} 中至少存储了一个字符，则返回状态为零。"

#. type: table
#: zsh.texi:32039
msgid ""
"If a @var{pattern} is given as well, output is read until the whole string read matches the @var{pattern}, even in the non-blocking case.  The return status is zero if the string read matches the pattern, "
"or if the command has exited but at least one character could still be read.  If the option @t{-m} is present, the return status is zero only if the pattern matches.  As of this writing, a maximum of one "
"megabyte of output can be consumed this way; if a full megabyte is read without matching the pattern, the return status is non-zero."
msgstr ""
"如果同时给出 @var{pattern}，即使在非阻塞情况下，也会读取输出，直到读取的整个字符串与 @var{pattern} 匹配为止。 如果读取的字符串与模式匹配，或者命令已退出但仍能读取至少一个字符，则返回状态为零。 如果存在选"
"项 @t{-m}，只有当模式匹配时，返回状态才为零。 截至本文撰写时，这种方式最多可消耗 1 兆字节的输出；如果读取了整整 1 兆字节，但没有匹配到模式，则返回状态为非零。"

#. type: table
#: zsh.texi:32043
msgid "In all cases, the return status is non-zero if nothing could be read, and is @t{2} if this is because the command has finished."
msgstr "在所有情况下，如果没有读取到任何内容，返回状态均为非零，如果是因为命令已执行完毕，返回状态则为 @t{2}。"

#. type: table
#: zsh.texi:32051
msgid ""
"If the @t{-r} option is combined with the @t{-t} option, @t{zpty} tests whether output is available before trying to read.  If no output is available, @t{zpty} immediately returns the status @t{1}.  When "
"used with a @var{pattern}, the behaviour on a failed poll is similar to when the command has exited: the return value is zero if at least one character could still be read even if the pattern failed to "
"match."
msgstr ""
"如果 @t{-r} 选项与 @t{-t} 选项结合使用，@t{zpty} 会在尝试读取之前测试输出是否可用。 如果输出不可用，@t{zpty} 会立即返回状态 @t{1}。 与 @var{pattern} 一起使用时，轮询失败时的行为与命令退出时类似：如果即使模"
"式匹配失败，仍能读取至少一个字符，则返回值为 0。"

#. type: item
#: zsh.texi:32052
#, no-wrap
msgid "@t{zpty} @t{-t} @var{name}"
msgstr "@t{zpty} @t{-t} @var{name}"

#. type: table
#: zsh.texi:32056
msgid "The @t{-t} option without the @t{-r} option can be used to test whether the command @var{name} is still running.  It returns a zero status if the command is running and a non-zero value otherwise."
msgstr "不带 @t{-r} 选项的 @t{-t} 选项可用于测试 @var{name} 命令是否仍在运行。 如果命令正在运行，则返回零状态，否则返回非零值。"

#. type: item
#: zsh.texi:32057
#, no-wrap
msgid "@t{zpty} [ @t{-L} ]"
msgstr "@t{zpty} [ @t{-L} ]"

#. type: table
#: zsh.texi:32061
msgid "The last form, without any arguments, is used to list the commands currently defined.  If the @t{-L} option is given, this is done in the form of calls to the @t{zpty} builtin."
msgstr "最后一种形式不带任何参数，用于列出当前定义的命令。 如果给定了 @t{-L} 选项，则将以调用 @t{zpty} 内置程序的形式完成。"

#. type: Plain text
#: zsh.texi:32071
msgid "The @t{zsh/zselect} module makes available one builtin command:"
msgstr "@t{zsh/zselect} 模块提供了一条内置命令："

#. type: findex
#: zsh.texi:32074
#, no-wrap
msgid "zselect"
msgstr "zselect"

#. type: cindex
#: zsh.texi:32075
#, no-wrap
msgid "select, system call"
msgstr "select, 系统调用"

#. type: cindex
#: zsh.texi:32076
#, no-wrap
msgid "file descriptors, waiting for"
msgstr "文件描述符, 等待"

#. type: item
#: zsh.texi:32077
#, no-wrap
msgid "@t{zselect} [ @t{-rwe} ] [ @t{-t} @var{timeout} ] [ @t{-a} @var{array} ] [ @t{-A} @var{assoc} ] [ @var{fd} ... ]"
msgstr "@t{zselect} [ @t{-rwe} ] [ @t{-t} @var{timeout} ] [ @t{-a} @var{array} ] [ @t{-A} @var{assoc} ] [ @var{fd} ... ]"

#. type: table
#: zsh.texi:32085
msgid ""
"The @t{zselect} builtin is a front-end to the `select' system call, which blocks until a file descriptor is ready for reading or writing, or has an error condition, with an optional timeout.  If this is "
"not available on your system, the command prints an error message and returns status 2 (normal errors return status 1).  For more information, see your system's documentation for select(3).  Note there is "
"no connection with the shell builtin of the same name."
msgstr ""
"@t{zselect} 内置命令是 `select' 系统调用的前端，它会一直阻塞，直到文件描述符可以读写或出现错误，并可选择超时。 如果p 这在系统中不可用，该命令将打印错误信息并返回状态 2（正常错误返回状态 1）。 更多信息，请"
"参阅系统中的 select(3) 文档。 请注意，该命令与同名的 shell 内置命令没有任何联系。"

#. type: table
#: zsh.texi:32095
msgid ""
"Arguments and options may be intermingled in any order.  Non-option arguments are file descriptors, which must be decimal integers.  By default, file descriptors are to be tested for reading, i.e. "
"@t{zselect} will return when data is available to be read from the file descriptor, or more precisely, when a read operation from the file descriptor will not block.  After a @t{-r}, @t{-w} and @t{-e}, "
"the given file descriptors are to be tested for reading, writing, or error conditions.  These options and an arbitrary list of file descriptors may be given in any order."
msgstr ""
"参数和选项可以任意顺序混合。 非选项参数是文件描述符，必须是十进制整数。 默认情况下，文件描述符将接受读取测试，即 @t{zselect} 将在可以从文件描述符读取数据时返回，或者更准确地说，在从文件描述符读取操作不会阻"
"塞时返回。 在 @t{-r}、@t{-w} 和 @t{-e} 之后，将对给定的文件描述符进行读、写或错误测试。 这些选项和任意文件描述符列表可以任意顺序给出。"

#. type: table
#: zsh.texi:32103
msgid ""
"(The presence of an `error condition' is not well defined in the documentation for many implementations of the select system call.  According to recent versions of the POSIX specification, it is really an "
"@emph{exception} condition, of which the only standard example is out-of-band data received on a socket.  So zsh users are unlikely to find the @t{-e} option useful.)"
msgstr ""
"(在许多实现 select 系统调用的文档中，`error condition' 的存在并没有明确定义。 根据 POSIX 规范的最新版本，它实际上是一个 @emph{exception} 条件，其中唯一的标准示例是通过套接字接收到的带外( out-of-band)数"
"据。 因此，zsh 用户不太可能发现 @t{-e} 选项有什么用）。"

#. type: table
#: zsh.texi:32111
msgid ""
"The option `@t{-t} @var{timeout}' specifies a timeout in hundredths of a second.  This may be zero, in which case the file descriptors will simply be polled and @t{zselect} will return immediately.  It is "
"possible to call zselect with no file descriptors and a non-zero timeout for use as a finer-grained replacement for `sleep'; note, however, the return status is always 1 for a timeout."
msgstr ""
"选项 `@t{-t} @var{timeout}' 以百分之一秒为单位指定超时时间。 超时时间可以为零，在这种情况下，文件描述符将被轮询，而 @t{zselect} 将立即返回。 可以用没有文件描述符和非零超时的 zselect 来 `sleep' 的更精细替"
"代；但需要注意的是，超时时的返回状态总是 1。"

#. type: table
#: zsh.texi:32118
msgid ""
"The option `@t{-a} @var{array}' indicates that @var{array} should be set to indicate the file descriptor(s) which are ready.  If the option is not given, the array @t{reply} will be used for this "
"purpose.  The array will contain a string similar to the arguments for @t{zselect}.  For example,"
msgstr "选项 `@t{-a} @var{array}' 表示应设置 @var{array} 以指示已就绪的文件描述符。 如果未给出该选项，则将使用数组 @t{reply}。 数组包含的字符串与 @t{zselect} 的参数类似。 例如,"

#. type: example
#: zsh.texi:32122
#, no-wrap
msgid "zselect -t 0 -r 0 -w 1\n"
msgstr "zselect -t 0 -r 0 -w 1\n"

#. type: table
#: zsh.texi:32128
msgid "might return immediately with status 0 and @t{$reply} containing `@t{-r 0 -w 1}' to show that both file descriptors are ready for the requested operations."
msgstr "可能会立即返回状态 0 和包含 `@t{-r 0 -w 1}' 的 @t{$reply}，以表明两个文件描述符都已准备好执行请求的操作。"

#. type: table
#: zsh.texi:32136
msgid ""
"The option `@t{-A} @var{assoc}' indicates that the associative array @var{assoc} should be set to indicate the file descriptor(s)  which are ready.  This option overrides the option @t{-a}, nor will "
"@t{reply} be modified.  The keys of @t{assoc} are the file descriptors, and the corresponding values are any of the characters `@t{rwe}' to indicate the condition."
msgstr ""
"选项 `@t{-A} @var{assoc}' 表示应设置关联数组 @var{assoc} 以指示已准备就绪的文件描述符。 该选项会覆盖 @t{-a} 选项，也不会修改 @t{reply}。 @t{assoc} 的键是文件描述符，对应的值是任意字符 `@t{rwe}' ，用于指示"
"条件。"

#. type: table
#: zsh.texi:32143
msgid ""
"The command returns status 0 if some file descriptors are ready for reading.  If the operation timed out, or a timeout of 0 was given and no file descriptors were ready, or there was an error, it returns "
"status 1 and the array will not be set (nor modified in any way).  If there was an error in the select operation the appropriate error message is printed."
msgstr ""
"如果某些文件描述符已准备好供读取，则命令返回状态 0。 如果操作超时，或超时时间为 0 但没有文件描述符准备就绪，或出现错误，则返回状态 1，数组不会被设置（也不会以任何方式修改）。 如果选择操作出错，将打印相应的"
"错误信息。"

#. type: cindex
#: zsh.texi:32152
#, no-wrap
msgid "builtins, utility"
msgstr "内置命令, 实用程序"

#. type: Plain text
#: zsh.texi:32154
msgid "The @t{zsh/zutil} module only adds some builtins:"
msgstr "@t{zsh/zutil} 模块只增加一些内置命令:"

#. type: item
#: zsh.texi:32158 zsh.texi:32224
#, no-wrap
msgid "@t{zstyle} [ @t{-L} [ @var{metapattern} [ @var{style} ] ] ]"
msgstr "@t{zstyle} [ @t{-L} [ @var{metapattern} [ @var{style} ] ] ]"

#. type: itemx
#: zsh.texi:32159
#, no-wrap
msgid "@t{zstyle} [ @t{-e} | @t{-} | @t{-}@t{-} ] @var{pattern} @var{style} @var{string} ..."
msgstr "@t{zstyle} [ @t{-e} | @t{-} | @t{-}@t{-} ] @var{pattern} @var{style} @var{string} ..."

#. type: item
#: zsh.texi:32160 zsh.texi:32252
#, no-wrap
msgid "@t{zstyle -d} [ @var{pattern} [ @var{style} ... ] ]"
msgstr "@t{zstyle -d} [ @var{pattern} [ @var{style} ... ] ]"

#. type: item
#: zsh.texi:32161 zsh.texi:32258
#, no-wrap
msgid "@t{zstyle -g} @var{name} [ @var{pattern} [ @var{style} ] ]"
msgstr "@t{zstyle -g} @var{name} [ @var{pattern} [ @var{style} ] ]"

#. type: itemx
#: zsh.texi:32162
#, no-wrap
msgid "@t{zstyle -}@{@t{a}|@t{b}|@t{s}@} @var{context} @var{style} @var{name} [ @var{sep} ]"
msgstr "@t{zstyle -}@{@t{a}|@t{b}|@t{s}@} @var{context} @var{style} @var{name} [ @var{sep} ]"

#. type: itemx
#: zsh.texi:32163
#, no-wrap
msgid "@t{zstyle -}@{@t{T}|@t{t}@} @var{context} @var{style} [ @var{string} ... ]"
msgstr "@t{zstyle -}@{@t{T}|@t{t}@} @var{context} @var{style} [ @var{string} ... ]"

#. type: item
#: zsh.texi:32164 zsh.texi:32314
#, no-wrap
msgid "@t{zstyle -m} @var{context} @var{style} @var{pattern}"
msgstr "@t{zstyle -m} @var{context} @var{style} @var{pattern}"

#. type: table
#: zsh.texi:32171
msgid ""
"This builtin command is used to define and lookup styles.  Styles are pairs of names and values, where the values consist of any number of strings.  They are stored together with patterns and lookup is "
"done by giving a string, called the `@emph{context}', which is matched against the patterns.  The definition stored for the most specific pattern that matches will be returned."
msgstr ""
"该内置命令用于定义和查找样式。 样式由名称和值组成，其中值由任意数量的字符串组成。 它们与模式一起存储，通过提供一个字符串（称为 `@emph{context}'）与模式匹配进行查找。 将返回为最匹配的特定模式存储的定义。"

#. type: table
#: zsh.texi:32182
msgid ""
"A pattern is considered to be more specific than another if it contains more components (substrings separated by colons) or if the patterns for the components are more specific, where simple strings are "
"considered to be more specific than patterns and complex patterns are considered to be more specific than the pattern `@t{*}'.  A `@t{*}' in the pattern will match zero or more characters in the context; "
"colons are not treated specially in this regard.  If two patterns are equally specific, the tie is broken in favour of the pattern that was defined first."
msgstr ""
"如果一个模式包含更多的成分（用冒号分隔的子串），或者如果成分的模式更具体，则该模式被认为比另一个模式更具体，其中简单字符串被认为比模式更具体，而复杂模式被认为比模式 `@t{*}' 更具体。 模式中的 `@t{*}' 将匹配"
"上下文中的零个或多个字符；冒号在这方面不作特殊处理。 如果两个模式的特定性相同，则先定义的模式优先。"

#. type: kindex
#: zsh.texi:32185
#, no-wrap
msgid "preferred-precipitation, example style"
msgstr "preferred-precipitation, 示例样式"

#. type: findex
#: zsh.texi:32186
#, no-wrap
msgid "weather, example function"
msgstr "天气, 示例函数"

#. type: table
#: zsh.texi:32193
msgid ""
"For example, a fictional `@t{weather}' plugin might state in its documentation that it looks up the @t{preferred-precipitation} style under the `@t{:weather:}@var{continent}@t{:}@var{day-of-the-week}@t{:}"
"@var{phase-of-the-moon}' context.  According to this, you might set the following in your @t{zshrc}:"
msgstr ""
"例如，一个虚构的 `@t{weather}' 插件可能会在其文档中说明，它会在 `@t{:weather:}@var{continent}@t{:}@var{day-of-the-week}@t{:}@var{phase-of-the-moon}' 上下文中查找 @t{preferred-precipitation} 样式。 据此，您"
"可以在 @t{zshrc} 中设置以下内容："

#. type: example
#: zsh.texi:32198
#, no-wrap
msgid ""
"zstyle ':weather:europe:*' preferred-precipitation rain\n"
"zstyle ':weather:*:Sunday:*' preferred-precipitation snow\n"
msgstr ""
"zstyle ':weather:europe:*' preferred-precipitation rain\n"
"zstyle ':weather:*:Sunday:*' preferred-precipitation snow\n"

#. type: table
#: zsh.texi:32202
msgid "Then the plugin would run under the hood a command such as"
msgstr "然后，插件会在内部（under the hood)运行一条命令，例如"

#. type: example
#: zsh.texi:32206
#, no-wrap
msgid "zstyle -s \":weather:$@{continent@}:$@{day_of_week@}:$@{moon_phase@}\" preferred-precipitation REPLY\n"
msgstr "zstyle -s \":weather:$@{continent@}:$@{day_of_week@}:$@{moon_phase@}\" preferred-precipitation REPLY\n"

#. type: table
#: zsh.texi:32215
msgid ""
"in order to retrieve your preference into the scalar variable @t{$REPLY}.  On Sundays @t{$REPLY} would be set to `@t{snow}'; in Europe it would be set to `@t{rain}'; and on Sundays in Europe it would be "
"set to `@t{snow}' again, because the patterns `@t{:weather:europe:*}' and `@t{:weather:*:Sunday:*}' both match the @var{context} argument to @t{zstyle -s}, are equally specific, and the latter is more "
"specific (because it has more colon-separated components)."
msgstr ""
"为了在标量变量 @t{$REPLY} 中获取您的偏好。 在周日，@t{$REPLY} 将被设置为 `@t{snow}'；在欧洲，它将被设置为 `@t{rain}'；在欧洲的周日，它将再次被设置为 `@t{snow}' ，因为模式 `@t{:weather:europe:*}' 和 `@t{:"
"weather:*:Sunday:*}' 都与 @t{zstyle -s} 的 @var{context} 参数相匹配，具有相同的特异性，而且后者更具特异性（因为它有更多以冒号分隔的成分）。"

#. type: subsection
#: zsh.texi:32218 zsh.texi:36327
#, no-wrap
msgid "Usage"
msgstr "用法"

#. type: table
#: zsh.texi:32221
msgid "The forms that operate on patterns are the following."
msgstr "对模式进行操作的形式如下。"

#. type: table
#: zsh.texi:32228
msgid "Without arguments, lists style definitions.  Styles are shown in alphabetic order and patterns are shown in the order @t{zstyle} will test them."
msgstr "不带参数，列出样式定义。 样式按字母顺序显示，模式按 @t{zstyle} 将测试它们的顺序显示。"

#. type: table
#: zsh.texi:32239
msgid ""
"If the @t{-L} option is given, listing is done in the form of calls to @t{zstyle}.  The optional first argument, @var{metapattern}, is a pattern which will be matched against the string supplied as "
"@var{pattern} when the style was defined.  Note: this means, for example, `@t{zstyle -L \":completion:*\"}' will match any supplied pattern beginning `@t{:completion:}', not just @t{\":completion:*\"}: "
"use @t{':completion:\\*'} to match that.  The optional second argument limits the output to a specific @var{style} (not a pattern).  @t{-L} is not compatible with any other options."
msgstr ""
"如果给出 @t{-L} 选项，则将以调用 @t{zstyle} 的形式列出。 可选的第一个参数 @var{metapattern} 是一个模式，将与定义样式时作为 @var{pattern} 提供的字符串进行匹配。 注意：这意味着，例如，`@t{zstyle -L \":"
"completion:*\"}' 将匹配以`@t{:completion:}' 开头的任何提供的模式，而不仅仅是 @t{\":completion:*\"}：使用 @t{':completion:\\*'} 来匹配。 可选的第二个参数将输出限制为特定的 @var{style}（而不是模式）。 @t{-"
"L} 与其他选项不兼容。"

#. type: item
#: zsh.texi:32240
#, no-wrap
msgid "@t{zstyle} [ @t{-} | @t{-}@t{-} | @t{-e} ] @var{pattern} @var{style} @var{string} ..."
msgstr "@t{zstyle} [ @t{-} | @t{-}@t{-} | @t{-e} ] @var{pattern} @var{style} @var{string} ..."

#. type: table
#: zsh.texi:32251
msgid ""
"Defines the given @var{style} for the @var{pattern} with the @var{string}s as the value.  If the @t{-e} option is given, the @var{string}s will be concatenated (separated by spaces) and the resulting "
"string will be evaluated (in the same way as it is done by the @t{eval} builtin command) when the style is looked up.  In this case the parameter `@t{reply}' must be assigned to set the strings returned "
"after the evaluation.  Before evaluating the value, @t{reply} is unset, and if it is still unset after the evaluation, the style is treated as if it were not set."
msgstr ""
"为 @var{pattern} 定义给定的 @var{style} 并将 @var{string}s 作为值。 如果给定了 @t{-e} 选项，则 @var{string}s 将被连接（用空格分隔），生成的字符串将在查找样式时进行评估（与 @t{eval} 内置命令的评估方式相"
"同）。 在这种情况下，必须指定参数 `@t{reply}' ，以设置求值后返回的字符串。 在求值之前，@t{reply} 将被取消设置，如果求值后仍未设置，则样式将被视为未设置。"

#. type: table
#: zsh.texi:32257
msgid ""
"Delete style definitions. Without arguments all definitions are deleted, with a @var{pattern} all definitions for that pattern are deleted and if any @var{style}s are given, then only those styles are "
"deleted for the @var{pattern}."
msgstr "删除样式定义。在不带参数的情况下，所有定义都会被删除；在带 @var{pattern} 的情况下，该样式的所有定义都会被删除；如果给定了任何 @var{style}，则只删除 @var{pattern} 的那些样式。"

#. type: table
#: zsh.texi:32265
msgid ""
"Retrieve a style definition. The @var{name} is used as the name of an array in which the results are stored. Without any further arguments, all patterns defined are returned. With a @var{pattern} the "
"styles defined for that pattern are returned and with both a @var{pattern} and a @var{style}, the value strings of that combination is returned."
msgstr ""
"读取样式定义。@var{name} 用作存储结果的数组名称。在没有其他参数的情况下，将返回所有已定义的样式。使用 @var{pattern} 时，将返回为该模式定义的样式；同时使用 @var{pattern} 和 @var{style} 时，将返回该组合的值"
"字符串。"

#. type: table
#: zsh.texi:32270
msgid "The other forms can be used to look up or test styles for a given context."
msgstr "其他形式可用于查找或测试特定环境下的样式。"

#. type: item
#: zsh.texi:32273
#, no-wrap
msgid "@t{zstyle -s} @var{context} @var{style} @var{name} [ @var{sep} ]"
msgstr "@t{zstyle -s} @var{context} @var{style} @var{name} [ @var{sep} ]"

#. type: table
#: zsh.texi:32277
msgid ""
"The parameter @var{name} is set to the value of the style interpreted as a string.  If the value contains several strings they are concatenated with spaces (or with the @var{sep} string if that is given) "
"between them."
msgstr "参数 @var{name} 将被设置为以字符串形式解释的样式值。 如果样式值包含多个字符串，则在字符串之间用空格（或 @var{sep} 字符串（如果已给出））连接起来。"

#. type: table
#: zsh.texi:32280 zsh.texi:32297
msgid "Return @t{0} if the style is set, @t{1} otherwise."
msgstr "如果设置了样式，则返回 @t{0}，否则返回 @t{1}。"

#. type: item
#: zsh.texi:32281
#, no-wrap
msgid "@t{zstyle -b} @var{context} @var{style} @var{name}"
msgstr "@t{zstyle -b} @var{context} @var{style} @var{name}"

#. type: table
#: zsh.texi:32286
msgid ""
"The value is stored in @var{name} as a boolean, i.e. as the string `@t{yes}' if the value has only one string and that string is equal to one of `@t{yes}', `@t{true}', `@t{on}', or `@t{1}'. If the value "
"is any other string or has more than one string, the parameter is set to `@t{no}'."
msgstr ""
"如果参数值只有一个字符串，且该字符串等于`@t{yes}', `@t{true}', `@t{on}' 或 `@t{1}' 中的一个，则参数值将以布尔形式保存在 @var{name} 中，即保存为字符串 `@t{yes}' 。如果数值是其他字符串或有多个字符串，参数将"
"被设置为 `@t{no}'。"

#. type: table
#: zsh.texi:32289
msgid "Return @t{0} if @var{name} is set to `@t{yes}', @t{1} otherwise."
msgstr "如果 @var{name} 设置为 `@t{yes}'，则返回 @t{0}，否则返回 @t{1}。"

#. type: item
#: zsh.texi:32290
#, no-wrap
msgid "@t{zstyle -a} @var{context} @var{style} @var{name}"
msgstr "@t{zstyle -a} @var{context} @var{style} @var{name}"

#. type: table
#: zsh.texi:32294
msgid "The value is stored in @var{name} as an array. If @var{name} is declared as an associative array, the first, third, etc. strings are used as the keys and the other strings are used as the values."
msgstr "值以数组形式存储在 @var{name} 中。如果 @var{name} 被声明为关联数组，则第一个、第三个等字符串将用作键，其他字符串将用作值。"

#. type: item
#: zsh.texi:32298
#, no-wrap
msgid "@t{zstyle -t} @var{context} @var{style} [ @var{string} ... ]"
msgstr "@t{zstyle -t} @var{context} @var{style} [ @var{string} ... ]"

#. type: itemx
#: zsh.texi:32299
#, no-wrap
msgid "@t{zstyle -T} @var{context} @var{style} [ @var{string} ... ]"
msgstr "@t{zstyle -T} @var{context} @var{style} [ @var{string} ... ]"

#. type: table
#: zsh.texi:32308
msgid ""
"Test the value of a style, i.e. the @t{-t} option only returns a status (sets @t{$?}).  Without any @var{string} the return status is zero if the style is defined for at least one matching pattern, has "
"only one string in its value, and that is equal to one of `@t{true}', `@t{yes}', `@t{on}' or `@t{1}'. If any @var{string}s are given the status is zero if and only if at least one of the @var{string}s is "
"equal to at least one of the strings in the value. If the style is defined but doesn't match, the return status is @t{1}. If the style is not defined, the status is @t{2}."
msgstr ""
"测试样式的值，即 @t{-t} 选项只返回状态（设置 @t{$?}）。 在不包含任何 @var{string} 的情况下，如果样式为至少一个匹配模式定义，其值中只有一个字符串，且等于 `@t{true}', `@t{yes}', `@t{on}' 或 `@t{1}' 中的一"
"个，则返回状态为零。如果给出任何 @var{string}s，则只有当 @var{string}s 中至少有一个字符串等于值中的至少一个字符串时，状态才为零。如果样式已定义但不匹配，则返回状态为 @t{1}。如果未定义样式，则返回状态为 "
"@t{2}。"

#. type: table
#: zsh.texi:32313
msgid "The @t{-T} option tests the values of the style like @t{-t}, but it returns status zero (rather than @t{2}) if the style is not defined for any matching pattern."
msgstr "@t{-T} 选项会像 @t{-t} 一样测试样式的值，但如果没有为任何匹配模式定义样式，则返回状态 0（而不是 @t{2}）。"

#. type: table
#: zsh.texi:32317
msgid "Match a value. Returns status zero if the @var{pattern} matches at least one of the strings in the value."
msgstr "匹配一个值。如果 @var{pattern} 至少匹配值中的一个字符串，则返回状态 0。"

#. type: item
#: zsh.texi:32321
#, no-wrap
msgid "@t{zformat -f} @var{param} @var{format} @var{spec} ..."
msgstr "@t{zformat -f} @var{param} @var{format} @var{spec} ..."

#. type: itemx
#: zsh.texi:32322
#, no-wrap
msgid "@t{zformat -F} @var{param} @var{format} @var{spec} ..."
msgstr "@t{zformat -F} @var{param} @var{format} @var{spec} ..."

#. type: itemx
#: zsh.texi:32323
#, no-wrap
msgid "@t{zformat -a} @var{array} @var{sep} @var{spec} ..."
msgstr "@t{zformat -a} @var{array} @var{sep} @var{spec} ..."

#. type: table
#: zsh.texi:32342
msgid ""
"This builtin provides different forms of formatting. The first form is selected with the @t{-f} option. In this case the @var{format} string will be modified by replacing sequences starting with a percent "
"sign in it with strings from the @var{spec}s.  Each @var{spec} should be of the form `@var{char}@t{:}@var{string}' which will cause every appearance of the sequence `@t{%}@var{char}' in @var{format} to be "
"replaced by the @var{string}.  The `@t{%}' sequence may also contain optional minimum and maximum field width specifications between the `@t{%}' and the `@var{char}' in the form `@t{%}@var{min}@t{.}"
"@var{max}@t{c}', i.e. the minimum field width is given first and if the maximum field width is used, it has to be preceded by a dot.  Specifying a minimum field width makes the result be padded with "
"spaces to the right if the @var{string} is shorter than the requested width.  Padding to the left can be achieved by giving a negative minimum field width.  If a maximum field width is specified, the "
"@var{string} will be truncated after that many characters.  After all `@t{%}' sequences for the given @var{spec}s have been processed, the resulting string is stored in the parameter @var{param}."
msgstr ""
"该内置程序提供不同的格式化形式。第一种形式通过 @t{-f} 选项选择。在这种情况下，@var{format} 字符串将被修改，用 @var{spec} 中的字符串替换以百分号开头的序列。 每个 @var{spec} 都应采用 `@var{char}@t{:}"
"@var{string}' 的形式，这样 @var{format} 中每次出现的 `@t{%}@var{char}' 序列都会被 @var{string} 所替换。 在 `@t{%}' 和 `@var{char}' 之间， `@t{%}' 序列还可以包含可选的最小和最大字段宽度说明，其形式为 `@t{%}"
"@var{min}@t{.}@var{max}@t{c}'，即首先给出最小字段宽度，如果使用最大字段宽度，则必须在其前加一个点。 如果 @var{string} 短于要求的宽度，指定最小字段宽度会使结果向右填充空格。 通过给出负的最小字段宽度，可以实"
"现向左填充。 如果指定了最大字段宽度，@var{string} 将在该字符数之后被截断。 处理完指定 @var{spec} 的所有 `@t{%}' 序列后，生成的字符串将存储在参数 @var{param} 中。"

#. type: table
#: zsh.texi:32360
msgid ""
"The @t{%}-escapes also understand ternary expressions in the form used by prompts.  The @t{%} is followed by a `@t{(}' and then an ordinary format specifier character as described above.  There may be a "
"set of digits either before or after the `@t{(}'; these specify a test number, which defaults to zero.  Negative numbers are also allowed.  An arbitrary delimiter character follows the format specifier, "
"which is followed by a piece of `true' text, the delimiter character again, a piece of `false' text, and a closing parenthesis.  The complete expression (without the digits) thus looks like `@t{%(}@var{X}"
"@t{.}@var{text1}@t{.}@var{text2}@t{)}', except that the `@t{.}' character is arbitrary.  The value given for the format specifier in the @var{char}@t{:}@var{string} expressions is evaluated as a "
"mathematical expression, and compared with the test number.  If they are the same, @var{text1} is output, else @var{text2} is output.  A parenthesis may be escaped in @var{text2} as @t{%)}.  Either of "
"@var{text1} or @var{text2} may contain nested @t{%}-escapes."
msgstr ""
"@t{%}转义也能理解提示符所用的三元表达式形式。 @t{%} 后面是一个 `@t{(}' ，然后是一个普通的格式规范字符，如上所述。 在 `@t{(}' 之前或之后可能有一组数字；这些数字指定一个测试数，默认为零。 也允许使用负数。 格"
"式指定符后是一个任意分隔符，之后是一段 `true' 文本、分隔符、一段 `false' 文本和一个闭括号。 因此，完整的表达式（不含数字）看起来就像 `@t{%(}@var{X}@t{.}@var{text1}@t{.}@var{text2}@t{)}'，只不过 `@t{.}' 字"
"符是任意的。 @var{char}@t{:}@var{string} 表达式中格式指定符的值将作为数学表达式进行运算，并与测试数进行比较。 如果两者相同，则输出 @var{text1}，否则输出 @var{text2}。 @var{text2} 中的括号可以转义为 "
"@t{%)}。 @var{text1} 或 @var{text2} 都可能包含嵌套的 @t{%} 转义。"

#. type: example
#: zsh.texi:32367
#, no-wrap
msgid "zformat -f REPLY \"The answer is '%3(c.yes.no)'.\" c:3\n"
msgstr "zformat -f REPLY \"The answer is '%3(c.yes.no)'.\" c:3\n"

#. type: table
#: zsh.texi:32373
msgid "outputs \"The answer is 'yes'.\" to @t{REPLY} since the value for the format specifier @t{c} is 3, agreeing with the digit argument to the ternary expression."
msgstr "由于格式指定符 @t{c} 的值为 3，与三元表达式的数字参数一致，因此会向 @t{REPLY} 输出 \"The answer is 'yes'.\"。"

#. type: table
#: zsh.texi:32380
msgid ""
"With @t{-F} instead of @t{-f}, ternary expressions choose between the `true' or `false' text on the basis of whether the format specifier is present and non-empty.  A test number indicates a minimum width "
"for the value given in the format specifier. Negative numbers reverse this, so the test is for whether the value exceeds a maximum width."
msgstr "使用 @t{-F} 代替 @t{-f}，三元表达式会根据格式指定符是否存在且非空来选择 `true' 或 `false' 文本。 测试数表示格式指定符中给定值的最小宽度。负数则相反，因此测试值是否超过最大宽度。"

#. type: table
#: zsh.texi:32395
msgid ""
"The form, using the @t{-a} option, can be used for aligning strings.  Here, the @var{spec}s are of the form `@var{left}@t{:}@var{right}' where `@var{left}' and `@var{right}' are arbitrary strings.  These "
"strings are modified by replacing the colons by the @var{sep} string and padding the @var{left} strings with spaces to the right so that the @var{sep} strings in the result (and hence the @var{right} "
"strings after them) are all aligned if the strings are printed below each other.  All strings without a colon are left unchanged and all strings with an empty @var{right} string have the trailing colon "
"removed.  In both cases the lengths of the strings are not used to determine how the other strings are to be aligned.  A colon in the @var{left} string can be escaped with a backslash.  The resulting "
"strings are stored in the @var{array}."
msgstr ""
"使用 @t{-a} 选项的形式可用于对齐字符串。 这里，@var{spec}s 的形式是 `@var{left}@t{:}@var{right}'，其中 `@var{left}' 和 `@var{right}' 是任意字符串。 修改这些字符串的方法是：用 @var{sep} 字符串替换冒号，并"
"在 @var{left} 字符串右侧填充空格，这样，如果字符串打印在彼此下方，结果中的 @var{sep} 字符串（以及后面的 @var{right} 字符串）都会对齐。 所有不带冒号的字符串都保持不变，所有带空 @var{right} 字符串的字符串都"
"去掉了后面的冒号。 在这两种情况下，字符串的长度不会用来决定其他字符串的对齐方式。 @var{left} 字符串中的冒号可以用反斜线转义。 结果字符串将存储在 @var{array} 中。"

#. type: table
#: zsh.texi:32399
msgid "This implements some internals of the @t{_regex_arguments} function."
msgstr "它实现了 @t{_regex_arguments} 函数的一些内部功能。"

#. type: item
#: zsh.texi:32401
#, no-wrap
msgid "@t{zparseopts} [ @t{-D} @t{-E} @t{-F} @t{-K} @t{-M} ] [ @t{-a} @var{array} ] [ @t{-A} @var{assoc} ] [ @t{-} ] @var{spec} ..."
msgstr "@t{zparseopts} [ @t{-D} @t{-E} @t{-F} @t{-K} @t{-M} ] [ @t{-a} @var{array} ] [ @t{-A} @var{assoc} ] [ @t{-} ] @var{spec} ..."

#. type: table
#: zsh.texi:32409
msgid ""
"This builtin simplifies the parsing of options in positional parameters, i.e. the set of arguments given by @t{$*}.  Each @var{spec} describes one option and must be of the form `@var{opt}[@t{=}"
"@var{array}]'.  If an option described by @var{opt} is found in the positional parameters it is copied into the @var{array} specified with the @t{-a} option; if the optional `@t{=}@var{array}' is given, "
"it is instead copied into that array, which should be declared as a normal array and never as an associative array."
msgstr ""
"该内置函数简化了位置参数（即 @t{$*} 给出的参数集）中选项的解析。 每个 @var{spec} 描述一个选项，其形式必须是 `@var{opt}[@t{=}@var{array}]'。 如果在位置参数中找到 @var{opt} 所描述的选项，则会将其复制到 @t{-"
"a} 选项指定的 @var{array} 中；如果给出了可选项 `@t{=}@var{array}' ，则会将其复制到该数组中,这里数组应声明为普通数组，而绝不能声明为关联数组。 。"

#. type: table
#: zsh.texi:32413
msgid "Note that it is an error to give any @var{spec} without an `@t{=}@var{array}' unless one of the @t{-a} or @t{-A} options is used."
msgstr "需要注意的是，除非使用 @t{-a} 或 @t{-A} 选项之一，否则在给出任何 @var{spec} 的同时不给出 `@t{=}@var{array}' 是错误的。"

#. type: table
#: zsh.texi:32419
msgid ""
"Unless the @t{-E} option is given, parsing stops at the first string that isn't described by one of the @var{spec}s.  Even with @t{-E}, parsing always stops at a positional parameter equal to `@t{-}' or "
"`@t{-}@t{-}'. See also @t{-F}."
msgstr "除非给出 @t{-E} 选项，否则解析会在第一个没有被 @var{spec}s 描述的字符串处停止。 即使使用 @t{-E}，解析也总是在位置参数等于 `@t{-}' 或 `@t{-}@t{-}' 时停止。另请参阅 @t{-F}。"

#. type: table
#: zsh.texi:32424
msgid "The @var{opt} description must be one of the following.  Any of the special characters can appear in the option name provided it is preceded by a backslash."
msgstr "@var{opt} 说明必须是下列内容之一。 任何特殊字符都可以出现在选项名称中，但必须在前面加上反斜杠。"

#. type: var{#1}
#: zsh.texi:32427
#, no-wrap
msgid "name"
msgstr "name"

#. type: itemx
#: zsh.texi:32428
#, no-wrap
msgid "@var{name}@t{+}"
msgstr "@var{name}@t{+}"

#. type: table
#: zsh.texi:32433
msgid ""
"The @var{name} is the name of the option without the leading `@t{-}'.  To specify a GNU-style long option, one of the usual two leading `@t{-}' must be included in @var{name}; for example, a `@t{-}@t{-"
"file}' option is represented by a @var{name} of `@t{-file}'."
msgstr "@var{name}是不带前导 `@t{-}' 的选项名称。 要指定 GNU 风格的长选项，@var{name} 中必须包含两个前导 `@t{-}' 中的一个；例如， `@t{-}@t{-file}' 选项由 @var{name} 中的 `@t{-file}' 表示。"

#. type: table
#: zsh.texi:32438
msgid ""
"If a `@t{+}' appears after @var{name}, the option is appended to @var{array} each time it is found in the positional parameters; without the `@t{+}' only the @emph{last} occurrence of the option is "
"preserved."
msgstr "如果在 @var{name} 后面出现 `@t{+}' ，则每次在位置参数中找到该选项时，都会将其追加到 @var{array} 中；如果没有 `@t{+}' ，则只保留选项的 @emph{最后一欠} 出现。"

#. type: table
#: zsh.texi:32443
msgid "If one of these forms is used, the option takes no argument, so parsing stops if the next positional parameter does not also begin with `@t{-}' (unless the @t{-E} option is used)."
msgstr "如果使用了其中一种形式，则该选项不带参数，因此，如果下一个位置参数也不是以 `@t{-}' 开头，解析就会停止（除非使用了 @t{-E} 选项）。"

#. type: item
#: zsh.texi:32444
#, no-wrap
msgid "@var{name}@t{:}"
msgstr "@var{name}@t{:}"

#. type: itemx
#: zsh.texi:32445
#, no-wrap
msgid "@var{name}@t{:-}"
msgstr "@var{name}@t{:-}"

#. type: itemx
#: zsh.texi:32446
#, no-wrap
msgid "@var{name}@t{::}"
msgstr "@var{name}@t{::}"

#. type: table
#: zsh.texi:32450
msgid ""
"If one or two colons are given, the option takes an argument; with one colon, the argument is mandatory and with two colons it is optional.  The argument is appended to the @var{array} after the option "
"itself."
msgstr "如果给出一个或两个冒号，则该选项包含一个参数；如果给出一个冒号，则该参数为必选参数，如果给出两个冒号，则该参数为可选参数。 参数会追加到选项本身之后的 @var{array} 中。"

#. type: table
#: zsh.texi:32456
msgid ""
"An optional argument is put into the same array element as the option name (note that this makes empty strings as arguments indistinguishable).  A mandatory argument is added as a separate element unless "
"the `@t{:-}' form is used, in which case the argument is put into the same element."
msgstr "可选参数与选项名称放在同一个数组元素中（注意，这使得作为参数的空字符串无法区分）。 除非使用了 `@t{:-}' 形式，否则必选参数会作为一个单独的元素加入，在这种情况下，参数会被放入同一个元素。"

#. type: table
#: zsh.texi:32460
msgid "A `@t{+}' as described above may appear between the @var{name} and the first colon."
msgstr "在 @var{name} 和第一个冒号之间可能会出现上文所述的 `@t{+}' 。"

#. type: table
#: zsh.texi:32470
msgid ""
"In all cases, option-arguments must appear either immediately following the option in the same positional parameter or in the next one. Even an optional argument may appear in the next parameter, unless "
"it begins with a `@t{-}'.  There is no special handling of `@t{=}' as with GNU-style argument parsers; given the @var{spec} `@t{-foo:}', the positional parameter `@t{-}@t{-foo=bar}' is parsed as `@t{-}@t{-"
"foo}' with an argument of `@t{=bar}'."
msgstr ""
"在任何情况下，选项参数都必须紧接着选项出现在同一位置参数中，或者出现在下一个参数中。即使是可选参数，也可以出现在下一个参数中，除非它以 `@t{-}' 开头。 在 GNU 风格的参数解析器中，对 `@t{=}' 没有特殊处理；给"
"定 @var{spec} `@t{-foo:}'，位置参数 `@t{-}@t{-foo=bar}' 会被解析为参数为`@t{=bar}' 的 `@t{-}@t{-foo}' 。"

#. type: table
#: zsh.texi:32478
msgid ""
"When the names of two options that take no arguments overlap, the longest one wins, so that parsing for the @var{spec}s `@t{-foo -foobar}' (for example) is unambiguous. However, due to the aforementioned "
"handling of option-arguments, ambiguities may arise when at least one overlapping @var{spec} takes an argument, as in `@t{-foo: -foobar}'. In that case, the last matching @var{spec} wins."
msgstr ""
"当两个不带参数的选项名称重叠时，最长的选项胜出，因此对于 @var{spec}s， `@t{-foo -foobar}'（例如）的解析是明确无误的。然而，由于上述对选项参数的处理，当至少有一个重叠的 @var{spec} 包含一个参数时，可能会产生"
"歧义，例如在  `@t{-foo: -foobar}' 中。在这种情况下，最后一个匹配的 @var{spec} 将胜出。"

#. type: table
#: zsh.texi:32484
msgid ""
"The options of @t{zparseopts} itself cannot be stacked because, for example, the stack `@t{-DEK}' is indistinguishable from a @var{spec} for the GNU-style long option `@t{-}@t{-DEK}'.  The options of "
"@t{zparseopts} itself are:"
msgstr "@t{zparseopts} 的选项本身无法堆叠（stacked），因为例如，堆栈（选项组合) `@t{-DEK}' 与 GNU 风格长选项  `@t{-}@t{-DEK}' 的 @var{spec} 无法区分。 @t{zparseopts} 本身的选项有"

#. type: item
#: zsh.texi:32487
#, no-wrap
msgid "@t{-a} @var{array}"
msgstr "@t{-a} @var{array}"

#. type: table
#: zsh.texi:32490
msgid "As described above, this names the default array in which to store the recognised options."
msgstr "如上所述，它命名了存储已识别选项的默认数组。"

#. type: item
#: zsh.texi:32491
#, no-wrap
msgid "@t{-A} @var{assoc}"
msgstr "@t{-A} @var{assoc}"

#. type: table
#: zsh.texi:32495
msgid "If this is given, the options and their values are also put into an associative array with the option names as keys and the arguments (if any)  as the values."
msgstr "如果给定了这个值，选项及其值也会被放入一个关联数组中，其中选项名称为键，参数（如果有）为值。"

#. type: table
#: zsh.texi:32502
msgid ""
"If this option is given, all options found are removed from the positional parameters of the calling shell or shell function, up to but not including any not described by the @var{spec}s.  If the first "
"such parameter is `@t{-}' or `@t{-}@t{-}', it is removed as well.  This is similar to using the @t{shift} builtin."
msgstr ""
"如果给定了这个选项，所有找到的选项都会从调用 shell 或 shell 函数的位置参数中移除，直至但不包括 @var{spec}s 未描述的参数。 如果第一个参数是 `@t{-}' 或 `@t{-}@t{-}'，也会被移除。 这与使用 @t{shift} 内置函数"
"类似。"

#. type: table
#: zsh.texi:32511
msgid ""
"This changes the parsing rules to @emph{not} stop at the first string that isn't described by one of the @var{spec}s.  It can be used to test for or (if used together with @t{-D}) extract options and "
"their arguments, ignoring all other options and arguments that may be in the positional parameters.  As indicated above, parsing still stops at the first `@t{-}' or `@t{-}@t{-}' not described by a "
"@var{spec}, but it is not removed when used with @t{-D}."
msgstr ""
"这将改变解析规则，使其 @emph{不会} 终止于第一个未被 @var{spec} 描述的字符串。 它可以用来测试或（如果与 @t{-D} 一起使用）提取选项及其参数，而忽略位置参数中的所有其他选项和参数。 如上所述，解析仍会在第一个 "
"@var{spec} 未描述的 `@t{-}' 或 `@t{-}@t{-}' 处停止，但与 @t{-D} 一起使用时不会删除。"

#. type: table
#: zsh.texi:32518
msgid ""
"If this option is given, @t{zparseopts} immediately stops at the first option-like parameter not described by one of the @var{spec}s, prints an error message, and returns status 1.  Removal (@t{-D}) and "
"extraction (@t{-E}) are not performed, and option arrays are not updated.  This provides basic validation for the given options."
msgstr ""
"如果给定了该选项，@t{zparseopts} 会在第一个 @var{spec}s 未描述的类选项参数处立即停止，打印错误信息并返回状态 1。 不执行移除（@t{-D}）和提取（@t{-E}）操作，也不更新选项数组。 这将对给定的选项进行基本验证。"

#. type: table
#: zsh.texi:32523
msgid ""
"Note that the appearance in the positional parameters of an option without its required argument always aborts parsing and returns an error as described above regardless of whether this option is used."
msgstr "需要注意的是，无论是否使用选项，如果在位置参数中出现一个不带必要参数的选项，解析过程都会中止，并如上所述返回错误信息。"

#. type: table
#: zsh.texi:32531
msgid ""
"With this option, the arrays specified with the @t{-a} option and with the `@t{=}@var{array}' forms are kept unchanged when none of the @var{spec}s for them is used.  Otherwise the entire array is "
"replaced when any of the @var{spec}s is used.  Individual elements of associative arrays specified with the @t{-A} option are preserved by @t{-K}.  This allows assignment of default values to arrays "
"before calling @t{zparseopts}."
msgstr ""
"有了这个选项，当使用 @t{-a} 选项和 `@t{=}@var{array}' 形式的数组都没有使用 @var{spec}s 时，这些数组将保持不变。 否则，在使用任何 @var{spec}s 时，整个数组都会被替换。 使用 @t{-A} 选项指定的关联数组的单个元"
"素会被 @t{-K} 保留。 这样就可以在调用 @t{zparseopts} 之前为数组赋默认值。"

#. type: table
#: zsh.texi:32540
msgid ""
"This changes the assignment rules to implement a map among equivalent option names.  If any @var{spec} uses the `@t{=}@var{array}' form, the string @var{array} is interpreted as the name of another "
"@var{spec}, which is used to choose where to store the values.  If no other @var{spec} is found, the values are stored as usual.  This changes only the way the values are stored, not the way @t{$*} is "
"parsed, so results may be unpredictable if the `@var{name}@t{+}' specifier is used inconsistently."
msgstr ""
"这就改变了赋值规则，实现了等价选项名称之间的映射。 如果任何 @var{spec} 使用了 `@t{=}@var{array}' 形式，则字符串 @var{array} 会被解释为另一个 @var{spec} 的名称，用于选择在何处存储值。 如果找不到其他 "
"@var{spec}，值将照常存储。 这只会改变值的存储方式，而不会改变 @t{$*} 的解析方式，因此，如果 `@var{name}@t{+}' 指定符的使用不一致，结果可能无法预测。"

#. type: example
#: zsh.texi:32550
#, no-wrap
msgid ""
"set -- -a -bx -c y -cz baz -cend\n"
"zparseopts a=foo b:=bar c+:=bar\n"
msgstr ""
"set -- -a -bx -c y -cz baz -cend\n"
"zparseopts a=foo b:=bar c+:=bar\n"

#. type: table
#: zsh.texi:32554 zsh.texi:32575
msgid "will have the effect of"
msgstr "将产生以下效果"

#. type: example
#: zsh.texi:32559
#, no-wrap
msgid ""
"foo=(-a)\n"
"bar=(-b x -c y -c z)\n"
msgstr ""
"foo=(-a)\n"
"bar=(-b x -c y -c z)\n"

#. type: table
#: zsh.texi:32563
msgid "The arguments from `@t{baz}' on will not be used."
msgstr "从 `@t{baz}' 开始的参数将不会被使用。"

#. type: table
#: zsh.texi:32566
msgid "As an example for the @t{-E} option, consider:"
msgstr "以 @t{-E} 选项为例，请看"

#. type: example
#: zsh.texi:32571
#, no-wrap
msgid ""
"set -- -a x -b y -c z arg1 arg2\n"
"zparseopts -E -D b:=bar\n"
msgstr ""
"set -- -a x -b y -c z arg1 arg2\n"
"zparseopts -E -D b:=bar\n"

#. type: example
#: zsh.texi:32580
#, no-wrap
msgid ""
"bar=(-b y)\n"
"set -- -a x -c z arg1 arg2\n"
msgstr ""
"bar=(-b y)\n"
"set -- -a x -c z arg1 arg2\n"

#. type: table
#: zsh.texi:32585
msgid "I.e., the option @t{-b} and its arguments are taken from the positional parameters and put into the array @t{bar}."
msgstr "即从位置参数中提取选项 @t{-b} 及其参数，并将其放入数组 @t{bar} 中。"

#. type: table
#: zsh.texi:32588
msgid "The @t{-M} option can be used like this:"
msgstr "@t{-M} 选项可以这样使用："

#. type: example
#: zsh.texi:32593
#, no-wrap
msgid ""
"set -- -a -bx -c y -cz baz -cend\n"
"zparseopts -A bar -M a=foo b+: c:=b\n"
msgstr ""
"set -- -a -bx -c y -cz baz -cend\n"
"zparseopts -A bar -M a=foo b+: c:=b\n"

#. type: table
#: zsh.texi:32597
msgid "to have the effect of"
msgstr "要产生效果"

#. type: example
#: zsh.texi:32602
#, no-wrap
msgid ""
"foo=(-a)\n"
"bar=(-a @value{dsq} -b xyz)\n"
msgstr ""
"foo=(-a)\n"
"bar=(-a @value{dsq} -b xyz)\n"

#. type: cindex
#: zsh.texi:32613
#, no-wrap
msgid "calendar function system"
msgstr "日历函数系统"

#. type: cindex
#: zsh.texi:32614
#, no-wrap
msgid "zsh/datetime, function system based on"
msgstr "zsh/datetime，函数系统基于"

#. type: Plain text
#: zsh.texi:32625
msgid ""
"The shell is supplied with a series of functions to replace and enhance the traditional Unix @t{calendar} programme, which warns the user of imminent or future events, details of which are stored in a "
"text file (typically @t{calendar} in the user's home directory).  The version provided here includes a mechanism for alerting the user when an event is due."
msgstr ""
"shell 提供了一系列函数来替代和增强传统的 Unix @t{calendar} 程序，该程序会在即将发生或未来将发生的事件中向用户发出警告，这些事件的详细信息存储在文本文件中（通常是用户主目录中的 @t{calendar}）。 这里提供的版"
"本包含了一种在事件即将发生时提醒用户的机制。"

#. type: Plain text
#: zsh.texi:32630
msgid "In addition functions @t{age}, @t{before} and @t{after} are provided that can be used in a glob qualifier; they allow files to be selected based on their modification times."
msgstr "此外，还提供了可在 glob 限定符中使用的 @t{age}, @t{before} 和 @t{after} 函数；它们允许根据文件的修改时间来选择文件。"

#. type: Plain text
#: zsh.texi:32635
msgid "The format of the @t{calendar} file and the dates used there in and in the @t{age} function are described first, then the functions that can be called to examine and modify the @t{calendar} file."
msgstr "@t{calendar}文件的格式以及其中使用的日期和@t{age}函数中使用的日期首先进行描述，然后描述可以调用以检查和修改@t{calendar}文件的函数。"

#. type: Plain text
#: zsh.texi:32641
msgid ""
"The functions here depend on the availability of the @t{zsh/datetime} module which is usually installed with the shell.  The library function @t{strptime()} must be available; it is present on most recent "
"operating systems."
msgstr "此处的函数依赖于 @t{zsh/datetime} 模块的可用性，该模块通常与 shell 一起安装。 库函数 @t{strptime()} 必须可用；在大多数最新的操作系统中都存在。"

#. type: node
#: zsh.texi:32652 zsh.texi:33013
#, no-wrap
msgid "Calendar File and Date Formats"
msgstr "日历文件和日期格式"

#. type: node
#: zsh.texi:32652 zsh.texi:33013 zsh.texi:33496
#, no-wrap
msgid "Calendar System User Functions"
msgstr "日历系统用户函数"

#. type: section
#: zsh.texi:32654
#, no-wrap
msgid "File and Date Formats"
msgstr "文件和日期格式"

#. type: subsection
#: zsh.texi:32659
#, no-wrap
msgid "Calendar File Format"
msgstr "日历文件格式"

#. type: Plain text
#: zsh.texi:32668
msgid ""
"The calendar file is by default @t{~/calendar}.  This can be configured by the @t{calendar-file} style, see @ref{Calendar Styles}.  The basic format consists of a series of separate lines, with no "
"indentation, each including a date and time specification followed by a description of the event."
msgstr "日历文件默认为 @t{~/calendar}。 可通过 @t{calendar-file} 样式进行配置，参见 @ref{日历样式}。 日历文件的基本格式由一系列独立的行组成，没有缩进，每行包括日期和时间说明，以及事件描述。"

#. type: Plain text
#: zsh.texi:32675
msgid ""
"Various enhancements to this format are supported, based on the syntax of Emacs calendar mode.  An indented line indicates a continuation line that continues the description of the event from the "
"preceding line (note the date may not be continued in this way).  An initial ampersand (@t{&}) is ignored for compatibility."
msgstr "根据 Emacs 日历模式的语法，该格式支持多种增强功能。 缩进行表示续行，继续前一行对事件的描述（注意日期不能以这种方式续写）。 为兼容起见，开头的逗号 (@t{&}) 将被忽略。"

#. type: Plain text
#: zsh.texi:32682
msgid ""
"An indented line on which the first non-whitespace character is @t{#} is not displayed with the calendar entry, but is still scanned for information.  This can be used to hide information useful to the "
"calendar system but not to the user, such as the unique identifier used by @t{calendar_add}."
msgstr "如果缩进行的第一个非空格字符是 @t{#}，则该行不会与日历条目一起显示，但仍会被扫描以获取信息。 这可用于隐藏对日历系统有用但对用户无用的信息，例如 @t{calendar_add} 使用的唯一标识符。"

#. type: Plain text
#: zsh.texi:32686
msgid "The Emacs extension that a date with no description may refer to a number of succeeding events at different times is not supported."
msgstr "没有说明的日期可能指不同时间的多个后续事件,这样的Emacs扩展是不支持的。"

#. type: Plain text
#: zsh.texi:32692
msgid ""
"Unless the @t{done-file} style has been altered, any events which have been processed are appended to the file with the same name as the calendar file with the suffix @t{.done}, hence @t{~/calendar.done} "
"by default."
msgstr "除非更改了 @t{done-file} 样式，否则任何已处理的事件都会被追加到与日历文件同名的文件中，并带有后缀 @t{.done}，因此默认情况下是 @t{~/calendar.done}。"

#. type: Plain text
#: zsh.texi:32695
msgid "An example is shown below."
msgstr "下面是一个例子。"

#. type: subsection
#: zsh.texi:32698
#, no-wrap
msgid "Date Format"
msgstr "日期格式"

#. type: Plain text
#: zsh.texi:32711
msgid ""
"The format of the date and time is designed to allow flexibility without admitting ambiguity.  (The words `date' and `time' are both used in the documentation below; except where specifically noted this "
"implies a string that may include both a date and a time specification.)  Note that there is no localization support; month and day names must be in English and separator characters are fixed.  Matching "
"is case insensitive, and only the first three letters of the names are significant, although as a special case a form beginning \"month\" does not match \"Monday\".  Furthermore, time zones are not "
"handled; all times are assumed to be local."
msgstr ""
"日期和时间的格式设计灵活，不会产生歧义。 ( `date' 日期和  `time' 时间这两个词在下面的文档中都有使用；除非有特别说明，否则这意味着一个字符串可能同时包含日期和时间说明）。 请注意，没有本地化支持；月名和日名"
"必须为英文，且分隔符是固定的。 匹配不区分大小写，只有名称的前三个字母才有意义，但作为特例，以 \"month\" 开头的形式不会匹配  \"Monday\"。 此外，不处理时区；所有时间均假定为本地时间。"

#. type: Plain text
#: zsh.texi:32716
msgid ""
"It is recommended that, rather than exploring the intricacies of the system, users find a date format that is natural to them and stick to it.  This will avoid unexpected effects.  Various key facts "
"should be noted."
msgstr "建议用户不要去探究系统的复杂性，而是找到一种自然的日期格式并坚持使用。 这将避免意想不到的效果。 应注意各种关键事实。"

#. type: itemize
#: zsh.texi:32726
msgid ""
"In particular, note the confusion between @var{month}@t{/}@var{day}@t{/}@var{year} and @var{day}@t{/}@var{month}@t{/}@var{year} when the month is numeric; these formats should be avoided if at all "
"possible.  Many alternatives are available."
msgstr "特别要注意的是，当月份为数字时， @var{month}@t{/}@var{day}@t{/}@var{year} 和 @var{day}@t{/}@var{month}@t{/}@var{year} 之间的混淆；应尽可能避免使用这些格式。 有许多替代格式可供选择。"

#. type: itemize
#: zsh.texi:32729
msgid "The year must be given in full to avoid confusion, and only years from 1900 to 2099 inclusive are matched."
msgstr "为避免混淆，年份必须完整填写，且只匹配 1900 年至 2099 年（含 2099 年）的年份。"

#. type: Plain text
#: zsh.texi:32738
msgid ""
"The following give some obvious examples; users finding here a format they like and not subject to vagaries of style may skip the full description.  As dates and times are matched separately (even though "
"the time may be embedded in the date), any date format may be mixed with any format for the time of day provide the separators are clear (whitespace, colons, commas)."
msgstr ""
"下面给出了一些明显的例子；如果用户在这里找到了自己喜欢的格式，并且不受风格变化的影响，可以跳过完整的描述。 由于日期和时间是分开匹配的（即使时间可能包含在日期中），只要分隔符（空格、冒号、逗号）明确，任何日"
"期格式都可以与任何时间格式混合使用。"

#. type: example
#: zsh.texi:32749
#, no-wrap
msgid ""
"2007/04/03 13:13\n"
"2007/04/03:13:13\n"
"2007/04/03 1:13 pm\n"
"3rd April 2007, 13:13\n"
"April 3rd 2007 1:13 p.m.\n"
"Apr 3, 2007 13:13\n"
"Tue Apr 03 13:13:00 2007\n"
"13:13 2007/apr/3\n"
msgstr ""
"2007/04/03 13:13\n"
"2007/04/03:13:13\n"
"2007/04/03 1:13 pm\n"
"3rd April 2007, 13:13\n"
"April 3rd 2007 1:13 p.m.\n"
"Apr 3, 2007 13:13\n"
"Tue Apr 03 13:13:00 2007\n"
"13:13 2007/apr/3\n"

#. type: Plain text
#: zsh.texi:32753
msgid "More detailed rules follow."
msgstr "更详细的规则如下。"

#. type: Plain text
#: zsh.texi:32758
msgid ""
"Times are parsed and extracted before dates.  They must use colons to separate hours and minutes, though a dot is allowed before seconds if they are present.  This limits time formats to the following:"
msgstr "时间在日期之前进行解析和提取。 它们必须使用冒号来分隔小时和分钟，如果有秒，则允许在秒前加点。 这就将时间格式限制为以下几种："

#. type: itemize
#: zsh.texi:32764
msgid "@var{HH}@t{:}@var{MM}[@t{:}@var{SS}[@t{.}@var{FFFFF}]] [@t{am}|@t{pm}|@t{a.m.}|@t{p.m.}]"
msgstr "@var{HH}@t{:}@var{MM}[@t{:}@var{SS}[@t{.}@var{FFFFF}]] [@t{am}|@t{pm}|@t{a.m.}|@t{p.m.}]"

#. type: itemize
#: zsh.texi:32766
msgid "@var{HH}@t{:}@var{MM}@t{.}@var{SS}[@t{.}@var{FFFFF}] [@t{am}|@t{pm}|@t{a.m.}|@t{p.m.}]"
msgstr "@var{HH}@t{:}@var{MM}@t{.}@var{SS}[@t{.}@var{FFFFF}] [@t{am}|@t{pm}|@t{a.m.}|@t{p.m.}]"

#. type: Plain text
#: zsh.texi:32776
msgid ""
"Here, square brackets indicate optional elements, possibly with alternatives.  Fractions of a second are recognised but ignored.  For absolute times (the normal format require by the @t{calendar} file and "
"the @t{age}, @t{before} and @t{after} functions) a date is mandatory but a time of day is not; the time returned is at the start of the date.  One variation is allowed: if @t{a.m.} or @t{p.m.} or one of "
"their variants is present, an hour without a minute is allowed, e.g. @t{3 p.m.}."
msgstr ""
"在这里，方括号表示可选要素，可能还有替代要素。 零点几秒是可以识别的，但会被忽略。 对于绝对时间（@t{calendar} 文件和 @t{age}、@t{before} 和 @t{after} 函数要求的正常格式），日期是必须的，但一天中的时间不是；"
"返回的时间是日期的起始时间。 允许一种变体：如果存在 @t{a.m.} 或 @t{p.m.} 或它们的变体之一，则允许使用不带分钟的小时，例如 @t{3 p.m.}。"

#. type: Plain text
#: zsh.texi:32782
msgid ""
"Time zones are not handled, though if one is matched following a time specification it will be removed to allow a surrounding date to be parsed.  This only happens if the format of the timezone is not too "
"unusual.  The following are examples of forms that are understood:"
msgstr "不处理时区，但如果在时间规范后匹配到时区，则会将其移除，以便解析周围的日期。 只有在时区格式不太特殊的情况下，才会发生这种情况。 以下是可以理解的格式示例："

#. type: example
#: zsh.texi:32789
#, no-wrap
msgid ""
"+0100\n"
"GMT\n"
"GMT-7\n"
"CET+1CDT\n"
msgstr ""
"+0100\n"
"GMT\n"
"GMT-7\n"
"CET+1CDT\n"

#. type: Plain text
#: zsh.texi:32794
msgid "Any part of the timezone that is not numeric must have exactly three capital letters in the name."
msgstr "时区名称中任何非数字部分都必须有三个大写字母。"

#. type: Plain text
#: zsh.texi:32804
msgid ""
"Dates suffer from the ambiguity between @var{DD}@t{/}@var{MM}@t{/}@var{YYYY} and @var{MM}@t{/}@var{DD}@t{/}@var{YYYY}.  It is recommended this form is avoided with purely numeric dates, but use of "
"ordinals, eg. @t{3rd/04/2007}, will resolve the ambiguity as the ordinal is always parsed as the day of the month.  Years must be four digits (and the first two must be @t{19} or @t{20}); @t{03/04/08} is "
"not recognised.  Other numbers may have leading zeroes, but they are not required.  The following are handled:"
msgstr ""
"日期在 @var{DD}@t{/}@var{MM}@t{/}@var{YYYY} 和 @var{MM}@t{/}@var{DD}@t{/}@var{YYYY} 之间存在歧义。 建议在使用纯数字日期时避免使用这种形式，但应使用序数词，例如：@t{3rd/04/2007} 可以消除歧义，因为序数词总是"
"被解析为该月的日期。 年份必须是四位数（前两位必须是 @t{19} 或 @t{20}）；@t{03/04/08} 不被识别。 其他数字可以有前导零，但不是必需的。 可处理下列情况："

#. type: itemize
#: zsh.texi:32810
msgid "@var{YYYY}@t{/}@var{MM}@t{/}@var{DD}"
msgstr "@var{YYYY}@t{/}@var{MM}@t{/}@var{DD}"

#. type: itemize
#: zsh.texi:32812
msgid "@var{YYYY}@t{-}@var{MM}@t{-}@var{DD}"
msgstr "@var{YYYY}@t{-}@var{MM}@t{-}@var{DD}"

#. type: itemize
#: zsh.texi:32814
msgid "@var{YYYY}@t{/}@var{MNM}@t{/}@var{DD}"
msgstr "@var{YYYY}@t{/}@var{MNM}@t{/}@var{DD}"

#. type: itemize
#: zsh.texi:32816
msgid "@var{YYYY}@t{-}@var{MNM}@t{-}@var{DD}"
msgstr "@var{YYYY}@t{-}@var{MNM}@t{-}@var{DD}"

#. type: itemize
#: zsh.texi:32818
msgid "@var{DD}[@t{th}|@t{st}|@t{rd}] @var{MNM}[@t{,}] [ @var{YYYY} ]"
msgstr "@var{DD}[@t{th}|@t{st}|@t{rd}] @var{MNM}[@t{,}] [ @var{YYYY} ]"

#. type: itemize
#: zsh.texi:32820
msgid "@var{MNM} @var{DD}[@t{th}|@t{st}|@t{rd}][@t{,}] [ @var{YYYY} ]"
msgstr "@var{MNM} @var{DD}[@t{th}|@t{st}|@t{rd}][@t{,}] [ @var{YYYY} ]"

#. type: itemize
#: zsh.texi:32822
msgid "@var{DD}[@t{th}|@t{st}|@t{rd}]@t{/}@var{MM}[@t{,}] @var{YYYY}"
msgstr "@var{DD}[@t{th}|@t{st}|@t{rd}]@t{/}@var{MM}[@t{,}] @var{YYYY}"

#. type: itemize
#: zsh.texi:32824
msgid "@var{DD}[@t{th}|@t{st}|@t{rd}]@t{/}@var{MM}@t{/}@var{YYYY}"
msgstr "@var{DD}[@t{th}|@t{st}|@t{rd}]@t{/}@var{MM}@t{/}@var{YYYY}"

#. type: itemize
#: zsh.texi:32826
msgid "@var{MM}@t{/}@var{DD}[@t{th}|@t{st}|@t{rd}][@t{,}] @var{YYYY}"
msgstr "@var{MM}@t{/}@var{DD}[@t{th}|@t{st}|@t{rd}][@t{,}] @var{YYYY}"

#. type: itemize
#: zsh.texi:32828
msgid "@var{MM}@t{/}@var{DD}[@t{th}|@t{st}|@t{rd}]@t{/}@var{YYYY}"
msgstr "@var{MM}@t{/}@var{DD}[@t{th}|@t{st}|@t{rd}]@t{/}@var{YYYY}"

#. type: Plain text
#: zsh.texi:32835
msgid ""
"Here, @var{MNM} is at least the first three letters of a month name, matched case-insensitively.  The remainder of the month name may appear but its contents are irrelevant, so janissary, febrile, "
"martial, apricot, maybe, junta, etc. are happily handled."
msgstr "在这里，@var{MNM} 至少是月份名称的前三个字母，并且匹配不区分大小写。 月名的其余部分可能会出现，但其内容无关紧要，因此 janissary, febrile, martial, apricot, maybe, junta 等都可以轻松处理。"

#. type: Plain text
#: zsh.texi:32842
msgid ""
"Where the year is shown as optional, the current year is assumed.  There are only two such cases, the form @t{Jun 20} or @t{14 September} (the only two commonly occurring forms, apart from a \"the\" in "
"some forms of English, which isn't currently supported).  Such dates will of course become ambiguous in the future, so should ideally be avoided."
msgstr "如果年份显示为可选项，则假定为当年。 这种情况只有两种： @t{Jun 20} 或 @t{14 September}（除了某些英语中的 \"the\"，目前还不支持 \"the\"）。 当然，这样的日期将来会变得模棱两可，因此最好避免使用。"

#. type: Plain text
#: zsh.texi:32852
msgid ""
"Times may follow dates with a colon, e.g. @t{1965/07/12:09:45}; this is in order to provide a format with no whitespace.  A comma and whitespace are allowed, e.g. @t{1965/07/12, 09:45}.  Currently the "
"order of these separators is not checked, so illogical formats such as @t{1965/07/12, : ,09:45} will also be matched.  For simplicity such variations are not shown in the list above.  Otherwise, a time is "
"only recognised as being associated with a date if there is only whitespace in between, or if the time was embedded in the date."
msgstr ""
"时间可以带冒号跟在日期后面，例如 @t{1965/07/12:09:45}；这是为了提供一种没有空格的格式。 逗号和空格是允许的，例如 @t{1965/07/12, 09:45}。 目前不检查这些分隔符的顺序，因此 @t{1965/07/12, : ,09:45} 等不合逻辑"
"的格式也会被匹配。 为简单起见，上面的列表中不显示此类变化。 否则，只有当时间与日期之间只有空白，或者时间被嵌入日期中时，时间才会被识别为与日期相关联。"

#. type: Plain text
#: zsh.texi:32865
msgid ""
"Days of the week are not normally scanned, but will be ignored if they occur at the start of the date pattern only.  However, in contexts where it is useful to specify dates relative to today, days of the "
"week with no other date specification may be given.  The day is assumed to be either today or within the past week.  Likewise, the words @t{yesterday}, @t{today} and @t{tomorrow} are handled.  All matches "
"are case-insensitive.  Hence if today is Monday, then @t{Sunday} is equivalent to @t{yesterday}, @t{Monday} is equivalent to @t{today}, but @t{Tuesday} gives a date six days ago.  This is not generally "
"useful within the calendar file.  Dates in this format may be combined with a time specification; for example @t{Tomorrow, 8 p.m.}."
msgstr ""
"通常不会扫描星期几，但如果星期几只出现在日期模式的起始位置，则会被忽略。 但是，在需要指定相对于今天的日期时，可以给出没有其他日期说明的星期几。 日期被假定为今天或过去一周内的日期。 同样， @t{yesterday}, "
"@t{today} 和 @t{tomorrow} 也会被处理。 所有匹配都不区分大小写。 因此，如果今天是星期一，那么  @t{Sunday} 相当于 @t{yesterday}，@t{Monday} 相当于 @t{today}，而 @t{Tuesday} 则给出六天前的日期。 这种格式在日"
"历文件中一般用处不大。 这种格式的日期可以与时间规范结合使用，例如 @t{Tomorrow, 8 p.m.}。"

#. type: Plain text
#: zsh.texi:32868
msgid "For example, the standard date format:"
msgstr "例如，标准日期格式："

#. type: example
#: zsh.texi:32872
#, no-wrap
msgid "Fri Aug 18 17:00:48 BST 2006\n"
msgstr "Fri Aug 18 17:00:48 BST 2006\n"

#. type: Plain text
#: zsh.texi:32877
msgid "is handled by matching @var{HH}@t{:}@var{MM}@t{:}@var{SS} and removing it together with the matched (but unused) time zone.  This leaves the following:"
msgstr "处理方法是匹配 @var{HH}@t{:}@var{MM}@t{:}@var{SS} 并将其与匹配的（但未使用的）时区一起删除。 这样就剩下以下内容："

#. type: example
#: zsh.texi:32881
#, no-wrap
msgid "Fri Aug 18 2006\n"
msgstr "Fri Aug 18 2006\n"

#. type: Plain text
#: zsh.texi:32885
msgid "@t{Fri} is ignored and the rest is matched according to the standard rules."
msgstr "@t{Fri} 将被忽略，其余内容将根据标准规则进行匹配。"

#. type: subsection
#: zsh.texi:32888
#, no-wrap
msgid "Relative Time Format"
msgstr "相关时间格式"

#. type: Plain text
#: zsh.texi:32896
msgid ""
"In certain places relative times are handled.  Here, a date is not allowed; instead a combination of various supported periods are allowed, together with an optional time.  The periods must be in order "
"from most to least significant."
msgstr "某些地方会处理相对时间。 这里不允许使用日期，而是允许使用各种支持的时段组合，以及可选的时间。 时间段必须按照从最重要到最不重要的顺序排列。"

#. type: Plain text
#: zsh.texi:32902
msgid ""
"In some cases, a more accurate calculation is possible when there is an anchor date: offsets of months or years pick the correct day, rather than being rounded, and it is possible to pick a particular day "
"in a month as `(1st Friday)', etc., as described in more detail below."
msgstr "在某些情况下，如果有一个锚定日期，就可以进行更精确的计算：月份或年份的偏移量会选择正确的日期，而不是四舍五入，也可以选择一个月中的某一天作为 `(1st Friday)' 等，下文将详细介绍。"

#. type: Plain text
#: zsh.texi:32914
msgid ""
"Anchors are available in the following cases.  If one or two times are passed to the function @t{calendar}, the start time acts an anchor for the end time when the end time is relative (even if the start "
"time is implicit).  When examining calendar files, the scheduled event being examined anchors the warning time when it is given explicitly by means of the @t{WARN} keyword; likewise, the scheduled event "
"anchors a repetition period when given by the @t{RPT} keyword, so that specifications such as @t{RPT 2 months, 3rd Thursday} are handled properly.  Finally, the @t{-R} argument to @t{calendar_scandate} "
"directly provides an anchor for relative calculations."
msgstr ""
"锚点在以下情况下可用。 如果向函数 @t{calendar} 传递了一个或两个时间，当结束时间是相对的（即使开始时间是隐含的），开始时间将作为结束时间的锚点。 在检查日历文件时，当通过 @t{WARN} 关键字明确给出警告时间时，"
"被检查的计划事件将锚定警告时间；同样，当通过 @t{RPT} 关键字给出重复周期时，计划事件将锚定重复周期，因此 @t{RPT 2 months, 3rd Thursday} 这样的规范可以得到正确处理。 最后，@t{calendar_scandate} 的 @t{-R} 参"
"数直接为相对计算提供了锚点。"

#. type: Plain text
#: zsh.texi:32917
msgid "The periods handled, with possible abbreviations are:"
msgstr "所处理的时段，可能的缩写是:"

#. type: item
#: zsh.texi:32920
#, no-wrap
msgid "Years"
msgstr "年"

#. type: table
#: zsh.texi:32923
msgid "@t{years}, @t{yrs}, @t{ys}, @t{year}, @t{yr}, @t{y}, @t{yearly}.  A year is 365.25 days unless there is an anchor."
msgstr "@t{years}, @t{yrs}, @t{ys}, @t{year}, @t{yr}, @t{y}, @t{yearly}.  一年是 365.25 天，除非有锚。"

#. type: item
#: zsh.texi:32924
#, no-wrap
msgid "Months"
msgstr "月"

#. type: table
#: zsh.texi:32929
msgid ""
"@t{months}, @t{mons}, @t{mnths}, @t{mths}, @t{month}, @t{mon}, @t{mnth}, @t{mth}, @t{monthly}.  Note that @t{m}, @t{ms}, @t{mn}, @t{mns} are ambiguous and are @emph{not} handled.  A month is a period of "
"30 days rather than a calendar month unless there is an anchor."
msgstr ""
"@t{months}, @t{mons}, @t{mnths}, @t{mths}, @t{month}, @t{mon}, @t{mnth}, @t{mth}, @t{monthly}。 请注意，@t{m}、@t{ms}、@t{mn}、@t{mns} 是模棱两可的，@emph{不}会被处理。 除非有锚点，否则 \"月 \"指的是 30 "
"天，而不是日历月。"

#. type: item
#: zsh.texi:32930
#, no-wrap
msgid "Weeks"
msgstr "星期"

#. type: table
#: zsh.texi:32932
msgid "@t{weeks}, @t{wks}, @t{ws}, @t{week}, @t{wk}, @t{w}, @t{weekly}"
msgstr "@t{weeks}, @t{wks}, @t{ws}, @t{week}, @t{wk}, @t{w}, @t{weekly}"

#. type: item
#: zsh.texi:32933
#, no-wrap
msgid "Days"
msgstr "日"

#. type: table
#: zsh.texi:32935
msgid "@t{days}, @t{dys}, @t{ds}, @t{day}, @t{dy}, @t{d}, @t{daily}"
msgstr "@t{days}, @t{dys}, @t{ds}, @t{day}, @t{dy}, @t{d}, @t{daily}"

#. type: item
#: zsh.texi:32936
#, no-wrap
msgid "Hours"
msgstr "时"

#. type: table
#: zsh.texi:32938
msgid "@t{hours}, @t{hrs}, @t{hs}, @t{hour}, @t{hr}, @t{h}, @t{hourly}"
msgstr "@t{hours}, @t{hrs}, @t{hs}, @t{hour}, @t{hr}, @t{h}, @t{hourly}"

#. type: item
#: zsh.texi:32939
#, no-wrap
msgid "Minutes"
msgstr "分"

#. type: table
#: zsh.texi:32942
msgid "@t{minutes}, @t{mins}, @t{minute}, @t{min}, but @emph{not} @t{m}, @t{ms}, @t{mn} or @t{mns}"
msgstr "@t{minutes}, @t{mins}, @t{minute}, @t{min}, but @emph{not} @t{m}, @t{ms}, @t{mn} or @t{mns}"

#. type: item
#: zsh.texi:32943
#, no-wrap
msgid "Seconds"
msgstr "秒"

#. type: table
#: zsh.texi:32945
msgid "@t{seconds}, @t{secs}, @t{ss}, @t{second}, @t{sec}, @t{s}"
msgstr "@t{seconds}, @t{secs}, @t{ss}, @t{second}, @t{sec}, @t{s}"

#. type: Plain text
#: zsh.texi:32951
msgid "Spaces between the numbers are optional, but are required between items, although a comma may be used (with or without spaces)."
msgstr "数字之间的空格是可选的，但项目之间需要空格，不过也可以使用逗号（带或不带空格）。"

#. type: Plain text
#: zsh.texi:32958
msgid ""
"The forms @t{yearly} to @t{hourly} allow the number to be omitted; it is assumed to be 1.  For example, @t{1 d} and @t{daily} are equivalent.  Note that using those forms with plurals is confusing; @t{2 "
"yearly} is the same as @t{2 years}, @emph{not} twice yearly, so it is recommended they only be used without numbers."
msgstr ""
"从 @t{yearly} 到 @t{hourly} 的形式允许省略数字；数字被假定为 1。 例如，@t{1 d} 和 @t{daily} 是等价的。 需要注意的是，将这些形式与复数一起使用会造成混淆；@t{2 yearly} 与 @t{2 years} 一样， @emph{不是} 每年"
"两次，因此建议只使用不带数字的形式。"

#. type: Plain text
#: zsh.texi:32971
msgid ""
"When an anchor time is present, there is an extension to handle regular events in the form of the @var{n}th @var{some}day of the month.  Such a specification must occur immediately after any year and "
"month specification, but before any time of day, and must be in the form @var{n}(@t{th}|@t{st}|@t{rd}) @var{day}, for example @t{1st Tuesday} or @t{3rd Monday}.  As in other places, days are matched case "
"insensitively, must be in English, and only the first three letters are significant except that a form beginning `month' does not match `Monday'.  No attempt is made to sanitize the resulting date; "
"attempts to squeeze too many occurrences into a month will push the day into the next month (but in the obvious fashion, retaining the correct day of the week)."
msgstr ""
"当存在锚点时间时，还可以扩展成第 @var{n} 个 @var{some}day 的形式处理常规事件。 这种规范必须紧跟在任何年月规范之后，但在任何日期的时间之前，并且必须以 @var{n}(@t{th}|@t{st}|@t{rd}) @var{day} 的形式出现，例"
"如 @t{1st Tuesday} 或 @t{3rd Monday}。 与在其他地方一样，日的匹配不区分大小写，必须是英文，而且只有前三个字母是重要的，以 `month' 开头的形式不匹配 `Monday'。不会对生成的日期进行净化处理；  如果在一个月内出"
"现过多的日期，则会将日期推到下一个月（但显然会保留正确的星期几）。"

#. type: Plain text
#: zsh.texi:32974
msgid "Here are some examples:"
msgstr "这里是一些示例："

#. type: example
#: zsh.texi:32981
#, no-wrap
msgid ""
"30 years 3 months 4 days 3:42:41\n"
"14 days 5 hours\n"
"Monthly, 3rd Thursday\n"
"4d,10hr\n"
msgstr ""
"30 years 3 months 4 days 3:42:41\n"
"14 days 5 hours\n"
"Monthly, 3rd Thursday\n"
"4d,10hr\n"

#. type: Plain text
#: zsh.texi:32991
msgid "Here is an example calendar file.  It uses a consistent date format, as recommended above."
msgstr "下面是一个日历文件示例。 如上文所建议，它使用了统一的日期格式。"

#. type: example
#: zsh.texi:33001
#, no-wrap
msgid ""
"Feb 1, 2006 14:30 Pointless bureaucratic meeting\n"
"Mar 27, 2006 11:00 Mutual recrimination and finger pointing\n"
"  Bring water pistol and waterproofs\n"
"Mar 31, 2006 14:00 Very serious managerial pontification\n"
"  # UID 12C7878A9A50\n"
"Apr 10, 2006 13:30 Even more pointless blame assignment exercise WARN 30 mins\n"
"May 18, 2006 16:00 Regular moaning session RPT monthly, 3rd Thursday\n"
msgstr ""
"Feb 1, 2006 14:30 Pointless bureaucratic meeting\n"
"Mar 27, 2006 11:00 Mutual recrimination and finger pointing\n"
"  Bring water pistol and waterproofs\n"
"Mar 31, 2006 14:00 Very serious managerial pontification\n"
"  # UID 12C7878A9A50\n"
"Apr 10, 2006 13:30 Even more pointless blame assignment exercise WARN 30 mins\n"
"May 18, 2006 16:00 Regular moaning session RPT monthly, 3rd Thursday\n"

#. type: Plain text
#: zsh.texi:33011
msgid ""
"The second entry has a continuation line.  The third entry has a continuation line that will not be shown when the entry is displayed, but the unique identifier will be used by the @t{calendar_add} "
"function when updating the event.  The fourth entry will produce a warning 30 minutes before the event (to allow you to equip yourself appropriately).  The fifth entry repeats after a month on the 3rd "
"Thursday, i.e. June 15, 2006, at the same time."
msgstr ""
"第二个条目有一个续行。 第三个条目有一个续行，在显示条目时不会显示，但 @t{calendar_add} 函数在更新事件时会使用该唯一标识符。 第四个条目会在事件发生前 30 分钟发出警告（以便您做好适当的准备）。 第五个条目会在"
"一个月后的第三个星期四重复出现，即 2006 年 6 月 15 日的同一时间。"

#. type: node
#: zsh.texi:33013 zsh.texi:33496 zsh.texi:33569
#, no-wrap
msgid "Calendar Styles"
msgstr "日历样式"

#. type: section
#: zsh.texi:33015
#, no-wrap
msgid "User Functions"
msgstr "用户函数"

#. type: Plain text
#: zsh.texi:33023
msgid ""
"This section describes functions that are designed to be called directly by the user.  The first part describes those functions associated with the user's calendar; the second part describes the use in "
"glob qualifiers."
msgstr "本节介绍用户可直接调用的函数。 第一部分介绍与用户日历相关的函数；第二部分介绍 glob 限定符中的使用。"

#. type: subsection
#: zsh.texi:33026
#, no-wrap
msgid "Calendar system functions"
msgstr "日历系统函数"

#. type: findex
#: zsh.texi:33031
#, no-wrap
msgid "calendar"
msgstr "calendar"

#. type: item
#: zsh.texi:33033
#, no-wrap
msgid "@t{calendar }[ @t{-abdDsv} ] [ @t{-C} @var{calfile} ] [ @t{-n} @var{num} ] [ @t{-S} @var{showprog} ]"
msgstr "@t{calendar }[ @t{-abdDsv} ] [ @t{-C} @var{calfile} ] [ @t{-n} @var{num} ] [ @t{-S} @var{showprog} ]"

#. type: itemx
#: zsh.texi:33034
#, no-wrap
msgid "@t{@ @ @ @ @ @ @ @ @ }[ [ @var{start} ] @var{end} ]"
msgstr "@t{@ @ @ @ @ @ @ @ @ }[ [ @var{start} ] @var{end} ]"

#. type: itemx
#: zsh.texi:33035
#, no-wrap
msgid "@t{calendar -r} [ @t{-abdDrsv} ] [ @t{-C} @var{calfile} ] [ @t{-n} @var{num} ] [ @t{-S} @var{showprog} ]"
msgstr "@t{calendar -r} [ @t{-abdDrsv} ] [ @t{-C} @var{calfile} ] [ @t{-n} @var{num} ] [ @t{-S} @var{showprog} ]"

#. type: itemx
#: zsh.texi:33036
#, no-wrap
msgid "@t{@ @ @ @ @ @ @ @ @ }[ @var{start} ]"
msgstr "@t{@ @ @ @ @ @ @ @ @ }[ @var{start} ]"

#. type: table
#: zsh.texi:33038
msgid "Show events in the calendar."
msgstr "显示日历中的事件。"

#. type: table
#: zsh.texi:33044
msgid ""
"With no arguments, show events from the start of today until the end of the next working day after today.  In other words, if today is Friday, Saturday, or Sunday, show up to the end of the following "
"Monday, otherwise show today and tomorrow."
msgstr "如果没有参数，则显示从今天开始到今天之后下一个工作日结束的事件。 换句话说，如果今天是周五、周六或周日，则显示到下周一结束，否则显示今天和明天。"

#. type: table
#: zsh.texi:33051
msgid ""
"If @var{end} is given, show events from the start of today up to the time and date given, which is in the format described in the previous section.  Note that if this is a date the time is assumed to be "
"midnight at the start of the date, so that effectively this shows all events before the given date."
msgstr "如果给定 @var{end}，则显示从今天开始到给定时间和日期的事件，给定时间和日期的格式如上一节所述。 需要注意的是，如果是日期，则时间假定为日期开始时的午夜，因此实际上会显示给定日期之前的所有事件。"

#. type: table
#: zsh.texi:33057
msgid ""
"@var{end} may start with a @t{+}, in which case the remainder of the specification is a relative time format as described in the previous section indicating the range of time from the start time that is "
"to be included."
msgstr "@var{end} 可以以 @t{+} 开始，在这种情况下，说明的其余部分是相对时间格式，如上一节所述，表示从开始时间算起的时间范围。"

#. type: table
#: zsh.texi:33061
msgid "If @var{start} is also given, show events starting from that time and date.  The word @t{now} can be used to indicate the current time."
msgstr "如果同时给出 @var{start}，则显示从该时间和日期开始的事件。 可以使用 @t{now} 表示当前时间。"

#. type: table
#: zsh.texi:33065
msgid "To implement an alert when events are due, include @t{calendar -s} in your @t{~/.zshrc} file."
msgstr "要在事件到期时发出警报，请在 @t{~/.zshrc} 文件中加入 @t{calendar -s}。"

#. type: table
#: zsh.texi:33074
msgid "Show all items in the calendar, regardless of the @t{start} and @t{end}."
msgstr "显示日历中的所有项目，与 @t{start} 和 @t{end} 无关。"

#. type: table
#: zsh.texi:33078
msgid "Brief: don't display continuation lines (i.e. indented lines following the line with the date/time), just the first line."
msgstr "简介：不显示续行（即日期/时间行之后的缩进行），只显示第一行。"

#. type: item
#: zsh.texi:33079
#, no-wrap
msgid "@t{-B} @var{lines}"
msgstr "@t{-B} @var{lines}"

#. type: table
#: zsh.texi:33082
msgid "Brief: display at most the first @var{lines} lines of the calendar entry.  `@t{-B 1}' is equivalent to `@t{-b}'."
msgstr "简介：最多显示日历条目的前 @var{lines} 行。`@t{-B 1}' 等同于 `@t{-b}'。"

#. type: item
#: zsh.texi:33083
#, no-wrap
msgid "@t{-C} @var{calfile}"
msgstr "@t{-C} @var{calfile}"

#. type: table
#: zsh.texi:33086
msgid "Explicitly specify a calendar file instead of the value of the @t{calendar-file} style or the default @t{~/calendar}."
msgstr "明确指定日历文件，而不是 @t{calendar-file} 样式或默认的 @t{~/calendar} 值。"

#. type: table
#: zsh.texi:33092
msgid ""
"Move any events that have passed from the calendar file to the \"done\" file, as given by the @t{done-file} style or the default which is the calendar file with @t{.done} appended.  This option is implied "
"by the @t{-s} option."
msgstr "将日历文件中的事件移至 \"已完成 \"文件，如 @t{done-file} 样式或默认值（即附加 @t{.done} 的日历文件）所示。 该选项由 @t{-s} 选项隐含。"

#. type: table
#: zsh.texi:33095
msgid "Turns off the option @t{-d}, even if the @t{-s} option is also present."
msgstr "关闭 @t{-d} 选项，即使同时存在 @t{-s} 选项。"

#. type: item
#: zsh.texi:33096
#, no-wrap
msgid "@t{-n} @var{num}, @t{-}@var{num}"
msgstr "@t{-n} @var{num}, @t{-}@var{num}"

#. type: table
#: zsh.texi:33099
msgid "Show at least @var{num} events, if present in the calendar file, regardless of the @t{start} and @t{end}."
msgstr "无论 @t{start} 和 @t{end} 如何，至少显示 @var{num} 个事件(如果日历文件中有)。"

#. type: table
#: zsh.texi:33104
msgid "Show all the remaining options in the calendar, ignoring the given @var{end} time.  The @var{start} time is respected; any argument given is treated as a @var{start} time."
msgstr "显示日历中的所有剩余选项，忽略给定的 @var{end} 时间。 @var{start} 时间受到尊重；任何给定的参数都会被视为 @var{start} 时间。"

#. type: table
#: zsh.texi:33110
msgid ""
"Use the shell's @t{sched} command to schedule a timed event that will warn the user when an event is due.  Note that the @t{sched} command only runs if the shell is at an interactive prompt; a foreground "
"task blocks the scheduled task from running until it is finished."
msgstr "使用 shell 的 @t{sched} 命令调度定时事件，在事件到期时向用户发出警告。 请注意，@t{sched} 命令只有在 shell 处于交互式提示符时才会运行；前台任务会阻止计划任务的运行，直到它结束。"

#. type: table
#: zsh.texi:33115
msgid "The timed event usually runs the programme @t{calendar_show} to show the event, as described in @ref{Calendar Utility Functions}."
msgstr "定时事件通常会运行 @t{calendar_show} 程序来显示事件，如 @ref{日历实用函数} 所述。"

#. type: table
#: zsh.texi:33122
msgid ""
"By default, a warning of the event is shown five minutes before it is due.  The warning period can be configured by the style @t{warn-time} or for a single calendar entry by including @t{WARN} "
"@var{reltime} in the first line of the entry, where @var{reltime} is one of the usual relative time formats."
msgstr ""
"默认情况下，事件警告会在到期前五分钟显示。 警告时间可通过 @t{warn-time} 样式配置，或者对单个日历条目，也可通过在条目的第一行中加入  @t{WARN} @var{reltime} 来配置。其中 @var{reltime} 是常用的相对时间格式之"
"一。"

#. type: table
#: zsh.texi:33131
msgid ""
"A repeated event may be indicated by including @t{RPT} @var{reldate} in the first line of the entry.  After the scheduled event has been displayed it will be re-entered into the calendar file at a time "
"@var{reldate} after the existing event.  Note that this is currently the only use made of the repeat count, so that it is not possible to query the schedule for a recurrence of an event in the calendar "
"until the previous event has passed."
msgstr ""
"重复事件可通过在第一行中加入 @t{RPT} @var{reldate} 来表示。 计划事件显示后，将在现有事件之后的 @var{reldate} 时间重新进入日历文件。 请注意，这是目前重复计数的唯一用途，因此在前一个事件过去之前，无法查询日"
"历中事件的重复发生时间表。"

#. type: table
#: zsh.texi:33146
msgid ""
"If @t{RPT} is used, it is also possible to specify that certain recurrences of an event are rescheduled or cancelled.  This is done with the @t{OCCURRENCE} keyword, followed by whitespace and the date and "
"time of the occurrence in the regular sequence, followed by whitespace and either the date and time of the rescheduled event or the exact string @t{CANCELLED}.  In this case the date and time must be in "
"exactly the \"date with local time\" format used by the @t{text/calendar} MIME type (RFC 2445), @var{<YYYY><MM><DD>}@t{T}@var{<hh><mm><ss>} (note the presence of the literal character @t{T}).  The first "
"word (the regular recurrence) may be something other than a proper date/time to indicate that the event is additional to the normal sequence; a convention that retains the formatting appearance is "
"@t{XXXXXXXXTXXXXXX}."
msgstr ""
"如果使用 @t{RPT}，还可以指定某些事件的特定重复发生是否重新安排或取消。使用 @t{OCCURRENCE} 关键字完成此，后跟空格和事件在常规序列中的日期和时间，然后是空格，接着是重新安排的事件的日期和时间，或者精确字符串 "
"@t{CANCELLED}。在这种情况下，日期和时间必须完全符合 @t{text/calendar} MIME 类型（RFC 2445）所使用的 \"带本地时间的日期\" 格式，即 @var{<YYYY><MM><DD>}@t{T}@var{<hh><mm><ss>}（注意文字 @t{T} 的存在）。第一"
"个词（正常重复发生）可以是其他内容，而不是正确的日期/时间，以表示事件是正常序列之外的额外事件；保留格式外观的约定是 @t{XXXXXXXXTXXXXXX}。"

#. type: table
#: zsh.texi:33154
msgid ""
"Furthermore, it is useful to record the next regular recurrence (as then the displayed date may be for a rescheduled event so cannot be used for calculating the regular sequence).  This is specified by "
"@t{RECURRENCE} and a time or date in the same format.  @t{calendar_add} adds such an indication when it encounters a recurring event that does not include one, based on the headline date/time."
msgstr ""
"此外，记录下一次定期重复事件也很有用（因为此时显示的日期可能是重新安排的事件，因此不能用于计算定期序列）。 这可以通过 @t{RECURRENCE} 和格式相同的时间或日期来指定。 @t{calendar_add} 在遇到不包含重复事件的重"
"复事件时，会根据标题日期/时间添加这样的指示。"

#. type: table
#: zsh.texi:33159
msgid ""
"If @t{calendar_add} is used to update occurrences the @t{UID} keyword described there should be present in both the existing entry and the added occurrence in order to identify recurring event sequences."
msgstr "如果 @t{calendar_add} 被用于更新事件，则现有条目和新增事件中都应包含 @t{UID} 关键字，以便识别重复出现的事件序列。"

#. type: example
#: zsh.texi:33169
#, no-wrap
msgid ""
"Thu May 6, 2010 11:00 Informal chat RPT 1 week\n"
"  # RECURRENCE 20100506T110000\n"
"  # OCCURRENCE 20100513T110000 20100513T120000\n"
"  # OCCURRENCE 20100520T110000 CANCELLED\n"
msgstr ""
"Thu May 6, 2010 11:00 Informal chat RPT 1 week\n"
"  # RECURRENCE 20100506T110000\n"
"  # OCCURRENCE 20100513T110000 20100513T120000\n"
"  # OCCURRENCE 20100520T110000 CANCELLED\n"

#. type: table
#: zsh.texi:33182
msgid ""
"The event that occurs at 11:00 on 13th May 2010 is rescheduled an hour later.  The event that occurs a week later is cancelled.  The occurrences are given on a continuation line starting with a @t{#} "
"character so will not usually be displayed as part of the event.  As elsewhere, no account of time zones is taken with the times. After the next event occurs the headline date/time will be `@t{Thu May 13, "
"2010 12:00}' while the @t{RECURRENCE} date/time will be `@t{20100513T110000}' (note that cancelled and moved events are not taken account of in the @t{RECURRENCE}, which records what the next regular "
"recurrence is, but they are accounted for in the headline date/time)."
msgstr ""
"2010年5月13 日 11:00 的活动改期到一小时后。 一周后发生的事件被取消。 事件发生在以 @t{#} 字符开头的续行中，因此通常不会作为事件的一部分显示。 和其他地方一样，时间不考虑时区。下一个事件发生后，头条(headline)"
"日期/时间将是 `@t{Thu May 13, 2010 12:00}' ，而 @t{RECURRENCE} 日期/时间将是 `@t{20100513T110000}' （请注意，@t{RECURRENCE} 记录的是下一个常规重复事件的时间，而取消和移动的事件不在其中，但它们会在头条日期/"
"时间中显示）。"

#. type: table
#: zsh.texi:33188
msgid ""
"It is safe to run @t{calendar -s} to reschedule an existing event (if the calendar file has changed, for example), and also to have it running in multiples instances of the shell since the calendar file "
"is locked when in use."
msgstr "运行 @t{calendar -s} 来重新安排现有事件是安全的（例如，如果日历文件已更改），而且还可以在 shell 的多个实例中运行，因为日历文件在使用时是锁定的。"

#. type: table
#: zsh.texi:33192
msgid "By default, expired events are moved to the \"done\" file; see the @t{-d} option.  Use @t{-D} to prevent this."
msgstr "默认情况下，过期事件会被移至 \"已完成 \"文件；请参阅 @t{-d} 选项。 使用 @t{-D} 可以避免这种情况。"

#. type: item
#: zsh.texi:33193
#, no-wrap
msgid "@t{-S} @var{showprog}"
msgstr "@t{-S} @var{showprog}"

#. type: table
#: zsh.texi:33196
msgid "Explicitly specify a programme to be used for showing events instead of the value of the @t{show-prog} style or the default @t{calendar_show}."
msgstr "明确指定用于显示事件的程序，而不是 @t{show-prog} 样式的值或默认的 @t{calendar_show}。"

#. type: table
#: zsh.texi:33201
msgid "Verbose: show more information about stages of processing.  This is useful for confirming that the function has successfully parsed the dates in the calendar file."
msgstr "Verbose：显示更多处理阶段的信息。 这有助于确认函数已成功解析日历文件中的日期。"

#. type: findex
#: zsh.texi:33204
#, no-wrap
msgid "calendar_add"
msgstr "calendar_add"

#. type: item
#: zsh.texi:33205
#, no-wrap
msgid "@t{calendar_add} [ @t{-BL} ] @var{event} ..."
msgstr "@t{calendar_add} [ @t{-BL} ] @var{event} ..."

#. type: table
#: zsh.texi:33213
msgid ""
"Adds a single event to the calendar in the appropriate location.  The event can contain multiple lines, as described in @ref{Calendar File and Date Formats}.  Using this function ensures that the calendar "
"file is sorted in date and time order.  It also makes special arrangements for locking the file while it is altered.  The old calendar is left in a file with the suffix @t{.old}."
msgstr ""
"在日历的适当位置添加一个事件。 如 @ref{日历文件和日期格式}所述，事件可以包含多行。 使用此函数可确保日历文件按日期和时间顺序排序。 在修改文件时，它还会为锁定文件做出特殊安排。 旧版日历将保留在后缀为 @t{."
"old} 的文件中。"

#. type: table
#: zsh.texi:33220
msgid ""
"The option @t{-B} indicates that backing up the calendar file will be handled by the caller and should not be performed by @t{calendar_add}.  The option @t{-L} indicates that @t{calendar_add} does not "
"need to lock the calendar file as it is already locked.  These options will not usually be needed by users."
msgstr "选项 @t{-B} 表示备份日历文件的工作将由调用者负责，而不应由 @t{calendar_add} 执行。 选项 @t{-L} 表示 @t{calendar_add} 无需锁定日历文件，因为它已经被锁定。 用户通常不需要这些选项。"

#. type: table
#: zsh.texi:33225
msgid "If the style @t{reformat-date} is true, the date and time of the new entry will be rewritten into the standard date format: see the descriptions of this style and the style @t{date-format}."
msgstr "如果样式 @t{reformat-date} 为 true，新条目中的日期和时间将被改写为标准日期格式：请参阅该样式和样式 @t{date-format} 的说明。"

#. type: table
#: zsh.texi:33234
msgid ""
"The function can use a unique identifier stored with each event to ensure that updates to existing events are treated correctly.  The entry should contain the word @t{UID}, followed by whitespace, "
"followed by a word consisting entirely of hexadecimal digits of arbitrary length (all digits are significant, including leading zeroes).  As the UID is not directly useful to the user, it is convenient to "
"hide it on an indented continuation line starting with a @t{#}, for example:"
msgstr ""
"函数可使用与每个事件一起存储的唯一标识符，以确保正确处理对现有事件的更新。 条目应包含 @t{UID} 字样，后面是空白，然后是一个完全由任意长度的十六进制数字组成的字样（所有数字都有意义，包括前导零）。 由于 UID "
"对用户没有直接用处，因此可以将其隐藏在以 @t{#} 开头的缩进续行中,例如："

#. type: example
#: zsh.texi:33239
#, no-wrap
msgid ""
"Aug 31, 2007 09:30  Celebrate the end of the holidays\n"
"  # UID 045B78A0\n"
msgstr ""
"Aug 31, 2007 09:30  Celebrate the end of the holidays\n"
"  # UID 045B78A0\n"

#. type: table
#: zsh.texi:33243
msgid "The second line will not be shown by the @t{calendar} function."
msgstr "@t{calendar} 函数不会显示第二行。"

#. type: table
#: zsh.texi:33250
msgid ""
"It is possible to specify the @t{RPT} keyword followed by @t{CANCELLED} instead of a relative time.  This causes any matched event or series of events to be cancelled (the original event does not have to "
"be marked as recurring in order to be cancelled by this method).  A @t{UID} is required in order to match an existing event in the calendar."
msgstr "可以指定 @t{RPT} 关键字，然后用 @t{CANCELLED} 代替相对时间。 这将导致任何匹配的事件或系列事件被取消（使用此方法取消事件时，原始事件不必被标记为重复发生）。 要匹配日历中的现有事件，必须有 @t{UID}。"

#. type: table
#: zsh.texi:33263
msgid ""
"@t{calendar_add} will attempt to manage recurrences and occurrences of repeating events as described for event scheduling by @t{calendar -s} above.  To reschedule or cancel a single event @t{calendar_add} "
"should be called with an entry that includes the correct @t{UID} but does @emph{not} include the @t{RPT} keyword as this is taken to mean the entry applies to a series of repeating events and hence "
"replaces all existing information.  Each rescheduled or cancelled occurrence must have an @t{OCCURRENCE} keyword in the entry passed to @t{calendar_add} which will be merged into the calendar file.  Any "
"existing reference to the occurrence is replaced.  An occurrence that does not refer to a valid existing event is added as a one-off occurrence to the same calendar entry."
msgstr ""
"@t{calendar_add} 将尝试管理重复事件的发生和重现，就像上文 @t{calendar -s} 所描述的事件调度一样。 要重新安排或取消单个事件，@t{calendar_add} 应调用包含正确 @t{UID} 的条目，但 @emph{不能} 包含 @t{RPT} 关键"
"字，因为这意味着该条目适用于一系列重复事件，因此会取代所有现有信息。 每个重新安排或取消的事件都必须在传给 @t{calendar_add} 的条目中包含 @t{OCCURRENCE} 关键字，并将其合并到日历文件中。 任何对该事件的现有引"
"用都会被替换。 未引用有效事件的事件发生记录将作为一次性事件发生记录添加到同一日历条目中。"

#. type: t{#1}
#: zsh.texi:33264 zsh.texi:33265
#, no-wrap
msgid "calendar_edit"
msgstr "calendar_edit"

#. type: table
#: zsh.texi:33270
msgid ""
"This calls the user's editor to edit the calendar file.  If there are arguments, they are taken as the editor to use (the file name is appended to the commands); otherwise, the editor is given by the "
"variable @t{VISUAL}, if set, else the variable @t{EDITOR}."
msgstr "调用用户的编辑器编辑日历文件。 如果有参数，它们将作为要使用的编辑器（文件名会附加到命令中）；否则，编辑器由变量 @t{VISUAL} 指定（如果已设置），否则由变量 @t{EDITOR} 指定。"

#. type: table
#: zsh.texi:33274
msgid "If the calendar scheduler was running, then after editing the file @t{calendar -s} is called to update it."
msgstr "如果日历调度程序正在运行，则会在编辑文件后调用 @t{calendar -s} 来更新文件。"

#. type: table
#: zsh.texi:33281
msgid ""
"This function locks out the calendar system during the edit.  Hence it should be used to edit the calendar file if there is any possibility of a calendar event occurring meanwhile.  Note this can lead to "
"another shell with calendar functions enabled hanging waiting for a lock, so it is necessary to quit the editor as soon as possible."
msgstr "在编辑过程中，该函数会锁定日历系统。 因此，在编辑日历文件时，如果同时可能发生日历事件，则应使用该函数。 请注意，这会导致另一个已启用日历功能的 shell 挂起等待锁定，因此必须尽快退出编辑器。"

#. type: findex
#: zsh.texi:33282
#, no-wrap
msgid "calendar_parse"
msgstr "calendar_parse"

#. type: item
#: zsh.texi:33283
#, no-wrap
msgid "@t{calendar_parse} @var{calendar-entry}"
msgstr "@t{calendar_parse} @var{calendar-entry}"

#. type: table
#: zsh.texi:33291
msgid ""
"This is the internal function that analyses the parts of a calendar entry, which is passed as the only argument.  The function returns status 1 if the argument could not be parsed as a calendar entry and "
"status 2 if the wrong number of arguments were passed; it also sets the parameter @t{reply} to an empty associative array.  Otherwise, it returns status 0 and sets elements of the associative array "
"@t{reply} as follows:"
msgstr ""
"这是一个内部函数，用于分析作为唯一参数传递的日历项的各个部分。 如果参数不能被解析为日历条目，函数将返回状态 1；如果传递的参数个数错误，函数将返回状态 2；它还会将参数 @t{reply} 设置为空关联数组。 否则返回状"
"态 0，并按如下方式设置关联数组 @t{reply} 中的元素："

#. type: table
#: zsh.texi:33297
msgid "The time as a string of digits in the same units as @t{$EPOCHSECONDS}"
msgstr "与 @t{$EPOCHSECONDS} 单位相同的数字时间字符串"

#. type: t{#1}
#: zsh.texi:33297
#, no-wrap
msgid "schedtime"
msgstr "schedtime"

#. type: table
#: zsh.texi:33302
msgid ""
"The regularly scheduled time.  This may differ from the actual event time @t{time} if this is a recurring event and the next occurrence has been rescheduled.  Then @t{time} gives the actual time and "
"@t{schedtime} the time of the regular recurrence before modification."
msgstr ""
"定期安排的时间。 如果这是一个重复发生的事件，且下一次事件发生的时间已重新安排，则该时间可能与实际事件时间 @t{time} 不同。 那么 @t{time} 给出的是实际时间，而 @t{schedtime} 给出的是修改前的定期重现时间。"

#. type: t{#1}
#: zsh.texi:33302
#, no-wrap
msgid "text1"
msgstr "text1"

#. type: table
#: zsh.texi:33305
msgid "The text from the line not including the date and time of the event, but including any @t{WARN} or @t{RPT} keywords and values."
msgstr "该行的文本，不包括事件的日期和时间，但包括任何 @t{WARN} 或 @t{RPT} 关键字和值。"

#. type: t{#1}
#: zsh.texi:33305
#, no-wrap
msgid "warntime"
msgstr "warntime"

#. type: table
#: zsh.texi:33311
msgid ""
"Any warning time given by the @t{WARN} keyword as a string of digits containing the time at which to warn in the same units as @t{$EPOCHSECONDS}.  (Note this is an absolute time, not the relative time "
"passed down.)  Not set no @t{WARN} keyword and value were matched."
msgstr "任何由 @t{WARN} 关键字给出的警告时间，以与 @t{$EPOCHSECONDS} 相同的单位表示，包含警告时间的数字字符串。 (注意，这是绝对时间，而不是向下传递的相对时间。 没有 @t{WARN} 关键字和值匹配，则不设置。"

#. type: t{#1}
#: zsh.texi:33311
#, no-wrap
msgid "warnstr"
msgstr "warnstr"

#. type: table
#: zsh.texi:33313
msgid "The raw string matched after the @t{WARN} keyword, else unset."
msgstr "在 @t{WARN} 关键字之后匹配的原始字符串，否则取消设置。"

#. type: t{#1}
#: zsh.texi:33313
#, no-wrap
msgid "rpttime"
msgstr "rpttime"

#. type: table
#: zsh.texi:33318
msgid ""
"Any recurrence time given by the @t{RPT} keyword as a string of digits containing the time of the recurrence in the same units as @t{$EPOCHSECONDS}.  (Note this is an absolute time.)  Not set if no "
"@t{RPT} keyword and value were matched."
msgstr "任何由 @t{RPT} 关键字给出的重复时间，是一个包含重复时间的数字字符串，单位与 @t{$EPOCHSECONDS} 相同。 (注意这是绝对时间。）如果没有 @t{RPT} 关键字和值匹配，则不设置。"

#. type: t{#1}
#: zsh.texi:33318
#, no-wrap
msgid "schedrpttime"
msgstr "schedrpttime"

#. type: table
#: zsh.texi:33323
msgid ""
"The next regularly scheduled occurrence of a recurring event before modification.  This may differ from @t{rpttime}, which is the actual time of the event that may have been rescheduled from the regular "
"time."
msgstr "在修改前，重复事件的下一次定期发生时间。 这可能与 @t{rpttime}不同，后者是事件的实际发生时间，可能已从正常时间重新安排。"

#. type: t{#1}
#: zsh.texi:33323
#, no-wrap
msgid "rptstr"
msgstr "rptstr"

#. type: table
#: zsh.texi:33325
msgid "The raw string matched after the @t{RPT} keyword, else unset."
msgstr "在 @t{RPT} 关键字之后匹配的原始字符串，否则取消设置。"

#. type: t{#1}
#: zsh.texi:33325
#, no-wrap
msgid "text2"
msgstr "text2"

#. type: table
#: zsh.texi:33328
msgid "The text from the line after removal of the date and any keywords and values."
msgstr "去掉日期、关键字和值后的文本。"

#. type: findex
#: zsh.texi:33332
#, no-wrap
msgid "calendar_showdate"
msgstr "calendar_showdate"

#. type: item
#: zsh.texi:33333
#, no-wrap
msgid "@t{calendar_showdate} [ @t{-r} ] [ @t{-f} @var{fmt} ] @var{date-spec} ..."
msgstr "@t{calendar_showdate} [ @t{-r} ] [ @t{-f} @var{fmt} ] @var{date-spec} ..."

#. type: table
#: zsh.texi:33341
msgid ""
"The given @var{date-spec} is interpreted and the corresponding date and time printed.  If the initial @var{date-spec} begins with a @t{+} or @t{-} it is treated as relative to the current time; @var{date-"
"spec}s after the first are treated as relative to the date calculated so far and a leading @t{+} is optional in that case.  This allows one to use the system as a date calculator.  For example, "
"@t{calendar_showdate '+1 month, 1st Friday'} shows the date of the first Friday of next month."
msgstr ""
"对给定的 @var{date-spec} 进行解释并打印相应的日期和时间。 如果初始的 @var{date-spec} 以 @t{+} 或 @t{-} 开头，则会被视为相对于当前时间；而第一个 @var{date-spec} 之后的 @var{date-spec}s 则被视为相对于迄今计"
"算出的日期，在这种情况下，前导 @t{+} 是可选的。 这样就可以将系统用作日期计算器。 例如，@t{calendar_showdate '+1 month, 1st Friday'} 显示的是下个月第一个星期五的日期。"

#. type: table
#: zsh.texi:33345
msgid "With the option @t{-r} nothing is printed but the value of the date and time in seconds since the epoch is stored in the parameter @t{REPLY}."
msgstr "如果使用选项 @t{-r}，则不会打印任何内容，但会将日期和时间值（以秒为单位，自纪元epoch起）保存在参数 @t{REPLY} 中。"

#. type: table
#: zsh.texi:33349
msgid "With the option @t{-f} @var{fmt} the given date/time conversion format is passed to @t{strftime}; see notes on the @t{date-format} style below."
msgstr "使用选项 @t{-f} @var{fmt} 将把指定的日期/时间转换格式传递给 @t{strftime}；请参阅下文关于 @t{date-format} 样式的说明。"

#. type: table
#: zsh.texi:33354
msgid "In order to avoid ambiguity with negative relative date specifications, options must occur in separate words; in other words, @t{-r} and @t{-f} should not be combined in the same word."
msgstr "为了避免负相对日期规范的歧义，选项必须出现在不同的词中；换句话说，@t{-r} 和 @t{-f} 不应组合在同一个词中。"

#. type: t{#1}
#: zsh.texi:33355 zsh.texi:33356
#, no-wrap
msgid "calendar_sort"
msgstr "calendar_sort"

#. type: table
#: zsh.texi:33359
msgid "Sorts the calendar file into date and time order.  The old calendar is left in a file with the suffix @t{.old}."
msgstr "将日历文件按日期和时间顺序排序。 旧的日历会保留在后缀为 @t{.old} 的文件中。"

#. type: subsection
#: zsh.texi:33364
#, no-wrap
msgid "Glob qualifiers"
msgstr "Glob 限定符"

#. type: findex
#: zsh.texi:33369 zsh.texi:33370
#, no-wrap
msgid "age"
msgstr "age"

#. type: table
#: zsh.texi:33375
msgid ""
"The function @t{age} can be autoloaded and use separately from the calendar system, although it uses the function @t{calendar_scandate} for date formatting.  It requires the @t{zsh/stat} builtin, but uses "
"only the builtin @t{zstat}."
msgstr "函数 @t{age} 可以自动加载，并与日历系统分开使用，不过它使用函数 @t{calendar_scandate} 进行日期格式化。 它需要 @t{zsh/stat} 内置命令，但只使用 @t{zstat} 内置命令。"

#. type: table
#: zsh.texi:33381
msgid ""
"@t{age} selects files having a given modification time for use as a glob qualifier.  The format of the date is the same as that understood by the calendar system, described in @ref{Calendar File and Date "
"Formats}."
msgstr "@t{age} 用于选择具有指定修改时间的文件作为 glob 限定符。 日期格式与日历系统理解的格式相同，详见 @ref{日历文件和日期格式}。"

#. type: table
#: zsh.texi:33385
msgid "The function can take one or two arguments, which can be supplied either directly as command or arguments, or separately as shell parameters."
msgstr "函数可以接受一个或两个参数，这些参数可以直接作为命令或参数提供，也可以单独作为 shell 参数提供。"

#. type: example
#: zsh.texi:33389
#, no-wrap
msgid "print *(e:age 2006/10/04 2006/10/09:)\n"
msgstr "print *(e:age 2006/10/04 2006/10/09:)\n"

#. type: table
#: zsh.texi:33395
msgid "The example above matches all files modified between the start of those dates.  The second argument may alternatively be a relative time introduced by a @t{+}:"
msgstr "以上示例匹配了在这些日期范围的起始时间之后修改过的所有文件。 第二个参数也可以是由 @t{+} 引入的相对时间："

#. type: example
#: zsh.texi:33399
#, no-wrap
msgid "print *(e:age 2006/10/04 +5d:)\n"
msgstr "print *(e:age 2006/10/04 +5d:)\n"

#. type: table
#: zsh.texi:33403
msgid "The example above is equivalent to the previous example."
msgstr "上面的例子与前面的例子是等价的。"

#. type: table
#: zsh.texi:33408
msgid "In addition to the special use of days of the week, @t{today} and @t{yesterday}, times with no date may be specified; these apply to today.  Obviously such uses become problematic around midnight."
msgstr "除了对星期几、@t{today} 和 @t{yesterday} 的特殊用法外，还可以指定不含日期的时间；这些时间适用于今天。 显然，这种使用在午夜前后会出现问题。"

#. type: example
#: zsh.texi:33412
#, no-wrap
msgid "print *(e-age 12:00 13:30-)\n"
msgstr "print *(e-age 12:00 13:30-)\n"

#. type: table
#: zsh.texi:33416
msgid "The example above shows files modified between 12:00 and 13:00 today."
msgstr "上例显示的是今天 12:00 至 13:00 之间修改的文件。"

#. type: example
#: zsh.texi:33420
#, no-wrap
msgid "print *(e:age 2006/10/04:)\n"
msgstr "print *(e:age 2006/10/04:)\n"

#. type: table
#: zsh.texi:33426
msgid "The example above matches all files modified on that date.  If the second argument is omitted it is taken to be exactly 24 hours after the first argument (even if the first argument contains a time)."
msgstr "上述示例匹配了在该日期修改的所有文件。 如果省略第二个参数，则会将其视为第一个参数之后的 24 小时（即使第一个参数包含时间）。"

#. type: example
#: zsh.texi:33430
#, no-wrap
msgid "print *(e-age 2006/10/04:10:15 2006/10/04:10:45-)\n"
msgstr "print *(e-age 2006/10/04:10:15 2006/10/04:10:45-)\n"

#. type: table
#: zsh.texi:33437
msgid ""
"The example above supplies times.  Note that whitespace within the time and date specification must be quoted to ensure @t{age} receives the correct arguments, hence the use of the additional colon to "
"separate the date and time."
msgstr "上面的示例提供了时间。 请注意，时间和日期说明中的空白必须加引号，以确保 @t{age} 接收到正确的参数，因此使用了额外的冒号来分隔日期和时间。"

#. type: example
#: zsh.texi:33443
#, no-wrap
msgid ""
"AGEREF=2006/10/04:10:15\n"
"AGEREF2=2006/10/04:10:45\n"
"print *(+age)\n"
msgstr ""
"AGEREF=2006/10/04:10:15\n"
"AGEREF2=2006/10/04:10:45\n"
"print *(+age)\n"

#. type: table
#: zsh.texi:33451
msgid ""
"This shows the same example before using another form of argument passing.  The dates and times in the parameters @t{AGEREF} and @t{AGEREF2} stay in effect until unset, but will be overridden if any "
"argument is passed as an explicit argument to age.  Any explicit argument causes both parameters to be ignored."
msgstr ""
"下面显示的是使用另一种参数传递方式之前的示例。 参数 @t{AGEREF} 和 @t{AGEREF2} 中的日期和时间在未设置前一直有效，但如果有任何参数作为显式参数传递给 age，则会被覆盖。 任何显式参数都会导致两个参数被忽略。"

#. type: table
#: zsh.texi:33456
msgid "Instead of an explicit date and time, it's possible to use the modification time of a file as the date and time for either argument by introducing the file name with a colon:"
msgstr "通过在文件名前加冒号，可以使用文件的修改时间作为任一参数的日期和时间，而不用明确的日期和时间："

#. type: example
#: zsh.texi:33460
#, no-wrap
msgid "print *(e-age :file1-)\n"
msgstr "print *(e-age :file1-)\n"

#. type: table
#: zsh.texi:33465
msgid "matches all files created on the same day (24 hours starting from midnight) as @t{file1}."
msgstr "匹配与 @t{file1} 在同一天（从午夜开始的 24 小时）创建的所有文件。"

#. type: example
#: zsh.texi:33469
#, no-wrap
msgid "print *(e-age :file1 :file2-)\n"
msgstr "print *(e-age :file1 :file2-)\n"

#. type: table
#: zsh.texi:33474
msgid "matches all files modified no earlier than @t{file1} and no later than @t{file2}; precision here is to the nearest second."
msgstr "匹配所有不早于 @t{file1}、不晚于 @t{file2}修改的文件；此处的精度为最接近的秒。"

#. type: findex
#: zsh.texi:33475 zsh.texi:33477
#, no-wrap
msgid "after"
msgstr "after"

#. type: findex
#: zsh.texi:33476 zsh.texi:33478
#, no-wrap
msgid "before"
msgstr "before"

#. type: table
#: zsh.texi:33485
msgid ""
"The functions @t{after} and @t{before} are simpler versions of @t{age} that take just one argument.  The argument is parsed similarly to an argument of @t{age}; if it is not given the variable @t{AGEREF} "
"is consulted.  As the names of the functions suggest, a file matches if its modification time is after or before the time and date specified.  If a time only is given the date is today."
msgstr ""
"函数 @t{after} 和 @t{before} 是 @t{age} 的简化版本，只接受一个参数。 对参数的解析与 @t{age} 的参数类似；如果没有给出参数，则会查询变量 @t{AGEREF}。 正如函数名称所示，如果文件的修改时间在指定的时间和日期之"
"后或之前，就会匹配该文件。 如果只给出了时间，那么日期就是今天。"

#. type: table
#: zsh.texi:33488
msgid "The two following examples are therefore equivalent:"
msgstr "因此，下面两个例子是等价的："

#. type: example
#: zsh.texi:33491
#, no-wrap
msgid ""
"print *(e-after 12:00-)\n"
"print *(e-after today:12:00-)\n"
msgstr ""
"print *(e-after 12:00-)\n"
"print *(e-after today:12:00-)\n"

#. type: node
#: zsh.texi:33496 zsh.texi:33569 zsh.texi:33688
#, no-wrap
msgid "Calendar Utility Functions"
msgstr "日历实用函数"

#. type: subsection
#: zsh.texi:33498 zsh.texi:39605 zsh.texi:41236
#, no-wrap
msgid "Styles"
msgstr "样式"

#. type: Plain text
#: zsh.texi:33505
msgid "The zsh style mechanism using the @t{zstyle} command is describe in @ref{The zsh/zutil Module}.  This is the same mechanism used in the completion system."
msgstr "@ref{zsh/zutil 模块} 中描述了使用 @t{zstyle} 命令的 zsh 样式机制。 这与补全系统中使用的机制相同。"

#. type: Plain text
#: zsh.texi:33509
msgid "The styles below are all examined in the context @t{:datetime:}@var{function}@t{:}, for example @t{:datetime:calendar:}."
msgstr "下面的样式都是在 @t{:datetime:}@var{function}@t{:} 的上下文中检查的，例如 @t{:datetime:calendar:}。"

#. type: t{#1}
#: zsh.texi:33512 zsh.texi:33513
#, no-wrap
msgid "calendar-file"
msgstr "calendar-file"

#. type: table
#: zsh.texi:33515
msgid "The location of the main calendar.  The default is @t{~/calendar}."
msgstr "主日历的位置。 默认为 @t{~/calendar}。"

#. type: t{#1}
#: zsh.texi:33516 zsh.texi:33517
#, no-wrap
msgid "date-format"
msgstr "date-format"

#. type: table
#: zsh.texi:33523
msgid ""
"A @t{strftime} format string (see strftime(3)) with the zsh extensions providing various numbers with no leading zero or space if the number is a single digit as described for the @t{%D@{}@var{string}"
"@t{@}} prompt format in @ref{Prompt Expansion}."
msgstr "一个 @t{strftime} 格式字符串（请参阅 strftime(3)），带有 zsh 扩展，提供各种数字，如果数字是个位数，则不带前导零或空格，如  @t{%D@{}@var{string}@t{@}} 提示符格式在 @ref{提示符扩展} 中所述。"

#. type: table
#: zsh.texi:33528
msgid ""
"This is used for outputting dates in @t{calendar}, both to support the @t{-v} option and when adding recurring events back to the calendar file, and in @t{calendar_showdate} as the final output format."
msgstr "用于在 @t{calendar} 中输出日期，以支持 @t{-v} 选项，并将循环事件添加回日历文件，以及在 @t{calendar_showdate} 中作为最终输出格式。"

#. type: table
#: zsh.texi:33533
msgid "If the style is not set, the default used is similar the standard system format as output by the @t{date} command (also known as `ctime format'): `@t{%a %b %d %H:%M:%S %Z %Y}'."
msgstr "如果未设置样式，则默认使用类似 @t{date} 命令输出的标准系统格式（也称为 `ctime 格式'）：`@t{%a %b %d %H:%M:%S %Z %Y}'。"

#. type: t{#1}
#: zsh.texi:33534 zsh.texi:33535
#, no-wrap
msgid "done-file"
msgstr "done-file"

#. type: table
#: zsh.texi:33540
msgid ""
"The location of the file to which events which have passed are appended.  The default is the calendar file location with the suffix @t{.done}.  The style may be set to an empty string in which case a "
"\"done\" file will not be maintained."
msgstr "追加已完成事件的文件位置。 默认情况下，日历文件的位置加上后缀 @t{.done}。 样式可以设置为空字符串，在这种情况下，将不会维护 \"已完成\" 文件。"

#. type: t{#1}
#: zsh.texi:33541 zsh.texi:33542
#, no-wrap
msgid "reformat-date"
msgstr "reformat-date"

#. type: table
#: zsh.texi:33548
msgid ""
"Boolean, used by @t{calendar_add}.  If it is true, the date and time of new entries added to the calendar will be reformatted to the format given by the style @t{date-format} or its default.  Only the "
"date and time of the event itself is reformatted; any subsidiary dates and times such as those associated with repeat and warning times are left alone."
msgstr ""
"布尔值，由 @t{calendar_add} 使用。 如果该值为 true，添加到日历中的新条目的日期和时间将按照 @t{date-format} 样式或其默认值重新格式化。 只有事件本身的日期和时间会被重新格式化，其他附属日期和时间（如与重复和"
"警告时间相关的日期和时间）将保持不变。"

#. type: t{#1}
#: zsh.texi:33549 zsh.texi:33550
#, no-wrap
msgid "show-prog"
msgstr "show-prog"

#. type: table
#: zsh.texi:33556
msgid ""
"The programme run by @t{calendar} for showing events.  It will be passed the start time and stop time of the events requested in seconds since the epoch followed by the event text.  Note that @t{calendar -"
"s} uses a start time and stop time equal to one another to indicate alerts for specific events."
msgstr ""
"由 @t{calendar} 运行的程序，用于显示事件。 它将收到所请求事件的开始时间和停止时间，单位为自纪元(epoch)起的秒数，然后是事件文本。 请注意，@t{calendar -s} 使用与开始时间和停止时间相等的别一个时间来显示特定事"
"件的警报。"

#. type: table
#: zsh.texi:33559
msgid "The default is the function @t{calendar_show}."
msgstr "默认使用函数 @t{calendar_show}。"

#. type: t{#1}
#: zsh.texi:33560 zsh.texi:33561
#, no-wrap
msgid "warn-time"
msgstr "warn-time"

#. type: table
#: zsh.texi:33565
msgid "The time before an event at which a warning will be displayed, if the first line of the event does not include the text @t{EVENT} @var{reltime}.  The default is 5 minutes."
msgstr "如果事件的第一行不包含 @t{EVENT} @var{reltime} 文本，则在事件发生前显示警告的时间。默认值为 5 分钟。"

#. type: section
#: zsh.texi:33571
#, no-wrap
msgid "Utility functions"
msgstr "实用函数"

#. type: t{#1}
#: zsh.texi:33576 zsh.texi:33577
#, no-wrap
msgid "calendar_lockfiles"
msgstr "calendar_lockfiles"

#. type: table
#: zsh.texi:33586
msgid ""
"Attempt to lock the files given in the argument.  To prevent problems with network file locking this is done in an ad hoc fashion by attempting to create a symbolic link to the file with the name "
"@var{file}@t{.lockfile}.  No other system level functions are used for locking, i.e. the file can be accessed and modified by any utility that does not use this mechanism.  In particular, the user is not "
"prevented from editing the calendar file at the same time unless @t{calendar_edit} is used."
msgstr ""
"尝试锁定参数中给出的文件。 为防止出现网络文件锁定的问题，将以临时的方式尝试创建一个名为 @var{file}@t{.lockfile} 的文件符号链接。 锁定过程中不使用其他系统级函数，也就是说，任何不使用该机制的实用程序都可以访"
"问和修改文件。 尤其是，除非使用 @t{calendar_edit}，否则不会阻止用户同时编辑日历文件。"

#. type: table
#: zsh.texi:33592
msgid ""
"Three attempts are made to lock the file before giving up.  If the module @t{zsh/zselect} is available, the times of the attempts are jittered so that multiple instances of the calling function are "
"unlikely to retry at the same time."
msgstr "在放弃之前，会尝试三次锁定文件。 如果 @t{zsh/zselect} 模块可用，尝试的时间会被抖动，这样调用函数的多个实例就不太可能同时重试。"

#. type: table
#: zsh.texi:33596
msgid "The files locked are appended to the array @t{lockfiles}, which should be local to the caller."
msgstr "锁定的文件会追加到数组 @t{lockfiles}，该数组应为调用者的本地数组。"

#. type: table
#: zsh.texi:33599
msgid "If all files were successfully locked, status zero is returned, else status one."
msgstr "如果所有文件都成功锁定，则返回状态 0，否则返回状态 1。"

#. type: table
#: zsh.texi:33603
msgid "This function may be used as a general file locking function, although this will only work if only this mechanism is used to lock files."
msgstr "该函数可用作一般的文件锁定函数，但只有在使用该机制锁定文件时才有效。"

#. type: t{#1}
#: zsh.texi:33604 zsh.texi:33605
#, no-wrap
msgid "calendar_read"
msgstr "calendar_read"

#. type: table
#: zsh.texi:33611
msgid ""
"This is a backend used by various other functions to parse the calendar file, which is passed as the only argument.  The array @t{calendar_entries} is set to the list of events in the file; no pruning is "
"done except that ampersands are removed from the start of the line.  Each entry may contain multiple lines."
msgstr "这是一个后端，用于其他各种函数解析日历文件，这是唯一的参数。 数组 @t{calendar_entries} 将被设置为文件中的事件列表；除了删除行首的逗号外，不会进行任何剪枝。 每个条目可以包含多行。"

#. type: t{#1}
#: zsh.texi:33612 zsh.texi:33613
#, no-wrap
msgid "calendar_scandate"
msgstr "calendar_scandate"

#. type: table
#: zsh.texi:33621
msgid ""
"This is a generic function to parse dates and times that may be used separately from the calendar system.  The argument is a date or time specification as described in @ref{Calendar File and Date "
"Formats}.  The parameter @t{REPLY} is set to the number of seconds since the epoch corresponding to that date or time.  By default, the date and time may occur anywhere within the given argument."
msgstr ""
"这是一个通用函数，用于解析可与日历系统分开使用的日期和时间。 参数是 @ref{ 日历文件和日期格式}中描述的日期或时间规范。 参数 @t{REPLY} 将被设置为自该日期或时间对应的纪元起的秒数。 默认情况下，日期和时间可以"
"出现在给定参数的任意位置。"

#. type: table
#: zsh.texi:33625
msgid "Returns status zero if the date and time were successfully parsed, else one."
msgstr "如果成功解析日期和时间，则返回状态 0，否则返回状态 1。"

#. type: table
#: zsh.texi:33632
msgid "The date and time are anchored to the start of the argument; they will not be matched if there is preceding text."
msgstr "日期和时间锚定在参数的开头；如果前面有文本，则不会匹配。"

#. type: table
#: zsh.texi:33636
msgid "The date and time are anchored to both the start and end of the argument; they will not be matched if the is any other text in the argument."
msgstr "日期和时间被锚定到参数的开始和结束位置；如果参数中有任何其他文本，将不会被匹配。"

#. type: table
#: zsh.texi:33639
msgid "Enable additional debugging output."
msgstr "启用额外的调试输出。"

#. type: table
#: zsh.texi:33643
msgid "Minus.  When @t{-R} @var{anchor_time} is also given the relative time is calculated backwards from @var{anchor_time}."
msgstr "减 。当 同时给出 @t{-R} @var{anchor_time} 时，相对时间将从 @var{anchor_time} 开始倒推计算。"

#. type: table
#: zsh.texi:33646
msgid "The argument passed is to be parsed as a relative time."
msgstr "传递的参数将被解析为相对时间。"

#. type: item
#: zsh.texi:33647
#, no-wrap
msgid "@t{-R} @var{anchor_time}"
msgstr "@t{-R} @var{anchor_time}"

#. type: table
#: zsh.texi:33657
msgid ""
"The argument passed is to be parsed as a relative time.  The time is relative to @var{anchor_time}, a time in seconds since the epoch, and the returned value is the absolute time corresponding to "
"advancing @var{anchor_time} by the relative time given.  This allows lengths of months to be correctly taken into account.  If the final day does not exist in the given month, the last day of the final "
"month is given.  For example, if the anchor time is during 31st January 2007 and the relative time is 1 month, the final time is the same time of day during 28th February 2007."
msgstr ""
"传入的参数将被解析为相对时间。 时间是相对于 @var{anchor_time}（以秒为单位的从纪元(epoch)开始的时间）的，返回值是将 @var{anchor_time} 提前一个相对时间后的绝对时间。 这样就能正确考虑月的长度。 如果给定月份中"
"没有最后一天，则返回最后一个月的最后一天。 例如，如果锚点时间为 2007 年 1 月 31 日，相对时间为 1 个月，则最终时间为 2007 年 2 月 28 日的同一天。"

#. type: table
#: zsh.texi:33662
msgid "In addition to setting @t{REPLY}, set @t{REPLY2} to the remainder of the argument after the date and time have been stripped.  This is empty if the option @t{-A} was given."
msgstr "除了设置 @t{REPLY} 外，还可以将 @t{REPLY2} 设置为日期和时间去除后参数的剩余部分。 如果使用了 @t{-A} 选项，则此值为空。"

#. type: table
#: zsh.texi:33667
msgid "Allow a time with no date specification.  The date is assumed to be today.  The behaviour is unspecified if the iron tongue of midnight is tolling twelve."
msgstr "允许输入没有日期说明的时间。 日期假定为今天。 如果午夜的铁舌正在鸣响，则行为是未指定的。"

#. type: t{#1}
#: zsh.texi:33670 zsh.texi:33671
#, no-wrap
msgid "calendar_show"
msgstr "calendar_show"

#. type: table
#: zsh.texi:33674
msgid "The function used by default to display events.  It accepts a start time and end time for events, both in epoch seconds, and an event description."
msgstr "默认用于显示事件的函数。 它接受事件的开始时间和结束时间（均以纪元epoch秒为单位）以及事件描述。"

#. type: table
#: zsh.texi:33679
msgid "The event is always printed to standard output.  If the command line editor is active (which will usually be the case) the command line will be redisplayed after the output."
msgstr "事件总是打印到标准输出中。 如果命令行编辑器处于活动状态（通常是这种情况），命令行将在输出后重新显示。"

#. type: table
#: zsh.texi:33684
msgid "If the parameter @t{DISPLAY} is set and the start and end times are the same (indicating a scheduled event), the function uses the command @t{xmessage} to display a window with the event details."
msgstr "如果设置了参数 @t{DISPLAY}，且开始时间和结束时间相同（表明为计划事件），则函数会使用命令 @t{xmessage} 显示包含事件详细信息的窗口。"

#. type: section
#: zsh.texi:33690
#, no-wrap
msgid "Bugs"
msgstr "错误"

#. type: Plain text
#: zsh.texi:33698
msgid ""
"As the system is based entirely on shell functions (with a little support from the @t{zsh/datetime} module) the mechanisms used are not as robust as those provided by a dedicated calendar utility.  "
"Consequently the user should not rely on the shell for vital alerts."
msgstr "由于该系统完全基于 shell 函数（@t{zsh/datetime} 模块提供了少量支持），因此所使用的机制并不像专用日历工具那样强大。 因此，用户不应依赖 shell 来获取重要警报。"

#. type: Plain text
#: zsh.texi:33701
msgid "There is no @t{calendar_delete} function."
msgstr "没有 @t{calendar_delete} 函数。"

#. type: Plain text
#: zsh.texi:33705
msgid "There is no localization support for dates and times, nor any support for the use of time zones."
msgstr "日期和时间不支持本地化，也不支持使用时区。"

#. type: Plain text
#: zsh.texi:33709
msgid "Relative periods of months and years do not take into account the variable number of days."
msgstr "月和年的相对周期没有考虑到可变的天数。"

#. type: Plain text
#: zsh.texi:33714
msgid ""
"The @t{calendar_show} function is currently hardwired to use @t{xmessage} for displaying alerts on X Window System displays.  This should be configurable and ideally integrate better with the desktop."
msgstr "@t{calendar_show} 函数目前硬连接到使用 @t{xmessage} 在 X 窗口系统显示器上显示警报。 这应该是可配置的，最好能与桌面更好地集成。"

#. type: Plain text
#: zsh.texi:33721
msgid "@t{calendar_lockfiles} hangs the shell while waiting for a lock on a file.  If called from a scheduled task, it should instead reschedule the event that caused it."
msgstr "@t{calendar_lockfiles} 会在等待锁定文件时挂起 shell。 如果从计划任务中调用，则应重新安排导致挂起的事件。"

#. type: cindex
#: zsh.texi:33725
#, no-wrap
msgid "TCP function system"
msgstr "TCP 函数系统"

#. type: cindex
#: zsh.texi:33726
#, no-wrap
msgid "ztcp, function system based on"
msgstr "ztcp, 函数系统基于"

#. type: Plain text
#: zsh.texi:33742
msgid ""
"A module @t{zsh/net/tcp} is provided to provide network I/O over TCP/IP from within the shell; see its description in @ref{Zsh Modules}.  This manual page describes a function suite based on the module.  "
"If the module is installed, the functions are usually installed at the same time, in which case they will be available for autoloading in the default function search path.  In addition to the @t{zsh/net/"
"tcp} module, the @t{zsh/zselect} module is used to implement timeouts on read operations.  For troubleshooting tips, consult the corresponding advice for the @t{zftp} functions described in @ref{Zftp "
"Function System}."
msgstr ""
"@t{zsh/net/tcp} 模块用于在 shell 中通过 TCP/IP 提供网络 I/O；请参阅 @ref{Zsh 模块} 中的描述。 本手册介绍了基于该模块的函数套件。 如果安装了该模块，函数通常也会同时安装，在这种情况下，它们会在默认函数搜索路"
"径中自动加载。 除 @t{zsh/net/tcp} 模块外，@t{zsh/zselect} 模块还用于实现读取操作的超时。 有关故障排除技巧，请参考 @ref{Zftp 函数系统} 中描述的 @t{zftp} 函数的相应建议。"

#. type: Plain text
#: zsh.texi:33752
msgid ""
"There are functions corresponding to the basic I/O operations open, close, read and send, named @t{tcp_open} etc., as well as a function @t{tcp_expect} for pattern match analysis of data read as input.  "
"The system makes it easy to receive data from and send data to multiple named sessions at once.  In addition, it can be linked with the shell's line editor in such a way that input data is automatically "
"shown at the terminal.  Other facilities available including logging, filtering and configurable output prompts."
msgstr ""
"系统提供了与基本 I/O 操作打开、关闭、读取和发送相对应的函数（名为 @t{tcp_open} 等），以及用于对作为输入读取的数据进行模式匹配分析的函数 @t{tcp_expect}。 该系统可以轻松地同时从多个命名会话接收数据并向其发送"
"数据。 此外，它还可以与 shell 的行编辑器连接，从而在终端自动显示输入数据。 其他可用设施包括日志记录、过滤和可配置的输出提示符。"

#. type: Plain text
#: zsh.texi:33758
msgid ""
"To use the system where it is available, it should be enough to `@t{autoload -U tcp_open}' and run @t{tcp_open} as documented below to start a session.  The @t{tcp_open} function will autoload the "
"remaining functions."
msgstr "要使用可用的系统，只需 `@t{autoload -U tcp_open}' 并运行 @t{tcp_open} 即可启动会话。 @t{tcp_open} 函数将自动加载其余函数。"

#. type: node
#: zsh.texi:33768 zsh.texi:34402
#, no-wrap
msgid "TCP Functions"
msgstr "TCP 函数"

#. type: node
#: zsh.texi:33768 zsh.texi:34402 zsh.texi:34617
#, no-wrap
msgid "TCP Parameters"
msgstr "TCP 参数"

#. type: section
#: zsh.texi:33770
#, no-wrap
msgid "TCP User Functions"
msgstr "TCP 用户函数"

#. type: subsection
#: zsh.texi:33775
#, no-wrap
msgid "Basic I/O"
msgstr "基本 I/O"

#. type: findex
#: zsh.texi:33780
#, no-wrap
msgid "tcp_open"
msgstr "tcp_open"

#. type: item
#: zsh.texi:33781
#, no-wrap
msgid "@t{tcp_open} [ @t{-qz} ] @var{host port} [ @var{sess} ]"
msgstr "@t{tcp_open} [ @t{-qz} ] @var{host port} [ @var{sess} ]"

#. type: itemx
#: zsh.texi:33782
#, no-wrap
msgid "@t{tcp_open} [ @t{-qz} ] [ @t{-s} @var{sess} | @t{-l} @var{sess}[@t{,}...] ] ..."
msgstr "@t{tcp_open} [ @t{-qz} ] [ @t{-s} @var{sess} | @t{-l} @var{sess}[@t{,}...] ] ..."

#. type: itemx
#: zsh.texi:33783
#, no-wrap
msgid "@t{tcp_open} [ @t{-qz} ] [ @t{-a} @var{fd} | @t{-f} @var{fd} ] [ @var{sess} ]"
msgstr "@t{tcp_open} [ @t{-qz} ] [ @t{-a} @var{fd} | @t{-f} @var{fd} ] [ @var{sess} ]"

#. type: table
#: zsh.texi:33787
msgid "Open a new session.  In the first and simplest form, open a TCP connection to host @var{host} at port @var{port}; numeric and symbolic forms are understood for both."
msgstr "打开一个新会话。 最简单的第一种形式是在端口 @var{port} 上打开与主机 @var{host} 的 TCP 连接；数字和符号形式都可以理解。"

#. type: table
#: zsh.texi:33796
msgid ""
"If @var{sess} is given, this becomes the name of the session which can be used to refer to multiple different TCP connections.  If @var{sess} is not given, the function will invent a numeric name value "
"(note this is @emph{not} the same as the file descriptor to which the session is attached).  It is recommended that session names not include `funny' characters, where funny characters are not well-"
"defined but certainly do not include alphanumerics or underscores, and certainly do include whitespace."
msgstr ""
"如果给出 @var{sess}，它将成为会话的名称，可用于指代多个不同的 TCP 连接。 如果未给出 @var{sess}，函数将生成一个数字名称值（注意这和与会话所连接的文件描述符 @emph{不} 相同）。 建议会话名称不包含 `funny' 字"
"符， funny 字符没有明确定义，但肯定不包含字母数字或下划线，而且肯定包含空白。"

#. type: table
#: zsh.texi:33808
msgid ""
"In the second case, one or more sessions to be opened are given by name.  A single session name is given after @t{-s} and a comma-separated list after @t{-l}; both options may be repeated as many times as "
"necessary.  A failure to open any session causes @t{tcp_open} to abort.  The host and port are read from the file @t{.ztcp_sessions} in the same directory as the user's zsh initialisation files, i.e. "
"usually the home directory, but @t{$ZDOTDIR} if that is set.  The file consists of lines each giving a session name and the corresponding host and port, in that order (note the session name comes first, "
"not last), separated by whitespace."
msgstr ""
"在第二种情况下，需要打开的一个或多个会话可以用名称表示。 在 @t{-s} 后给出一个会话名称，在 @t{-l} 后给出一个以逗号分隔的列表；这两个选项可根据需要重复多次。 如果无法打开任何会话，@t{tcp_open} 就会终止。 主"
"机和端口从 @t{.ztcp_sessions} 文件中读取，该文件与用户的 zsh 初始化文件位于同一目录，即通常的主目录，但如果设置了 @t{$ZDOTDIR}，也可以从 @t{$ZDOTDIR} 中读取。 该文件由几行组成，每行按顺序给出一个会话名称以"
"及相应的主机和端口（注意会话名称在前，而不是在后），中间用空格隔开。"

#. type: table
#: zsh.texi:33820
msgid ""
"The third form allows passive and fake TCP connections.  If the option @t{-a} is used, its argument is a file descriptor open for listening for connections.  No function front-end is provided to open such "
"a file descriptor, but a call to `@t{ztcp -l} @var{port}' will create one with the file descriptor stored in the parameter @t{$REPLY}.  The listening port can be closed with `@t{ztcp -c} @var{fd}'.  A "
"call to `@t{tcp_open -a} @var{fd}' will block until a remote TCP connection is made to @var{port} on the local machine.  At this point, a session is created in the usual way and is largely "
"indistinguishable from an active connection created with one of the first two forms."
msgstr ""
"第三种形式允许被动和假 TCP 连接。 如果使用选项 @t{-a}，其参数就是一个用于监听连接的文件描述符。 没有提供打开此类文件描述符的前端函数，但调用  `@t{ztcp -l} @var{port}' 将创建一个文件描述符，该文件描述符存储"
"在参数 @t{$REPLY} 中。 可以使用 `@t{ztcp -c} @var{fd}' 关闭监听端口。 调用 `@t{tcp_open -a} @var{fd}' 将被阻塞，直到本地计算机上的 @var{port} 建立了远程 TCP 连接。 此时，会话将以常规方式创建，与使用前两种"
"形式之一创建的活动连接基本没有区别。"

#. type: table
#: zsh.texi:33828
msgid ""
"If the option @t{-f} is used, its argument is a file descriptor which is used directly as if it were a TCP session.  How well the remainder of the TCP function system copes with this depends on what "
"actually underlies this file descriptor.  A regular file is likely to be unusable; a FIFO (pipe) of some sort will work better, but note that it is not a good idea for two different sessions to attempt to "
"read from the same FIFO at once."
msgstr ""
"如果使用选项 @t{-f}，它的参数就是一个文件描述符，直接使用它就像是 TCP 会话一样。 TCP 函数系统的其他部分能否很好地处理这个问题，取决于这个文件描述符的实际内容。 普通文件可能无法使用； FIFO（管道）效果会更"
"好，但要注意的是，两个不同的会话试图同时从同一个 FIFO 中读取数据并不是一个好主意。"

#. type: table
#: zsh.texi:33833
msgid "If the option @t{-q} is given with any of the three forms, @t{tcp_open} will not print informational messages, although it will in any case exit with an appropriate status."
msgstr "如果选项 @t{-q} 与三种形式中的任何一种同时给出，@t{tcp_open} 将不会打印信息，但无论如何都会以适当的状态退出。"

#. type: table
#: zsh.texi:33847
msgid ""
"If the line editor (zle) is in use, which is typically the case if the shell is interactive, @t{tcp_open} installs a handler inside zle which will check for new data at the same time as it checks for "
"keyboard input.  This is convenient as the shell consumes no CPU time while waiting; the test is performed by the operating system.  Giving the option @t{-z} to any of the forms of @t{tcp_open} prevents "
"the handler from being installed, so data must be read explicitly.  Note, however, this is not necessary for executing complete sets of send and read commands from a function, as zle is not active at this "
"point.  Generally speaking, the handler is only active when the shell is waiting for input at a command prompt or in the @t{vared} builtin.  The option has no effect if zle is not active; `@t{[[ -o "
"zle]]}' will test for this."
msgstr ""
"如果正在使用行编辑器 (zle)，也就是通常的交互式 shell，@t{tcp_open} 会在 zle 中安装一个处理程序，在检查键盘输入的同时检查是否有新数据。 这样做很方便，因为 shell 在等待时不会消耗 CPU 时间；测试由操作系统执"
"行。 如果在 @t{tcp_open} 的任何形式中添加 @t{-z} 选项，则无法安装处理程序，因此必须明确读取数据。 但要注意的是，从函数中执行整套发送和读取命令并不是必须的，因为此时zle并不处于活动状态。 一般来说，只有在 "
"shell 在命令提示符下输入或在 @t{vared} 内置命令中时，处理程序才会激活。 如果 zle 未激活，该选项将不起作用；`@t{[[ -o zle]]}' 将对此进行测试。"

#. type: table
#: zsh.texi:33853
msgid ""
"The first session to be opened becomes the current session and subsequent calls to @t{tcp_open} do not change it.  The current session is stored in the parameter @t{$TCP_SESS}; see below for more detail "
"about the parameters used by the system."
msgstr "第一个打开的会话将成为当前会话，后续调用 @t{tcp_open} 不会改变它。 当前会话存储在参数 @t{$TCP_SESS} 中；有关系统使用参数的更多详情，请参阅下文。"

#. type: table
#: zsh.texi:33857
msgid "The function @t{tcp_on_open}, if defined, is called when a session is opened.  See the description below."
msgstr "如果定义了函数 @t{tcp_on_open}，则会在会话打开时调用该函数。 请参阅下面的说明。"

#. type: findex
#: zsh.texi:33858
#, no-wrap
msgid "tcp_close"
msgstr "tcp_close"

#. type: item
#: zsh.texi:33859
#, no-wrap
msgid "@t{tcp_close} [ @t{-qn} ] [ @t{-a} | @t{-l} @var{sess}[@t{,}...] | @var{sess} ... ]"
msgstr "@t{tcp_close} [ @t{-qn} ] [ @t{-a} | @t{-l} @var{sess}[@t{,}...] | @var{sess} ... ]"

#. type: table
#: zsh.texi:33864
msgid ""
"Close the named sessions, or the current session if none is given, or all open sessions if @t{-a} is given.  The options @t{-l} and @t{-s} are both handled for consistency with @t{tcp_open}, although the "
"latter is redundant."
msgstr "关闭指定的会话，如果没有指定，则关闭当前会话，如果指定了 @t{-a}，则关闭所有打开的会话。 为了与 @t{tcp_open} 保持一致，@t{-l} 和 @t{-s} 选项都会被处理，不过后者是多余的。"

#. type: table
#: zsh.texi:33868
msgid "If the session being closed is the current one, @t{$TCP_SESS} is unset, leaving no current session, even if there are other sessions still open."
msgstr "如果关闭的会话是当前会话，@t{$TCP_SESS} 将被取消设置，即使还有其他会话仍处于打开状态，也不会留下当前会话。"

#. type: table
#: zsh.texi:33876
msgid ""
"If the session was opened with @t{tcp_open -f}, the file descriptor is closed so long as it is in the range 0 to 9 accessible directly from the command line.  If the option @t{-n} is given, no attempt "
"will be made to close file descriptors in this case.  The @t{-n} option is not used for genuine @t{ztcp} session; the file descriptors are always closed with the session."
msgstr ""
"如果会话是通过 @t{tcp_open -f} 打开的，那么只要文件描述符在命令行可直接访问的 0 至 9 范围内，就会被关闭。 如果给出 @t{-n} 选项，在这种情况下将不会尝试关闭文件描述符。 @t{-n} 选项不用于真正的 @t{ztcp} 会"
"话；文件描述符总是与会话一起关闭。"

#. type: table
#: zsh.texi:33879
msgid "If the option @t{-q} is given, no informational messages will be printed."
msgstr "如果给出选项 @t{-q}，则不会打印任何信息。"

#. type: findex
#: zsh.texi:33880
#, no-wrap
msgid "tcp_read"
msgstr "tcp_read"

#. type: item
#: zsh.texi:33882
#, no-wrap
msgid "@t{tcp_read }[ @t{-bdq} ] [ @t{-t} @var{TO} ] [ @t{-T} @var{TO} ]"
msgstr "@t{tcp_read }[ @t{-bdq} ] [ @t{-t} @var{TO} ] [ @t{-T} @var{TO} ]"

#. type: itemx
#: zsh.texi:33883
#, no-wrap
msgid "@t{@ @ @ @ @ @ @ @ @ }[ @t{-a} | @t{-u} @var{fd}[@t{,}...] | @t{-l} @var{sess}[@t{,}...] | @t{-s} @var{sess} ... ]"
msgstr "@t{@ @ @ @ @ @ @ @ @ }[ @t{-a} | @t{-u} @var{fd}[@t{,}...] | @t{-l} @var{sess}[@t{,}...] | @t{-s} @var{sess} ... ]"

#. type: table
#: zsh.texi:33891
msgid ""
"Perform a read operation on the current session, or on a list of sessions if any are given with @t{-u}, @t{-l} or @t{-s}, or all open sessions if the option @t{-a} is given.  Any of the @t{-u}, @t{-l} or "
"@t{-s} options may be repeated or mixed together.  The @t{-u} option specifies a file descriptor directly (only those managed by this system are useful), the other two specify sessions as described for "
"@t{tcp_open} above."
msgstr ""
"对当前会话执行读操作，或对会话列表执行读操作（如果使用 @t{-u}、@t{-l} 或 @t{-s})，或所有打开的会话（如果使用 @t{-a} 选项）。 任何 @t{-u}、@t{-l} 或 @t{-s} 选项都可以重复或混合使用。 @t{-u} 选项直接指定文件"
"描述符（只有本系统管理的文件描述符才有用），其他两个选项指定会话，如上文 @t{tcp_open} 所述。"

#. type: table
#: zsh.texi:33903
msgid ""
"The function checks for new data available on all the sessions listed.  Unless the @t{-b} option is given, it will not block waiting for new data.  Any one line of data from any of the available sessions "
"will be read, stored in the parameter @t{$TCP_LINE}, and displayed to standard output unless @t{$TCP_SILENT} contains a non-empty string.  When printed to standard output the string @t{$TCP_PROMPT} will "
"be shown at the start of the line; the default form for this includes the name of the session being read.  See below for more information on these parameters.  In this mode, @t{tcp_read} can be called "
"repeatedly until it returns status 2 which indicates all pending input from all specified sessions has been handled."
msgstr ""
"该函数会检查列出的所有会话是否有新数据。 除非给出 @t{-b} 选项，否则不会阻塞等待新数据的过程。 除非 @t{$TCP_SILENT} 包含一个非空字符串，否则将从任何可用会话中读取任何一行数据，并存储在参数 @t{$TCP_LINE} "
"中，然后显示到标准输出中。 打印到标准输出时，字符串 @t{$TCP_PROMPT} 将显示在行首；默认形式包括正在读取的会话名称。 有关这些参数的更多信息，请参阅下文。 在这种模式下，可以反复调用 @t{tcp_read}，直到返回状"
"态 2（表示已处理完来自所有指定会话的所有待处理输入）为止。"

#. type: table
#: zsh.texi:33908
msgid "With the option @t{-b}, equivalent to an infinite timeout, the function will block until a line is available to read from one of the specified sessions.  However, only a single line is returned."
msgstr "如果使用选项 @t{-b}（相当于无限超时），函数将阻塞，直到从指定会话中读取一行。 不过，只会返回一行。"

#. type: table
#: zsh.texi:33915
msgid ""
"The option @t{-d} indicates that all pending input should be drained.  In this case @t{tcp_read} may process multiple lines in the manner given above; only the last is stored in @t{$TCP_LINE}, but the "
"complete set is stored in the array @t{$tcp_lines}.  This is cleared at the start of each call to @t{tcp_read}."
msgstr ""
"选项 @t{-d} 表示应排空所有待处理的输入。 在这种情况下，@t{tcp_read} 可以按照上述方式处理多行数据；只有最后一行数据会保存在 @t{$TCP_LINE} 中，但整组数据集会保存在数组 @t{$tcp_lines} 中。 每次调用 "
"@t{tcp_read} 开始时，都会清空该数组。"

#. type: table
#: zsh.texi:33923
msgid ""
"The options @t{-t} and @t{-T} specify a timeout in seconds, which may be a floating point number for increased accuracy.  With @t{-t} the timeout is applied before each line read.  With @t{-T}, the "
"timeout applies to the overall operation, possibly including multiple read operations if the option @t{-d} is present; without this option, there is no distinction between @t{-t} and @t{-T}."
msgstr ""
"选项 @t{-t} 和 @t{-T} 以秒为单位指定超时时间，为提高精确度，可以使用浮点数。 使用 @t{-t}，超时将在每次读取行之前应用。 对于 @t{-T}，超时适用于整个操作，如果有 @t{-d} 选项，则可能包括多个读取操作；如果没有"
"该选项，则 @t{-t} 和 @t{-T} 没有区别。"

#. type: table
#: zsh.texi:33927
msgid "The function does not print informational messages, but if the option @t{-q} is given, no error message is printed for a non-existent session."
msgstr "该函数不打印信息，但如果给出选项 @t{-q}，则不会为不存在的会话打印错误信息。"

#. type: table
#: zsh.texi:33931
msgid "A return status of 2 indicates a timeout or no data to read.  Any other non-zero return status indicates some error condition."
msgstr "返回状态为 2 表示超时或无数据可读。 任何其他非零返回状态都表示出现错误条件。"

#. type: table
#: zsh.texi:33934
msgid "See @t{tcp_log} for how to control where data is sent by @t{tcp_read}."
msgstr "请参阅 @t{tcp_log}，了解如何控制 @t{tcp_read} 发送数据的位置。"

#. type: findex
#: zsh.texi:33935
#, no-wrap
msgid "tcp_send"
msgstr "tcp_send"

#. type: item
#: zsh.texi:33936
#, no-wrap
msgid "@t{tcp_send} [ @t{-cnq} ] [ @t{-s} @var{sess} | @t{-l} @var{sess}[@t{,}...] ] @var{data} ..."
msgstr "@t{tcp_send} [ @t{-cnq} ] [ @t{-s} @var{sess} | @t{-l} @var{sess}[@t{,}...] ] @var{data} ..."

#. type: itemx
#: zsh.texi:33937
#, no-wrap
msgid "@t{tcp_send} [ @t{-cnq} ] @t{-a} @var{data} ..."
msgstr "@t{tcp_send} [ @t{-cnq} ] @t{-a} @var{data} ..."

#. type: table
#: zsh.texi:33942
msgid ""
"Send the supplied data strings to all the specified sessions in turn.  The underlying operation differs little from a `@t{print -r}' to the session's file descriptor, although it attempts to prevent the "
"shell from dying owing to a @t{SIGPIPE} caused by an attempt to write to a defunct session."
msgstr "依次向所有指定会话发送所提供的数据字符串。 其基本操作与向会话的文件描述符发送 `@t{print -r}' 几乎没有什么区别，不过它试图防止因试图向已失效的会话写入数据而导致 @t{SIGPIPE} 引起的 shell 死机。"

#. type: table
#: zsh.texi:33948
msgid ""
"The option @t{-c} causes @t{tcp_send} to behave like @t{cat}.  It reads lines from standard input until end of input and sends them in turn to the specified session(s) exactly as if they were given as "
"@var{data} arguments to individual @t{tcp_send} commands."
msgstr "选项 @t{-c} 会使 @t{tcp_send} 的行为与 @t{cat} 类似。 它会从标准输入读取行，直到输入结束，然后依次将它们发送到指定的会话，就像将 @var{data} 作为 @t{tcp_send} 命令的参数一样。"

#. type: table
#: zsh.texi:33952
msgid "The option @t{-n} prevents @t{tcp_send} from putting a newline at the end of the data strings."
msgstr "选项 @t{-n} 可防止 @t{tcp_send} 在数据字符串末尾增加换行。"

#. type: table
#: zsh.texi:33955
msgid "The remaining options all behave as for @t{tcp_read}."
msgstr "其余选项的行为与 @t{tcp_read} 相同。"

#. type: table
#: zsh.texi:33959
msgid "The data arguments are not further processed once they have been passed to @t{tcp_send}; they are simply passed down to @t{print -r}."
msgstr "数据参数传递给 @t{tcp_send} 后不会再进一步处理，而是直接传给 @t{print -r}。"

#. type: table
#: zsh.texi:33965
msgid ""
"If the parameter @t{$TCP_OUTPUT} is a non-empty string and logging is enabled then the data sent to each session will be echoed to the log file(s) with @t{$TCP_OUTPUT} in front where appropriate, much in "
"the manner of @t{$TCP_PROMPT}."
msgstr "如果参数 @t{$TCP_OUTPUT} 是一个非空字符串，并且启用了日志记录功能，那么发送到每个会话的数据都将以 @t{$TCP_OUTPUT} 的方式回传到日志文件，并酌情在前面加上 @t{$TCP_PROMPT}。"

#. type: subsection
#: zsh.texi:33970
#, no-wrap
msgid "Session Management"
msgstr "会话管理"

#. type: findex
#: zsh.texi:33975
#, no-wrap
msgid "tcp_alias"
msgstr "tcp_alias"

#. type: item
#: zsh.texi:33976
#, no-wrap
msgid "@t{tcp_alias} [ @t{-q} ] @var{alias}@t{=}@var{sess} ..."
msgstr "@t{tcp_alias} [ @t{-q} ] @var{alias}@t{=}@var{sess} ..."

#. type: itemx
#: zsh.texi:33977
#, no-wrap
msgid "@t{tcp_alias} [ @t{-q} ] [ @var{alias} ... ]"
msgstr "@t{tcp_alias} [ @t{-q} ] [ @var{alias} ... ]"

#. type: itemx
#: zsh.texi:33978
#, no-wrap
msgid "@t{tcp_alias} @t{-d} [ @t{-q} ] @var{alias} ..."
msgstr "@t{tcp_alias} @t{-d} [ @t{-q} ] @var{alias} ..."

#. type: table
#: zsh.texi:33980
msgid "This function is not particularly well tested."
msgstr "该函数没有经过特别完善的测试。"

#. type: table
#: zsh.texi:33985
msgid "The first form creates an alias for a session name; @var{alias} can then be used to refer to the existing session @var{sess}.  As many aliases may be listed as required."
msgstr "第一种形式是为会话名称创建别名；然后可以使用 @var{alias} 来引用现有会话 @var{sess}。 可以根据需要列出任意多个别名。"

#. type: table
#: zsh.texi:33988
msgid "The second form lists any aliases specified, or all aliases if none."
msgstr "第二种形式列出指定的别名，如果没有，则列出所有别名。"

#. type: table
#: zsh.texi:33992
msgid "The third form deletes all the aliases listed.  The underlying sessions are not affected."
msgstr "第三种形式会删除列出的所有别名。 底层会话不受影响。"

#. type: table
#: zsh.texi:33996
msgid "The option @t{-q} suppresses an inconsistently chosen subset of error messages."
msgstr "选项 @t{-q} 会抑制选择不一致的错误信息子集。"

#. type: findex
#: zsh.texi:33997
#, no-wrap
msgid "tcp_log"
msgstr "tcp_log"

#. type: item
#: zsh.texi:33998
#, no-wrap
msgid "@t{tcp_log} [ @t{-asc} ] [ @t{-n} | @t{-N} ] [ @var{logfile} ]"
msgstr "@t{tcp_log} [ @t{-asc} ] [ @t{-n} | @t{-N} ] [ @var{logfile} ]"

#. type: table
#: zsh.texi:34003
msgid ""
"With an argument @var{logfile}, all future input from @t{tcp_read} will be logged to the named file.  Unless @t{-a} (append) is given, this file will first be truncated or created empty.  With no "
"arguments, show the current status of logging."
msgstr "通过参数 @var{logfile}，将来所有来自 @t{tcp_read} 的输入将被记录到指定文件中。 除非给出 @t{-a}（追加），否则该文件将首先被截断或创建为空文件。 在没有参数的情况下，显示日志记录的当前状态。"

#. type: table
#: zsh.texi:34011
msgid ""
"With the option @t{-s}, per-session logging is enabled.  Input from @t{tcp_read} is output to the file @var{logfile}@t{.}@var{sess}.  As the session is automatically discriminated by the filename, the "
"contents are raw (no @t{$TCP_PROMPT}).  The option @t{-a} applies as above.  Per-session logging and logging of all data in one file are not mutually exclusive."
msgstr ""
"使用选项 @t{-s}，可启用按会话记录日志功能。 来自 @t{tcp_read} 的输入将输出到文件 @var{logfile}@t{.}@var{sess}。 由于文件名会自动区分会话，因此文件内容是原始的（没有 @t{$TCP_PROMPT}）。 选项 @t{-a} 的应用同"
"上。 按会话记录日志和在一个文件中记录所有数据并不相互排斥。"

#. type: table
#: zsh.texi:34014
msgid "The option @t{-c} closes all logging, both complete and per-session logs."
msgstr "选项 @t{-c} 关闭所有日志记录，包括完整日志和每个会话的日志。"

#. type: table
#: zsh.texi:34019
msgid "The options @t{-n} and @t{-N} respectively turn off or restore output of data read by @t{tcp_read} to standard output; hence `@t{tcp_log -cn}' turns off all output by @t{tcp_read}."
msgstr "选项 @t{-n} 和 @t{-N} 分别关闭或恢复 @t{tcp_read} 读取的数据输出到标准输出；因此，`@t{tcp_log -cn}' 关闭 @t{tcp_read} 的所有输出。"

#. type: table
#: zsh.texi:34023
msgid "The function is purely a convenient front end to setting the parameters @t{$TCP_LOG}, @t{$TCP_LOG_SESS}, @t{$TCP_SILENT}, which are described below."
msgstr "该函数纯粹是设置参数 @t{$TCP_LOG}、@t{$TCP_LOG_SESS}、@t{$TCP_SILENT} 的便捷前端，下文将对这些参数进行说明。"

#. type: findex
#: zsh.texi:34024
#, no-wrap
msgid "tcp_rename"
msgstr "tcp_rename"

#. type: item
#: zsh.texi:34025
#, no-wrap
msgid "@t{tcp_rename} @var{old} @var{new}"
msgstr "@t{tcp_rename} @var{old} @var{new}"

#. type: table
#: zsh.texi:34027
msgid "Rename session @var{old} to session @var{new}.  The old name becomes invalid."
msgstr "将会话 @var{old} 重命名为会话 @var{new}。 旧名称将失效。"

#. type: findex
#: zsh.texi:34028
#, no-wrap
msgid "tcp_sess"
msgstr "tcp_sess"

#. type: item
#: zsh.texi:34029
#, no-wrap
msgid "@t{tcp_sess} [ @var{sess} [ @var{command} [ @var{arg} ... ] ] ]"
msgstr "@t{tcp_sess} [ @var{sess} [ @var{command} [ @var{arg} ... ] ] ]"

#. type: table
#: zsh.texi:34034
msgid ""
"With no arguments, list all the open sessions and associated file descriptors.  The current session is marked with a star.  For use in functions, direct access to the parameters @t{$tcp_by_name}, "
"@t{$tcp_by_fd} and @t{$TCP_SESS} is probably more convenient; see below."
msgstr "在没有参数的情况下，列出所有打开的会话和相关文件描述符。 当前会话用星号标记。 在函数中使用时，直接访问参数 @t{$tcp_by_name}、@t{$tcp_by_fd} 和 @t{$TCP_SESS} 可能更方便；请参阅下文。"

#. type: table
#: zsh.texi:34038
msgid "With a @var{sess} argument, set the current session to @var{sess}.  This is equivalent to changing @t{$TCP_SESS} directly."
msgstr "通过 @var{sess} 参数，将当前会话设置为 @var{sess}。 这等同于直接更改 @t{$TCP_SESS}。"

#. type: table
#: zsh.texi:34045
msgid ""
"With additional arguments, temporarily set the current session while executing `@var{command} @var{arg} ...'.  @var{command} is re-evaluated so as to expand aliases etc., but the remaining @var{arg}s are "
"passed through as that appear to @t{tcp_sess}.  The original session is restored when @t{tcp_sess} exits."
msgstr ""
"使用额外的参数，在执行 `@var{command} @var{arg} ...' 时，会临时设置会话。 @var{command} 会被重新计算，以便扩展别名等，但其余的 @var{arg}s 会以 @t{tcp_sess} 显示的形式传递。 当 @t{tcp_sess} 退出时，将恢复原"
"始会话。"

#. type: subsection
#: zsh.texi:34050
#, no-wrap
msgid "Advanced I/O"
msgstr "高级 I/O"

#. type: findex
#: zsh.texi:34055
#, no-wrap
msgid "tcp_command"
msgstr "tcp_command"

#. type: item
#: zsh.texi:34056
#, no-wrap
msgid "@t{tcp_command} @var{send-option} ... @var{send-argument} ..."
msgstr "@t{tcp_command} @var{send-option} ... @var{send-argument} ..."

#. type: table
#: zsh.texi:34062
msgid ""
"This is a convenient front-end to @t{tcp_send}.  All arguments are passed to @t{tcp_send}, then the function pauses waiting for data.  While data is arriving at least every @t{$TCP_TIMEOUT} (default 0.3) "
"seconds, data is handled and printed out according to the current settings.  Status 0 is always returned."
msgstr "这是 @t{tcp_send} 的便捷前端。 所有参数传递给 @t{tcp_send}，然后函数暂停等待数据。 当数据至少每 @t{$TCP_TIMEOUT}（默认值 0.3）秒到达时，将根据当前设置处理并打印数据。 始终返回状态 0 。"

#. type: table
#: zsh.texi:34068
msgid ""
"This is generally only useful for interactive use, to prevent the display becoming fragmented by output returned from the connection.  Within a programme or function it is generally better to handle "
"reading data by a more explicit method."
msgstr "这通常只适用于交互式使用，以防止从连接返回的输出使显示变得支离破碎。 在程序或函数中，通常最好使用更明确的方法来处理读取数据。"

#. type: findex
#: zsh.texi:34069
#, no-wrap
msgid "tcp_expect"
msgstr "tcp_expect"

#. type: item
#: zsh.texi:34071
#, no-wrap
msgid "@t{tcp_expect }[ @t{-q} ] [ @t{-p} @var{var} | @t{-P} @var{var} ] [ @t{-t} @var{TO} | @t{-T} @var{TO} ]"
msgstr "@t{tcp_expect }[ @t{-q} ] [ @t{-p} @var{var} | @t{-P} @var{var} ] [ @t{-t} @var{TO} | @t{-T} @var{TO} ]"

#. type: itemx
#: zsh.texi:34072
#, no-wrap
msgid "@t{@ @ @ @ @ @ @ @ @ @ @ }[ @t{-a} | @t{-s} @var{sess} | @t{-l} @var{sess}[@t{,}...] ] @var{pattern} ..."
msgstr "@t{@ @ @ @ @ @ @ @ @ @ @ }[ @t{-a} | @t{-s} @var{sess} | @t{-l} @var{sess}[@t{,}...] ] @var{pattern} ..."

#. type: table
#: zsh.texi:34078
msgid ""
"Wait for input matching any of the given @var{pattern}s from any of the specified sessions.  Input is ignored until an input line matches one of the given patterns; at this point status zero is returned, "
"the matching line is stored in @t{$TCP_LINE}, and the full set of lines read during the call to @t{tcp_expect} is stored in the array @t{$tcp_expect_lines}."
msgstr ""
"等待来自任何指定会话的与给定 @var{pattern}s 匹配的输入。 在输入行与给定模式之一匹配之前，输入将被忽略；此时将返回状态 0，匹配的行将存储在 @t{$TCP_LINE} 中，调用 @t{tcp_expect} 时读取的所有行将存储在数组 "
"@t{$tcp_expect_lines} 中。"

#. type: table
#: zsh.texi:34083
msgid "Sessions are specified in the same way as @t{tcp_read}: the default is to use the current session, otherwise the sessions specified by @t{-a}, @t{-s}, or @t{-l} are used."
msgstr "会话的指定方式与 @t{tcp_read} 相同：默认使用当前会话，否则使用 @t{-a}、@t{-s} 或 @t{-l} 指定的会话。"

#. type: table
#: zsh.texi:34093
msgid ""
"Each @var{pattern} is a standard zsh extended-globbing pattern; note that it needs to be quoted to avoid it being expanded immediately by filename generation.  It must match the full line, so to match a "
"substring there must be a `@t{*}' at the start and end.  The line matched against includes the @t{$TCP_PROMPT} added by @t{tcp_read}.  It is possible to include the globbing flags `@t{#b}' or `@t{#m}' in "
"the patterns to make backreferences available in the parameters @t{$MATCH}, @t{$match}, etc., as described in the base zsh documentation on pattern matching."
msgstr ""
"每个 @var{pattern} 都是一个标准的 zsh 扩展 globbing 模式；注意需要加引号，以避免在生成文件名时被立即展开。 它必须匹配整行，因此要匹配子串，必须在开头和结尾都有一个 `@t{*}' 。 匹配的行包括 @t{tcp_read} 添加"
"的 @t{$TCP_PROMPT} 。 可以在模式中包含 globbing 标志 `@t{#b}' 或 `@t{#m}' ，以便在参数 @t{$MATCH}、@t{$match} 等中提供反向引用，具体说明请参见模式匹配的基础 zsh 文档。"

#. type: table
#: zsh.texi:34101
msgid ""
"Unlike @t{tcp_read}, the default behaviour of @t{tcp_expect} is to block indefinitely until the required input is found.  This can be modified by specifying a timeout with @t{-t} or @t{-T}; these function "
"as in @t{tcp_read}, specifying a per-read or overall timeout, respectively, in seconds, as an integer or floating-point number.  As @t{tcp_read}, the function returns status 2 if a timeout occurs."
msgstr ""
"与 @t{tcp_read} 不同，@t{tcp_expect} 的默认行为是无限阻塞，直到找到所需的输入。 您可以使用 @t{-t} 或 @t{-T} 指定超时时间；它们的功能与 @t{tcp_read} 相同，分别以整数或浮点数指定每次读取或整体超时时间（以秒"
"为单位）。 与 @t{tcp_read} 一样，如果超时，函数将返回状态 2。"

#. type: table
#: zsh.texi:34110
msgid ""
"The function returns as soon as any one of the patterns given match.  If the caller needs to know which of the patterns matched, the option @t{-p} @var{var} can be used; on return, @t{$var} is set to the "
"number of the pattern using ordinary zsh indexing, i.e. the first is 1, and so on.  Note the absence of a `@t{$}' in front of @var{var}.  To avoid clashes, the parameter cannot begin with `@t{_expect}'.  "
"The index -1 is used if there is a timeout and 0 if there is no match."
msgstr ""
"只要所给模式中有任何一个匹配，函数就会返回。 如果调用者需要知道哪些模式匹配，可以使用 @t{-p} @var{var} 选项;返回时，@t{$var} 将使用普通的 zsh 索引设置为模式的编号，即第一个为 1，以此类推。 请注意 "
"@var{var} 前面没有 `@t{$}' 。 为避免冲突，参数不能以 `@t{_expect}' 开头。 如果出现超时，则使用索引-1，如果没有匹配，则使用索引 0。"

#. type: table
#: zsh.texi:34119
msgid ""
"The option @t{-P} @var{var} works similarly to @t{-p}, but instead of numerical indexes the regular arguments must begin with a prefix followed by a colon: that prefix is then used as a tag to which "
"@var{var} is set when the argument matches.  The tag @t{timeout} is used if there is a timeout and the empty string if there is no match.  Note it is acceptable for different arguments to start with the "
"same prefix if the matches do not need to be distinguished."
msgstr ""
"选项 @t{-P} @var{var} 的工作原理与 @t{-p}类似，但正则参数必须以前缀开头，后跟冒号，而不是以数字索引开头：当参数匹配时，前缀会被用作 @var{var} 的标记。 如果有超时，则使用 @t{timeout} 标记，如果没有匹配，则"
"使用空字符串。 需要注意的是，如果不需要区分不同的匹配，也可以使用以相同前缀开头的参数。"

#. type: table
#: zsh.texi:34122
msgid "The option @t{-q} is passed directly down to @t{tcp_read}."
msgstr "选项 @t{-q} 会直接传给 @t{tcp_read}。"

#. type: table
#: zsh.texi:34129
msgid ""
"As all input is done via @t{tcp_read}, all the usual rules about output of lines read apply.  One exception is that the parameter @t{$tcp_lines} will only reflect the line actually matched by "
"@t{tcp_expect}; use @t{$tcp_expect_lines} for the full set of lines read during the function call."
msgstr ""
"由于所有输入都是通过 @t{tcp_read} 完成的，因此所有关于读取行输出的常规规则都适用。 一个例外是，参数 @t{$tcp_lines} 只反映 @t{tcp_expect} 实际匹配的行；使用 @t{$tcp_expect_lines} 可以获得函数调用期间读取的"
"全部行。"

#. type: t{#1}
#: zsh.texi:34130 zsh.texi:34131
#, no-wrap
msgid "tcp_proxy"
msgstr "tcp_proxy"

#. type: table
#: zsh.texi:34136
msgid ""
"This is a simple-minded function to accept a TCP connection and execute a command with I/O redirected to the connection.  Extreme caution should be taken as there is no security whatsoever and this can "
"leave your computer open to the world.  Ideally, it should only be used behind a firewall."
msgstr "这是一个思想简单的函数，用于接受 TCP 连接并执行命令，同时将 I/O 重定向到该连接。 由于没有任何安全性可言，使用时应格外小心，因为这可能会让你的电脑向全世界敞开大门。 理想情况下，它只能在防火墙后使用。"

#. type: table
#: zsh.texi:34139
msgid "The first argument is a TCP port on which the function will listen."
msgstr "第一个参数是函数将监听的 TCP 端口。"

#. type: table
#: zsh.texi:34147
msgid ""
"The remaining arguments give a command and its arguments to execute with standard input, standard output and standard error redirected to the file descriptor on which the TCP session has been accepted.  "
"If no command is given, a new zsh is started.  This gives everyone on your network direct access to your account, which in many cases will be a bad thing."
msgstr ""
"其余参数给出了要执行的命令及其参数，并将标准输入、标准输出和标准错误重定向到接受 TCP 会话的文件描述符。 如果没有给出命令，则会启动一个新的 zsh。 这样，网络上的每个人都可以直接访问你的账户，这在很多情况下是"
"件坏事。"

#. type: table
#: zsh.texi:34151
msgid "The command is run in the background, so @t{tcp_proxy} can then accept new connections.  It continues to accept new connections until interrupted."
msgstr "该命令在后台运行，因此 @t{tcp_proxy} 可以接受新的连接。 它会持续接受新连接，直至被中断。"

#. type: findex
#: zsh.texi:34152
#, no-wrap
msgid "tcp_spam"
msgstr "tcp_spam"

#. type: item
#: zsh.texi:34153
#, no-wrap
msgid "@t{tcp_spam} [ @t{-ertv} ] [ @t{-a} | @t{-s} @var{sess} | @t{-l} @var{sess}[@t{,}...] ] @var{cmd} [ @var{arg} ... ]"
msgstr "@t{tcp_spam} [ @t{-ertv} ] [ @t{-a} | @t{-s} @var{sess} | @t{-l} @var{sess}[@t{,}...] ] @var{cmd} [ @var{arg} ... ]"

#. type: table
#: zsh.texi:34157
msgid "Execute `@var{cmd} [ @var{arg} ... ]' for each session in turn.  Note this executes the command and arguments; it does not send the command line as data unless the @t{-t} (transmit) option is given."
msgstr "依次为每个会话执行 `@var{cmd} [ @var{arg} ... ]'。 请注意，这将执行命令和参数；除非给出 @t{-t}（transmit）选项，否则不会将命令行作为数据发送。"

#. type: table
#: zsh.texi:34165
msgid ""
"The sessions may be selected explicitly with the standard @t{-a}, @t{-s} or @t{-l} options, or may be chosen implicitly.  If none of the three options is given the rules are: first, if the array "
"@t{$tcp_spam_list} is set, this is taken as the list of sessions, otherwise all sessions are taken.  Second, any sessions given in the array @t{$tcp_no_spam_list} are removed from the list of sessions."
msgstr ""
"会话可以通过标准的 @t{-a}、@t{-s} 或 @t{-l} 选项显式选择，也可以隐式选择。 如果没有给出这三个选项，则规则如下：首先，如果设置了 @t{$tcp_spam_list} 数组，则将其作为会话列表，否则将选择所有会话。 其次，"
"@t{$tcp_no_spam_list} 数组中的任何会话都将从会话列表中删除。"

#. type: table
#: zsh.texi:34171
msgid ""
"Normally, any sessions added by the `@t{-a}' flag or when all sessions are chosen implicitly are spammed in alphabetic order; sessions given by the @t{$tcp_spam_list} array or on the command line are "
"spammed in the order given.  The @t{-r} flag reverses the order however it was arrived it."
msgstr "通常，通过 `@t{-a}' 标志添加的会话或隐式选择所有会话时，会按字母顺序列出；通过 @t{$tcp_spam_list} 数组或命令行给出的会话，会按给出的顺序列出。 如果使用 @t{-r} 标志，则会颠倒列出,不管它是如何得到的。"

#. type: table
#: zsh.texi:34177
msgid ""
"The @t{-v} flag specifies that a @t{$TCP_PROMPT} will be output before each session.  This is output after any modification to @t{TCP_SESS} by the user-defined @t{tcp_on_spam} function described below.  "
"(Obviously that function is able to generate its own output.)"
msgstr "@t{-v} 标志指定在每次会话前输出 @t{$TCP_PROMPT}。 在用户定义的 @t{tcp_on_spam} 函数对 @t{TCP_SESS} 进行任何修改后，都会输出该信息。 (显然，该函数能够生成自己的输出）。"

#. type: table
#: zsh.texi:34181
msgid "If the option @t{-e} is present, the line given as `@var{cmd} [ @var{arg} ... ]' is executed using @t{eval}, otherwise it is executed without any further processing."
msgstr "如果存在选项 @t{-e}，则使用 @t{eval} 执行以 `@var{cmd} [ @var{arg} ... ]' 形式给出的行，否则不做任何进一步处理直接执行。"

#. type: t{#1}
#: zsh.texi:34182 zsh.texi:34183
#, no-wrap
msgid "tcp_talk"
msgstr "tcp_talk"

#. type: table
#: zsh.texi:34186
msgid "This is a fairly simple-minded attempt to force input to the line editor to go straight to the default @t{TCP_SESS}."
msgstr "这是一个相当简单的尝试，目的是将输入强制发送到默认的 @t{TCP_SESS}。"

#. type: table
#: zsh.texi:34194
msgid ""
"An escape string, @t{$TCP_TALK_ESCAPE}, default `@t{:}', is used to allow access to normal shell operation.  If it is on its own at the start of the line, or followed only by whitespace, the line editor "
"returns to normal operation.  Otherwise, the string and any following whitespace are skipped and the remainder of the line executed as shell input without any change of the line editor's operating mode."
msgstr ""
"转义字符 @t{$TCP_TALK_ESCAPE}（默认为 `@t{:}'）用于允许访问正常的 shell 操作。 如果该字符串位于行首，或后面只有空白，行编辑器将返回正常操作。 否则，将跳过该字符串和后面的空白，并将该行的其余部分作为 shell "
"输入执行，而不改变行编辑器的运行模式。"

#. type: table
#: zsh.texi:34201
msgid ""
"The current implementation is somewhat deficient in terms of use of the command history.  For this reason, many users will prefer to use some form of alternative approach for sending data easily to the "
"current session.  One simple approach is to alias some special character (such as `@t{%}') to `@t{tcp_command -}@t{-}'."
msgstr ""
"在使用命令历史记录方面，当前的实现方式存在一定缺陷。 因此，许多用户倾向于使用某种形式的替代方法，以方便地向当前会话发送数据。 一种简单的方法是将某些特殊字符（如 `@t{%}'）别名为 `@t{tcp_command -}@t{-}'。"

#. type: t{#1}
#: zsh.texi:34202 zsh.texi:34203
#, no-wrap
msgid "tcp_wait"
msgstr "tcp_wait"

#. type: table
#: zsh.texi:34209
msgid ""
"The sole argument is an integer or floating point number which gives the seconds to delay.  The shell will do nothing for that period except wait for input on all TCP sessions by calling @t{tcp_read -a}.  "
"This is similar to the interactive behaviour at the command prompt when zle handlers are installed."
msgstr "唯一的参数是一个整数或浮点数，表示延迟的秒数。 在这段时间内，除了通过调用 @t{tcp_read -a} 来等待所有 TCP 会话的输入外，shell 不会做任何事情。 这与安装了 zle 处理程序后在命令提示符下的交互行为类似。"

#. type: subsection
#: zsh.texi:34214
#, no-wrap
msgid "`One-shot' file transfer"
msgstr "`One-shot' 文件传输"

#. type: item
#: zsh.texi:34217
#, no-wrap
msgid "@t{tcp_point} @var{port}"
msgstr "@t{tcp_point} @var{port}"

#. type: itemx
#: zsh.texi:34218
#, no-wrap
msgid "@t{tcp_shoot} @var{host} @var{port}"
msgstr "@t{tcp_shoot} @var{host} @var{port}"

#. type: table
#: zsh.texi:34226
msgid ""
"This pair of functions provide a simple way to transfer a file between two hosts within the shell.  Note, however, that bulk data transfer is currently done using @t{cat}.  @t{tcp_point} reads any data "
"arriving at @var{port} and sends it to standard output; @t{tcp_shoot} connects to @var{port} on @var{host} and sends its standard input.  Any unused @var{port} may be used; the standard mechanism for "
"picking a port is to think of a random four-digit number above 1024 until one works."
msgstr ""
"这对函数提供了在 shell 内两个主机间传输文件的简单方法。 需要注意的是，目前使用 @t{cat} 来进行大量数据传输。 @t{tcp_point} 读取到达 @var{port} 的任何数据，并将其发送到标准输出；@t{tcp_shoot} 连接到 "
"@var{host} 上的 @var{port} 并发送其标准输入。 可以使用任何未使用的 @var{port}；选择端口的标准方法是随机想一个高于 1024 的四位数，直到有一个能用为止。"

#. type: table
#: zsh.texi:34230
msgid "To transfer a file from host @t{woodcock} to host @t{springes}, on @t{springes}:"
msgstr "在 @t{springes} 上从主机 @t{woodcock} 向主机 @t{springes} 传输文件："

#. type: example
#: zsh.texi:34234
#, no-wrap
msgid "tcp_point 8091 >output_file\n"
msgstr "tcp_point 8091 >output_file\n"

#. type: table
#: zsh.texi:34238
msgid "and on @t{woodcock}:"
msgstr "和 @t{woodcock}："

#. type: example
#: zsh.texi:34242
#, no-wrap
msgid "tcp_shoot springes 8091 <input_file\n"
msgstr "tcp_shoot springes 8091 <input_file\n"

#. type: table
#: zsh.texi:34247
msgid "As these two functions do not require @t{tcp_open} to set up a TCP connection first, they may need to be autoloaded separately."
msgstr "由于这两个函数不需要 @t{tcp_open} 先建立 TCP 连接，因此可能需要单独自动加载。"

#. type: section
#: zsh.texi:34252
#, no-wrap
msgid "TCP User-defined Functions"
msgstr "TCP 用户定义函数"

#. type: Plain text
#: zsh.texi:34261
msgid ""
"Certain functions, if defined by the user, will be called by the function system in certain contexts.  This facility depends on the module @t{zsh/parameter}, which is usually available in interactive "
"shells as the completion system depends on it.  None of the functions need be defined; they simply provide convenient hooks when necessary."
msgstr ""
"如果用户定义了某些函数，函数系统会在某些上下文中调用这些函数。 该功能依赖于 @t{zsh/parameter} 模块，通常在交互式 shell 中可用，因为补全系统依赖于它。 这些函数都不需要定义；它们只是在必要时提供方便的钩子。"

#. type: Plain text
#: zsh.texi:34265
msgid "Typically, these are called after the requested action has been taken, so that the various parameters will reflect the new state."
msgstr "通常情况下，这些参数会在请求的操作完成后被调用，这样各种参数就会反映新的状态。"

#. type: findex
#: zsh.texi:34268
#, no-wrap
msgid "tcp_on_alias"
msgstr "tcp_on_alias"

#. type: item
#: zsh.texi:34269
#, no-wrap
msgid "@t{tcp_on_alias} @var{alias} @var{fd}"
msgstr "@t{tcp_on_alias} @var{alias} @var{fd}"

#. type: table
#: zsh.texi:34272
msgid "When an alias is defined, this function will be called with two arguments: the name of the alias, and the file descriptor of the corresponding session."
msgstr "定义了别名后，调用该函数时将使用两个参数：别名的名称和相应会话的文件描述符。"

#. type: findex
#: zsh.texi:34273
#, no-wrap
msgid "tcp_on_awol"
msgstr "tcp_on_awol"

#. type: item
#: zsh.texi:34274
#, no-wrap
msgid "@t{tcp_on_awol} @var{sess} @var{fd}"
msgstr "@t{tcp_on_awol} @var{sess} @var{fd}"

#. type: table
#: zsh.texi:34285
msgid ""
"If the function @t{tcp_fd_handler} is handling input from the line editor and detects that the file descriptor is no longer reusable, by default it removes it from the list of file descriptors handled by "
"this method and prints a message.  If the function @t{tcp_on_awol} is defined it is called immediately before this point.  It may return status 100, which indicates that the normal handling should still "
"be performed; any other return status indicates that no further action should be taken and the @t{tcp_fd_handler} should return immediately with the given status.  Typically the action of @t{tcp_on_awol} "
"will be to close the session."
msgstr ""
"如果函数 @t{tcp_fd_handler} 正在处理来自行编辑器的输入，并检测到文件描述符不再可重复使用，默认情况下会将其从本方法处理的文件描述符列表中删除，并打印一条信息。 如果定义了函数 @t{tcp_on_awol}，则会紧接着在这"
"之前调用该函数。 它可能会返回状态 100，表示仍应执行正常的处理；任何其他返回状态都表示不应采取进一步的操作，@t{tcp_fd_handler} 应立即以给定的状态返回。 通常情况下，@t{tcp_on_awol} 的操作是关闭会话。"

#. type: table
#: zsh.texi:34290
msgid "The variable @t{TCP_INVALIDATE_ZLE} will be a non-empty string if it is necessary to invalidate the line editor display using `@t{zle -I}' before printing output from the function."
msgstr "如果需要在从函数打印输出之前使用 `@t{zle -I}' 来使行编辑器显示无效，则变量 @t{TCP_INVALIDATE_ZLE} 将是一个非空字符串。"

#. type: table
#: zsh.texi:34294
msgid "(`AWOL' is military jargon for `absent without leave' or some variation.  It has no pre-existing technical meaning known to the author.)"
msgstr "(`AWOL' 是军事术语，意为 `未经请假而缺勤' 或某种变体。 就作者所知，该词并无现成的技术含义）。"

#. type: findex
#: zsh.texi:34295
#, no-wrap
msgid "tcp_on_close"
msgstr "tcp_on_close"

#. type: item
#: zsh.texi:34296
#, no-wrap
msgid "@t{tcp_on_close} @var{sess} @var{fd}"
msgstr "@t{tcp_on_close} @var{sess} @var{fd}"

#. type: table
#: zsh.texi:34300
msgid "This is called with the name of a session being closed and the file descriptor which corresponded to that session.  Both will be invalid by the time the function is called."
msgstr "调用该函数时，需要输入正在关闭的会话名称以及与该会话相对应的文件描述符。 调用该函数时，这两个都将失效。"

#. type: findex
#: zsh.texi:34301
#, no-wrap
msgid "tcp_on_open"
msgstr "tcp_on_open"

#. type: item
#: zsh.texi:34302
#, no-wrap
msgid "@t{tcp_on_open} @var{sess} @var{fd}"
msgstr "@t{tcp_on_open} @var{sess} @var{fd}"

#. type: table
#: zsh.texi:34308
msgid ""
"This is called after a new session has been defined with the session name and file descriptor as arguments.  If it returns a non-zero status, opening the session is assumed to fail and the session is "
"closed again; however, @t{tcp_open} will continue to attempt to open any remaining sessions given on the command line."
msgstr "以会话名称和文件描述符为参数定义新会话后调用。 如果返回非零状态，则假定会话打开失败，并再次关闭会话；但 @t{tcp_open} 会继续尝试打开命令行中指定的其他会话。"

#. type: findex
#: zsh.texi:34309
#, no-wrap
msgid "tcp_on_rename"
msgstr "tcp_on_rename"

#. type: item
#: zsh.texi:34310
#, no-wrap
msgid "@t{tcp_on_rename} @var{oldsess} @var{fd} @var{newsess}"
msgstr "@t{tcp_on_rename} @var{oldsess} @var{fd} @var{newsess}"

#. type: table
#: zsh.texi:34313
msgid "This is called after a session has been renamed with the three arguments old session name, file descriptor, new session name."
msgstr "会话重命名后会调用该函数，参数包括旧会话名称、文件描述符和新会话名称。"

#. type: findex
#: zsh.texi:34314
#, no-wrap
msgid "tcp_on_spam"
msgstr "tcp_on_spam"

#. type: item
#: zsh.texi:34315
#, no-wrap
msgid "@t{tcp_on_spam} @var{sess} @var{command ...}"
msgstr "@t{tcp_on_spam} @var{sess} @var{command ...}"

#. type: table
#: zsh.texi:34320
msgid ""
"This is called once for each session spammed, just @emph{before} a command is executed for a session by @t{tcp_spam}.  The arguments are the session name followed by the command list to be executed.  If "
"@t{tcp_spam} was called with the option @t{-t}, the first command will be @t{tcp_send}."
msgstr "每个会话都会被调用一次,在 @t{tcp_spam} 为会话执行命令之前。 参数包括会话名称和要执行的命令列表。 如果 @t{tcp_spam} 在调用时使用了选项 @t{-t}，则第一个命令将是 @t{tcp_send}。"

#. type: table
#: zsh.texi:34327
msgid ""
"This function is called after @t{$TCP_SESS} is set to reflect the session to be spammed, but before any use of it is made.  Hence it is possible to alter the value of @t{$TCP_SESS} within this function.  "
"For example, the session arguments to @t{tcp_spam} could include extra information to be stripped off and processed in @t{tcp_on_spam}."
msgstr ""
"该函数在 @t{$TCP_SESS} 设置以反应要发送的会话后，但在使用该会话之前被调用。 因此，可以在此函数中更改 @t{$TCP_SESS} 的值。 例如，@t{tcp_spam} 的会话参数可以包含额外信息，并在 @t{tcp_on_spam} 中进行剥离和处"
"理。"

#. type: table
#: zsh.texi:34332
msgid "If the function sets the parameter @t{$REPLY} to `@t{done}', the command line is not executed; in addition, no prompt is printed for the @t{-v} option to @t{tcp_spam}."
msgstr "如果函数将参数 @t{$REPLY} 设置为 `@t{done}'，则不执行命令行；此外，对于 @t{tcp_spam} 的 @t{-v} 选项，也不打印提示符。"

#. type: findex
#: zsh.texi:34333
#, no-wrap
msgid "tcp_on_unalias"
msgstr "tcp_on_unalias"

#. type: item
#: zsh.texi:34334
#, no-wrap
msgid "@t{tcp_on_unalias} @var{alias} @var{fd}"
msgstr "@t{tcp_on_unalias} @var{alias} @var{fd}"

#. type: table
#: zsh.texi:34337
msgid "This is called with the name of an alias and the corresponding session's file descriptor after an alias has been deleted."
msgstr "在删除别名后，会使用别名的名称和相应会话的文件描述符调用该函数。"

#. type: section
#: zsh.texi:34342
#, no-wrap
msgid "TCP Utility Functions"
msgstr "TCP 实用函数"

#. type: Plain text
#: zsh.texi:34348
msgid "The following functions are used by the TCP function system but will rarely if ever need to be called directly."
msgstr "TCP 函数系统使用以下函数，但很少需要直接调用。"

#. type: t{#1}
#: zsh.texi:34351 zsh.texi:34352
#, no-wrap
msgid "tcp_fd_handler"
msgstr "tcp_fd_handler"

#. type: table
#: zsh.texi:34358
msgid ""
"This is the function installed by @t{tcp_open} for handling input from within the line editor, if that is required.  It is in the format documented for the builtin `@t{zle -F}' in @ref{Zle Builtins} ."
msgstr "这是 @t{tcp_open} 安装的函数，用于处理来自行编辑器的输入（如果需要）。 其格式与 @ref{Zle 内置命令} 中的内置命令 `@t{zle -F}' 相同。"

#. type: table
#: zsh.texi:34364
msgid ""
"While active, the function sets the parameter @t{TCP_HANDLER_ACTIVE} to 1.  This allows shell code called internally (for example, by setting @t{tcp_on_read}) to tell if is being called when the shell is "
"otherwise idle at the editor prompt."
msgstr "当处于激活状态时，函数会将参数 @t{TCP_HANDLER_ACTIVE} 设为 1，从而允许内部调用的 shell 代码（例如，通过设置 @t{tcp_on_read}）在编辑器提示符下处于空闲状态时判断是否被调用。"

#. type: findex
#: zsh.texi:34365
#, no-wrap
msgid "tcp_output"
msgstr "tcp_output"

#. type: item
#: zsh.texi:34366
#, no-wrap
msgid "@t{tcp_output} [ @t{-q} ] @t{-P} @var{prompt} @t{-F} @var{fd} @t{-S} @var{sess}"
msgstr "@t{tcp_output} [ @t{-q} ] @t{-P} @var{prompt} @t{-F} @var{fd} @t{-S} @var{sess}"

#. type: table
#: zsh.texi:34370
msgid "This function is used for both logging and handling output to standard output, from within @t{tcp_read} and (if @t{$TCP_OUTPUT} is set)  @t{tcp_send}."
msgstr "该函数用于在 @t{tcp_read} 和（如果设置了 @t{$TCP_OUTPUT}）@t{tcp_send} 中记录日志和处理到达标准输出的输出。"

#. type: table
#: zsh.texi:34374
msgid "The @var{prompt} to use is specified by @t{-P}; the default is the empty string.  It can contain:"
msgstr "要使用的 @var{prompt} 由 @t{-P} 指定；默认为空字符串。 它可以包含:"

#. type: table
#: zsh.texi:34379
msgid "Expands to 1 if the session is the current session, otherwise 0.  Used with ternary expressions such as `@t{%(c.-.+)}' to output `@t{+}' for the current session and `@t{-}' otherwise."
msgstr "如果会话是当前会话，则扩展为 1，否则为 0。与三元表达式（如 `@t{%(c.-.+)}' ）一起使用时，为当前会话输出 `@t{+}' ，否则输出 `@t{-}' 。"

#. type: table
#: zsh.texi:34382
msgid "Replaced by the session's file descriptor."
msgstr "由会话的文件描述符代替。"

#. type: table
#: zsh.texi:34385
msgid "Replaced by the session name."
msgstr "用会话名称代替。"

#. type: table
#: zsh.texi:34388
msgid "Replaced by a single `@t{%}'."
msgstr "由单个 `@t{%}' 代替。"

#. type: table
#: zsh.texi:34394
msgid "The option @t{-q} suppresses output to standard output, but not to any log files which are configured."
msgstr "选项 @t{-q} 会抑制输出到标准输出，但不会抑制输出到任何已配置的日志文件。"

#. type: table
#: zsh.texi:34398
msgid "The @t{-S} and @t{-F} options are used to pass in the session name and file descriptor for possible replacement in the prompt."
msgstr "@t{-S} 和 @t{-F} 选项用于传递会话名称和文件描述符，以便在提示符中进行替换。"

#. type: node
#: zsh.texi:34402 zsh.texi:34617 zsh.texi:34619 zsh.texi:34674
#, no-wrap
msgid "TCP Examples"
msgstr "TCP 示例"

#. type: section
#: zsh.texi:34404
#, no-wrap
msgid "TCP User Parameters"
msgstr "TCP 用户参数"

#. type: Plain text
#: zsh.texi:34414
msgid ""
"Parameters follow the usual convention that uppercase is used for scalars and integers, while lowercase is used for normal and associative array.  It is always safe for user code to read these "
"parameters.  Some parameters may also be set; these are noted explicitly.  Others are included in this group as they are set by the function system for the user's benefit, i.e. setting them is typically "
"not useful but is benign."
msgstr ""
"参数遵循通常的惯例，即标量和整数使用大写，普通数组和关联数组使用小写。 用户代码可以安全地读取这些参数。 有些参数也可以设置；这些参数已明确注明。 其他参数包括在这一组中，因为它们是由函数系统为了用户的利益而"
"设置的，也就是说，设置它们通常没有什么用处，但却是无害的。"

#. type: Plain text
#: zsh.texi:34423
msgid ""
"It is often also useful to make settable parameters local to a function.  For example, `@t{local TCP_SILENT=1}' specifies that data read during the function call will not be printed to standard output, "
"regardless of the setting outside the function.  Likewise, `@t{local TCP_SESS=}@var{sess}' sets a session for the duration of a function, and `@t{local TCP_PROMPT=}' specifies that no prompt is used for "
"input during the function."
msgstr ""
"将可设置参数设置为函数的局部参数通常也很有用。 例如， `@t{local TCP_SILENT=1}' 指定在函数调用期间读取的数据不会打印到标准输出，与函数外部的设置无关。 同样，`@t{local TCP_SESS=}@var{sess}' 为函数的持续时间"
"设置会话，而 `@t{local TCP_PROMPT=}' 则指定在函数期间不使用提示符输入。"

#. type: t{#1}
#: zsh.texi:34426 zsh.texi:34427
#, no-wrap
msgid "tcp_expect_lines"
msgstr "tcp_expect_lines"

#. type: table
#: zsh.texi:34430
msgid "Array.  The set of lines read during the last call to @t{tcp_expect}, including the last (@t{$TCP_LINE})."
msgstr "数组。 上次调用 @t{tcp_expect} 时读取的行集合，包括最后的行（@t{$TCP_LINE}）。"

#. type: t{#1}
#: zsh.texi:34431 zsh.texi:34432
#, no-wrap
msgid "tcp_filter"
msgstr "tcp_filter"

#. type: table
#: zsh.texi:34437
msgid ""
"Array. May be set directly.  A set of extended globbing patterns which, if matched in @t{tcp_output}, will cause the line not to be printed to standard output.  The patterns should be defined as described "
"for the arguments to @t{tcp_expect}.  Output of line to log files is not affected."
msgstr "数组。可直接设置。 一组扩展的 globbing 模式，如果与 @t{tcp_output} 中的模式匹配，将导致该行不被打印到标准输出。 这些模式的定义应与 @t{tcp_expect} 的参数相同。 向日志文件输出行不受影响。"

#. type: t{#1}
#: zsh.texi:34438 zsh.texi:34439
#, no-wrap
msgid "TCP_HANDLER_ACTIVE"
msgstr "TCP_HANDLER_ACTIVE"

#. type: table
#: zsh.texi:34443
msgid "Scalar.  Set to 1 within @t{tcp_fd_handler} to indicate to functions called recursively that they have been called during an editor session.  Otherwise unset."
msgstr "标量。 在 @t{tcp_fd_handler} 中设置为 1，以向递归调用的函数表明它们已在编辑器会话中被调用。 否则不设置。"

#. type: t{#1}
#: zsh.texi:34444 zsh.texi:34445
#, no-wrap
msgid "TCP_LINE"
msgstr "TCP_LINE"

#. type: table
#: zsh.texi:34447
msgid "The last line read by @t{tcp_read}, and hence also @t{tcp_expect}."
msgstr "@t{tcp_read} 读取的最后一行，因此也是 @t{tcp_expect} 。"

#. type: t{#1}
#: zsh.texi:34448 zsh.texi:34449
#, no-wrap
msgid "TCP_LINE_FD"
msgstr "TCP_LINE_FD"

#. type: table
#: zsh.texi:34452
msgid "The file descriptor from which @t{$TCP_LINE} was read.  @t{$@{tcp_by_fd[$TCP_LINE_FD]@}} will give the corresponding session name."
msgstr "@t{$TCP_LINE} 读取的文件描述符。 @t{$@{tcp_by_fd[$TCP_LINE_FD]@}} 将给出相应的会话名称。"

#. type: t{#1}
#: zsh.texi:34453 zsh.texi:34454
#, no-wrap
msgid "tcp_lines"
msgstr "tcp_lines"

#. type: table
#: zsh.texi:34457
msgid "Array. The set of lines read during the last call to @t{tcp_read}, including the last (@t{$TCP_LINE})."
msgstr "数组。最后一次调用 @t{tcp_read} 时读取的行的集合，包括最后一次调用（@t{$TCP_LINE}）。"

#. type: t{#1}
#: zsh.texi:34458 zsh.texi:34459
#, no-wrap
msgid "TCP_LOG"
msgstr "TCP_LOG"

#. type: table
#: zsh.texi:34464
msgid ""
"May be set directly, although it is also controlled by @t{tcp_log}.  The name of a file to which output from all sessions will be sent.  The output is proceeded by the usual @t{$TCP_PROMPT}.  If it is not "
"an absolute path name, it will follow the user's current directory."
msgstr "可以直接设置，但也受 @t{tcp_log} 控制。 所有会话的输出将要发送到的文件名。 输出将以通常的 @t{$TCP_PROMPT} 方式进行。 如果不是绝对路径名，则将遵循用户的当前目录。"

#. type: t{#1}
#: zsh.texi:34465 zsh.texi:34466
#, no-wrap
msgid "TCP_LOG_SESS"
msgstr "TCP_LOG_SESS"

#. type: table
#: zsh.texi:34472
msgid ""
"May be set directly, although it is also controlled by @t{tcp_log}.  The prefix for a set of files to which output from each session separately will be sent; the full filename is @t{$@{TCP_LOG_SESS@}.}"
"@var{sess}.  Output to each file is raw; no prompt is added.  If it is not an absolute path name, it will follow the user's current directory."
msgstr ""
"可以直接设置，但也受 @t{tcp_log} 控制。 一组文件的前缀，每个会话的输出将分别发送到这些文件；完整的文件名是  @t{$@{TCP_LOG_SESS@}.}@var{sess}。 每个文件的输出都是原始的，不会添加提示符。 如果不是绝对路径"
"名，则将遵循用户的当前目录。"

#. type: t{#1}
#: zsh.texi:34473 zsh.texi:34474
#, no-wrap
msgid "tcp_no_spam_list"
msgstr "tcp_no_spam_list"

#. type: table
#: zsh.texi:34476
msgid "Array.  May be set directly.  See @t{tcp_spam} for how this is used."
msgstr "数组。 可直接设置。 有关使用方法，请参见 @t{tcp_spam}。"

#. type: t{#1}
#: zsh.texi:34477 zsh.texi:34478
#, no-wrap
msgid "TCP_OUTPUT"
msgstr "TCP_OUTPUT"

#. type: table
#: zsh.texi:34484
msgid ""
"May be set directly.  If a non-empty string, any data sent to a session by @t{tcp_send} will be logged.  This parameter gives the prompt to be used in a file specified by @t{$TCP_LOG} but not in a file "
"generated from @t{$TCP_LOG_SESS}.  The prompt string has the same format as @t{TCP_PROMPT} and the same rules for its use apply."
msgstr ""
"可直接设置。 如果是非空字符串，则会记录 @t{tcp_send} 发送到会话的任何数据。 此参数给出的提示符将用于 @t{$TCP_LOG} 指定的文件，但不用于 @t{$TCP_LOG_SESS} 生成的文件。 提示符字符串的格式与 @t{TCP_PROMPT} 相"
"同，使用规则也相同。"

#. type: t{#1}
#: zsh.texi:34485 zsh.texi:34486
#, no-wrap
msgid "TCP_PROMPT"
msgstr "TCP_PROMPT"

#. type: table
#: zsh.texi:34496
msgid ""
"May be set directly.  Used as the prefix for data read by @t{tcp_read} which is printed to standard output or to the log file given by @t{$TCP_LOG}, if any.  Any `@t{%s}', `@t{%f}' or `@t{%%}' occurring "
"in the string will be replaced by the name of the session, the session's underlying file descriptor, or a single `@t{%}', respectively.  The expression `@t{%c}' expands to 1 if the session being read is "
"the current session, else 0; this is most useful in ternary expressions such as `@t{%(c.-.+)}' which outputs `@t{+}' if the session is the current one, else `@t{-}'."
msgstr ""
"可直接设置。 作为 @t{tcp_read} 读取数据的前缀，这些数据会被打印到标准输出或 @t{$TCP_LOG} 指定的日志文件（如果有）。 字符串中出现的`@t{%s}', `@t{%f}' 或 `@t{%%}' 将分别被会话名称、会话的底层文件描述符或单"
"个 `@t{%}' 替换。 如果读取的会话是当前会话，表达式  `@t{%c}' 将扩展为 1，否则为 0；这在三元表达式中最有用，例如 `@t{%(c.-.+)}' ，如果会话是当前会话，则输出 `@t{+}' ，否则输出 `@t{-}'。"

#. type: table
#: zsh.texi:34501
msgid "If the prompt starts with @t{%P}, this is stripped and the complete result of the previous stage is passed through standard prompt @t{%}-style formatting before being output."
msgstr "如果提示符以 @t{%P} 开头，则会将其删除，并在输出前将前一阶段的完整结果通过标准提示符 @t{%} 样式的格式进行处理。"

#. type: t{#1}
#: zsh.texi:34502 zsh.texi:34503
#, no-wrap
msgid "TCP_READ_DEBUG"
msgstr "TCP_READ_DEBUG"

#. type: table
#: zsh.texi:34506
msgid "May be set directly.  If this has non-zero length, @t{tcp_read} will give some limited diagnostics about data being read."
msgstr "可直接设置。 如果长度不为零，@t{tcp_read} 将对读取的数据进行有限的诊断。"

#. type: t{#1}
#: zsh.texi:34507 zsh.texi:34508
#, no-wrap
msgid "TCP_SECONDS_START"
msgstr "TCP_SECONDS_START"

#. type: table
#: zsh.texi:34510
msgid "This value is created and initialised to zero by tcp_open."
msgstr "该值由 tcp_open 创建并初始化为 0。"

#. type: table
#: zsh.texi:34521
msgid ""
"The functions @t{tcp_read} and @t{tcp_expect} use the shell's @t{SECONDS} parameter for their own timing purposes.  If that parameter is not of floating point type on entry to one of the functions, it "
"will create a local parameter @t{SECONDS} which is floating point and set the parameter @t{TCP_SECONDS_START} to the previous value of @t{$SECONDS}.  If the parameter is already floating point, it is used "
"without a local copy being created and @t{TCP_SECONDS_START} is not set.  As the global value is zero, the shell elapsed time is guaranteed to be the sum of @t{$SECONDS} and @t{$TCP_SECONDS_START}."
msgstr ""
"函数 @t{tcp_read} 和 @t{tcp_expect} 会使用 shell 的 @t{SECONDS} 参数来实现自己的定(计)时目的。 如果在进入其中一个函数时该参数不是浮点类型，则会创建一个浮点的本地参数 @t{SECONDS}，并将参数 "
"@t{TCP_SECONDS_START} 设置为 @t{$SECONDS} 之前的值。 如果参数已经是浮点数，则无需创建本地副本即可使用，也不会设置 @t{TCP_SECONDS_START}。 由于全局值为零，因此可以保证 shell 的运行时间是 @t{$SECONDS} 和 "
"@t{$TCP_SECONDS_START} 的总和。"

#. type: table
#: zsh.texi:34526
msgid ""
"This can be avoided by setting @t{SECONDS} globally to a floating point value using `@t{typeset -F SECONDS}'; then the TCP functions will never make a local copy and never set @t{TCP_SECONDS_START} to a "
"non-zero value."
msgstr "使用 `@t{typeset -F SECONDS}' 将 @t{SECONDS} 全局设置为浮点数，就可以避免这种情况；这样 TCP 函数就不会创建本地副本，也不会将 @t{TCP_SECONDS_START} 设置为非零值。"

#. type: t{#1}
#: zsh.texi:34527 zsh.texi:34528
#, no-wrap
msgid "TCP_SESS"
msgstr "TCP_SESS"

#. type: table
#: zsh.texi:34531
msgid "May be set directly.  The current session; must refer to one of the sessions established by @t{tcp_open}."
msgstr "可直接设置。 当前会话；必须是 @t{tcp_open} 建立的会话之一。"

#. type: t{#1}
#: zsh.texi:34532 zsh.texi:34533
#, no-wrap
msgid "TCP_SILENT"
msgstr "TCP_SILENT"

#. type: table
#: zsh.texi:34537
msgid ""
"May be set directly, although it is also controlled by @t{tcp_log}.  If of non-zero length, data read by @t{tcp_read} will not be written to standard output, though may still be written to a log file."
msgstr "可以直接设置，但也受 @t{tcp_log} 控制。 如果长度不为零，@t{tcp_read} 读取的数据将不会写入标准输出，但仍有可能写入日志文件。"

#. type: t{#1}
#: zsh.texi:34538 zsh.texi:34539
#, no-wrap
msgid "tcp_spam_list"
msgstr "tcp_spam_list"

#. type: table
#: zsh.texi:34542
msgid "Array.  May be set directly.  See the description of the function @t{tcp_spam} for how this is used."
msgstr "数组。 可直接设置。 具体用法请参见函数 @t{tcp_spam} 的描述。"

#. type: t{#1}
#: zsh.texi:34543 zsh.texi:34544
#, no-wrap
msgid "TCP_TALK_ESCAPE"
msgstr "TCP_TALK_ESCAPE"

#. type: table
#: zsh.texi:34547
msgid "May be set directly.  See the description of the function @t{tcp_talk} for how this is used."
msgstr "可直接设置。 使用方法请参阅函数 @t{tcp_talk} 的说明。"

#. type: t{#1}
#: zsh.texi:34548 zsh.texi:34549
#, no-wrap
msgid "TCP_TIMEOUT"
msgstr "TCP_TIMEOUT"

#. type: table
#: zsh.texi:34552
msgid "May be set directly.  Currently this is only used by the function @t{tcp_command}, see above."
msgstr "可直接设置。 目前只有 @t{tcp_command} 函数会使用它，见上文。"

#. type: section
#: zsh.texi:34557
#, no-wrap
msgid "TCP User-defined Parameters"
msgstr "TCP 用户定义参数"

#. type: Plain text
#: zsh.texi:34563
msgid "The following parameters are not set by the function system, but have a special effect if set by the user."
msgstr "以下参数不是由函数系统设置，但如果由用户设置，则会产生特殊效果。"

#. type: t{#1}
#: zsh.texi:34566 zsh.texi:34567
#, no-wrap
msgid "tcp_on_read"
msgstr "tcp_on_read"

#. type: table
#: zsh.texi:34576
msgid ""
"This should be an associative array; if it is not, the behaviour is undefined.  Each key is the name of a shell function or other command, and the corresponding value is a shell pattern (using "
"@t{EXTENDED_GLOB}).  Every line read from a TCP session directly or indirectly using @t{tcp_read} (which includes lines read by @t{tcp_expect}) is compared against the pattern.  If the line matches, the "
"command given in the key is called with two arguments: the name of the session from which the line was read, and the line itself."
msgstr ""
"这应该是一个关联数组；如果不是，则行为未定义。 每个键都是 shell 函数或其他命令的名称，相应的值是 shell 模式（使用 @t{EXTENDED_GLOB}）。 直接或间接使用 @t{tcp_read} 从 TCP 会话读取的每一行（包括通过 "
"@t{tcp_expect} 读取的行）都会与模式进行比较。 如果匹配，则调用关键字中给出的命令，命令包含两个参数：读取该行的会话名称和该行本身。"

#. type: table
#: zsh.texi:34584
msgid ""
"If any function called to handle a line returns a non-zero status, the line is not output.  Thus a @t{tcp_on_read} handler containing only the instruction `@t{return 1}' can be used to suppress output of "
"particular lines (see, however, @t{tcp_filter} above).  However, the line is still stored in @t{TCP_LINE} and @t{tcp_lines}; this occurs after all @t{tcp_on_read} processing."
msgstr ""
"如果为处理某一行而调用的函数返回非零状态，则不输出该行。 因此，只包含指令 `@t{return 1}' 的 @t{tcp_on_read} 处理程序可以用来抑制特定行的输出（参见上文的 @t{tcp_filter}）。 不过，该行仍会存储在 "
"@t{TCP_LINE} 和 @t{tcp_lines} 中；这发生在所有 @t{tcp_on_read} 处理之后。"

#. type: section
#: zsh.texi:34589
#, no-wrap
msgid "TCP Utility Parameters"
msgstr "TCP 实用参数"

#. type: Plain text
#: zsh.texi:34595
msgid "These parameters are controlled by the function system; they may be read directly, but should not usually be set by user code."
msgstr "这些参数由函数系统控制；可以直接读取，但通常不应由用户代码设置。"

#. type: t{#1}
#: zsh.texi:34598 zsh.texi:34599
#, no-wrap
msgid "tcp_aliases"
msgstr "tcp_aliases"

#. type: table
#: zsh.texi:34603
msgid "Associative array.  The keys are the names of sessions established with @t{tcp_open}; each value is a space-separated list of aliases which refer to that session."
msgstr "关联数组。 键是使用 @t{tcp_open} 建立的会话名称；每个值是以空格分隔的别名列表，引用了该会话。"

#. type: t{#1}
#: zsh.texi:34604 zsh.texi:34605
#, no-wrap
msgid "tcp_by_fd"
msgstr "tcp_by_fd"

#. type: table
#: zsh.texi:34608
msgid "Associative array.  The keys are session file descriptors; each value is the name of that session."
msgstr "关联数组。 键是会话文件描述符；每个值是该会话的名称。"

#. type: t{#1}
#: zsh.texi:34609 zsh.texi:34610
#, no-wrap
msgid "tcp_by_name"
msgstr "tcp_by_name"

#. type: table
#: zsh.texi:34613
msgid "Associative array.  The keys are the names of sessions; each value is the file descriptor associated with that session."
msgstr "关联数组。 键是会话的名称，每个值是与该会话相关的文件描述符。"

#. type: Plain text
#: zsh.texi:34624
msgid "Here is a trivial example using a remote calculator."
msgstr "下面是一个使用远程计算器的微不足道的例子。"

#. type: Plain text
#: zsh.texi:34628
msgid "To create a calculator server on port 7337 (see the @t{dc} manual page for quite how infuriating the underlying command is):"
msgstr "在 7337 端口创建计算器服务器（请参阅 @t{dc} 手册页面，了解底层命令有多令人恼火）："

#. type: example
#: zsh.texi:34632
#, no-wrap
msgid "tcp_proxy 7337 dc\n"
msgstr "tcp_proxy 7337 dc\n"

#. type: Plain text
#: zsh.texi:34636
msgid "To connect to this from the same host with a session also named `@t{dc}':"
msgstr "从同一主机连接到同样名为 `@t{dc}' 的会话："

#. type: example
#: zsh.texi:34640
#, no-wrap
msgid "tcp_open localhost 7337 dc\n"
msgstr "tcp_open localhost 7337 dc\n"

#. type: Plain text
#: zsh.texi:34645
msgid "To send a command to the remote session and wait a short while for output (assuming @t{dc} is the current session):"
msgstr "向远程会话发送命令并稍候输出（假设 @t{dc} 是当前会话）："

#. type: example
#: zsh.texi:34649
#, no-wrap
msgid "tcp_command 2 4 + p\n"
msgstr "tcp_command 2 4 + p\n"

#. type: Plain text
#: zsh.texi:34653
msgid "To close the session:"
msgstr "要关闭会话："

#. type: example
#: zsh.texi:34657
#, no-wrap
msgid "tcp_close\n"
msgstr "tcp_close\n"

#. type: Plain text
#: zsh.texi:34663
msgid "The @t{tcp_proxy} needs to be killed to be stopped.  Note this will not usually kill any connections which have already been accepted, and also that the port is not immediately available for reuse."
msgstr "@t{tcp_proxy} 需要被删除才能停止。 请注意，这通常不会删除任何已接受的连接，而且端口也不会立即被重用。"

#. type: Plain text
#: zsh.texi:34667
msgid "The following chunk of code puts a list of sessions into an xterm header, with the current session followed by a star."
msgstr "下面的代码会将会话列表放入 xterm 头中，当前会话后面跟一个星号。"

#. type: example
#: zsh.texi:34671
#, no-wrap
msgid "print -n \"\\033]2;TCP:\" $@{(k)tcp_by_name:/$TCP_SESS/$TCP_SESS\\*@} \"\\a\"\n"
msgstr "print -n \"\\033]2;TCP:\" $@{(k)tcp_by_name:/$TCP_SESS/$TCP_SESS\\*@} \"\\a\"\n"

#. type: Plain text
#: zsh.texi:34683
msgid "The function @t{tcp_read} uses the shell's normal @t{read} builtin.  As this reads a complete line at once, data arriving without a terminating newline can cause the function to block indefinitely."
msgstr "函数 @t{tcp_read} 使用 shell 的常规 @t{read} 内置函数。 由于该函数一次读取一整行的数据，如果数据到达时没有换行结束符，就会导致函数无限阻塞。"

#. type: Plain text
#: zsh.texi:34690
msgid "Though the function suite works well for interactive use and for data arriving in small amounts, the performance when large amounts of data are being exchanged is likely to be extremely poor."
msgstr "虽然该函数套件在交互式使用和传输少量数据时运行良好，但在交换大量数据时，其性能可能极差。"

#. type: cindex
#: zsh.texi:34694
#, no-wrap
msgid "zftp function system"
msgstr "zftp 函数系统"

#. type: cindex
#: zsh.texi:34695
#, no-wrap
msgid "FTP, functions for using shell as client"
msgstr "FTP，使用 shell 作为客户端的函数"

#. type: Plain text
#: zsh.texi:34709
msgid ""
"This describes the set of shell functions supplied with the source distribution as an interface to the @t{zftp} builtin command, allowing you to perform FTP operations from the shell command line or "
"within functions or scripts.  The interface is similar to a traditional FTP client (e.g. the @t{ftp} command itself, see ftp(1)), but as it is entirely done within the shell all the familiar completion, "
"editing and globbing features, and so on, are present, and macros are particularly simple to write as they are just ordinary shell functions."
msgstr ""
"这里介绍的是随源码发行版提供的一组 shell 函数，它们是 @t{zftp} 内置命令的接口，允许你在 shell 命令行或函数或脚本中执行 FTP 操作。 该界面类似于传统的 FTP 客户端（例如 @t{ftp} 命令本身，参见 ftp(1)），但由于"
"它完全是在 shell 中完成的，因此所有熟悉的补全、编辑和 globbing 功能等都一应俱全，宏的编写也特别简单，因为它们只是普通的 shell 函数。"

#. type: Plain text
#: zsh.texi:34720
msgid ""
"The prerequisite is that the @t{zftp} command, as described in @ref{The zsh/zftp Module} , must be available in the version of @t{zsh} installed at your site.  If the shell is configured to load new "
"commands at run time, it probably is: typing `@t{zmodload zsh/zftp}' will make sure (if that runs silently, it has worked).  If this is not the case, it is possible @t{zftp} was linked into the shell "
"anyway: to test this, type `@t{which zftp}' and if @t{zftp} is available you will get the message `@t{zftp: shell built-in command}'."
msgstr ""
"前提条件是 @t{zftp} 命令（如 @ref{zsh/zftp 模块} 中所述）必须在您站点上安装的 @t{zsh} 版本中可用。 如果 shell 被配置为在运行时加载新命令，那么它很可能是可用的：键入  `@t{zmodload zsh/zftp}'  将确保这一点"
"（如果运行时没有提示，则说明已经成功）。 如果不是这种情况，则有可能 @t{zftp} 已经链接到 shell 中：要测试这一点，请键入 `@t{which zftp}' ，如果 @t{zftp} 可用，您将收到 `@t{zftp: shell built-in command}' 的"
"信息。"

#. type: Plain text
#: zsh.texi:34727
msgid ""
"Commands given directly with @t{zftp} builtin may be interspersed between the functions in this suite; in a few cases, using @t{zftp} directly may cause some of the status information stored in shell "
"parameters to become invalid.  Note in particular the description of the variables @t{$ZFTP_TMOUT}, @t{$ZFTP_PREFS} and @t{$ZFTP_VERBOSE} for @t{zftp}."
msgstr ""
"直接使用 @t{zftp} 内建的命令可能会穿插在本套件的函数之间；在少数情况下，直接使用 @t{zftp} 可能会导致存储在 shell 参数中的某些状态信息失效。 请特别注意@t{zftp} 的变量 @t{$ZFTP_TMOUT}、@t{$ZFTP_PREFS} 和 "
"@t{$ZFTP_VERBOSE} 的描述。"

#. type: subsection
#: zsh.texi:34736 zsh.texi:34738 zsh.texi:34768 zsh.texi:35961 zsh.texi:37913
#, no-wrap
msgid "Installation"
msgstr "安装"

#. type: node
#: zsh.texi:34736 zsh.texi:34768 zsh.texi:35266
#, no-wrap
msgid "Zftp Functions"
msgstr "Zftp 函数"

#. type: Plain text
#: zsh.texi:34752
msgid ""
"You should make sure all the functions from the @t{Functions/Zftp} directory of the source distribution are available; they all begin with the two letters `@t{zf}'.  They may already have been installed "
"on your system; otherwise, you will need to find them and copy them.  The directory should appear as one of the elements of the @t{$fpath} array (this should already be the case if they were installed), "
"and at least the function @t{zfinit} should be autoloaded; it will autoload the rest.  Finally, to initialize the use of the system you need to call the @t{zfinit} function.  The following code in your "
"@t{.zshrc} will arrange for this; assume the functions are stored in the directory @t{~/myfns}:"
msgstr ""
"您应确保源代码发行版 @t{Functions/Zftp} 目录中的所有函数都可用；它们都以两个字母 `@t{zf}' 开头。 它们可能已经安装在你的系统中；否则，你需要找到并复制它们。 目录应作为 @t{$fpath} 数组的元素之一出现（如果已"
"经安装，则应如此），并且至少应自动加载 @t{zfinit} 函数；它将自动加载其他函数。 最后，要初始化系统的使用，需要调用 @t{zfinit} 函数。@t{.zshrc} 中的以下代码将为此做出安排；假定函数存储在 @t{~/myfns} 目录中："

#. type: example
#: zsh.texi:34758
#, no-wrap
msgid ""
"fpath=(~/myfns $fpath)\n"
"autoload -U zfinit\n"
"zfinit\n"
msgstr ""
"fpath=(~/myfns $fpath)\n"
"autoload -U zfinit\n"
"zfinit\n"

#. type: Plain text
#: zsh.texi:34766
msgid ""
"Note that @t{zfinit} assumes you are using the @t{zmodload} method to load the @t{zftp} command.  If it is already built into the shell, change @t{zfinit} to @t{zfinit -n}.  It is helpful (though not "
"essential) if the call to @t{zfinit} appears after any code to initialize the new completion system, else unnecessary @t{compctl} commands will be given."
msgstr ""
"需要注意的是，@t{zfinit} 假设你正在使用 @t{zmodload} 方法加载 @t{zftp} 命令。 如果 shell 已内置该命令，请将 @t{zfinit} 改为 @t{zfinit -n}。 如果在任何初始化新补全系统的代码之后调用 @t{zfinit} ，则会有所帮"
"助（但并非必要），否则会给出不必要的 @t{compctl} 命令。"

#. type: Plain text
#: zsh.texi:34779
msgid ""
"The sequence of operations in performing a file transfer is essentially the same as that in a standard FTP client.  Note that, due to a quirk of the shell's @t{getopts} builtin, for those functions that "
"handle options you must use `@t{-}@t{-}' rather than `@t{-}' to ensure the remaining arguments are treated literally (a single `@t{-}' is treated as an argument)."
msgstr ""
"执行文件传输的操作顺序与标准 FTP 客户端的操作顺序基本相同。 需要注意的是，由于 shell 的 @t{getopts} 内置函数的特殊性，对于那些处理选项的函数，必须使用 `@t{-}@t{-}' 而不是 `@t{-}' ，以确保剩余的参数按字面意"
"思处理（单个`@t{-}' 被视为一个参数）。"

#. type: subsection
#: zsh.texi:34782
#, no-wrap
msgid "Opening a connection"
msgstr "打开连接"

#. type: findex
#: zsh.texi:34785
#, no-wrap
msgid "zfparams"
msgstr "zfparams"

#. type: item
#: zsh.texi:34786
#, no-wrap
msgid "@t{zfparams} [ @var{host} [ @var{user} [ @var{password} ... ] ] ]"
msgstr "@t{zfparams} [ @var{host} [ @var{user} [ @var{password} ... ] ] ]"

#. type: table
#: zsh.texi:34795
msgid ""
"Set or show the parameters for a future @t{zfopen} with no arguments.  If no arguments are given, the current parameters are displayed (the password will be shown as a line of asterisks).  If a @var{host} "
"is given, and either the @var{user} or @var{password} is not, they will be prompted for; also, any parameter given as `@t{?}' will be prompted for, and if the `@t{?}' is followed by a string, that will be "
"used as the prompt.  As @t{zfopen} calls @t{zfparams} to store the parameters, this usually need not be called directly."
msgstr ""
"设置或显示未来 @t{zfopen} 的参数，不带实参。 如果未给出实参，则显示当前参数（密码将显示为一行星号）。 如果给定了 @var{host}，但未给定 @var{user} 或 @var{password}，则会提示输入这两个参数；此外，以 `@t{?}' "
"形式给定的任何参数都会被提示输入，如果 `@t{?}' 后面跟了一个字符串，则该字符串将被用作提示符。 由于 @t{zfopen} 会调用 @t{zfparams} 来存储参数，因此通常不需要直接调用它。"

#. type: table
#: zsh.texi:34800
msgid "A single argument `@t{-}' will delete the stored parameters.  This will also cause the memory of the last directory (and so on) on the other host to be deleted."
msgstr "单个参数 `@t{-}' 将删除存储的参数。 这也会导致删除另一台主机上最后一个目录的记忆（以此类推）。"

#. type: findex
#: zsh.texi:34801
#, no-wrap
msgid "zfopen"
msgstr "zfopen"

#. type: item
#: zsh.texi:34802
#, no-wrap
msgid "@t{zfopen} [ @t{-1} ] [ @var{host} [ @var{user} [ @var{password} [ @var{account} ] ] ] ]"
msgstr "@t{zfopen} [ @t{-1} ] [ @var{host} [ @var{user} [ @var{password} [ @var{account} ] ] ] ]"

#. type: table
#: zsh.texi:34808
msgid ""
"If @var{host} is present, open a connection to that host under username @var{user} with password @var{password} (and, on the rare occasions when it is necessary, account @var{account}).  If a necessary "
"parameter is missing or given as `@t{?}' it will be prompted for.  If @var{host} is not present, use a previously stored set of parameters."
msgstr ""
"如果存在 @var{host}，则以用户名 @var{user} 和密码 @var{password}（以及在极少数必要情况下的账户 @var{account}）打开与该主机的连接。 如果缺少必要的参数或参数为 `@t{?}'，系统将提示输入。 如果 @var{host} 不存"
"在，则使用以前存储的参数集。"

#. type: table
#: zsh.texi:34814
msgid ""
"If the command was successful, and the terminal is compatible with @t{xterm} or is @t{sun-cmd}, a summary will appear in the title bar, giving the local @t{host:directory} and the remote @t{host:"
"directory}; this is handled by the function @t{zftp_chpwd}, described below."
msgstr "如果命令成功执行，且终端与 @t{xterm} 兼容或为 @t{sun-cmd}，标题栏中将显示摘要，给定本地 @t{host:directory} 和远程 @t{host:directory}；这由 @t{zftp_chpwd} 函数处理，详情如下。"

#. type: table
#: zsh.texi:34823
msgid ""
"Normally, the @var{host}, @var{user} and @var{password} are internally recorded for later re-opening, either by a @t{zfopen} with no arguments, or automatically (see below).  With the option `@t{-1}', no "
"information is stored.  Also, if an open command with arguments failed, the parameters will not be retained (and any previous parameters will also be deleted).  A @t{zfopen} on its own, or a @t{zfopen "
"-1}, never alters the stored parameters."
msgstr ""
"通常，内部会记录 @var{host}、@var{user} 和 @var{password}，以便日后通过不带参数的 @t{zfopen} 或自动（见下文）重新打开。 如果使用选项 `@t{-1}'，则不会存储任何信息。 此外，如果带参数的打开命令失败，参数将不"
"会被保留（之前的参数也将被删除）。 @t{zfopen} 本身或 @t{zfopen -1}，都不会更改存储的参数。"

#. type: table
#: zsh.texi:34832
msgid ""
"Both @t{zfopen} and @t{zfanon} (but not @t{zfparams}) understand URLs of the form @t{ftp://}@var{host}/@var{path...} as meaning to connect to the @var{host}, then change directory to @var{path} (which "
"must be a directory, not a file).  The `@t{ftp://}' can be omitted; the trailing `@t{/}' is enough to trigger recognition of the @var{path}.  Note prefixes other than `@t{ftp:}' are not recognized, and "
"that all characters after the first slash beyond @var{host} are significant in @var{path}."
msgstr ""
"@t{zfopen} 和 @t{zffanon}（但不包括 @t{zfparams}）都能将 @t{ftp://}@var{host}/@var{path...} 形式的 URL 理解为连接到 @var{host}，然后将目录更改为 @var{path}（必须是目录，而非文件）。 `@t{ftp://}' 可以省略；"
"尾部的 `@t{/}' 足以触发对 @var{path} 的识别。 需要注意的是， `@t{ftp:}' 以外的前缀不会被识别，而且 @var{host} 以外第一个斜线后的所有字符在 @var{path} 中都有意义。"

#. type: findex
#: zsh.texi:34833
#, no-wrap
msgid "zfanon"
msgstr "zfanon"

#. type: item
#: zsh.texi:34834
#, no-wrap
msgid "@t{zfanon} [ @t{-1} ] @var{host}"
msgstr "@t{zfanon} [ @t{-1} ] @var{host}"

#. type: table
#: zsh.texi:34840
msgid ""
"Open a connection @var{host} for anonymous FTP.  The username used is `@t{anonymous}'.  The password (which will be reported the first time) is generated as @var{user}@t{@@}@var{host}; this is then stored "
"in the shell parameter @t{$EMAIL_ADDR} which can alternatively be set manually to a suitable string."
msgstr "为匿名 FTP 打开 @var{host} 连接。 使用的用户名为 `@t{anonymous}'。 密码（将在第一次报告）生成为 @var{user}@t{@@}@var{host}；然后存储在 shell 参数 @t{$EMAIL_ADDR} 中，也可手动设置为合适的字符串。"

#. type: subsection
#: zsh.texi:34845
#, no-wrap
msgid "Directory management"
msgstr "目录管理"

#. type: findex
#: zsh.texi:34848
#, no-wrap
msgid "zfcd"
msgstr "zfcd"

#. type: item
#: zsh.texi:34849
#, no-wrap
msgid "@t{zfcd} [ @var{dir} ]"
msgstr "@t{zfcd} [ @var{dir} ]"

#. type: t{#1}
#: zsh.texi:34850
#, no-wrap
msgid "zfcd -"
msgstr "zfcd -"

#. type: itemx
#: zsh.texi:34851
#, no-wrap
msgid "@t{zfcd} @var{old} @var{new}"
msgstr "@t{zfcd} @var{old} @var{new}"

#. type: table
#: zsh.texi:34854
msgid "Change the current directory on the remote server: this is implemented to have many of the features of the shell builtin @t{cd}."
msgstr "更改远程服务器上的当前目录：该功能具有 shell 内置 @t{cd} 的许多功能。"

#. type: table
#: zsh.texi:34860
msgid ""
"In the first form with @var{dir} present, change to the directory @var{dir}.  The command `@t{zfcd ..}' is treated specially, so is guaranteed to work on non-UNIX servers (note this is handled internally "
"by @t{zftp}).  If @var{dir} is omitted, has the effect of `@t{zfcd ~}'."
msgstr ""
"在存在 @var{dir} 的第一种形式中，更改为 @var{dir} 目录。 命令 `@t{zfcd ..}' 会被特殊处理，因此保证能在非 UNIX 服务器上运行（注意这将由 @t{zftp} 内部处理）。 如果省略 @var{dir}，则效果与 `@t{zfcd ~}' 相同。"

#. type: table
#: zsh.texi:34863
msgid "The second form changes to the directory previously current."
msgstr "第二个形式会更改为之前的当前目录。"

#. type: table
#: zsh.texi:34868
msgid "The third form attempts to change the current directory by replacing the first occurrence of the string @var{old} with the string @var{new} in the current directory."
msgstr "第三种形式是尝试用 @var{new} 替换当前目录中第一个出现的 @var{old} 字符串，从而更改当前目录。"

#. type: table
#: zsh.texi:34881
msgid ""
"Note that in this command, and indeed anywhere a remote filename is expected, the string which on the local host corresponds to `@t{~}' is converted back to a `@t{~}' before being passed to the remote "
"machine.  This is convenient because of the way expansion is performed on the command line before @t{zfcd} receives a string.  For example, suppose the command is `@t{zfcd ~/foo}'.  The shell will expand "
"this to a full path such as `@t{zfcd /home/user2/pws/foo}'.  At this stage, @t{zfcd} recognises the initial path as corresponding to `@t{~}' and will send the directory to the remote host as @t{~/foo}, so "
"that the `@t{~}' will be expanded by the server to the correct remote host directory.  Other named directories of the form `@t{~name}' are not treated in this fashion."
msgstr ""
"请注意，在这条命令中，以及在任何需要远程文件名的地方，本地主机上对应于 `@t{~}' 的字符串在传给远程机器之前都会被转换回 `@t{~}'。 这样做很方便，因为在 @t{zfcd} 接收字符串之前，会在命令行上执行扩展。 例如，假"
"设命令是 `@t{zfcd ~/foo}'。 shell 会将其扩展为完整路径，如 `@t{zfcd /home/user2/pws/foo}'。 在此阶段，@t{zfcd} 会将识别初始路径为对应于 `@t{~}' ，并将目录以 @t{~/foo} 的形式发送到远程主机，这样服务器就会"
"将 `@t{~}' 扩展为正确的远程主机目录。 其他形式为 `@t{~name}' 的命名目录不按此方式处理。"

#. type: t{#1}
#: zsh.texi:34882 zsh.texi:34883
#, no-wrap
msgid "zfhere"
msgstr "zfhere"

#. type: table
#: zsh.texi:34888
msgid ""
"Change directory on the remote server to the one corresponding to the current local directory, with special handling of `@t{~}' as in @t{zfcd}.  For example, if the current local directory is @t{~/foo/"
"bar}, then @t{zfhere} performs the effect of `@t{zfcd ~/foo/bar}'."
msgstr ""
"将远程服务器上的目录更改为与当前本地目录相对应的目录，并对`@t{~}' 进行特殊处理，就像在 zfcd 命令中一样。 例如，如果当前的本地目录是 @t{~/foo/bar}，那么 @t{zfhere} 就会执行 `@t{zfcd ~/foo/bar}' 的效果。"

#. type: findex
#: zsh.texi:34889
#, no-wrap
msgid "zfdir"
msgstr "zfdir"

#. type: item
#: zsh.texi:34890
#, no-wrap
msgid "@t{zfdir} [ @t{-rfd} ] [ @t{-} ] [ @var{dir-options} ] [ @var{dir} ]"
msgstr "@t{zfdir} [ @t{-rfd} ] [ @t{-} ] [ @var{dir-options} ] [ @var{dir} ]"

#. type: table
#: zsh.texi:34897
msgid ""
"Produce a long directory listing.  The arguments @var{dir-options} and @var{dir} are passed directly to the server and their effect is implementation dependent, but specifying a particular remote "
"directory @var{dir} is usually possible.  The output is passed through a pager given by the environment variable @t{$PAGER}, or `@t{more}' if that is not set."
msgstr ""
"生成长目录列表。 参数 @var{dir-options} 和 @var{dir} 直接传递给服务器，其效果取决于实现，但通常可以指定特定的远程目录 @var{dir}。 输出通过环境变量 @t{$PAGER} 指定的分页器传递，如果未设置环境变量，则通过 "
"`@t{more}' 传递。"

#. type: table
#: zsh.texi:34911
msgid ""
"The directory is usually cached for re-use.  In fact, two caches are maintained.  One is for use when there is no @var{dir-options} or @var{dir}, i.e. a full listing of the current remote directory; it is "
"flushed when the current remote directory changes.  The other is kept for repeated use of @t{zfdir} with the same arguments; for example, repeated use of `@t{zfdir /pub/gnu}' will only require the "
"directory to be retrieved on the first call.  Alternatively, this cache can be re-viewed with the @t{-r} option.  As relative directories will confuse @t{zfdir}, the @t{-f} option can be used to force the "
"cache to be flushed before the directory is listed.  The option @t{-d} will delete both caches without showing a directory listing; it will also delete the cache of file names in the current remote "
"directory, if any."
msgstr ""
"目录通常被缓存起来，以便重复使用。 事实上，会维护两个缓存。 一个是在没有 @var{dir-options} 或 @var{dir} 时使用的缓存，即当前远程目录的完整列表；当当前远程目录发生变化时，缓存会被刷新。 另一个缓存用于重复使"
"用相同参数的 @t{zfdir}；例如，重复使用 `@t{zfdir /pub/gnu}' 时，只需在第一次调用时检索目录。 另外，也可以使用 @t{-r} 选项重新查看这个缓存。 由于相对目录会混淆 @t{zfdir}，因此可以使用 @t{-f} 选项强制在列出"
"目录之前刷新缓存。 选项 @t{-d} 会在不显示目录列表的情况下删除两个缓存；它还会删除当前远程目录中的文件名缓存（如果有的话）。"

#. type: findex
#: zsh.texi:34912
#, no-wrap
msgid "zfls"
msgstr "zfls"

#. type: item
#: zsh.texi:34913
#, no-wrap
msgid "@t{zfls} [ @var{ls-options} ] [ @var{dir} ]"
msgstr "@t{zfls} [ @var{ls-options} ] [ @var{dir} ]"

#. type: table
#: zsh.texi:34917
msgid ""
"List files on the remote server.  With no arguments, this will produce a simple list of file names for the current remote directory.  Any arguments are passed directly to the server.  No pager and no "
"caching is used."
msgstr "列出远程服务器上的文件。 在没有参数的情况下，它会产生一个当前远程目录的简单文件名列表。 任何参数都将直接传递给服务器。 不使用分页器和缓存。"

#. type: subsection
#: zsh.texi:34922
#, no-wrap
msgid "Status commands"
msgstr "状态命令"

#. type: findex
#: zsh.texi:34925
#, no-wrap
msgid "zftype"
msgstr "zftype"

#. type: item
#: zsh.texi:34926
#, no-wrap
msgid "@t{zftype} [ @var{type} ]"
msgstr "@t{zftype} [ @var{type} ]"

#. type: table
#: zsh.texi:34931
msgid ""
"With no arguments, show the type of data to be transferred, usually ASCII or binary.  With an argument, change the type: the types `@t{A}' or `@t{ASCII}' for ASCII data and `@t{B}' or `@t{BINARY}', "
"`@t{I}' or `@t{IMAGE}' for binary data are understood case-insensitively."
msgstr ""
"在没有参数的情况下，显示要传输的数据类型，通常是 ASCII 或二进制数据。 如果有参数，则更改类型：对于 ASCII 数据，类型为 `@t{A}' 或`@t{ASCII}' ；对于二进制数据，类型为 `@t{B}' 或 `@t{BINARY}'、`@t{I}' 或 "
"`@t{IMAGE}' ,大小写无关。"

#. type: findex
#: zsh.texi:34932
#, no-wrap
msgid "zfstat"
msgstr "zfstat"

#. type: item
#: zsh.texi:34933
#, no-wrap
msgid "@t{zfstat} [ @t{-v} ]"
msgstr "@t{zfstat} [ @t{-v} ]"

#. type: table
#: zsh.texi:34938
msgid ""
"Show the status of the current or last connection, as well as the status of some of @t{zftp}'s status variables.  With the @t{-v} option, a more verbose listing is produced by querying the server for its "
"version of events, too."
msgstr "显示当前或上次连接的状态，以及 @t{zftp} 的某些状态变量的状态。 使用 @t{-v} 选项，还可以通过查询服务器的事件版本，生成更详细的列表。  "

#. type: subsection
#: zsh.texi:34943
#, no-wrap
msgid "Retrieving files"
msgstr "检索文件"

#. type: Plain text
#: zsh.texi:34950
msgid ""
"The commands for retrieving files all take at least two options. @t{-G} suppresses remote filename expansion which would otherwise be performed (see below for a more detailed description of that).  @t{-t} "
"attempts to set the modification time of the local file to that of the remote file: see the description of the function @t{zfrtime} below for more information."
msgstr ""
"检索文件的命令都至少包含两个选项。@t{-G} 会抑制本应执行的远程文件名扩展（更详细的说明见下文）。 @t{-t} 尝试将本地文件的修改时间设置为远程文件的修改时间：更多信息，请参阅下文对函数 @t{zfrtime} 的描述。"

#. type: findex
#: zsh.texi:34953
#, no-wrap
msgid "zfget"
msgstr "zfget"

#. type: item
#: zsh.texi:34954
#, no-wrap
msgid "@t{zfget} [ @t{-Gtc} ] @var{file1} ..."
msgstr "@t{zfget} [ @t{-Gtc} ] @var{file1} ..."

#. type: table
#: zsh.texi:34961
msgid ""
"Retrieve all the listed files @var{file1} ... one at a time from the remote server.  If a file contains a `@t{/}', the full name is passed to the remote server, but the file is stored locally under the "
"name given by the part after the final `@t{/}'.  The option @t{-c} (cat) forces all files to be sent as a single stream to standard output; in this case the @t{-t} option has no effect."
msgstr ""
"从远程服务器一次检索所有列出的文件 @var{file1} ... 。 如果文件包含 `@t{/}'，全名将传递给远程服务器，但文件将以最后的 `@t{/}' 之后的部分给出的名称存储在本地。 选项 @t{-c}（cat）会强制将所有文件作为单一数据"
"流发送到标准输出；在这种情况下，@t{-t} 选项不起作用。"

#. type: findex
#: zsh.texi:34962
#, no-wrap
msgid "zfuget"
msgstr "zfuget"

#. type: item
#: zsh.texi:34963
#, no-wrap
msgid "@t{zfuget} [ @t{-Gvst} ] @var{file1} ..."
msgstr "@t{zfuget} [ @t{-Gvst} ] @var{file1} ..."

#. type: table
#: zsh.texi:34972
msgid ""
"As @t{zfget}, but only retrieve files where the version on the remote server is newer (has a later modification time), or where the local file does not exist.  If the remote file is older but the files "
"have different sizes, or if the sizes are the same but the remote file is newer, the user will usually be queried.  With the option @t{-s}, the command runs silently and will always retrieve the file in "
"either of those two cases.  With the option @t{-v}, the command prints more information about the files while it is working out whether or not to transfer them."
msgstr ""
"与 @t{zfget}相同，但只检索远程服务器上版本较新（修改时间较晚）或本地不存在的文件。 如果远程文件较早但文件大小不同，或者文件大小相同但远程文件较新，通常会询问用户。 如果使用选项 @t{-s}，命令将静默运行，并始"
"终在这两种情况下检索文件。 如果使用选项 @t{-v}，命令在决定是否传输文件时会打印更多文件信息。"

#. type: findex
#: zsh.texi:34973
#, no-wrap
msgid "zfcget"
msgstr "zfcget"

#. type: item
#: zsh.texi:34974
#, no-wrap
msgid "@t{zfcget} [ @t{-Gt} ] @var{file1} ..."
msgstr "@t{zfcget} [ @t{-Gt} ] @var{file1} ..."

#. type: table
#: zsh.texi:34979
msgid ""
"As @t{zfget}, but if any of the local files exists, and is shorter than the corresponding remote file, the command assumes that it is the result of a partially completed transfer and attempts to transfer "
"the rest of the file.  This is useful on a poor connection which keeps failing."
msgstr "与 @t{zfget}相同，但如果本地文件存在，且比相应远程文件短，命令会认为这是部分传输完成的结果，并尝试传输文件的其余部分。 这在连接不畅、不断失败的情况下非常有用。"

#. type: table
#: zsh.texi:34983
msgid "Note that this requires a commonly implemented, but non-standard, version of the FTP protocol, so is not guaranteed to work on all servers."
msgstr "请注意，这需要一个常用但非标准的 FTP 协议版本，因此不能保证在所有服务器上都能运行。"

#. type: findex
#: zsh.texi:34984
#, no-wrap
msgid "zfgcp"
msgstr "zfgcp"

#. type: item
#: zsh.texi:34985
#, no-wrap
msgid "@t{zfgcp} [ @t{-Gt} ] @var{remote-file} @var{local-file}"
msgstr "@t{zfgcp} [ @t{-Gt} ] @var{remote-file} @var{local-file}"

#. type: itemx
#: zsh.texi:34986
#, no-wrap
msgid "@t{zfgcp} [ @t{-Gt} ] @var{rfile1} ... @var{ldir}"
msgstr "@t{zfgcp} [ @t{-Gt} ] @var{rfile1} ... @var{ldir}"

#. type: table
#: zsh.texi:34989
msgid "This retrieves files from the remote server with arguments behaving similarly to the @t{cp} command."
msgstr "该命令从远程服务器检索文件，参数行为与 @t{cp} 命令类似。"

#. type: table
#: zsh.texi:34993
msgid "In the first form, copy @var{remote-file} from the server to the local file @var{local-file}."
msgstr "在第一种形式中，将 @var{remote-file} 从服务器复制到本地文件 @var{local-file}。"

#. type: table
#: zsh.texi:34998
msgid "In the second form, copy all the remote files @var{rfile1} ... into the local directory @var{ldir} retaining the same basenames.  This assumes UNIX directory semantics."
msgstr "在第二种形式中，将所有远程文件 @var{rfile1} ... 复制到本地目录 @var{ldir} 中，并保留相同的基名。 这假定了 UNIX 的目录语义。"

#. type: subsection
#: zsh.texi:35003
#, no-wrap
msgid "Sending files"
msgstr "发送文件"

#. type: findex
#: zsh.texi:35006
#, no-wrap
msgid "zfput"
msgstr "zfput"

#. type: item
#: zsh.texi:35007
#, no-wrap
msgid "@t{zfput} [ @t{-r} ] @var{file1} ..."
msgstr "@t{zfput} [ @t{-r} ] @var{file1} ..."

#. type: table
#: zsh.texi:35011
msgid ""
"Send all the @var{file1} ... given separately to the remote server.  If a filename contains a `@t{/}', the full filename is used locally to find the file, but only the basename is used for the remote file "
"name."
msgstr "将所有给定的 @var{file1} ... 分别发送到远程服务器。 如果文件名包含 `@t{/}'，本地将使用完整的文件名查找该文件，但远程文件名只使用基名。"

#. type: table
#: zsh.texi:35017
msgid ""
"With the option @t{-r}, if any of the @var{files} are directories they are sent recursively with all their subdirectories, including files beginning with `@t{.}'.  This requires that the remote machine "
"understand UNIX file semantics, since `@t{/}' is used as a directory separator."
msgstr "使用选项 @t{-r}，如果 @var{files} 中有任何一个是目录，则会递归发送所有子目录，包括以 `@t{.}' 开头的文件。 这要求远程机器理解 UNIX 文件语义，因为 `@t{/}' 被用作目录分隔符。"

#. type: findex
#: zsh.texi:35018
#, no-wrap
msgid "zfuput"
msgstr "zfuput"

#. type: item
#: zsh.texi:35019
#, no-wrap
msgid "@t{zfuput} [ @t{-vs} ] @var{file1} ..."
msgstr "@t{zfuput} [ @t{-vs} ] @var{file1} ..."

#. type: table
#: zsh.texi:35023
msgid ""
"As @t{zfput}, but only send files which are newer than their remote equivalents, or if the remote file does not exist.  The logic is the same as for @t{zfuget}, but reversed between local and remote files."
msgstr "与 @t{zfput}相同，但只发送比远程文件更新的文件，或者远程文件不存在时才发送。 逻辑与 @t{zfuget}相同，但本地文件和远程文件的逻辑相反。"

#. type: findex
#: zsh.texi:35024
#, no-wrap
msgid "zfcput"
msgstr "zfcput"

#. type: item
#: zsh.texi:35025
#, no-wrap
msgid "@t{zfcput} @var{file1} ..."
msgstr "@t{zfcput} @var{file1} ..."

#. type: table
#: zsh.texi:35031
msgid ""
"As @t{zfput}, but if any remote file already exists and is shorter than the local equivalent, assume it is the result of an incomplete transfer and send the rest of the file to append to the existing "
"part.  As the FTP append command is part of the standard set, this is in principle more likely to work than @t{zfcget}."
msgstr ""
"与 @t{zfput}相同，但如果任何远程文件已经存在，且比本地文件短，则假定这是传输不完整的结果，并发送文件的其余部分以追加到现有部分。 由于 FTP 追加命令是标准集的一部分，因此原则上这比 @t{zfcget} 更有可能奏效。"

#. type: findex
#: zsh.texi:35032
#, no-wrap
msgid "zfpcp"
msgstr "zfpcp"

#. type: item
#: zsh.texi:35033
#, no-wrap
msgid "@t{zfpcp} @var{local-file} @var{remote-file}"
msgstr "@t{zfpcp} @var{local-file} @var{remote-file}"

#. type: itemx
#: zsh.texi:35034
#, no-wrap
msgid "@t{zfpcp} @var{lfile1} ... @var{rdir}"
msgstr "@t{zfpcp} @var{lfile1} ... @var{rdir}"

#. type: table
#: zsh.texi:35037
msgid "This sends files to the remote server with arguments behaving similarly to the @t{cp} command."
msgstr "它会将文件发送到远程服务器，其参数行为与 @t{cp} 命令类似。"

#. type: table
#: zsh.texi:35041
msgid "With two arguments, copy @var{local-file} to the server as @var{remote-file}."
msgstr "使用两个参数，将 @var{local-file} 复制到服务器上的 @var{remote-file} 中。"

#. type: table
#: zsh.texi:35046
msgid "With more than two arguments, copy all the local files @var{lfile1} ... into the existing remote directory @var{rdir} retaining the same basenames.  This assumes UNIX directory semantics."
msgstr "在有两个以上参数的情况下，将所有本地文件 @var{lfile1} ... 复制到现有远程目录 @var{rdir} 中，并保留相同的基名。 这假定了 UNIX 的目录语义。"

#. type: table
#: zsh.texi:35057
msgid ""
"A problem arises if you attempt to use @t{zfpcp} @var{lfile1} @var{rdir}, i.e. the second form of copying but with two arguments, as the command has no simple way of knowing if @var{rdir} corresponds to a "
"directory or a filename.  It attempts to resolve this in various ways.  First, if the @var{rdir} argument is `@t{.}' or `@t{..}' or ends in a slash, it is assumed to be a directory.  Secondly, if the "
"operation of copying to a remote file in the first form failed, and the remote server sends back the expected failure code 553 and a reply including the string `@t{Is a directory}', then @t{zfpcp} will "
"retry using the second form."
msgstr ""
"如果尝试使用 @t{zfpcp} @var{lfile1} @var{rdir} 就会出现问题，即复制的第二种形式，但有两个参数，因为命令无法简单判断 @var{rdir} 对应的是目录还是文件名。 命令试图通过多种方式解析这个问题。 首先，如果 "
"@var{rdir} 参数是 `@t{.}' 或 `@t{..}' ，或以斜线结束，则假定它是一个目录。 其次，如果以第一种形式复制到远程文件的操作失败，并且远程服务器发送了预期的失败代码 553 ，并包含字符串 `@t{Is a directory}' 的回"
"复，那么 @t{zfpcp} 将使用第二种形式重试。"

#. type: subsection
#: zsh.texi:35062
#, no-wrap
msgid "Closing the connection"
msgstr "关闭连接"

#. type: t{#1}
#: zsh.texi:35065 zsh.texi:35066
#, no-wrap
msgid "zfclose"
msgstr "zfclose"

#. type: table
#: zsh.texi:35068
msgid "Close the connection."
msgstr "关闭连接"

#. type: subsection
#: zsh.texi:35073
#, no-wrap
msgid "Session management"
msgstr "会话管理"

#. type: findex
#: zsh.texi:35076
#, no-wrap
msgid "zfsession"
msgstr "zfsession"

#. type: item
#: zsh.texi:35077
#, no-wrap
msgid "@t{zfsession} [ @t{-lvod} ] [ @var{sessname} ]"
msgstr "@t{zfsession} [ @t{-lvod} ] [ @var{sessname} ]"

#. type: table
#: zsh.texi:35086
msgid ""
"Allows you to manage multiple FTP sessions at once.  By default, connections take place in a session called `@t{default}'; by giving the command `@t{zfsession} @var{sessname}' you can change to a new or "
"existing session with a name of your choice.  The new session remembers its own connection, as well as associated shell parameters, and also the host/user parameters set by @t{zfparams}.  Hence you can "
"have different sessions set up to connect to different hosts, each remembering the appropriate host, user and password."
msgstr ""
"允许你同时管理多个 FTP 会话。 默认情况下，连接是在名为 `@t{default}' 的会话中进行的。 通过给出 `@t{zfsession} @var{sessname}' 命令，你就可以用自己选择的名称切换到一个新的或现有的会话。 新会话会记住自己的连"
"接、相关的 shell 参数以及 @t{zfparams} 设置的 host/user 参数。 因此，你可以设置不同的会话来连接不同的主机，每个会话都会记住相应的主机、用户和密码。"

#. type: table
#: zsh.texi:35093
msgid ""
"With no arguments, @t{zfsession} prints the name of the current session; with the option @t{-l} it lists all sessions which currently exist, and with the option @t{-v} it gives a verbose list showing the "
"host and directory for each session, where the current session is marked with an asterisk.  With @t{-o}, it will switch to the most recent previous session."
msgstr ""
"在没有参数的情况下，@t{zfsession} 会打印当前会话的名称；在使用选项 @t{-l} 的情况下，它会列出当前存在的所有会话；在使用选项 @t{-v} 的情况下，它会给出一个详细的列表，显示每个会话的主机和目录，其中当前会话用"
"星号标记。 如果使用 @t{-o}，则会切换到最近的上一个会话。"

#. type: table
#: zsh.texi:35100
msgid ""
"With @t{-d}, the given session (or else the current one) is removed; everything to do with it is completely forgotten.  If it was the only session, a new session called `@t{default}' is created and made "
"current.  It is safest not to delete sessions while background commands using @t{zftp} are active."
msgstr ""
"使用 @t{-d}，给定会话（或当前会话）将被移除；与之相关的一切都将被彻底遗忘。 如果它是唯一的会话，则会创建一个名为 `@t{default}' 的新会话，并使其成为当前会话。 在使用 @t{zftp} 的后台命令处于活动状态时，最好"
"不要删除会话。"

#. type: findex
#: zsh.texi:35101
#, no-wrap
msgid "zftransfer"
msgstr "zftransfer"

#. type: item
#: zsh.texi:35102
#, no-wrap
msgid "@t{zftransfer} @var{sess1}@t{:}@var{file1} @var{sess2}@t{:}@var{file2}"
msgstr "@t{zftransfer} @var{sess1}@t{:}@var{file1} @var{sess2}@t{:}@var{file2}"

#. type: table
#: zsh.texi:35112
msgid ""
"Transfer files between two sessions; no local copy is made.  The file is read from the session @var{sess1} as @var{file1} and written to session @var{sess2} as file @var{file2}; @var{file1} and "
"@var{file2} may be relative to the current directories of the session.  Either @var{sess1} or @var{sess2} may be omitted (though the colon should be retained if there is a possibility of a colon appearing "
"in the file name) and defaults to the current session; @var{file2} may be omitted or may end with a slash, in which case the basename of @var{file1} will be added.  The sessions @var{sess1} and "
"@var{sess2} must be distinct."
msgstr ""
"在两个会话之间传输文件；不创建本地副本。 文件以 @var{file1} 的形式从会话 @var{sess1} 读取，并以文件 @var{file2} 的形式写入会话 @var{sess2}；@var{file1} 和 @var{file2} 可以是会话当前目录的相对文件。 "
"@var{sess1} 或 @var{sess2} 均可省略（但如果文件名中可能出现冒号，则应保留冒号），并默认为当前会话；@var{file2} 可省略或以斜线结尾，在这种情况下，将添加 @var{file1} 的基名。 会话 @var{sess1} 和 @var{sess2} "
"必须是不同的。"

#. type: table
#: zsh.texi:35117
msgid ""
"The operation is performed using pipes, so it is required that the connections still be valid in a subshell, which is not the case under versions of some operating systems, presumably due to a system bug."
msgstr "该操作是使用管道执行的，因此要求连接在子 shell 中仍然有效，而在某些操作系统版本下，情况并非如此，这可能是由于系统漏洞造成的。"

#. type: subsection
#: zsh.texi:35122
#, no-wrap
msgid "Bookmarks"
msgstr "书签"

#. type: Plain text
#: zsh.texi:35130
msgid ""
"The two functions @t{zfmark} and @t{zfgoto} allow you to `bookmark' the present location (host, user and directory) of the current FTP connection for later use.  The file to be used for storing and "
"retrieving bookmarks is given by the parameter @t{$ZFTP_BMFILE}; if not set when one of the two functions is called, it will be set to the file @t{.zfbkmarks} in the directory where your zsh startup files "
"live (usually @t{~})."
msgstr ""
"通过 @t{zfmark} 和 @t{zfgoto} 这两个函数，您可以为当前 FTP 连接的当前位置（主机、用户和目录）打上 `bookmark' ，以便日后使用。 用于存储和检索书签的文件由参数 @t{$ZFTP_BMFILE} 提供；如果调用这两个函数之一时"
"未设置，则将设置为 zsh 启动文件所在目录（通常为 @t{~}）中的文件 @t{.zfbkmarks}。"

#. type: findex
#: zsh.texi:35133
#, no-wrap
msgid "zfmark"
msgstr "zfmark"

#. type: item
#: zsh.texi:35134
#, no-wrap
msgid "@t{zfmark} [ @var{bookmark} ]"
msgstr "@t{zfmark} [ @var{bookmark} ]"

#. type: table
#: zsh.texi:35140
msgid ""
"If given an argument, mark the current host, user and directory under the name @var{bookmark} for later use by @t{zfgoto}.  If there is no connection open, use the values for the last connection "
"immediately before it was closed; it is an error if there was none.  Any existing bookmark under the same name will be silently replaced."
msgstr ""
"如果给定了参数，则会在 @var{bookmark} 名称下标记当前主机、用户和目录，供 @t{zfgoto} 后续使用。 如果没有打开连接，则使用最后一个连接关闭前的值。 如果没有，则是错误。任何已存在的同名书签都将被无声替换。"

#. type: table
#: zsh.texi:35146
msgid ""
"If not given an argument, list the existing bookmarks and the points to which they refer in the form @var{user}@t{@@}@var{host}@t{:}@var{directory}; this is the format in which they are stored, and the "
"file may be edited directly."
msgstr "如果没有给定参数，则会以 @var{user}@t{@@}@var{host}@t{:}@var{directory} 的形式列出现有书签及其指向的点。这就是它们的存储格式，可以直接对文件进行编辑。"

#. type: findex
#: zsh.texi:35147
#, no-wrap
msgid "zfgoto"
msgstr "zfgoto"

#. type: item
#: zsh.texi:35148
#, no-wrap
msgid "@t{zfgoto} [ @t{-n} ] @var{bookmark}"
msgstr "@t{zfgoto} [ @t{-n} ] @var{bookmark}"

#. type: table
#: zsh.texi:35155
msgid ""
"Return to the location given by @var{bookmark}, as previously set by @t{zfmark}.  If the location has user `@t{ftp}' or `@t{anonymous}', open the connection with @t{zfanon}, so that no password is "
"required.  If the user and host parameters match those stored for the current session, if any, those will be used, and again no password is required.  Otherwise a password will be prompted for."
msgstr ""
"返回 @t{zfmark} 之前设置的 @var{bookmark} 指定的位置。 如果该位置有用户为 `@t{ftp}' 或 `@t{anonymous}'，则使用 @t{zfanon} 打开连接，因此无需密码。 如果用户和主机参数与当前会话存储的参数（如果有）匹配，则使"
"用这些参数，同样无需密码。 否则将提示输入密码。"

#. type: table
#: zsh.texi:35162
msgid ""
"With the option @t{-n}, the bookmark is taken to be a nickname stored by the @t{ncftp} program in its bookmark file, which is assumed to be @t{~/.ncftp/bookmarks}.  The function works identically in other "
"ways.  Note that there is no mechanism for adding or modifying @t{ncftp} bookmarks from the zftp functions."
msgstr ""
"使用选项 @t{-n}，书签将被视为 @t{ncftp} 程序存储在其书签文件中的昵称，该文件被假定为 @t{~/.ncftp/bookmarks}。 该函数在其他方面的工作原理相同。 请注意，zftp 函数中没有添加或修改 @t{ncftp} 书签的机制。"

#. type: subsection
#: zsh.texi:35167
#, no-wrap
msgid "Other functions"
msgstr "其它函数"

#. type: Plain text
#: zsh.texi:35172
msgid "Mostly, these functions will not be called directly (apart from @t{zfinit}), but are described here for completeness.  You may wish to alter @t{zftp_chpwd} and @t{zftp_progress}, in particular."
msgstr "大多数情况下，这些函数不会被直接调用（除了 @t{zfinit}），但为完整起见，还是在此介绍一下。 您可能希望对 @t{zftp_chpwd} 和 @t{zftp_progress} 进行修改。"

#. type: findex
#: zsh.texi:35175
#, no-wrap
msgid "zfinit"
msgstr "zfinit"

#. type: item
#: zsh.texi:35176
#, no-wrap
msgid "@t{zfinit} [ @t{-n} ]"
msgstr "@t{zfinit} [ @t{-n} ]"

#. type: table
#: zsh.texi:35180
msgid "As described above, this is used to initialize the zftp function system.  The @t{-n} option should be used if the zftp command is already built into the shell."
msgstr "如上所述，它用于初始化 zftp 函数系统。 如果 shell 已内置 zftp 命令，则应使用 @t{-n} 选项。"

#. type: findex
#: zsh.texi:35181
#, no-wrap
msgid "zfautocheck"
msgstr "zfautocheck"

#. type: item
#: zsh.texi:35182
#, no-wrap
msgid "@t{zfautocheck} [ @t{-dn} ]"
msgstr "@t{zfautocheck} [ @t{-dn} ]"

#. type: table
#: zsh.texi:35191
msgid ""
"This function is called to implement automatic reopening behaviour, as described in more detail below.  The options must appear in the first argument; @t{-n} prevents the command from changing to the old "
"directory, while @t{-d} prevents it from setting the variable @t{do_close}, which it otherwise does as a flag for automatically closing the connection after a transfer.  The host and directory for the "
"last session are stored in the variable @t{$zflastsession}, but the internal host/user/password parameters must also be correctly set."
msgstr ""
"调用该函数是为了实现自动重新打开行为，下文将详细介绍。 选项必须出现在第一个参数中；@t{-n}会阻止命令切换到旧目录，而 @t{-d} 则会阻止命令设置变量 @t{do_close}，否则命令会将其作为传输后自动关闭连接的标志。 最"
"后一次会话的主机和目录保存在变量 @t{$zflastsession} 中，但内部 host/user/password 参数也必须正确设置。"

#. type: findex
#: zsh.texi:35192
#, no-wrap
msgid "zfcd_match"
msgstr "zfcd_match"

#. type: t{#1}
#: zsh.texi:35193
#, no-wrap
msgid "zfcd_match @var{prefix} @var{suffix}"
msgstr "zfcd_match @var{prefix} @var{suffix}"

#. type: table
#: zsh.texi:35200
msgid ""
"This performs matching for completion of remote directory names.  If the remote server is UNIX, it will attempt to persuade the server to list the remote directory with subdirectories marked, which "
"usually works but is not guaranteed.  On other hosts it simply calls @t{zfget_match} and hence completes all files, not just directories.  On some systems, directories may not even look like filenames."
msgstr ""
"这将执行远程目录名的补全匹配。 如果远程服务器是 UNIX，它将尝试说服服务器列出远程目录，并标注子目录，这通常有效，但不能保证。 在其他主机上，它只需调用 @t{zfget_match}，从而补全所有文件，而不仅仅是目录。 在"
"某些系统中，目录可能看起来甚至不像文件名。"

#. type: findex
#: zsh.texi:35201
#, no-wrap
msgid "zfget_match"
msgstr "zfget_match"

#. type: t{#1}
#: zsh.texi:35202
#, no-wrap
msgid "zfget_match @var{prefix} @var{suffix}"
msgstr "zfget_match @var{prefix} @var{suffix}"

#. type: table
#: zsh.texi:35208
msgid ""
"This performs matching for completion of remote filenames.  It caches files for the current directory (only) in the shell parameter @t{$zftp_fcache}.  It is in the form to be called by the @t{-K} option "
"of @t{compctl}, but also works when called from a widget-style completion function with @var{prefix} and @var{suffix} set appropriately."
msgstr ""
"该功能用于补全远程文件名的匹配。 它会将当前目录下的文件缓存到 shell 参数 @t{$zftp_fcache} 中。 它采用 @t{compctl} 的 @t{-K} 选项调用的形式，但也可在适当设置 @var{prefix} 和 @var{suffix} 的小部件式补全函数"
"中调用。"

#. type: findex
#: zsh.texi:35209
#, no-wrap
msgid "zfrglob"
msgstr "zfrglob"

#. type: t{#1}
#: zsh.texi:35210
#, no-wrap
msgid "zfrglob @var{varname}"
msgstr "zfrglob @var{varname}"

#. type: table
#: zsh.texi:35215
msgid ""
"Perform remote globbing, as describes in more detail below.  @var{varname} is the name of a variable containing the pattern to be expanded; if there were any matches, the same variable will be set to the "
"expanded set of filenames on return."
msgstr "执行远程 globbing，详情如下。 @var{varname} 是一个变量的名称，包含要扩展的模式；如果有任何匹配，返回时将把同一变量设置为扩展后的文件名集。"

#. type: findex
#: zsh.texi:35216
#, no-wrap
msgid "zfrtime"
msgstr "zfrtime"

#. type: item
#: zsh.texi:35217
#, no-wrap
msgid "@t{zfrtime} @var{lfile} @var{rfile} [ @var{time} ]"
msgstr "@t{zfrtime} @var{lfile} @var{rfile} [ @var{time} ]"

#. type: table
#: zsh.texi:35223
msgid ""
"Set the local file @var{lfile} to have the same modification time as the remote file @var{rfile}, or the explicit time @var{time} in FTP format @t{CCYYMMDDhhmmSS} for the GMT timezone.  This uses the "
"shell's @t{zsh/datetime} module to perform the conversion from GMT to local time."
msgstr ""
"设置本地文件 @var{lfile} 的修改时间与远程文件 @var{rfile} 的修改时间相同，或为 GMT 时区设置 FTP 格式 @t{CCYYMMDDhhmmSS} 的显式时间 @var{time} 。 这将使用 shell 的 @t{zsh/datetime} 模块执行从 GMT 到本地时间"
"的转换。"

#. type: findex
#: zsh.texi:35224
#, no-wrap
msgid "zftp_chpwd, supplied version"
msgstr "zftp_chpwd, 提供的版本"

#. type: table
#: zsh.texi:35232
msgid ""
"This function is called every time a connection is opened, or closed, or the remote directory changes.  This version alters the title bar of an @t{xterm}-compatible or @t{sun-cmd} terminal emulator to "
"reflect the local and remote hostnames and current directories.  It works best when combined with the function @t{chpwd}.  In particular, a function of the form"
msgstr ""
"每次打开、关闭连接或更改远程目录时，都会调用该函数。 该版本会更改 @t{xterm} 兼容终端或 @t{sun-cmd} 终端模拟器的标题栏，以反映本地和远程主机名及当前目录。 与函数 @t{chpwd} 结合使用效果最佳。 特别是，下面形"
"式的函数"

#. type: example
#: zsh.texi:35242
#, no-wrap
msgid ""
"chpwd() @{\n"
"  if [[ -n $ZFTP_USER ]]; then\n"
"    zftp_chpwd\n"
"  else\n"
"    # usual chpwd e.g put host:directory in title bar\n"
"  fi\n"
"@}\n"
msgstr ""
"chpwd() @{\n"
"  if [[ -n $ZFTP_USER ]]; then\n"
"    zftp_chpwd\n"
"  else\n"
"    # usual chpwd e.g put host:directory in title bar\n"
"  fi\n"
"@}\n"

#. type: table
#: zsh.texi:35246
msgid "fits in well."
msgstr "非常适合。"

#. type: findex
#: zsh.texi:35247
#, no-wrap
msgid "zftp_progress, supplied version"
msgstr "zftp_progress, 提供的版本"

#. type: table
#: zsh.texi:35257
msgid ""
"This function shows the status of the transfer.  It will not write anything unless the output is going to a terminal; however, if you transfer files in the background, you should turn off progress reports "
"by hand using `@t{zstyle ':zftp:*' progress none}'.  Note also that if you alter it, any output @emph{must} be to standard error, as standard output may be a file being received.  The form of the progress "
"meter, or whether it is used at all, can be configured without altering the function, as described in the next section."
msgstr ""
"此函数显示传输状态。 除非输出到终端，否则不会写入任何内容；不过，如果在后台传输文件，则应使用 `@t{zstyle ':zftp:*' progress none}' 手动关闭进度报告。 还要注意的是，如果更改了进度表，任何输出都 @emph{必须} "
"输出到标准错误，因为标准输出可能是正在接收的文件。 进度表的形式，或者是否使用进度表，都可以在不修改函数的情况下进行配置，详见下一节。"

#. type: t{#1}
#: zsh.texi:35258 zsh.texi:35259
#, no-wrap
msgid "zffcache"
msgstr "zffcache"

#. type: table
#: zsh.texi:35262
msgid "This is used to implement caching of files in the current directory for each session separately.  It is used by @t{zfget_match} and @t{zfrglob}."
msgstr "用于为每个会话分别缓存当前目录中的文件。 它被 @t{zfget_match} 和 @t{zfrglob} 使用。"

#. type: subsection
#: zsh.texi:35273 zsh.texi:36068 zsh.texi:36348 zsh.texi:36668
#, no-wrap
msgid "Configuration"
msgstr "配置"

#. type: cindex
#: zsh.texi:35275
#, no-wrap
msgid "zftp function system, configuration"
msgstr "zftp 函数系统, 配置"

#. type: cindex
#: zsh.texi:35276
#, no-wrap
msgid "zftp function system, styles"
msgstr "zftp 函数系统, 样式"

#. type: cindex
#: zsh.texi:35277
#, no-wrap
msgid "styles in zftp functions"
msgstr "zftp 函数中的样式"

#. type: Plain text
#: zsh.texi:35296
msgid ""
"Various styles are available using the standard shell style mechanism, described in @ref{The zsh/zutil Module}. Briefly, the command `@t{zstyle ':zftp:*'} @var{style} @var{value} ...'.  defines the "
"@var{style} to have value @var{value}; more than one value may be given, although that is not useful in the cases described here.  These values will then be used throughout the zftp function system.  For "
"more precise control, the first argument, which gives a pattern that matches @emph{contexts} in which the style applies, can be modified to include a particular function, as for example `@t{:zftp:zfget}': "
"the style will then have the given value only in the @t{zfget} function, and will override styles set under `@t{:zftp:*}'.  Note that only the top level function name, as called by the user, is used; "
"calling of lower level functions is transparent to the user.  Hence modifications to the title bar in @t{zftp_chpwd} use the contexts @t{:zftp:zfopen}, @t{:zftp:zfcd}, etc., depending where it was called "
"from.  The following styles are understood:"
msgstr ""
"使用标准 shell 样式机制可获得各种样式，详见 @ref{zsh/zutil 模块}。简而言之，命令  `@t{zstyle ':zftp:*'} @var{style} @var{value} ...'.  定义 @var{style} 的值为 @var{value}；可以给出一个以上的值，但在这里描"
"述的情况下并无用处。 这些值将在整个 zftp 函数系统中使用。  为了实现更精确的控制，可以修改第一个参数（该参数给出了与 @emph{contexts} 匹配的模式，在该模式中，样式适用）以包含特定函数，例如 `@t{:zftp:"
"zfget}'： 这样，样式将仅在 @t{zfget} 函数中具有给定值，并覆盖在 `@t{:zftp:*}'下设置的样式。 需要注意的是，只有用户调用的顶级函数名称才会被使用；低级函数的调用对用户是透明的。 因此，对 @t{zftp_chpwd} 中标题"
"栏的修改会使用 @t{:zftp:zfopen}、@t{:zftp:zfcd} 等上下文，具体取决于从何处调用。 可理解以下样式："

#. type: kindex
#: zsh.texi:35299
#, no-wrap
msgid "progress, zftp style"
msgstr "progress, zftp 样式"

#. type: t{#1}
#: zsh.texi:35300
#, no-wrap
msgid "progress"
msgstr "progress"

#. type: table
#: zsh.texi:35310
msgid ""
"Controls the way that @t{zftp_progress} reports on the progress of a transfer.  If empty, unset, or `@t{none}', no progress report is made; if `@t{bar}' a growing bar of inverse video is shown; if "
"`@t{percent}' (or any other string, though this may change in future), the percentage of the file transferred is shown.  The bar meter requires that the width of the terminal be available via the "
"@t{$COLUMNS} parameter (normally this is set automatically).  If the size of the file being transferred is not available, @t{bar} and @t{percent} meters will simply show the number of bytes transferred so "
"far."
msgstr ""
"控制 @t{zftp_progress} 报告传输进度的方式。 如果为空、未设置或 `@t{none}'，则不会报告传输进度；如果为`@t{bar}' ，则会显示一个不断增长的反向视频条；如果为 `@t{percent}' （或其他字符串，但将来可能会更改），"
"则会显示已传输文件的百分比。 条形仪表要求通过 @t{$COLUMNS} 参数提供终端的宽度（通常会自动设置）。 如果无法提供正在传输的文件大小，@t{bar} 和 @t{percent} 仪表将只显示目前传输的字节数。"

#. type: table
#: zsh.texi:35314
msgid "When @t{zfinit} is run, if this style is not defined for the context @t{:zftp:*}, it will be set to `bar'."
msgstr "运行 @t{zfinit} 时，如果没有为上下文 @t{:zftp:*} 定义此样式，则会将其设置为 `bar'。"

#. type: kindex
#: zsh.texi:35315
#, no-wrap
msgid "update, zftp style"
msgstr "update, zftp 样式"

#. type: t{#1}
#: zsh.texi:35316
#, no-wrap
msgid "update"
msgstr "update"

#. type: table
#: zsh.texi:35320
msgid ""
"Specifies the minimum time interval between updates of the progress meter in seconds.  No update is made unless new data has been received, so the actual time interval is limited only by @t{$ZFTP_TIMEOUT}."
msgstr "指定进度表更新的最小时间间隔（秒）。 除非收到新数据，否则不会进行更新，因此实际时间间隔仅受 @t{$ZFTP_TIMEOUT} 的限制。"

#. type: table
#: zsh.texi:35323 zsh.texi:35337
msgid "As described for @t{progress}, @t{zfinit} will force this to default to 1."
msgstr "如 @t{progress} 所述，@t{zfinit} 会强制将其默认为 1。"

#. type: kindex
#: zsh.texi:35324
#, no-wrap
msgid "remote-glob, zftp style"
msgstr "remote-glob, zftp 样式"

#. type: t{#1}
#: zsh.texi:35325
#, no-wrap
msgid "remote-glob"
msgstr "remote-glob"

#. type: table
#: zsh.texi:35328
msgid "If set to `@t{1}', `@t{yes}' or `@t{true}', filename generation (globbing) is performed on the remote machine instead of by zsh itself; see below."
msgstr "如果设置为 `@t{1}', `@t{yes}' 或 `@t{true}'，文件名生成（globbing）将在远程机器上执行，而不是由 zsh 本身执行；见下文。"

#. type: kindex
#: zsh.texi:35329
#, no-wrap
msgid "titlebar, zftp style"
msgstr "titlebar, zftp 样式"

#. type: t{#1}
#: zsh.texi:35330
#, no-wrap
msgid "titlebar"
msgstr "titlebar"

#. type: table
#: zsh.texi:35334
msgid "If set to `@t{1}', `@t{yes}' or `@t{true}', @t{zftp_chpwd} will put the remote host and remote directory into the titlebar of terminal emulators such as xterm or sun-cmd that allow this."
msgstr "如果设置为 `@t{1}', `@t{yes}' 或 `@t{true}'，那么 @t{zftp_chpwd} 将在 xterm 或 sun-cmd 等终端模拟器的标题栏中显示远程主机和远程目录。"

#. type: kindex
#: zsh.texi:35338
#, no-wrap
msgid "chpwd, zftp style"
msgstr "chpwd, zftp 样式"

#. type: table
#: zsh.texi:35344
msgid ""
"If set to `@t{1}' `@t{yes}' or `@t{true}', @t{zftp_chpwd} will call the function @t{chpwd} when a connection is closed.  This is useful if the remote host details were put into the terminal title bar by "
"@t{zftp_chpwd} and your usual @t{chpwd} also modifies the title bar."
msgstr ""
"如果设置为 `@t{1}' `@t{yes}' 或`@t{true}'，@t{zftp_chpwd} 将在连接关闭时调用函数 @t{chpwd}。 如果远程主机的详细信息被 @t{zftp_chpwd} 放进了终端标题栏，而您常用的 @t{chpwd} 也会修改标题栏，那么这将非常有"
"用。"

#. type: table
#: zsh.texi:35349
msgid "When @t{zfinit} is run, it will determine whether @t{chpwd} exists and if so it will set the default value for the style to 1 if none exists already."
msgstr "运行 @t{zfinit} 时，它会判断 @t{chpwd} 是否存在，如果存在，则会将样式的默认值设为 1,如果尚未存在样式。"

#. type: Plain text
#: zsh.texi:35356
msgid "Note that there is also an associative array @t{zfconfig} which contains values used by the function system.  This should not be modified or overwritten."
msgstr "请注意，还有一个关联数组 @t{zfconfig}，其中包含函数系统使用的值。 该数组不应被修改或覆盖。"

#. type: subsection
#: zsh.texi:35359
#, no-wrap
msgid "Remote globbing"
msgstr "远程 globbing"

#. type: cindex
#: zsh.texi:35361
#, no-wrap
msgid "zftp function system, remote globbing"
msgstr "zftp 函数系统, 远程 globbing"

#. type: Plain text
#: zsh.texi:35377
msgid ""
"The commands for retrieving files usually perform filename generation (globbing) on their arguments; this can be turned off by passing the option @t{-G} to each of the commands.  Normally this operates by "
"retrieving a complete list of files for the directory in question, then matching these locally against the pattern supplied.  This has the advantage that the full range of zsh patterns (respecting the "
"setting of the option @t{EXTENDED_GLOB}) can be used.  However, it means that the directory part of a filename will not be expanded and must be given exactly.  If the remote server does not support the "
"UNIX directory semantics, directory handling is problematic and it is recommended that globbing only be used within the current directory.  The list of files in the current directory, if retrieved, will "
"be cached, so that subsequent globs in the same directory without an intervening @t{zfcd} are much faster."
msgstr ""
"检索文件的命令通常会对其参数执行文件名生成（globbing）；通过向每个命令传递选项 @t{-G} 可以关闭该功能。 通常情况下，该操作是检索相关目录的完整文件列表，然后将这些文件与提供的模式进行本地匹配。 这样做的好处"
"是可以使用全部的 zsh 模式（与选项 @t{EXTENDED_GLOB} 的设置一致）。 不过，这意味着文件名的目录部分不会被展开，必须准确给出。 如果远程服务器不支持 UNIX 目录语义，那么目录处理就会出现问题，因此建议只在当前目"
"录下使用 globbing。 如果检索到当前目录下的文件列表，则会将其缓存起来，这样在同一目录下进行后续的 globb 操作时，不需要 @t{zfcd} 的介入，速度会更快。"

#. type: Plain text
#: zsh.texi:35385
msgid ""
"If the @t{remote-glob} style (see above) is set, globbing is instead performed on the remote host: the server is asked for a list of matching files.  This is highly dependent on how the server is "
"implemented, though typically UNIX servers will provide support for basic glob patterns.  This may in some cases be faster, as it avoids retrieving the entire list of directory contents."
msgstr ""
"如果设置了 @t{remote-glob} 样式（见上文），则会在远程主机上执行 globbing：要求服务器提供匹配文件的列表。 这在很大程度上取决于服务器是如何实现的，不过通常 UNIX 服务器会提供对基本 glob 模式的支持。 在某些情"
"况下，这可能会更快，因为它避免了检索整个目录内容列表。"

#. type: subsection
#: zsh.texi:35388
#, no-wrap
msgid "Automatic and temporary reopening"
msgstr "自动和临时重新打开"

#. type: cindex
#: zsh.texi:35390
#, no-wrap
msgid "zftp function system, automatic reopening"
msgstr "zftp 函数系统, 自动重新打开"

#. type: Plain text
#: zsh.texi:35398
msgid ""
"As described for the @t{zfopen} command, a subsequent @t{zfopen} with no parameters will reopen the connection to the last host (this includes connections made with the @t{zfanon} command).  Opened in "
"this fashion, the connection starts in the default remote directory and will remain open until explicitly closed."
msgstr ""
"如 @t{zfopen} 命令所述，后续不带参数的 @t{zfopen} 将重新打开与上一个主机的连接（包括使用 @t{zfanon} 命令建立的连接）。 以这种方式打开的连接会从默认远程目录开始，并一直保持打开状态，直到显式关闭为止。"

#. type: Plain text
#: zsh.texi:35408
msgid ""
"Automatic re-opening is also available.  If a connection is not currently open and a command requiring a connection is given, the last connection is implicitly reopened.  In this case the directory which "
"was current when the connection was closed again becomes the current directory (unless, of course, the command given changes it).  Automatic reopening will also take place if the connection was close by "
"the remote server for whatever reason (e.g. a timeout).  It is not available if the @t{-1} option to @t{zfopen} or @t{zfanon} was used."
msgstr ""
"也可以自动重新打开。 如果连接当前未打开，而给出的命令需要连接，则会隐式地重新打开上一个连接。 在这种情况下，关闭连接时的当前目录将再次成为当前目录（当然，除非所下达的命令更改了该目录）。 如果远程服务器因某"
"种原因（如超时）关闭了连接，也会自动重新打开连接。 如果使用了 @t{zfopen} 或 @t{zfanon} 的 @t{-1} 选项，则不可用。"

#. type: Plain text
#: zsh.texi:35417
msgid ""
"Furthermore, if the command issued is a file transfer, the connection will be closed after the transfer is finished, hence providing a one-shot mode for transfers.  This does not apply to directory "
"changing or listing commands; for example a @t{zfdir} may reopen a connection but will leave it open.  Also, automatic closure will only ever happen in the same command as automatic opening, i.e a "
"@t{zfdir} directly followed by a @t{zfget} will never close the connection automatically."
msgstr ""
"此外，如果发出的命令是文件传输，连接将在传输完成后关闭，从而为传输提供了一次性模式。 这不适用于目录更改或列表命令；例如，@t{zfdir} 可能会重新打开连接，但会保持打开状态。 此外，自动关闭只会发生在与自动打开"
"相同的命令中，即 @t{zfdir} 之后直接执行 @t{zfget} 永远不会自动关闭连接。"

#. type: Plain text
#: zsh.texi:35421
msgid "Information about the previous connection is given by the @t{zfstat} function.  So, for example, if that reports:"
msgstr "@t{zfstat} 函数提供了前一次连接的信息。 因此，举例来说，如果报告:"

#. type: example
#: zsh.texi:35427
#, no-wrap
msgid ""
"Session:        default\n"
"Not connected.\n"
"Last session:   ftp.bar.com:/pub/textfiles\n"
msgstr ""
"Session:        default\n"
"Not connected.\n"
"Last session:   ftp.bar.com:/pub/textfiles\n"

#. type: Plain text
#: zsh.texi:35434
msgid ""
"then the command @t{zfget file.txt} will attempt to reopen a connection to @t{ftp.bar.com}, retrieve the file @t{/pub/textfiles/file.txt}, and immediately close the connection again.  On the other hand, "
"@t{zfcd ..} will open the connection in the directory @t{/pub} and leave it open."
msgstr ""
"那么命令 @t{zfget file.txt} 将尝试重新打开与 @t{ftp.bar.com} 的连接，获取文件 @t{/pub/textfiles/file.txt}，然后立即再次关闭连接。 另一方面， @t{zfcd ..} 将在 @t{/pub} 目录中打开连接，并保持打开状态。"

#. type: Plain text
#: zsh.texi:35439
msgid "Note that all the above is local to each session; if you return to a previous session, the connection for that session is the one which will be reopened."
msgstr "请注意，上述所有内容都是每个会话的本地内容；如果返回到以前的会话，则会重新打开该会话的连接。"

#. type: Plain text
#: zsh.texi:35454
msgid ""
"Completion of local and remote files, directories, sessions and bookmarks is supported.  The older, @t{compctl}-style completion is defined when @t{zfinit} is called; support for the new widget-based "
"completion system is provided in the function @t{Completion/Zsh/Command/_zftp}, which should be installed with the other functions of the completion system and hence should automatically be available."
msgstr ""
"支持本地和远程文件、目录、会话和书签的补全。 调用 @t{zfinit} 时定义了较早的、@t{compctl} 风格的补全；对基于小部件的新补全系统的支持在函数 @t{Completion/Zsh/Command/_zftp} 中提供，该函数应该已经与补全系统的"
"其他函数一起安装，因此应自动可用。"

#. type: cindex
#: zsh.texi:35458
#, no-wrap
msgid "user contributions"
msgstr "用户贡献"

#. type: Plain text
#: zsh.texi:35469
msgid ""
"The Zsh source distribution includes a number of items contributed by the user community.  These are not inherently a part of the shell, and some may not be available in every zsh installation.  The most "
"significant of these are documented here.  For documentation on other contributed items such as shell functions, look for comments in the function source files."
msgstr ""
"Zsh 源代码发行版包含许多由用户社区贡献的项目。 这些项目本身并不是 shell 的一部分，而且有些项目可能并不是每个 zsh 安装都可用。 这里记录了其中最重要的部分。 有关其他贡献项目（如 shell 函数）的文档，请查看函"
"数源文件中的注释。"

#. type: node
#: zsh.texi:35486 zsh.texi:35932 zsh.texi:36273
#, no-wrap
msgid "Recent Directories"
msgstr "最新目录"

#. type: subsection
#: zsh.texi:35493
#, no-wrap
msgid "Accessing On-Line Help"
msgstr "访问在线帮助"

#. type: cindex
#: zsh.texi:35495
#, no-wrap
msgid "helpfiles utility"
msgstr "帮助文件实用工具"

#. type: Plain text
#: zsh.texi:35505
msgid ""
"The key sequence @t{ESC h} is normally bound by ZLE to execute the @t{run-help} widget (see @ref{Zsh Line Editor}).  This invokes the @t{run-help} command with the command word from the current input line "
"as its argument.  By default, @t{run-help} is an alias for the @t{man} command, so this often fails when the command word is a shell builtin or a user-defined function.  By redefining the @t{run-help} "
"alias, one can improve the on-line help provided by the shell."
msgstr ""
"键序 @t{ESC h} 通常被 ZLE 绑定为执行 @t{run-help} 小部件（参见 @ref{Zsh 行编辑器}）。 这将调用 @t{run-help} 命令，并将当前输入行中的命令字作为其参数。 默认情况下，@t{run-help} 是 @t{man} 命令的别名，因此当"
"命令字是 shell 内置命令或用户自定义函数时，调用 @t{run-help} 往往会失败。 通过重新定义 @t{run-help} 别名，可以改进 shell 提供的联机帮助。"

#. type: Plain text
#: zsh.texi:35513
msgid ""
"The @t{helpfiles} utility, found in the @t{Util} directory of the distribution, is a Perl program that can be used to process the zsh manual to produce a separate help file for each shell builtin and for "
"many other shell features as well.  The autoloadable @t{run-help} function, found in @t{Functions/Misc}, searches for these helpfiles and performs several other tests to produce the most complete help "
"possible for the command."
msgstr ""
"@t{helpfiles} 工具位于发行版的 @t{Util} 目录中，是一个 Perl 程序，可用于处理 zsh 手册，为每个 shell 内置功能和许多其他 shell 功能生成单独的帮助文件。 可自动加载的 @t{Functions/Misc} 目录下的 @t{run-help} "
"函数会搜索这些帮助文件，并执行其他一些测试，为命令生成尽可能完整的帮助。"

#. type: Plain text
#: zsh.texi:35517
msgid "Help files are installed by default to a subdirectory of @t{/usr/share/zsh} or @t{/usr/local/share/zsh}."
msgstr "帮助文件默认安装在 @t{/usr/share/zsh} 或 @t{/usr/local/share/zsh} 的子目录下。"

#. type: Plain text
#: zsh.texi:35523
msgid ""
"To create your own help files with @t{helpfiles}, choose or create a directory where the individual command help files will reside.  For example, you might choose @t{~/zsh_help}.  If you unpacked the zsh "
"distribution in your home directory, you would use the commands:"
msgstr "要使用 @t{helpfiles} 创建自己的帮助文件，请选择或创建一个存放各个命令帮助文件的目录。 例如，你可以选择 @t{~/zsh_help}。 如果将 zsh 发行版解压到你的主目录，则可以使用以下命令："

#. type: example
#: zsh.texi:35528
#, no-wrap
msgid ""
"mkdir ~/zsh_help\n"
"perl ~/zsh-5.9/Util/helpfiles ~/zsh_help\n"
msgstr ""
"mkdir ~/zsh_help\n"
"perl ~/zsh-5.9/Util/helpfiles ~/zsh_help\n"

#. type: vindex
#: zsh.texi:35531
#, no-wrap
msgid "HELPDIR"
msgstr "HELPDIR"

#. type: Plain text
#: zsh.texi:35536
msgid ""
"The @t{HELPDIR} parameter tells @t{run-help} where to look for the help files. When unset, it uses the default installation path.  To use your own set of help files, set this to the appropriate path in "
"one of your startup files:"
msgstr "@t{HELPDIR} 参数用于告诉 @t{run-help} 从何处查找帮助文件。未设置时，将使用默认安装路径。 要使用自己的帮助文件集，请在启动文件中将其设置为相应的路径："

#. type: example
#: zsh.texi:35540
#, no-wrap
msgid "HELPDIR=~/zsh_help\n"
msgstr "HELPDIR=~/zsh_help\n"

#. type: findex
#: zsh.texi:35543
#, no-wrap
msgid "run-help, use of"
msgstr "run-help, use of"

#. type: Plain text
#: zsh.texi:35546
msgid "To use the @t{run-help} function, you need to add lines something like the following to your @t{.zshrc} or equivalent startup file:"
msgstr "要使用 @t{run-help} 函数，需要在 @t{.zshrc} 或类似的启动文件中添加如下行文："

#. type: example
#: zsh.texi:35551
#, no-wrap
msgid ""
"unalias run-help\n"
"autoload run-help\n"
msgstr ""
"unalias run-help\n"
"autoload run-help\n"

#. type: Plain text
#: zsh.texi:35559
msgid ""
"Note that in order for `@t{autoload run-help}' to work, the @t{run-help} file must be in one of the directories named in your @t{fpath} array (see @ref{Parameters Used By The Shell}).  This should already "
"be the case if you have a standard zsh installation; if it is not, copy @t{Functions/Misc/run-help} to an appropriate directory."
msgstr ""
"请注意，要使 `@t{autoload run-help}' 生效，@t{run-help} 文件必须位于 @t{fpath} 数组中指定的目录下（参见 @ref{Shell 使用的参数}）。 如果您安装的是标准 zsh，则应已存在该目录；如果没有，请将 @t{Functions/"
"Misc/run-help} 复制到适当的目录。"

#. type: subsection
#: zsh.texi:35562
#, no-wrap
msgid "Recompiling Functions"
msgstr "重新编译函数"

#. type: cindex
#: zsh.texi:35564
#, no-wrap
msgid "functions, recompiling"
msgstr "函数, 重新编译"

#. type: cindex
#: zsh.texi:35565
#, no-wrap
msgid "zrecompile utility"
msgstr "zrecompile 实用工具"

#. type: Plain text
#: zsh.texi:35576
msgid ""
"If you frequently edit your zsh functions, or periodically update your zsh installation to track the latest developments, you may find that function digests compiled with the @t{zcompile} builtin are "
"frequently out of date with respect to the function source files.  This is not usually a problem, because zsh always looks for the newest file when loading a function, but it may cause slower shell "
"startup and function loading.  Also, if a digest file is explicitly used as an element of @t{fpath}, zsh won't check whether any of its source files has changed."
msgstr ""
"如果您经常编辑您的 zsh 函数，或定期更新您的 zsh 安装以跟踪最新开发进展，您可能会发现使用 @t{zcompile} 内置命令编译的函数摘要经常会比函数源文件过时。 这通常不是问题，因为 zsh 在加载函数时总是会查找最新的文"
"件，但它可能会导致 shell 启动和函数加载速度变慢。 此外，如果摘要文件被显式地用作 @t{fpath} 的元素，zsh 将不会检查其源文件是否已更改。"

#. type: Plain text
#: zsh.texi:35580
msgid "The @t{zrecompile} autoloadable function, found in @t{Functions/Misc}, can be used to keep function digests up to date."
msgstr "@t{Functions/Misc} 中的 @t{zrecompile} 可自动加载函数可用于更新函数摘要。"

#. type: t{#1}
#: zsh.texi:35583 zsh.texi:41208
#, no-wrap
msgid "zrecompile"
msgstr "zrecompile"

#. type: item
#: zsh.texi:35584
#, no-wrap
msgid "@t{zrecompile} [ @t{-qt} ] [ @var{name} ... ]"
msgstr "@t{zrecompile} [ @t{-qt} ] [ @var{name} ... ]"

#. type: itemx
#: zsh.texi:35585
#, no-wrap
msgid "@t{zrecompile} [ @t{-qt} ] @t{-p} @var{arg} ... [ @t{-}@t{-} @var{arg} ... ]"
msgstr "@t{zrecompile} [ @t{-qt} ] @t{-p} @var{arg} ... [ @t{-}@t{-} @var{arg} ... ]"

#. type: table
#: zsh.texi:35590
msgid ""
"This tries to find @t{*.zwc} files and automatically re-compile them if at least one of the original files is newer than the compiled file.  This works only if the names stored in the compiled files are "
"full paths or are relative to the directory that contains the @t{.zwc} file."
msgstr "此功能会尝试查找 @t{*.zwc} 文件，并在至少一个原始文件比编译文件新的情况下自动重新编译它们。 只有当编译文件中存储的名称是全路径或相对于包含 @t{.zwc} 文件的目录时，此功能才会起作用。"

#. type: table
#: zsh.texi:35596
msgid ""
"In the first form, each @var{name} is the name of a compiled file or a directory containing @t{*.zwc} files that should be checked.  If no arguments are given, the directories and @t{*.zwc} files in "
"@t{fpath} are used."
msgstr "在第一种形式中，每个 @var{name} 是一个编译文件的名称，或者是一个包含 @t{*.zwc} 文件的目录的名称,这些应该被检查。 如果没有给出参数，则使用 @t{fpath} 中的目录和 @t{*.zwc} 文件。"

#. type: table
#: zsh.texi:35602
msgid ""
"When @t{-t} is given, no compilation is performed, but a return status of zero (true) is set if there are files that need to be re-compiled and non-zero (false) otherwise.  The @t{-q} option quiets the "
"chatty output that describes what @t{zrecompile} is doing."
msgstr "如果给出 @t{-t}，则不执行编译，但如果有文件需要重新编译，则返回状态为零（true），否则返回状态为非零（false）。 使用 @t{-q} 选项时，@t{zrecompile} 会静默输出。"

#. type: table
#: zsh.texi:35607
msgid "Without the @t{-t} option, the return status is zero if all files that needed re-compilation could be compiled and non-zero if compilation for at least one of the files failed."
msgstr "如果不使用 @t{-t} 选项，所有需要重新编译的文件都编译成功，则返回状态为零；如果至少有一个文件编译失败，则返回状态为非零。"

#. type: table
#: zsh.texi:35612
msgid "If the @t{-p} option is given, the @var{arg}s are interpreted as one or more sets of arguments for @t{zcompile}, separated by `@t{-}@t{-}'.  For example:"
msgstr "如果给出 @t{-p} 选项，则 @var{arg}s 将被解释为 @t{zcompile} 的一个或多个参数集，并用 `@t{-}@t{-}' 分隔。 例如:"

#. type: example
#: zsh.texi:35619
#, no-wrap
msgid ""
"zrecompile -p \\ \n"
"           -R ~/.zshrc -- \\ \n"
"           -M ~/.zcompdump -- \\ \n"
"           ~/zsh/comp.zwc ~/zsh/Completion/*/_*\n"
msgstr ""
"zrecompile -p \\ \n"
"           -R ~/.zshrc -- \\ \n"
"           -M ~/.zcompdump -- \\ \n"
"           ~/zsh/comp.zwc ~/zsh/Completion/*/_*\n"

#. type: table
#: zsh.texi:35628
msgid ""
"This compiles @t{~/.zshrc} into @t{~/.zshrc.zwc} if that doesn't exist or if it is older than @t{~/.zshrc}. The compiled file will be marked for reading instead of mapping. The same is done for @t{~/."
"zcompdump} and @t{~/.zcompdump.zwc}, but this compiled file is marked for mapping. The last line re-creates the file @t{~/zsh/comp.zwc} if any of the files matching the given pattern is newer than it."
msgstr ""
"如果  @t{~/.zshrc.zwc} 不存在或比 @t{~/.zshrc} 旧，则会将 @t{~/.zshrc} 编译成 @t{~/.zshrc.zwc}。编译后的文件将被标记为用于读取文件，而不是映射文件。对于 @t{~/.zcompdump} 和 @t{~/.zcompdump.zwc} 也是如此，"
"但该编译文件会被标记为用于映射文件。最后一行将重新创建文件 @t{~/zsh/comp.zwc}，前提是任何与给定模式匹配的文件都比它新。"

#. type: table
#: zsh.texi:35632
msgid "Without the @t{-p} option, @t{zrecompile} does not create function digests that do not already exist, nor does it add new functions to the digest."
msgstr "如果没有 @t{-p} 选项，@t{zrecompile} 不会创建不存在的函数的摘要，也不会向摘要中添加新函数。"

#. type: Plain text
#: zsh.texi:35639
msgid "The following shell loop is an example of a method for creating function digests for all functions in your @t{fpath}, assuming that you have write permission to the directories:"
msgstr "下面的 shell 循环是为 @t{fpath} 中的所有函数创建函数摘要的方法示例，前提是你对目录有写入权限："

#. type: example
#: zsh.texi:35657
#, no-wrap
msgid ""
"for ((i=1; i <= $#fpath; ++i)); do\n"
"  dir=$fpath[i]\n"
"  zwc=$@{dir:t@}.zwc\n"
"  if [[ $dir == (.|..) || $dir == (.|..)/* ]]; then\n"
"    continue\n"
"  fi\n"
"  files=($dir/*(N-.))\n"
"  if [[ -w $dir:h && -n $files ]]; then\n"
"    files=($@{$@{(M)files%/*/*@}#/@})\n"
"    if ( cd $dir:h &&\n"
"         zrecompile -p -U -z $zwc $files ); then\n"
"      fpath[i]=$fpath[i].zwc\n"
"    fi\n"
"  fi\n"
"done\n"
msgstr ""
"for ((i=1; i <= $#fpath; ++i)); do\n"
"  dir=$fpath[i]\n"
"  zwc=$@{dir:t@}.zwc\n"
"  if [[ $dir == (.|..) || $dir == (.|..)/* ]]; then\n"
"    continue\n"
"  fi\n"
"  files=($dir/*(N-.))\n"
"  if [[ -w $dir:h && -n $files ]]; then\n"
"    files=($@{$@{(M)files%/*/*@}#/@})\n"
"    if ( cd $dir:h &&\n"
"         zrecompile -p -U -z $zwc $files ); then\n"
"      fpath[i]=$fpath[i].zwc\n"
"    fi\n"
"  fi\n"
"done\n"

#. type: Plain text
#: zsh.texi:35663
msgid "The @t{-U} and @t{-z} options are appropriate for functions in the default zsh installation @t{fpath}; you may need to use different options for your personal function directories."
msgstr "@t{-U} 和 @t{-z} 选项适用于默认 zsh 安装 @t{fpath} 中的函数；对于个人函数目录，可能需要使用不同的选项。"

#. type: Plain text
#: zsh.texi:35668
msgid "Once the digests have been created and your @t{fpath} modified to refer to them, you can keep them up to date by running @t{zrecompile} with no arguments."
msgstr "一旦创建了摘要，并修改了 @t{fpath} 以引用它们，就可以通过运行不带参数的 @t{zrecompile} 来保持更新。"

#. type: subsection
#: zsh.texi:35671
#, no-wrap
msgid "Keyboard Definition"
msgstr "键盘定义"

#. type: cindex
#: zsh.texi:35673
#, no-wrap
msgid "keyboard definition"
msgstr "键盘定义"

#. type: t{#1}
#: zsh.texi:35676 zsh.texi:41092
#, no-wrap
msgid "zkbd"
msgstr "zkbd"

#. type: Plain text
#: zsh.texi:35682
msgid ""
"The large number of possible combinations of keyboards, workstations, terminals, emulators, and window systems makes it impossible for zsh to have built-in key bindings for every situation.  The @t{zkbd} "
"utility, found in @t{Functions/Misc}, can help you quickly create key bindings for your configuration."
msgstr "由于键盘、工作站、终端、模拟器和窗口系统可能存在大量组合，zsh 不可能为每种情况都提供内置的按键绑定。 @t{Functions/Misc} 中的 @t{zkbd} 工具可以帮助你快速创建适合你配置的按键绑定。"

#. type: Plain text
#: zsh.texi:35685
msgid "Run @t{zkbd} either as an autoloaded function, or as a shell script:"
msgstr "以自动加载函数或 shell 脚本的形式运行 @t{zkbd}："

#. type: example
#: zsh.texi:35689
#, no-wrap
msgid "zsh -f ~/zsh-5.9/Functions/Misc/zkbd\n"
msgstr "zsh -f ~/zsh-5.9/Functions/Misc/zkbd\n"

#. type: Plain text
#: zsh.texi:35697
msgid ""
"When you run @t{zkbd}, it first asks you to enter your terminal type; if the default it offers is correct, just press return.  It then asks you to press a number of different keys to determine "
"characteristics of your keyboard and terminal; @t{zkbd} warns you if it finds anything out of the ordinary, such as a Delete key that sends neither @t{^H} nor @t{^?}."
msgstr ""
"运行 @t{zkbd} 时，它首先会要求你输入终端类型；如果它提供的默认类型正确，只需按回车键即可。然后，它会要求你按下一些不同的键，以确定键盘和终端的特征；  @t{zkbd} 如果发现任何异常，例如 Delete 键既不发送 "
"@t{^H} 也不发达 @t{^?}，就会发出警告。"

#. type: Plain text
#: zsh.texi:35704
msgid ""
"The keystrokes read by @t{zkbd} are recorded as a definition for an associative array named @t{key}, written to a file in the subdirectory @t{.zkbd} within either your @t{HOME} or @t{ZDOTDIR} directory.  "
"The name of the file is composed from the @t{TERM}, @t{VENDOR} and @t{OSTYPE} parameters, joined by hyphens."
msgstr "@t{zkbd} 读取的按键记录成名为 @t{key} 的关联数组的定义，并写入 @t{HOME} 或 @t{ZDOTDIR} 目录下 @t{.zkbd} 子目录中的文件。 文件名由 @t{TERM}、@t{VENDOR} 和 @t{OSTYPE} 参数组成，并用连字符连接。"

#. type: Plain text
#: zsh.texi:35709
msgid "You may read this file into your @t{.zshrc} or another startup file with the `@t{source}' or `@t{.}' commands, then reference the @t{key} parameter in bindkey commands, like this:"
msgstr "你可以使用 `@t{source}' 或 `@t{.}' 命令将该文件读入 @t{.zshrc} 或其他启动文件，然后在 bindkey 命令中引用 @t{key} 参数，就像这样："

#. type: example
#: zsh.texi:35716
#, no-wrap
msgid ""
"source $@{ZDOTDIR:-$HOME@}/.zkbd/$TERM-$VENDOR-$OSTYPE\n"
"[[ -n $@{key[Left]@} ]] && bindkey \"$@{key[Left]@}\" backward-char\n"
"[[ -n $@{key[Right]@} ]] && bindkey \"$@{key[Right]@}\" forward-char\n"
"# etc.\n"
msgstr ""
"source $@{ZDOTDIR:-$HOME@}/.zkbd/$TERM-$VENDOR-$OSTYPE\n"
"[[ -n $@{key[Left]@} ]] && bindkey \"$@{key[Left]@}\" backward-char\n"
"[[ -n $@{key[Right]@} ]] && bindkey \"$@{key[Right]@}\" forward-char\n"
"# etc.\n"

#. type: Plain text
#: zsh.texi:35724
msgid ""
"Note that in order for `@t{autoload zkbd}' to work, the @t{zkdb} file must be in one of the directories named in your @t{fpath} array (see @ref{Parameters Used By The Shell}).  This should already be the "
"case if you have a standard zsh installation; if it is not, copy @t{Functions/Misc/zkbd} to an appropriate directory."
msgstr ""
"请注意，要使 `@t{autoload zkbd}' 正常工作，@t{zkdb} 文件必须位于 @t{fpath} 数组中指定的目录下（参见 @ref{Shell 使用的参数}）。 如果您安装的是标准 zsh，则应该已经存在；如果没有，请将 @t{Functions/Misc/"
"zkbd} 复制到适当的目录。"

#. type: subsection
#: zsh.texi:35727
#, no-wrap
msgid "Dumping Shell State"
msgstr "转储 shell 状态"

#. type: cindex
#: zsh.texi:35729
#, no-wrap
msgid "reporter utility"
msgstr "reporter 实用工具"

#. type: Plain text
#: zsh.texi:35738
msgid ""
"Occasionally you may encounter what appears to be a bug in the shell, particularly if you are using a beta version of zsh or a development release.  Usually it is sufficient to send a description of the "
"problem to one of the zsh mailing lists (see @ref{Mailing Lists}), but sometimes one of the zsh developers will need to recreate your environment in order to track the problem down."
msgstr ""
"有时您可能会在 shell 中遇到看似错误的问题，尤其是当您使用的是 zsh 测试版或开发版时。 通常情况下，将问题描述发送到 zsh 邮件列表（请参阅 @ref{邮件列表}）就足够了，但有时 zsh 开发人员需要重新创建您的环境才能"
"跟踪问题。"

#. type: Plain text
#: zsh.texi:35746
msgid ""
"The script named @t{reporter}, found in the @t{Util} directory of the distribution, is provided for this purpose.  (It is also possible to @t{autoload reporter}, but @t{reporter} is not installed in "
"@t{fpath} by default.)  This script outputs a detailed dump of the shell state, in the form of another script that can be read with `@t{zsh -f}' to recreate that state."
msgstr ""
"发行版 @t{Util} 目录中名为 @t{reporter} 的脚本就是为此目的而提供的。 (也可以 @t{autoload reporter}，但 @t{reporter} 默认并未安装在 @t{fpath} 中）。这个脚本输出了shell状态的详细转储，以另一个脚本的形式呈"
"现，可以使用 `@t{zsh -f}' 读取，以重建该状态。"

#. type: Plain text
#: zsh.texi:35750
msgid "To use @t{reporter}, read the script into your shell with the `@t{.}' command and redirect the output into a file:"
msgstr "要使用 @t{reporter}，请使用 `@t{.}' 命令将脚本读入 shell，并将输出重定向到文件中："

#. type: example
#: zsh.texi:35754
#, no-wrap
msgid ". ~/zsh-5.9/Util/reporter > zsh.report\n"
msgstr ". ~/zsh-5.9/Util/reporter > zsh.report\n"

#. type: Plain text
#: zsh.texi:35761
msgid ""
"You should check the @t{zsh.report} file for any sensitive information such as passwords and delete them by hand before sending the script to the developers.  Also, as the output can be voluminous, it's "
"best to wait for the developers to ask for this information before sending it."
msgstr "您应该检查 @t{zsh.report} 文件中是否有密码等敏感信息，并在将脚本发送给开发人员之前手动删除它们。 此外，由于输出可能非常庞大，最好等开发人员询问这些信息后再发送。"

#. type: Plain text
#: zsh.texi:35771
msgid ""
"You can also use @t{reporter} to dump only a subset of the shell state.  This is sometimes useful for creating startup files for the first time.  Most of the output from reporter is far more detailed than "
"usually is necessary for a startup file, but the @t{aliases}, @t{options}, and @t{zstyles} states may be useful because they include only changes from the defaults.  The @t{bindings} state may be useful "
"if you have created any of your own keymaps, because @t{reporter} arranges to dump the keymap creation commands as well as the bindings for every keymap."
msgstr ""
"您还可以使用 @t{reporter} 只转储 shell 状态的子集。 这对于首次创建启动文件有时很有用。 大多数 reporter 输出的内容都比启动文件通常需要的内容要详细得多，但 @t{aliases}、@t{options} 和 @t{zstyles} 状态可能会"
"很有用，因为它们只包含了默认值之外的更改。 如果你创建了自己的键映射，@t{bindings} 状态可能会有用，因为 @t{reporter} 会转储键映射创建命令以及每个键映射的绑定。"

#. type: Plain text
#: zsh.texi:35779
msgid ""
"As is usual with automated tools, if you create a startup file with @t{reporter}, you should edit the results to remove unnecessary commands.  Note that if you're using the new completion system, you "
"should @emph{not} dump the @t{functions} state to your startup files with @t{reporter}; use the @t{compdump} function instead (see @ref{Completion System})."
msgstr ""
"按照自动化工具的惯例，如果使用 @t{reporter} 创建启动文件，则应编辑结果以删除不必要的命令。 请注意，如果您使用的是新的补全系统，则不应使用 @t{reporter} 将 @t{functions} 状态转储到启动文件中；而应使用 "
"@t{compdump} 函数（参见 @ref{补全系统}）。"

#. type: item
#: zsh.texi:35782
#, no-wrap
msgid "@t{reporter} [ @var{state} ... ]"
msgstr "@t{reporter} [ @var{state} ... ]"

#. type: findex
#: zsh.texi:35783
#, no-wrap
msgid "reporter"
msgstr "reporter"

#. type: table
#: zsh.texi:35786
msgid "Print to standard output the indicated subset of the current shell state.  The @var{state} arguments may be one or more of:"
msgstr "将当前 shell 状态的指定子集打印到标准输出。 @var{state} 参数可以是一个或多个："

#. type: t{#1}
#: zsh.texi:35789
#, no-wrap
msgid "all"
msgstr "all"

#. type: table
#: zsh.texi:35791
msgid "Output everything listed below."
msgstr "输出下面列出的所有内容。"

#. type: table
#: zsh.texi:35793
msgid "Output alias definitions."
msgstr "输出别名定义。"

#. type: t{#1}
#: zsh.texi:35793
#, no-wrap
msgid "bindings"
msgstr "bindings"

#. type: table
#: zsh.texi:35795
msgid "Output ZLE key maps and bindings."
msgstr "输出 ZLE 键映射和绑定。"

#. type: t{#1}
#: zsh.texi:35795
#, no-wrap
msgid "completion"
msgstr "completion"

#. type: table
#: zsh.texi:35798
msgid "Output old-style @t{compctl} commands.  New completion is covered by @t{functions} and @t{zstyles}."
msgstr "输出旧式 @t{compctl} 命令。 新的补全由 @t{functions} 和 @t{zstyles} 涵盖。"

#. type: table
#: zsh.texi:35800
msgid "Output autoloads and function definitions."
msgstr "输出自动加载和函数定义。"

#. type: table
#: zsh.texi:35802
msgid "Output @t{limit} commands."
msgstr "输出 @t{limit} 命令。"

#. type: table
#: zsh.texi:35804
msgid "Output @t{setopt} commands."
msgstr "输出 @t{setopt} 命令。"

#. type: table
#: zsh.texi:35806
msgid "Same as @t{zstyles}."
msgstr "与 @t{zstyles} 相同。"

#. type: table
#: zsh.texi:35809
msgid "Output shell parameter assignments, plus @t{export} commands for any environment variables."
msgstr "输出 shell 参数赋值，为任何环境变量的加上 @t{export} 命令。"

#. type: t{#1}
#: zsh.texi:35809
#, no-wrap
msgid "zstyles"
msgstr "zstyles"

#. type: table
#: zsh.texi:35811
msgid "Output @t{zstyle} commands."
msgstr "输出 @t{zstyle} 命令。"

#. type: table
#: zsh.texi:35815
msgid "If the @var{state} is omitted, @t{all} is assumed."
msgstr "如果省略 @var{state}，则假定使用 @t{all}。"

#. type: table
#: zsh.texi:35821
msgid "With the exception of `@t{all}', every @var{state} can be abbreviated by any prefix, even a single letter; thus @t{a} is the same as @t{aliases}, @t{z} is the same as @t{zstyles}, etc."
msgstr "除 `@t{all}' 外，每个 @var{state} 都可以用任何前缀缩写，甚至一个字母；因此 @t{a} 与 @t{aliases} 相同，@t{z} 与 @t{zstyles} 相同，等等。"

#. type: subsection
#: zsh.texi:35825
#, no-wrap
msgid "Manipulating Hook Functions"
msgstr "操作勾子函数"

#. type: cindex
#: zsh.texi:35827
#, no-wrap
msgid "hook function utility"
msgstr "钩子函数实用工具"

#. type: findex
#: zsh.texi:35831
#, no-wrap
msgid "add-zsh-hook"
msgstr "add-zsh-hook"

#. type: item
#: zsh.texi:35832
#, no-wrap
msgid "@t{add-zsh-hook} [ @t{-L} | @t{-dD} ] [ @t{-Uzk} ] @var{hook} @var{function}"
msgstr "@t{add-zsh-hook} [ @t{-L} | @t{-dD} ] [ @t{-Uzk} ] @var{hook} @var{function}"

#. type: table
#: zsh.texi:35840
msgid ""
"Several functions are special to the shell, as described in the section Special Functions, @ref{Functions}, in that they are automatically called at specific points during shell execution.  Each has an "
"associated array consisting of names of functions to be called at the same point; these are so-called `hook functions'.  The shell function @t{add-zsh-hook} provides a simple way of adding or removing "
"functions from the array."
msgstr ""
"如 @ref{函数} 中特殊函数一节所述，有几个函数对 shell 来说是特殊的，它们会在 shell 执行过程中的特定时刻被自动调用。 每个函数都有一个关联数组，由在同一时刻被调用的函数名称组成；这些函数就是所谓的 `钩子函"
"数'。 shell 函数 @t{add-zsh-hook} 提供了一种从数组中添加或删除函数的简单方法。"

#. type: table
#: zsh.texi:35847
msgid ""
"@var{hook} is one of @t{chpwd}, @t{periodic}, @t{precmd}, @t{preexec}, @t{zshaddhistory}, @t{zshexit}, or @t{zsh_directory_name}, the special functions in question.  Note that @t{zsh_directory_name} is "
"called in a different way from the other functions, but may still be manipulated as a hook."
msgstr ""
"@var{hook} 是 @t{chpwd}、@t{periodic}、@t{precmd}、@t{preexec}、@t{zshaddhistory}、@t{zshexit} 或 @t{zsh_directory_name} 中的一个，即相关的特殊函数。 请注意 @t{zsh_directory_name} 的调用方式与其他函数不"
"同，但仍可作为钩子进行操作。"

#. type: table
#: zsh.texi:35853
msgid ""
"@var{function} is name of an ordinary shell function.  If no options are given this will be added to the array of functions to be executed in the given context.  Functions are invoked in the order they "
"were added."
msgstr "@var{function} 是普通 shell 函数的名称。 如果没有给定选项，该函数将被添加到要在给定上下文中执行的函数的数组中。 函数将按照添加的顺序被调用。"

#. type: table
#: zsh.texi:35857
msgid "If the option @t{-L} is given, the current values for the hook arrays are listed with @t{typeset}."
msgstr "如果给出 @t{-L} 选项，钩子数组的当前值将与 @t{typeset} 一起列出。"

#. type: table
#: zsh.texi:35861
msgid "If the option @t{-d} is given, the @var{function} is removed from the array of functions to be executed."
msgstr "如果给出选项 @t{-d}，@var{function} 将从要执行的函数数组中删除。"

#. type: table
#: zsh.texi:35866
msgid "If the option @t{-D} is given, the @var{function} is treated as a pattern and any matching names of functions are removed from the array of functions to be executed."
msgstr "如果给出选项 @t{-D}，@var{function} 将被视为一种模式，任何匹配的函数名称都将从要执行的函数数组中删除。"

#. type: table
#: zsh.texi:35871
msgid "The options @t{-U}, @t{-z} and @t{-k} are passed as arguments to @t{autoload} for @var{function}.  For functions contributed with zsh, the options @t{-Uz} are appropriate."
msgstr "选项 @t{-U}、@t{-z} 和 @t{-k} 将作为 @var{function} 的参数传递给 @t{autoload}。 对于使用 zsh 提供的函数，选项 @t{-Uz} 是合适的。"

#. type: findex
#: zsh.texi:35872
#, no-wrap
msgid "add-zle-hook-widget"
msgstr "add-zle-hook-widget"

#. type: item
#: zsh.texi:35873
#, no-wrap
msgid "@t{add-zle-hook-widget} [ @t{-L} | @t{-dD} ] [ @t{-Uzk} ] @var{hook} @var{widgetname}"
msgstr "@t{add-zle-hook-widget} [ @t{-L} | @t{-dD} ] [ @t{-Uzk} ] @var{hook} @var{widgetname}"

#. type: table
#: zsh.texi:35881
msgid ""
"Several widget names are special to the line editor, as described in the section Special Widgets, @ref{Zle Widgets}, in that they are automatically called at specific points during editing.  Unlike "
"function hooks, these do not use a predefined array of other names to call at the same point; the shell function @t{add-zle-hook-widget} maintains a similar array and arranges for the special widget to "
"invoke those additional widgets."
msgstr ""
"正如 \"特殊小部件\" @ref{Zle 小部件}）一节所述，有几个小部件名称对于行编辑器来说是特殊的，它们会在编辑过程中的特定点自动调用。 与函数钩不同的是，这些不使用预定义的其他名称数组来在同一点调用;；shell 函数 "
"@t{add-zle-hook-widget} 维护一个类似的数组，并安排特殊小部件调用这些额外的小部件。"

#. type: table
#: zsh.texi:35888
msgid ""
"@var{hook} is one of @t{isearch-exit}, @t{isearch-update}, @t{line-pre-redraw}, @t{line-init}, @t{line-finish}, @t{history-line-set}, or @t{keymap-select}, corresponding to each of the special widgets "
"@t{zle-isearch-exit}, etc.  The special widget names are also accepted as the @var{hook} argument."
msgstr ""
"@var{hook} 是 @t{isearch-exit}、@t{isearch-update}、@t{line-pre-redraw}、@t{line-init}、@t{line-finish}、@t{history-line-set} 或 @t{keymap-select} 中的一个，分别对应 @t{zle-isearch-exit} 等特殊小部件。 这"
"些特殊小部件的名称也可作为 @var{hook} 参数使用。"

#. type: table
#: zsh.texi:35893
msgid ""
"@var{widgetname} is the name of a ZLE widget.  If no options are given this is added to the array of widgets to be invoked in the given hook context.  Widgets are invoked in the order they were added, with"
msgstr "@var{widgetname} 是 ZLE 小部件的名称。 如果没有给定选项，这将被添加到要在给定钩子上下文中调用的小部件数组中。 小部件会按照添加的顺序被调用，并以"

#. type: example
#: zsh.texi:35895
#, no-wrap
msgid "@t{zle }@var{widgetname}@t{ -Nw -f \"nolast\" -- \"$@@\"}\n"
msgstr "@t{zle }@var{widgetname}@t{ -Nw -f \"nolast\" -- \"$@@\"}\n"

#. type: vindex
#: zsh.texi:35898
#, no-wrap
msgid "WIDGET, in hooks"
msgstr "WIDGET, 勾子中"

#. type: table
#: zsh.texi:35902
msgid "Note that this means that the `@t{WIDGET}' special parameter tracks the @var{widgetname} when the widget function is called, rather than tracking the name of the corresponding special hook widget."
msgstr "请注意，这意味着在调用小部件函数时， `@t{WIDGET}' 特殊参数会跟踪 @var{widgetname}，而不是跟踪相应特殊钩子小部件的名称。"

#. type: table
#: zsh.texi:35906
msgid "If the option @t{-d} is given, the @var{widgetname} is removed from the array of widgets to be executed."
msgstr "如果给出选项 @t{-d}，@var{widgetname} 将从要执行的小部件数组中删除。"

#. type: table
#: zsh.texi:35910
msgid "If the option @t{-D} is given, the @var{widgetname} is treated as a pattern and any matching names of widgets are removed from the array."
msgstr "如果给出选项 @t{-D}，@var{widgetname} 将被视为一种模式，任何匹配的小部件名称都将从数组中删除。"

#. type: table
#: zsh.texi:35919
msgid ""
"If @var{widgetname} does not name an existing widget when added to the array, it is assumed that a shell function also named @var{widgetname} is meant to provide the implementation of the widget.  This "
"name is therefore marked for autoloading, and the options @t{-U}, @t{-z} and @t{-k} are passed as arguments to @t{autoload} as with @t{add-zsh-hook}.  The widget is also created with `@t{zle -N }"
"@var{widgetname}' to cause the corresponding function to be loaded the first time the hook is called."
msgstr ""
"如果 @var{widgetname} 在添加到数组时没有命名一个现有的小部件，则会假定一个同样命名为 @var{widgetname} 的 shell 函数将提供该小部件的实现。 因此，该名称被标记为自动加载，选项 @t{-U}、@t{-z} 和 @t{-k} 将作为 "
"@t{autoload} 的参数传递给 @t{autoload}，与 @t{add-zsh-hook} 一样。 小部件也是通过`@t{zle -N }@var{widgetname}' 创建的，以便在第一次调用钩子时加载相应的函数。"

#. type: table
#: zsh.texi:35928
msgid ""
"The arrays of @var{widgetname} are currently maintained in @t{zstyle} contexts, one for each @var{hook} context, with a style of `@t{widgets}'.  If the @t{-L} option is given, this set of styles is listed "
"with `@t{zstyle -L}'.  This implementation may change, and the special widgets that refer to the styles are created only if @t{add-zle-hook-widget} is called to add at least one widget, so if this "
"function is used for any hooks, then all hooks should be managed only via this function."
msgstr ""
"@var{widgetname} 的数组目前保存在 @t{zstyle} 上下文中，每个 @var{hook} 上下文有一个，样式为`@t{widgets}'。 如果给出 @t{-L} 选项，这组样式将以 `@t{zstyle -L}' 列出。 这种实现方式可能会发生变化，只有调用 "
"@t{add-zle-hook-widget} 添加至少一个小部件时，才会创建引用样式的特殊小部件，因此如果此函数用于任何钩子，那么所有钩子都应只通过此函数进行管理。"

#. type: node
#: zsh.texi:35932 zsh.texi:36273 zsh.texi:36505
#, no-wrap
msgid "Other Directory Functions"
msgstr "其它目录函数"

#. type: cindex
#: zsh.texi:35933
#, no-wrap
msgid "recent directories, maintaining list of"
msgstr "最近的目录, 维护列表"

#. type: cindex
#: zsh.texi:35934
#, no-wrap
msgid "directories, maintaining list of recent"
msgstr "目录, 维护最近的"

#. type: findex
#: zsh.texi:35935
#, no-wrap
msgid "cdr"
msgstr "cdr"

#. type: findex
#: zsh.texi:35936
#, no-wrap
msgid "_cdr"
msgstr "_cdr"

#. type: findex
#: zsh.texi:35937
#, no-wrap
msgid "chpwd_recent_add"
msgstr "chpwd_recent_add"

#. type: findex
#: zsh.texi:35938
#, no-wrap
msgid "chpwd_recent_dirs"
msgstr "chpwd_recent_dirs"

#. type: findex
#: zsh.texi:35939
#, no-wrap
msgid "chpwd_recent_filehandler"
msgstr "chpwd_recent_filehandler"

#. type: section
#: zsh.texi:35941
#, no-wrap
msgid "Remembering Recent Directories"
msgstr "记住最近的目录"

#. type: Plain text
#: zsh.texi:35953
msgid ""
"The function @t{cdr} allows you to change the working directory to a previous working directory from a list maintained automatically.  It is similar in concept to the directory stack controlled by the "
"@t{pushd}, @t{popd} and @t{dirs} builtins, but is more configurable, and as it stores all entries in files it is maintained across sessions and (by default)  between terminal emulators in the current "
"session.  Duplicates are automatically removed, so that the list reflects the single most recent use of each directory."
msgstr ""
"通过函数 @t{cdr}，可以从自动维护的列表中将工作目录更改为前一个工作目录。 它的概念类似于 @t{pushd}、@t{popd} 和 @t{dirs} 内置程序所控制的目录堆栈，但可配置性更强，而且由于它将所有条目都存储在文件中，因此可"
"以跨会话维护，（默认情况下）也可以在当前会话的终端模拟器之间维护。 重复的条目会自动删除，因此列表反映的是每个目录最近一次使用的情况。"

#. type: Plain text
#: zsh.texi:35958
msgid "Note that the @t{pushd} directory stack is not actually modified or used by @t{cdr} unless you configure it to do so as described in the configuration section below."
msgstr "请注意，@t{pushd} 目录栈实际上不会被 @t{cdr} 修改或使用，除非按照下文配置部分所述进行配置。"

#. type: Plain text
#: zsh.texi:35968
msgid ""
"The system works by means of a hook function that is called every time the directory changes.  To install the system, autoload the required functions and use the @t{add-zsh-hook} function described above:"
msgstr "该系统通过一个钩子函数工作，每次目录发生变化时都会调用该函数。 要安装该系统，请自动加载所需的函数，并使用上述 @t{add-zsh-hook} 函数："

#. type: example
#: zsh.texi:35973
#, no-wrap
msgid ""
"autoload -Uz chpwd_recent_dirs cdr add-zsh-hook\n"
"add-zsh-hook chpwd chpwd_recent_dirs\n"
msgstr ""
"autoload -Uz chpwd_recent_dirs cdr add-zsh-hook\n"
"add-zsh-hook chpwd chpwd_recent_dirs\n"

#. type: Plain text
#: zsh.texi:35979
msgid "Now every time you change directly interactively, no matter which command you use, the directory to which you change will be remembered in most-recent-first order."
msgstr "现在，每次以交互方式直接更改目录时，无论使用哪条命令，都会以,最近的优先,这样的顺序记住更改的目录。"

#. type: subsection
#: zsh.texi:35982
#, no-wrap
msgid "Use"
msgstr "用法"

#. type: Plain text
#: zsh.texi:35987
msgid "All direct user interaction is via the @t{cdr} function."
msgstr "所有直接的用户交互都是通过 @t{cdr} 函数进行的。"

#. type: Plain text
#: zsh.texi:35996
msgid ""
"The argument to cdr is a number @var{N} corresponding to the @var{N}th most recently changed-to directory.  1 is the immediately preceding directory; the current directory is remembered but is not offered "
"as a destination.  Note that if you have multiple windows open 1 may refer to a directory changed to in another window; you can avoid this by having per-terminal files for storing directory as described "
"for the @t{recent-dirs-file} style below."
msgstr ""
"cdr 的参数是一个数字 @var{N}，与第 @var{N} 个最近更改过的目录相对应。 1 指的是最近的目录；当前目录会被记住，但不会作为目标目录提供。 需要注意的是，如果打开了多个窗口，1 可能指的是另一个窗口中已更改的目录；"
"为避免出现这种情况，可以使用基于每个终端的文件来存储目录，详见以下 @t{recent-dirs-file} 样式的描述。"

#. type: Plain text
#: zsh.texi:36002
msgid ""
"If you set the @t{recent-dirs-default} style described below @t{cdr} will behave the same as @t{cd} if given a non-numeric argument, or more than one argument.  The recent directory list is updated just "
"the same however you change directory."
msgstr "如果你设置了下面描述的 @t{recent-dirs-default} 风格，那么当使用非数字参数或多个参数调用 @t{cdr} 时，它将与 @t{cd} 的行为相同。但无论你如何切换目录，最近目录列表仍将得到更新。"

#. type: Plain text
#: zsh.texi:36006
msgid "If the argument is omitted, 1 is assumed.  This is similar to @t{pushd}'s behaviour of swapping the two most recent directories on the stack."
msgstr "如果省略参数，则假定为 1。 这与 @t{pushd} 交换堆栈中最近的两个目录的行为类似。"

#. type: Plain text
#: zsh.texi:36010
msgid "Completion for the argument to @t{cdr} is available if compinit has been run; menu selection is recommended, using:"
msgstr "如果已运行 compinit，则 @t{cdr} 的参数可以补全；建议使用菜单选择, 用："

#. type: example
#: zsh.texi:36014
#, no-wrap
msgid "zstyle ':completion:*:*:cdr:*:*' menu selection\n"
msgstr "zstyle ':completion:*:*:cdr:*:*' menu selection\n"

#. type: Plain text
#: zsh.texi:36021
msgid ""
"to allow you to cycle through recent directories; the order is preserved, so the first choice is the most recent directory before the current one.  The verbose style is also recommended to ensure the "
"directory is shown; this style is on by default so no action is required unless you have changed it."
msgstr "允许你循环查看最近的目录；顺序会被保留，所以第一个选择是当前目录之前最近的目录。 此外，还建议使用 \"verbose\" 样式，以确保显示目录；该样式默认为打开，因此除非更改，否则无需执行任何操作。"

#. type: Plain text
#: zsh.texi:36029
msgid "The behaviour of @t{cdr} may be modified by the following options."
msgstr "@t{cdr} 的行为可以通过以下选项进行修改。"

#. type: table
#: zsh.texi:36038
msgid ""
"lists the numbers and the corresponding directories in abbreviated form (i.e. with @t{~} substitution reapplied), one per line.  The directories here are not quoted (this would only be an issue if a "
"directory name contained a newline).  This is used by the completion system."
msgstr "以缩写形式（即重新使用 @t{~} 替换）列出数字和相应的目录，每行一个。 这里的目录不加引号（只有在目录名包含换行符时才会出现问题）。 这是由补全系统使用的。"

#. type: table
#: zsh.texi:36042
msgid "sets the variable @t{reply} to the current set of directories.  Nothing is printed and the directory is not changed."
msgstr "将变量 @t{reply} 设置为当前目录集。 不会打印任何内容，也不会更改目录。"

#. type: table
#: zsh.texi:36050
msgid ""
"allows you to edit the list of directories, one per line.  The list can be edited to any extent you like; no sanity checking is performed.  Completion is available.  No quoting is necessary (except for "
"newlines, where I have in any case no sympathy); directories are in unabbreviated form and contain an absolute path, i.e. they start with @t{/}.  Usually the first entry should be left as the current "
"directory."
msgstr ""
"可以编辑目录列表，每行一个。 该列表可任意编辑，但不进行正确性检查。 可以补全。 无需加引号（换行符除外，我对换行符没有任何同情心）；目录采用非缩写形式，包含绝对路径，即以 @t{/} 开头。 通常第一个条目应作为当"
"前目录。"

#. type: item
#: zsh.texi:36051
#, no-wrap
msgid "@t{-p '}@var{pattern}@t{'}"
msgstr "@t{-p '}@var{pattern}@t{'}"

#. type: table
#: zsh.texi:36058
msgid ""
"Prunes any items in the directory list that match the given extended glob pattern; the pattern needs to be quoted from immediate expansion on the command line.  The pattern is matched against each "
"completely expanded file name in the list; the full string must match, so wildcards at the end (e.g. @t{'*removeme*'}) are needed to remove entries with a given substring."
msgstr ""
"删除目录列表中任何与给定扩展 glob 模式匹配的条目；该模式需要加引号，以避免在命令行中立即展开。 该模式与列表中每个完全展开的文件名匹配；必须补全整个字符串，因此需要在末尾添加通配符（例如 "
"@t{'*removeme*'}），以删除带有给定子字符串的条目。"

#. type: table
#: zsh.texi:36063
msgid ""
"If output is to a terminal, then the function will print the new list after pruning and prompt for confirmation by the user.  This output and confirmation step can be skipped by using @t{-P} instead of "
"@t{-p}."
msgstr "如果输出到终端，函数将在修剪后打印新列表，并提示用户确认。 使用 @t{-P} 代替 @t{-p} 可以跳过输出和确认步骤。"

#. type: Plain text
#: zsh.texi:36077
msgid ""
"Configuration is by means of the styles mechanism that should be familiar from completion; if not, see the description of the @t{zstyle} command in @ref{The zsh/zutil Module}.  The context for setting "
"styles should be @t{':chpwd:*'} in case the meaning of the context is extended in future, for example:"
msgstr "配置是通过样式机制来完成的，这一点大家应该很熟悉；如果不熟悉，请参阅 @ref{zsh/zutil 模块} 中 @t{zstyle} 命令的描述。设置样式的上下文应为 @t{':chpwd:*'}，以防将来上下文的含义被扩展，例如："

#. type: example
#: zsh.texi:36081
#, no-wrap
msgid "zstyle ':chpwd:*' recent-dirs-max 0\n"
msgstr "zstyle ':chpwd:*' recent-dirs-max 0\n"

#. type: Plain text
#: zsh.texi:36086
msgid "sets the value of the @t{recent-dirs-max} style to 0.  In practice the style name is specific enough that a context of '*' should be fine."
msgstr "将 @t{recent-dirs-max} 样式的值设置为 0。实际上，该样式名称足够具体，使用 '*' 上下文就可以了。"

#. type: Plain text
#: zsh.texi:36092
msgid ""
"An exception is @t{recent-dirs-insert}, which is used exclusively by the completion system and so has the usual completion system context (@t{':completion:*'} if nothing more specific is needed), though "
"again @t{'*'} should be fine in practice."
msgstr "@t{recent-dirs-insert} 是个例外，它是由补全系统专用的，因此有通常的补全系统上下文（@t{':completion:*'} ，如果不需要更具体的内容），不过 @t{'*'} 在实际使用中也应该没问题。"

#. type: t{#1}
#: zsh.texi:36095
#, no-wrap
msgid "recent-dirs-default"
msgstr "recent-dirs-default"

#. type: table
#: zsh.texi:36102
msgid ""
"If true, and the command is expecting a recent directory index, and either there is more than one argument or the argument is not an integer, then fall through to \"cd\".  This allows the lazy to use only "
"one command for directory changing.  Completion recognises this, too; see recent-dirs-insert for how to control completion when this option is in use."
msgstr ""
"如果为 \"true\"，并且该命令期待的是一个最近的目录索引，而参数不只一个或参数不是整数，则转为 \"cd\"。 这样，懒人就可以只使用一条命令来更改目录。 补全也能识别这一点；关于使用该选项时如何控制补全，请参阅 "
"recent-dirs-insert。"

#. type: t{#1}
#: zsh.texi:36103
#, no-wrap
msgid "recent-dirs-file"
msgstr "recent-dirs-file"

#. type: table
#: zsh.texi:36110
msgid ""
"The file where the list of directories is saved.  The default is @t{$@{ZDOTDIR:-$HOME@}/.chpwd-recent-dirs}, i.e. this is in your home directory unless you have set the variable @t{ZDOTDIR} to point "
"somewhere else.  Directory names are saved in @t{$'}@var{...}@t{'} quoted form, so each line in the file can be supplied directly to the shell as an argument."
msgstr ""
"保存目录列表的文件。 默认值为 @t{$@{ZDOTDIR:-$HOME@}/.chpwd-recent-dirs}，也就是说，除非你将变量 @t{ZDOTDIR} 设为指向其他地方，否则该文件将保存在你的主目录中。 目录名以 @t{$'}@var{...}@t{'} 的引号形式保"
"存，因此文件中的每一行都可以作为参数直接提供给 shell。"

#. type: table
#: zsh.texi:36122
msgid ""
"The value of this style may be an array.  In this case, the first file in the list will always be used for saving directories while any other files are left untouched.  When reading the recent directory "
"list, if there are fewer than the maximum number of entries in the first file, the contents of later files in the array will be appended with duplicates removed from the list shown.  The contents of the "
"two files are not sorted together, i.e. all the entries in the first file are shown first.  The special value @t{+} can appear in the list to indicate the default file should be read at that point.  This "
"allows effects like the following:"
msgstr ""
"该样式的值可以是一个数组。 在这种情况下，列表中的第一个文件将始终用于保存目录，而其他文件则保持不变。 读取最近目录列表时，如果第一个文件中的条目数少于最大值，数组中后面文件的内容将被追加，并从显示的列表中"
"删除重复的文件。 两个文件的内容不会一起排序，即第一个文件中的所有条目都会首先显示。 特殊值 @t{+} 可以出现在列表中，表示在该点应读取默认文件。 这样就可以达到如下效果："

#. type: example
#: zsh.texi:36127
#, no-wrap
msgid ""
"zstyle ':chpwd:*' recent-dirs-file \\ \n"
"~/.chpwd-recent-dirs-$@{TTY##*/@} +\n"
msgstr ""
"zstyle ':chpwd:*' recent-dirs-file \\ \n"
"~/.chpwd-recent-dirs-$@{TTY##*/@} +\n"

#. type: table
#: zsh.texi:36133
msgid "Recent directories are read from a file numbered according to the terminal.  If there are insufficient entries the list is supplemented from the default file."
msgstr "最近的目录是从一个根据终端编号的文件中读取的。 如果条目不足，则从默认文件中补充。"

#. type: table
#: zsh.texi:36137
msgid "It is possible to use @t{zstyle -e} to make the directory configurable at run time:"
msgstr "使用 @t{zstyle -e} 可以使目录在运行时可配置："

#. type: example
#: zsh.texi:36148
#, no-wrap
msgid ""
"zstyle -e ':chpwd:*' recent-dirs-file pick-recent-dirs-file\n"
"pick-recent-dirs-file() @{\n"
"  if [[ $PWD = ~/text/writing(|/*) ]]; then\n"
"    reply=(~/.chpwd-recent-dirs-writing)\n"
"  else\n"
"    reply=(+)\n"
"  fi\n"
"@}\n"
msgstr ""
"zstyle -e ':chpwd:*' recent-dirs-file pick-recent-dirs-file\n"
"pick-recent-dirs-file() @{\n"
"  if [[ $PWD = ~/text/writing(|/*) ]]; then\n"
"    reply=(~/.chpwd-recent-dirs-writing)\n"
"  else\n"
"    reply=(+)\n"
"  fi\n"
"@}\n"

#. type: table
#: zsh.texi:36154
msgid "In this example, if the current directory is @t{~/text/writing} or a directory under it, then use a special file for saving recent directories, else use the default."
msgstr "在本例中，如果当前目录是 @t{~/text/writing} 或其下的一个目录，则使用特殊文件保存最近的目录，否则使用默认文件。"

#. type: t{#1}
#: zsh.texi:36155
#, no-wrap
msgid "recent-dirs-insert"
msgstr "recent-dirs-insert"

#. type: table
#: zsh.texi:36165
msgid ""
"Used by completion.  If @t{recent-dirs-default} is true, then setting this to @t{true} causes the actual directory, rather than its index, to be inserted on the command line; this has the same effect as "
"using the corresponding index, but makes the history clearer and the line easier to edit.  With this setting, if part of an argument was already typed, normal directory completion rather than recent "
"directory completion is done; this is because recent directory completion is expected to be done by cycling through entries menu fashion."
msgstr ""
"补全时使用。 如果 @t{recent-dirs-default} 为 true，则将其设置为 @t{true}，会在命令行中插入实际目录，而不是目录索引；这与使用相应索引的效果相同，但会使历史记录更清晰，行更易于编辑。 在此设置下，如果参数的一"
"部分已经输入，则会执行正常的目录补全，而不是最近的目录补全；这是因为最近的目录补全预计会以菜单方式条目执行。"

#. type: table
#: zsh.texi:36170
msgid "If the value of the style is @t{always}, then only recent directories will be completed; in that case, use the @t{cd} command when you want to complete other directories."
msgstr "如果样式的值是 @t{always}，那么只会补全最近的目录；在这种情况下，当你想补全其他目录时，请使用 @t{cd} 命令。"

#. type: table
#: zsh.texi:36175
msgid "If the value is @t{fallback}, recent directories will be tried first, then normal directory completion is performed if recent directory completion failed to find a match."
msgstr "如果值为 @t{fallback}，将首先尝试最近的目录，如果最近目录的补全未能找到匹配，则执行正常目录的补全。"

#. type: table
#: zsh.texi:36181
msgid ""
"Finally, if the value is @t{both} then both sets of completions are presented; the usual tag mechanism can be used to distinguish results, with recent directories tagged as @t{recent-dirs}.  Note that the "
"recent directories inserted are abbreviated with directory names where appropriate."
msgstr "最后，如果值为 @t{both}，则会同时显示两组补全；可以使用常用的标记机制来区分结果，最近的目录会被标记为 @t{recent-dirs}。 需要注意的是，插入的最近目录会根据情况用目录名缩写。"

#. type: t{#1}
#: zsh.texi:36182
#, no-wrap
msgid "recent-dirs-max"
msgstr "recent-dirs-max"

#. type: table
#: zsh.texi:36188
msgid ""
"The maximum number of directories to save to the file.  If this is zero or negative there is no maximum.  The default is 20.  Note this includes the current directory, which isn't offered, so the highest "
"number of directories you will be offered is one less than the maximum."
msgstr "要保存到文件中的最大目录数。 如果为零或负数，则没有最大值。 默认值为 20。 请注意，这包括当前目录，因为当前目录不提供，所以提供的最高目录数比最大值少一个。"

#. type: t{#1}
#: zsh.texi:36189
#, no-wrap
msgid "recent-dirs-prune"
msgstr "recent-dirs-prune"

#. type: table
#: zsh.texi:36192
msgid "This style is an array determining what directories should (or should not) be added to the recent list.  Elements of the array can include:"
msgstr "该样式是一个数组，用于确定哪些目录应（或不应）添加到最近列表中。 数组的元素可以包括:"

#. type: table
#: zsh.texi:36204
msgid ""
"Prune parents (more accurately, ancestors) from the recent list.  If present, changing directly down by any number of directories causes the current directory to be overwritten.  For example, changing "
"from ~pws to ~pws/some/other/dir causes ~pws not to be left on the recent directory stack.  This only applies to direct changes to descendant directories; earlier directories on the list are not pruned.  "
"For example, changing from ~pws/yet/another to ~pws/some/other/dir does not cause ~pws to be pruned."
msgstr ""
"从最近列表中剪除父目录（更准确地说，是祖目录）。 如果存在，直接向下更改任意数量的目录会导致当前目录被覆盖。 例如，从 ~pws 改为 ~pws/some/other/dir 会导致 ~pws 不再留在最近目录堆栈中。 这只适用于对后代目录"
"的直接更改；列表中较早的目录不会被剪枝。 例如，从 ~pws/yet/another 更改为 ~pws/some/other/dir 不会导致 ~pws 被剪除。"

#. type: item
#: zsh.texi:36205
#, no-wrap
msgid "@t{pattern:}@var{pattern}"
msgstr "@t{pattern:}@var{pattern}"

#. type: table
#: zsh.texi:36212
msgid ""
"Gives a zsh pattern for directories that should not be added to the recent list (if not already there).  This element can be repeated to add different patterns.  For example, @t{'pattern:/tmp(|/*)'} stops "
"@t{/tmp} or its descendants from being added.  The @t{EXTENDED_GLOB} option is always turned on for these patterns."
msgstr ""
"为不应添加到最近列表（如果尚未添加）的目录提供一个 zsh 模式。 此元素可以重复添加到不同的模式。 例如，@t{'pattern:/tmp(|/*)'} 会阻止 @t{/tmp} 或其子目录被添加。 对于这些模式，@t{EXTENDED_GLOB} 选项始终处于"
"开启状态。"

#. type: t{#1}
#: zsh.texi:36215
#, no-wrap
msgid "recent-dirs-pushd"
msgstr "recent-dirs-pushd"

#. type: table
#: zsh.texi:36221
msgid ""
"If set to true, @t{cdr} will use @t{pushd} instead of @t{cd} to change the directory, so the directory is saved on the directory stack.  As the directory stack is completely separate from the list of "
"files saved by the mechanism used in this file there is no obvious reason to do this."
msgstr "如果设置为 true，@t{cdr} 将使用 @t{pushd} 而不是 @t{cd} 来更改目录，因此目录将保存在目录栈中。 由于目录栈与本文件使用的机制所保存的文件列表是完全独立的，因此没有明显的理由这样做。"

#. type: subsection
#: zsh.texi:36226
#, no-wrap
msgid "Use with dynamic directory naming"
msgstr "与动态目录命名一起使用"

#. type: Plain text
#: zsh.texi:36233
msgid "It is possible to refer to recent directories using the dynamic directory name syntax by using the supplied function @t{zsh_directory_name_cdr} a hook:"
msgstr "可以使用动态目录名语法引用最近的目录, 通过使用提供的函数 @t{zsh_directory_name_cdr} 勾子："

#. type: example
#: zsh.texi:36238
#, no-wrap
msgid ""
"autoload -Uz add-zsh-hook\n"
"add-zsh-hook -Uz zsh_directory_name zsh_directory_name_cdr\n"
msgstr ""
"autoload -Uz add-zsh-hook\n"
"add-zsh-hook -Uz zsh_directory_name zsh_directory_name_cdr\n"

#. type: Plain text
#: zsh.texi:36244
msgid "When this is done, @t{~[1]} will refer to the most recent directory other than $PWD, and so on.  Completion after @t{~[}@var{...} also works."
msgstr "完成后，@t{~[1]} 将指向 $PWD 以外的最新目录，依此类推。 在 @t{~[}@var{...} 之后补全也同样有效。"

#. type: subsection
#: zsh.texi:36247
#, no-wrap
msgid "Details of directory handling"
msgstr "目录处理细节"

#. type: Plain text
#: zsh.texi:36253
msgid "This section is for the curious or confused; most users will not need to know this information."
msgstr "这部分内容是为好奇或困惑的用户准备的，大多数用户并不需要了解这些信息。"

#. type: Plain text
#: zsh.texi:36262
msgid ""
"Recent directories are saved to a file immediately and hence are preserved across sessions.  Note currently no file locking is applied: the list is updated immediately on interactive commands and nowhere "
"else (unlike history), and it is assumed you are only going to change directory in one window at once.  This is not safe on shared accounts, but in any case the system has limited utility when someone "
"else is changing to a different set of directories behind your back."
msgstr ""
"最近的目录会立即保存到文件中，因此会跨(across)会话保留。 需要注意的是，目前没有应用文件锁定：列表会在交互式命令中立即更新，而不会在其他地方更新（与历史记录不同），并且假定你一次只会在一个窗口中更改目录。 "
"这在共享账户中并不安全，但无论如何，当别人背着你更改不同的目录集时，该系统的作用就很有限了。"

#. type: Plain text
#: zsh.texi:36271
msgid ""
"To make this a little safer, only directory changes instituted from the command line, either directly or indirectly through shell function calls (but not through subshells, evals, traps, completion "
"functions and the like) are saved.  Shell functions should use @t{cd -q} or @t{pushd -q} to avoid side effects if the change to the directory is to be invisible at the command line.  See the contents of "
"the function @t{chpwd_recent_dirs} for more details."
msgstr ""
"为了让这个过程更安全，只有通过命令行直接或间接地（但不是通过子shell、evals、traps、补全函数等）进行的目录更改才会被保存。Shell函数应该使用 @t{cd -q} 或 @t{pushd -q} 来避免副作用，如果目录的更改在命令行上是"
"不可见的。更多详情请参考函数 @t{chpwd_recent_dirs} 的内容。"

#. type: node
#: zsh.texi:36273 zsh.texi:36505 zsh.texi:36581 zsh.texi:36666 zsh.texi:37170 zsh.texi:37193 zsh.texi:37314 zsh.texi:37375 zsh.texi:37398 zsh.texi:37715 zsh.texi:37906
#, no-wrap
msgid "Version Control Information"
msgstr "版本控制信息"

#. type: cindex
#: zsh.texi:36274
#, no-wrap
msgid "directories, named, dynamic, helper function"
msgstr "目录, 命名, 动态, 辅助函数"

#. type: cindex
#: zsh.texi:36275
#, no-wrap
msgid "dynamic directory naming, helper function"
msgstr "动态目录命名, 辅助函数"

#. type: cindex
#: zsh.texi:36276
#, no-wrap
msgid "named directories, dynamic, helper function"
msgstr "命名目录, 动态, 辅助函数"

#. type: findex
#: zsh.texi:36277
#, no-wrap
msgid "zsh_directory_name_generic"
msgstr "zsh_directory_name_generic"

#. type: section
#: zsh.texi:36279
#, no-wrap
msgid "Abbreviated dynamic references to directories"
msgstr "目录的简略动态引用"

#. type: Plain text
#: zsh.texi:36288
msgid ""
"The dynamic directory naming system is described in the subsection @emph{Dynamic named directories} of @ref{Filename Expansion}.  In this, a reference to @t{~[}@var{...}@t{]} is expanded by a function "
"found by the hooks mechanism."
msgstr "动态目录命名系统在 @ref{文件名扩展} 的 @emph{动态命名目录} 小节中进行了描述。 其中，@t{~[}@var{...}@t{]} 的引用由钩子机制找到的函数展开。"

#. type: Plain text
#: zsh.texi:36295
msgid ""
"The contributed function @t{zsh_directory_name_generic} provides a system allowing the user to refer to directories with only a limited amount of new code.  It supports all three of the standard "
"interfaces for directory naming: converting from a name to a directory, converting in the reverse direction to find a short name, and completion of names."
msgstr "贡献函数 @t{zsh_directory_name_generic} 提供了一个系统，用户只需编写少量新代码即可引用目录。 它支持目录命名的所有三个标准接口：从名称到目录的转换、反向转换以查找简短名称，以及名称的补全。"

#. type: Plain text
#: zsh.texi:36300
msgid "The main feature of this function is a path-like syntax, combining abbreviations at multiple levels separated by \":\".  As an example, ~[g:p:s] might specify:"
msgstr "该函数的主要特点是采用类似路径的语法，将多级缩写以 \":\" 分隔。 例如， ~[g:p:s] 可以指定："

#. type: table
#: zsh.texi:36305
msgid "The top level directory for your git area.  This first component has to match, or the function will return indicating another directory name hook function should be tried."
msgstr "git 区域的顶级目录。 第一个组件必须匹配，否则函数将返回，指示应尝试另一个目录名钩子函数。"

#. type: table
#: zsh.texi:36308
msgid "The name of a project within your git area."
msgstr "git 区域内的项目名称。"

#. type: table
#: zsh.texi:36311
msgid "The source area within that project."
msgstr "该项目中的源区。"

#. type: Plain text
#: zsh.texi:36316
msgid "This allows you to collapse references to long hierarchies to a very compact form, particularly if the hierarchies are similar across different areas of the disk."
msgstr "这样就可以将长层次结构的引用折叠成非常紧凑的形式，尤其是在磁盘不同区域的层次结构相似的情况下。"

#. type: Plain text
#: zsh.texi:36324
msgid ""
"Name components may be completed: if a description is shown at the top of the list of completions, it includes the path to which previous components expand, while the description for an individual "
"completion shows the path segment it would add.  No additional configuration is needed for this as the completion system is aware of the dynamic directory name mechanism."
msgstr "名称组件可以补全：如果在补全列表顶部显示说明，则包括之前组件扩展的路径，而单个补全的说明则显示它将添加的路径段。 由于补全系统知道动态目录名称机制，因此无需为此进行额外配置。"

#. type: Plain text
#: zsh.texi:36336
msgid ""
"To use the function, first define a wrapper function for your specific case.  We'll assume it's to be autoloaded.  This can have any name but we'll refer to it as zdn_mywrapper.  This wrapper function "
"will define various variables and then call this function with the same arguments that the wrapper function gets.  This configuration is described below."
msgstr ""
"要使用该函数，首先要针对具体情况定义一个封装函数。 我们假设它是自动加载的。 它可以有任何名称，但我们将其称为 zdn_mywrapper。 该封装函数将定义各种变量，然后使用封装函数获得的相同参数调用该函数。 下面将介绍"
"这种配置。"

#. type: Plain text
#: zsh.texi:36339
msgid "Then arrange for the wrapper to be run as a zsh_directory_name hook:"
msgstr "然后安排封装器作为 zsh_directory_name 钩子运行："

#. type: example
#: zsh.texi:36344
#, no-wrap
msgid ""
"autoload -Uz add-zsh-hook zsh_directory_name_generic zdn_mywrapper\n"
"add-zsh-hook -U zsh_directory_name zdn_mywrapper\n"
msgstr ""
"autoload -Uz add-zsh-hook zsh_directory_name_generic zdn_mywrapper\n"
"add-zsh-hook -U zsh_directory_name zdn_mywrapper\n"

#. type: Plain text
#: zsh.texi:36357
msgid ""
"The wrapper function should define a local associative array zdn_top.  Alternatively, this can be set with a style called @t{mapping}.  The context for the style is @t{:zdn:}@var{wrapper-name} where "
"@var{wrapper-name} is the function calling zsh_directory_name_generic; for example:"
msgstr ""
"封装函数应定义一个本地关联数组 zdn_top。 或者，也可以使用名为 @t{mapping} 的样式来设置。 样式的上下文为 @t{:zdn:}@var{wrapper-name}，其中 @var{wrapper-name} 是调用 zsh_directory_name_generic 的函数；例如"

#. type: example
#: zsh.texi:36361
#, no-wrap
msgid "zstyle :zdn:zdn_mywrapper: mapping zdn_mywrapper_top\n"
msgstr "zstyle :zdn:zdn_mywrapper: mapping zdn_mywrapper_top\n"

#. type: Plain text
#: zsh.texi:36376
msgid ""
"The keys in this associative array correspond to the first component of the name.  The values are matching directories.  They may have an optional suffix with a slash followed by a colon and the name of a "
"variable in the same format to give the next component.  (The slash before the colon is to disambiguate the case where a colon is needed in the path for a drive.  There is otherwise no syntax for escaping "
"this, so path components whose names start with a colon are not supported.)  A special component @t{:default:} specifies a variable in the form @t{/:}@var{var} (the path section is ignored and so is "
"usually empty)  that will be used for the next component if no variable is given for the path.  Variables referred to within @t{zdn_top} have the same format as @t{zdn_top} itself, but contain relative "
"paths."
msgstr ""
"该关联数组的键与名称的第一个组件相对应。 值是匹配的目录。 它们可以有一个可选的后缀，后缀是一个斜线，后面跟一个冒号和一个格式相同的变量名，以便给出下一个组件。 (冒号前的斜线是为了消除歧义，这种情况，驱动器"
"路径中需要冒号。 除此之外，没有任何语法可以将其转义，因此不支持名称以冒号开头的路径组件）。 一个特殊的组件 @t{:default:} 以 @t{/:}@var{var} 的形式指定了一个变量（路径部分将被忽略，因此通常为空），如果没有"
"为路径指定变量，下一个组件将使用该变量。 @t{zdn_top} 中引用的变量格式与 @t{zdn_top} 本身相同，但包含相对路径。"

#. type: example
#: zsh.texi:36388
#, no-wrap
msgid ""
"local -A zdn_top=(\n"
"  g   ~/git\n"
"  ga  ~/alternate/git\n"
"  gs  /scratch/$USER/git/:second2\n"
"  :default: /:second1\n"
")\n"
msgstr ""
"local -A zdn_top=(\n"
"  g   ~/git\n"
"  ga  ~/alternate/git\n"
"  gs  /scratch/$USER/git/:second2\n"
"  :default: /:second1\n"
")\n"

#. type: Plain text
#: zsh.texi:36397
msgid ""
"This specifies the behaviour of a directory referred to as @t{~[g:...]} or @t{~[ga:...]} or @t{~[gs:...]}.  Later path components are optional; in that case @t{~[g]} expands to @t{~/git}, and so on.  "
"@t{gs} expands to @t{/scratch/$USER/git} and uses the associative array @t{second2} to match the second component; @t{g} and @t{ga} use the associative array @t{second1} to match the second component."
msgstr ""
"这指定了被称为 @t{~[g:...]} 或 @t{~[ga:...]} 或 @t{~[gs:...]}的目录的行为。 后面的路径组件是可选的；在这种情况下，@t{~[g]} 会扩展为 @t{~/git}，以此类推。 @t{gs} 扩展为 @t{/scratch/$USER/git}，并使用关联数"
"组 @t{second2} 匹配第二个组件；@t{g} 和 @t{ga} 使用关联数组 @t{second1} 匹配第二个组件。"

#. type: Plain text
#: zsh.texi:36405
msgid ""
"When expanding a name to a directory, if the first component is not @t{g} or @t{ga} or @t{gs}, it is not an error; the function simply returns 1 so that a later hook function can be tried.  However, "
"matching the first component commits the function, so if a later component does not match, an error is printed (though this still does not stop later hooks from being executed)."
msgstr ""
"在将名称扩展为目录时，如果第一个组件不是 @t{g}、@t{ga} 或 @t{gs}，则不会出错；函数只会返回 1，以便尝试后面的钩子函数。 不过，匹配第一个组件会提交函数，因此如果后面的组件不匹配，就会打印错误信息（尽管这仍不"
"能阻止后面的钩子执行）。"

#. type: Plain text
#: zsh.texi:36409
msgid "For components after the first, a relative path is expected, but note that multiple levels may still appear.  Here is an example of @t{second1}:"
msgstr "对于第一个组件之后的组件，预计会使用相对路径，但注意仍可能出现多个层级。 下面是 @t{second1} 的示例："

#. type: example
#: zsh.texi:36417
#, no-wrap
msgid ""
"local -A second1=(\n"
"  p   myproject\n"
"  s   somproject\n"
"  os  otherproject/subproject/:third\n"
")\n"
msgstr ""
"local -A second1=(\n"
"  p   myproject\n"
"  s   somproject\n"
"  os  otherproject/subproject/:third\n"
")\n"

#. type: Plain text
#: zsh.texi:36427
msgid ""
"The path as found from @t{zdn_top} is extended with the matching directory, so @t{~[g:p]} becomes @t{~/git/myproject}.  The slash between is added automatically (it's not possible to have a later "
"component modify the name of a directory already matched).  Only @t{os} specifies a variable for a third component, and there's no @t{:default:}, so it's an error to use a name like @t{~[g:p:x]} or "
"@t{~[ga:s:y]} because there's nowhere to look up the @t{x} or @t{y}."
msgstr ""
"从 @t{zdn_top} 中找到的路径会用匹配目录进行扩展，因此 @t{~[g:p]} 变成了 @t{~/git/myproject}。 中间的斜线是自动添加的（不可能让后面的组件修改已匹配目录的名称）。 只有 @t{os} 为第三个组件指定了变量，而且没"
"有 @t{:default:}，因此使用 @t{~[g:p:x]} 或 @t{~[ga:s:y]} 这样的名称是错误的，因为没有地方可以查找 @t{x} 或 @t{y}。"

#. type: Plain text
#: zsh.texi:36434
msgid ""
"The associative arrays need to be visible within this function; the generic function therefore uses internal variable names beginning @t{_zdn_} in order to avoid clashes.  Note that the variable @t{reply} "
"needs to be passed back to the shell, so should not be local in the calling function."
msgstr "关联数组需要在该函数中可见；因此，为了避免冲突，泛型函数使用了以 @t{_zdn_} 开头的内部变量名。 需要注意的是，变量 @t{reply} 需要传回 shell，因此不应在调用函数中本地化。"

#. type: Plain text
#: zsh.texi:36440
msgid ""
"The function does not test whether directories assembled by component actually exist; this allows the system to work across automounted file systems.  The error from the command trying to use a non-"
"existent directory should be sufficient to indicate the problem."
msgstr "该函数并不测试由组件组成的目录是否实际存在；这使得系统可以在自动挂载的文件系统中运行。 试图使用不存在的目录时，命令会出现错误，这足以说明问题所在。"

#. type: subsection
#: zsh.texi:36443
#, no-wrap
msgid "Complete example"
msgstr "补全示例"

#. type: Plain text
#: zsh.texi:36451
msgid ""
"Here is a full fictitious but usable autoloadable definition of the example function defined by the code above.  So @t{~[gs:p:s]} expands to @t{/scratch/$USER/git/myscratchproject/top/srcdir} (with "
"@t{$USER} also expanded)."
msgstr "以下是上述代码定义的示例函数的完整虚构但可用的自动加载定义。 因此， @t{~[gs:p:s]} 会展开为 @t{/scratch/$USER/git/myscratchproject/top/srcdir}（@t{$USER} 也会展开）。"

#. type: example
#: zsh.texi:36460
#, no-wrap
msgid ""
"local -A zdn_top=(\n"
"  g   ~/git\n"
"  ga  ~/alternate/git\n"
"  gs  /scratch/$USER/git/:second2\n"
"  :default: /:second1\n"
")\n"
"\n"
msgstr ""
"local -A zdn_top=(\n"
"  g   ~/git\n"
"  ga  ~/alternate/git\n"
"  gs  /scratch/$USER/git/:second2\n"
"  :default: /:second1\n"
")\n"
"\n"

#. type: example
#: zsh.texi:36466
#, no-wrap
msgid ""
"local -A second1=(\n"
"  p   myproject\n"
"  s   somproject\n"
"  os  otherproject/subproject/:third\n"
")\n"
"\n"
msgstr ""
"local -A second1=(\n"
"  p   myproject\n"
"  s   somproject\n"
"  os  otherproject/subproject/:third\n"
")\n"
"\n"

#. type: example
#: zsh.texi:36471
#, no-wrap
msgid ""
"local -A second2=(\n"
"  p   myscratchproject\n"
"  s   somescratchproject\n"
")\n"
"\n"
msgstr ""
"local -A second2=(\n"
"  p   myscratchproject\n"
"  s   somescratchproject\n"
")\n"
"\n"

#. type: example
#: zsh.texi:36476
#, no-wrap
msgid ""
"local -A third=(\n"
"  s   top/srcdir\n"
"  d   top/documentation\n"
")\n"
"\n"
msgstr ""
"local -A third=(\n"
"  s   top/srcdir\n"
"  d   top/documentation\n"
")\n"
"\n"

#. type: example
#: zsh.texi:36480
#, no-wrap
msgid ""
"# autoload not needed if you did this at initialisation...\n"
"autoload -Uz zsh_directory_name_generic\n"
"zsh_directory_name_generic \"$@@\n"
msgstr ""
"# autoload not needed if you did this at initialisation...\n"
"autoload -Uz zsh_directory_name_generic\n"
"zsh_directory_name_generic \"$@@\n"

#. type: Plain text
#: zsh.texi:36486
msgid "It is also possible to use global associative arrays, suitably named, and set the style for the context of your wrapper function to refer to this.  Then your set up code would contain the following:"
msgstr "也可以使用全局关联数组（以适当的方式命名），并将封装函数的上下文样式设置为引用到这个数组。 这样，您的设置代码将包含以下内容："

#. type: example
#: zsh.texi:36494
#, no-wrap
msgid ""
"typeset -A zdn_mywrapper_top=(...)\n"
"# ... and so on for other associative arrays ...\n"
"zstyle ':zdn:zdn_mywrapper:' mapping zdn_mywrapper_top\n"
"autoload -Uz add-zsh-hook zsh_directory_name_generic zdn_mywrapper\n"
"add-zsh-hook -U zsh_directory_name zdn_mywrapper\n"
msgstr ""
"typeset -A zdn_mywrapper_top=(...)\n"
"# ... and so on for other associative arrays ...\n"
"zstyle ':zdn:zdn_mywrapper:' mapping zdn_mywrapper_top\n"
"autoload -Uz add-zsh-hook zsh_directory_name_generic zdn_mywrapper\n"
"add-zsh-hook -U zsh_directory_name zdn_mywrapper\n"

#. type: Plain text
#: zsh.texi:36498
msgid "and the function @t{zdn_mywrapper} would contain only the following:"
msgstr "而函数 @t{zdn_mywrapper} 将只包含以下内容："

#. type: example
#: zsh.texi:36502
#, no-wrap
msgid "zsh_directory_name_generic \"$@@\"\n"
msgstr "zsh_directory_name_generic \"$@@\"\n"

#. type: node
#: zsh.texi:36505 zsh.texi:37906 zsh.texi:37908 zsh.texi:38080
#, no-wrap
msgid "Prompt Themes"
msgstr "提示符主题"

#. type: section
#: zsh.texi:36507
#, no-wrap
msgid "Gathering information from version control systems"
msgstr "从版本控制系统中收集信息"

#. type: cindex
#: zsh.texi:36509
#, no-wrap
msgid "version control utility"
msgstr "版本控制实用程序"

#. type: Plain text
#: zsh.texi:36516
msgid ""
"In a lot of cases, it is nice to automatically retrieve information from version control systems (VCSs), such as subversion, CVS or git, to be able to provide it to the user; possibly in the user's "
"prompt. So that you can instantly tell which branch you are currently on, for example."
msgstr "在很多情况下，从版本控制系统（VCS）（如 subversion、CVS 或 git）中自动获取信息并提供给用户（可能是在用户提示符中）是件好事。例如，这样你就能立即知道当前在哪个分支上。"

#. type: Plain text
#: zsh.texi:36519
msgid "In order to do that, you may use the @t{vcs_info} function."
msgstr "为此，您可以使用 @t{vcs_info} 函数。"

#. type: Plain text
#: zsh.texi:36523
msgid "The following VCSs are supported, showing the abbreviated name by which they are referred to within the system:"
msgstr "系统支持以下版本控制系统，并显示了系统内使用的简称："

#. type: item
#: zsh.texi:36524
#, no-wrap
msgid "Bazaar (@t{bzr})"
msgstr "Bazaar (@t{bzr})"

#. type: t{#1}
#: zsh.texi:36526
msgid "@uref{https://bazaar.canonical.com/}"
msgstr "@uref{https://bazaar.canonical.com/}"

#. type: item
#: zsh.texi:36526
#, no-wrap
msgid "Codeville (@t{cdv})"
msgstr "Codeville (@t{cdv})"

#. type: t{#1}
#: zsh.texi:36528
msgid "@uref{http://freecode.com/projects/codeville/}"
msgstr "@uref{http://freecode.com/projects/codeville/}"

#. type: item
#: zsh.texi:36528
#, no-wrap
msgid "Concurrent Versioning System (@t{cvs})"
msgstr "Concurrent Versioning System (@t{cvs})"

#. type: t{#1}
#: zsh.texi:36530
msgid "@uref{https://www.nongnu.org/cvs/}"
msgstr "@uref{https://www.nongnu.org/cvs/}"

#. type: item
#: zsh.texi:36530
#, no-wrap
msgid "Darcs (@t{darcs})"
msgstr "Darcs (@t{darcs})"

#. type: t{#1}
#: zsh.texi:36532
msgid "@uref{http://darcs.net/}"
msgstr "@uref{http://darcs.net/}"

#. type: item
#: zsh.texi:36532
#, no-wrap
msgid "Fossil (@t{fossil})"
msgstr "Fossil (@t{fossil})"

#. type: t{#1}
#: zsh.texi:36534
msgid "@uref{https://fossil-scm.org/}"
msgstr "@uref{https://fossil-scm.org/}"

#. type: item
#: zsh.texi:36534
#, no-wrap
msgid "Git (@t{git})"
msgstr "Git (@t{git})"

#. type: t{#1}
#: zsh.texi:36536
msgid "@uref{https://git-scm.com/}"
msgstr "@uref{https://git-scm.com/}"

#. type: item
#: zsh.texi:36536
#, no-wrap
msgid "GNU arch (@t{tla})"
msgstr "GNU arch (@t{tla})"

#. type: t{#1}
#: zsh.texi:36538
msgid "@uref{https://www.gnu.org/software/gnu-arch/}"
msgstr "@uref{https://www.gnu.org/software/gnu-arch/}"

#. type: item
#: zsh.texi:36538
#, no-wrap
msgid "Mercurial (@t{hg})"
msgstr "Mercurial (@t{hg})"

#. type: t{#1}
#: zsh.texi:36540
msgid "@uref{https://www.mercurial-scm.org/}"
msgstr "@uref{https://www.mercurial-scm.org/}"

#. type: item
#: zsh.texi:36540
#, no-wrap
msgid "Monotone (@t{mtn})"
msgstr "Monotone (@t{mtn})"

#. type: t{#1}
#: zsh.texi:36542
msgid "@uref{https://monotone.ca/}"
msgstr "@uref{https://monotone.ca/}"

#. type: item
#: zsh.texi:36542
#, no-wrap
msgid "Perforce (@t{p4})"
msgstr "Perforce (@t{p4})"

#. type: t{#1}
#: zsh.texi:36544
msgid "@uref{https://www.perforce.com/}"
msgstr "@uref{https://www.perforce.com/}"

#. type: item
#: zsh.texi:36544
#, no-wrap
msgid "Subversion (@t{svn})"
msgstr "Subversion (@t{svn})"

#. type: t{#1}
#: zsh.texi:36546
msgid "@uref{https://subversion.apache.org/}"
msgstr "@uref{https://subversion.apache.org/}"

#. type: item
#: zsh.texi:36546
#, no-wrap
msgid "SVK (@t{svk})"
msgstr "SVK (@t{svk})"

#. type: t{#1}
#: zsh.texi:36548
msgid "@uref{https://svk.bestpractical.com/}"
msgstr "@uref{https://svk.bestpractical.com/}"

#. type: Plain text
#: zsh.texi:36555
msgid "There is also support for the patch management system @t{quilt} (@t{@uref{https://savannah.nongnu.org/projects/quilt}}). See @ref{vcs_info Quilt Support} below for details."
msgstr "此外，还支持补丁管理系统 @t{quilt} (@t{@uref{https://savannah.nongnu.org/projects/quilt}})。详情请参见下面的 @ref{vcs_info Quilt 支持}。"

#. type: Plain text
#: zsh.texi:36558
msgid "To load @t{vcs_info}:"
msgstr "载入 @t{vcs_info}:"

#. type: example
#: zsh.texi:36562
#, no-wrap
msgid "autoload -Uz vcs_info\n"
msgstr "autoload -Uz vcs_info\n"

#. type: Plain text
#: zsh.texi:36567
msgid "It can be used in any existing prompt, because it does not require any specific @t{$psvar} entries to be available."
msgstr "它可以在任何现有提示符中使用，因为它不需要任何特定的 @t{$psvar} 条目。"

#. type: menuentry
#: zsh.texi:36578
msgid "vcs_info Quickstart::"
msgstr "vcs_info 快速开始::"

#. type: menuentry
#: zsh.texi:36578
msgid "vcs_info Configuration::"
msgstr "vcs_info 配置::"

#. type: menuentry
#: zsh.texi:36578
msgid "vcs_info Oddities::"
msgstr "vcs_info 奇特现象::"

#. type: menuentry
#: zsh.texi:36578
msgid "vcs_info Quilt Support::"
msgstr "vcs_info Quilt 支持::"

#. type: menuentry
#: zsh.texi:36578
msgid "vcs_info API::"
msgstr "vcs_info API::"

#. type: menuentry
#: zsh.texi:36578
msgid "vcs_info Variables::"
msgstr "vcs_info 变量::"

#. type: menuentry
#: zsh.texi:36578
msgid "vcs_info Hooks::"
msgstr "vcs_info 勾子::"

#. type: node
#: zsh.texi:36578 zsh.texi:37398 zsh.texi:37715
#, no-wrap
msgid "vcs_info Examples"
msgstr "vcs_info 示例"

#. type: node
#: zsh.texi:36581 zsh.texi:36666
#, no-wrap
msgid "vcs_info Quickstart"
msgstr "vcs_info 快速开始"

#. type: node
#: zsh.texi:36581 zsh.texi:36666 zsh.texi:37170
#, no-wrap
msgid "vcs_info Configuration"
msgstr "vcs_info 配置"

#. type: subsection
#: zsh.texi:36583
#, no-wrap
msgid "Quickstart"
msgstr "快速开始"

#. type: Plain text
#: zsh.texi:36589
msgid "To get this feature working quickly (including colors), you can do the following (assuming, you loaded @t{vcs_info} properly - see above):"
msgstr "要快速使用此功能（包括颜色），可以执行以下操作（假设已正确加载 @t{vcs_info} - 参见上文）："

#. type: example
#: zsh.texi:36599
#, no-wrap
msgid ""
"zstyle ':vcs_info:*' actionformats \\ \n"
"    '%F@{5@}(%f%s%F@{5@})%F@{3@}-%F@{5@}[%F@{2@}%b%F@{3@}|%F@{1@}%a%F@{5@}]%f '\n"
"zstyle ':vcs_info:*' formats       \\ \n"
"    '%F@{5@}(%f%s%F@{5@})%F@{3@}-%F@{5@}[%F@{2@}%b%F@{5@}]%f '\n"
"zstyle ':vcs_info:(sv[nk]|bzr):*' branchformat '%b%F@{1@}:%F@{3@}%r'\n"
"precmd () @{ vcs_info @}\n"
"PS1='%F@{5@}[%F@{2@}%n%F@{5@}] %F@{3@}%3~ $@{vcs_info_msg_0_@}%f%# '\n"
msgstr ""
"zstyle ':vcs_info:*' actionformats \\ \n"
"    '%F@{5@}(%f%s%F@{5@})%F@{3@}-%F@{5@}[%F@{2@}%b%F@{3@}|%F@{1@}%a%F@{5@}]%f '\n"
"zstyle ':vcs_info:*' formats       \\ \n"
"    '%F@{5@}(%f%s%F@{5@})%F@{3@}-%F@{5@}[%F@{2@}%b%F@{5@}]%f '\n"
"zstyle ':vcs_info:(sv[nk]|bzr):*' branchformat '%b%F@{1@}:%F@{3@}%r'\n"
"precmd () @{ vcs_info @}\n"
"PS1='%F@{5@}[%F@{2@}%n%F@{5@}] %F@{3@}%3~ $@{vcs_info_msg_0_@}%f%# '\n"

#. type: Plain text
#: zsh.texi:36605
msgid ""
"Obviously, the last two lines are there for demonstration. You need to call @t{vcs_info} from your @t{precmd} function. Once that is done you need a @emph{single quoted} @t{'$@{vcs_info_msg_0_@}'} in your "
"prompt."
msgstr "很明显，最后两行是用来演示的。您需要从 @t{precmd} 函数中调用 @t{vcs_info}。调用完成后，您需要在提示符中为 @t{'$@{vcs_info_msg_0_@}'} @emph{加单引号} 。"

#. type: Plain text
#: zsh.texi:36609
msgid "To be able to use @t{'$@{vcs_info_msg_0_@}'} directly in your prompt like this, you will need to have the @t{PROMPT_SUBST} option enabled."
msgstr "要像这样在提示符中直接使用 @t{'$@{vcs_info_msg_0_@}'} ，需要启用 @t{PROMPT_SUBST} 选项。"

#. type: Plain text
#: zsh.texi:36612
msgid "Now call the @t{vcs_info_printsys} utility from the command line:"
msgstr "现在从命令行调用 @t{vcs_info_printsys} 工具："

#. type: example
#: zsh.texi:36638
#, no-wrap
msgid ""
"% vcs_info_printsys\n"
"## list of supported version control backends:\n"
"## disabled systems are prefixed by a hash sign (#)\n"
"bzr\n"
"cdv\n"
"cvs\n"
"darcs\n"
"fossil\n"
"git\n"
"hg\n"
"mtn\n"
"p4\n"
"svk\n"
"svn\n"
"tla\n"
"## flavours (cannot be used in the enable or disable styles; they\n"
"## are enabled and disabled with their master [git-svn -> git])\n"
"## they *can* be used in contexts: ':vcs_info:git-svn:*'.\n"
"git-p4\n"
"git-svn\n"
"hg-git\n"
"hg-hgsubversion\n"
"hg-hgsvn\n"
msgstr ""
"% vcs_info_printsys\n"
"## list of supported version control backends:\n"
"## disabled systems are prefixed by a hash sign (#)\n"
"bzr\n"
"cdv\n"
"cvs\n"
"darcs\n"
"fossil\n"
"git\n"
"hg\n"
"mtn\n"
"p4\n"
"svk\n"
"svn\n"
"tla\n"
"## flavours (cannot be used in the enable or disable styles; they\n"
"## are enabled and disabled with their master [git-svn -> git])\n"
"## they *can* be used in contexts: ':vcs_info:git-svn:*'.\n"
"git-p4\n"
"git-svn\n"
"hg-git\n"
"hg-hgsubversion\n"
"hg-hgsvn\n"

#. type: Plain text
#: zsh.texi:36644
msgid "You may not want all of these because there is no point in running the code to detect systems you do not use.  So there is a way to disable some backends altogether:"
msgstr "您可能不需要所有这些，因为运行代码来检测您不使用的系统毫无意义。 因此，有一种方法可以完全禁用某些后端："

#. type: example
#: zsh.texi:36648
#, no-wrap
msgid "zstyle ':vcs_info:*' disable bzr cdv darcs mtn svk tla\n"
msgstr "zstyle ':vcs_info:*' disable bzr cdv darcs mtn svk tla\n"

#. type: Plain text
#: zsh.texi:36652
msgid "You may also pick a few from that list and enable only those:"
msgstr "您也可以从列表中挑选几项，并只启用那几项："

#. type: example
#: zsh.texi:36656
#, no-wrap
msgid "zstyle ':vcs_info:*' enable git cvs svn\n"
msgstr "zstyle ':vcs_info:*' enable git cvs svn\n"

#. type: Plain text
#: zsh.texi:36664
msgid ""
"If you rerun @t{vcs_info_printsys} after one of these commands, you will see the backends listed in the @t{disable} style (or backends not in the @t{enable} style - if you used that) marked as disabled by "
"a hash sign.  That means the detection of these systems is skipped @emph{completely}. No wasted time there."
msgstr ""
"如果你在执行完这些命令后重新运行 @t{vcs_info_printsys}，你会看到 @t{disable} 样式中列出的后端（或 @t{enable} 样式中没有列出的后端（如果你使用了））以哈希符号标记为禁用。 这意味着将 @emph{完全} 跳过对这些系"
"统的检测。不会浪费时间。"

#. type: node
#: zsh.texi:36666 zsh.texi:37170 zsh.texi:37193
#, no-wrap
msgid "vcs_info Oddities"
msgstr "vcs_info 奇特现象"

#. type: Plain text
#: zsh.texi:36673
msgid "The @t{vcs_info} feature can be configured via @t{zstyle}."
msgstr "可通过 @t{zstyle} 配置 @t{vcs_info} 功能。"

#. type: Plain text
#: zsh.texi:36676
msgid "First, the context in which we are working:"
msgstr "首先是我们工作的上下文："

#. type: example
#: zsh.texi:36678
#, no-wrap
msgid ":vcs_info:@var{vcs-string}:@var{user-context}:@var{repo-root-name}\n"
msgstr ":vcs_info:@var{vcs-string}:@var{user-context}:@var{repo-root-name}\n"

#. type: var{#1}
#: zsh.texi:36682
#, no-wrap
msgid "vcs-string"
msgstr "vcs-string"

#. type: table
#: zsh.texi:36690
msgid ""
"is one of: @t{git}, @t{git-svn}, @t{git-p4}, @t{hg}, @t{hg-git}, @t{hg-hgsubversion}, @t{hg-hgsvn}, @t{darcs}, @t{bzr}, @t{cdv}, @t{mtn}, @t{svn}, @t{cvs}, @t{svk}, @t{tla}, @t{p4} or @t{fossil}.  This is "
"followed by `@t{.quilt-}@var{quilt-mode}' in Quilt mode (see @ref{vcs_info Quilt Support} for details)  and by `@t{+}@var{hook-name}' while hooks are active (see @ref{vcs_info Hooks} for details)."
msgstr ""
"是下列之一： @t{git}、@t{git-svn}、@t{git-p4}、@t{hg}、@t{hg-git}、@t{hg-hgsubversion}、@t{hg-hgsvn}、@t{darcs}、@t{bzr}、@t{cdv}、@t{mtn}、@t{svn}、@t{cvs}、@t{svk}、@t{tla}、@t{p4} 或 @t{fossil}。 在 "
"Quilt 模式（详见 @ref{vcs_info Quilt 支持}）下，后跟 `@t{.quilt-}@var{quilt-mode}' ；在钩子激活时，后跟 `@t{+}@var{hook-name}' （详见 @ref{vcs_info 勾子}）。"

#. type: table
#: zsh.texi:36695
msgid "Currently, hooks in quilt mode don't add the `@t{.quilt-}@var{quilt-mode}' information.  This may change in the future."
msgstr "目前，quilt 模式下的钩子不会添加 `@t{.quilt-}@var{quilt-mode}' 信息。 这点未来可能会有所改变。"

#. type: var{#1}
#: zsh.texi:36696
#, no-wrap
msgid "user-context"
msgstr "user-context"

#. type: table
#: zsh.texi:36700
msgid "is a freely configurable string, assignable by the user as the first argument to @t{vcs_info} (see its description below)."
msgstr "是一个可自由配置的字符串，用户可将其指定为 @t{vcs_info}的第一个参数（参见下文的描述）。"

#. type: var{#1}
#: zsh.texi:36701
#, no-wrap
msgid "repo-root-name"
msgstr "repo-root-name"

#. type: table
#: zsh.texi:36706
msgid ""
"is the name of a repository in which you want a style to match. So, if you want a setting specific to @t{/usr/src/zsh}, with that being a CVS checkout, you can set @var{repo-root-name} to @t{zsh} to make "
"it so."
msgstr "是您希望匹配样式的版本库名称。因此，如果你想对 @t{/usr/src/zsh} 进行特定设置，并将其作为 CVS 检出，你可以将 @var{repo-root-name} 设置为 @t{zsh}，这样就可以了。"

#. type: Plain text
#: zsh.texi:36716
msgid ""
"There are three special values for @var{vcs-string}: The first is named @t{-init-}, that is in effect as long as there was no decision what VCS backend to use. The second is @t{-preinit-}; it is used "
"@emph{before} @t{vcs_info} is run, when initializing the data exporting variables. The third special value is @t{formats} and is used by the @t{vcs_info_lastmsg} for looking up its styles."
msgstr ""
"@var{vcs-string} 有三个特殊值： 第一种名为 @t{-init-}，在尚未决定使用哪种 VCS 后端时有效。第二个是 @t{-preinit-}；它在 @t{vcs_info}  @emph{之前}，初始化数据导出变量时， 使用。第三个特殊值是 @t{formats}，用"
"于 @t{vcs_info_lastmsg} 查找样式。"

#. type: Plain text
#: zsh.texi:36724
msgid ""
"The initial value of @var{repo-root-name} is @t{-all-} and it is replaced with the actual name, as soon as it is known. Only use this part of the context for defining the @t{formats}, @t{actionformats} or "
"@t{branchformat} styles, as it is guaranteed that @var{repo-root-name} is set up correctly for these only. For all other styles, just use @t{'*'} instead."
msgstr ""
"@var{repo-root-name} 的初始值为 @t{-all-}，一旦知道实际名称，就会立即替换为该名称。只有在定义 @t{formats}、@t{actionformats} 或 @t{branchformat} 样式时才会使用这部分上下文，因为只有在这些情况下 @var{repo-"
"root-name} 才会被正确设置。对于其他样式，只需使用 @t{'*'} 代替即可。"

#. type: Plain text
#: zsh.texi:36727
msgid "There are two pre-defined values for @var{user-context}:"
msgstr "@var{user-context} 有两个预定义值："

#. type: table
#: zsh.texi:36730
msgid "the one used if none is specified"
msgstr "如果没有指定，则使用"

#. type: table
#: zsh.texi:36732
msgid "used by vcs_info_lastmsg to lookup its styles"
msgstr "被 vcs_info_lastmsg 用于查找其样式"

#. type: Plain text
#: zsh.texi:36737
msgid "You can of course use @t{':vcs_info:*'} to match all VCSs in all user-contexts at once."
msgstr "当然，您也可以使用 @t{':vcs_info:*'} 一次匹配所有用户上下文中的所有 VCS。"

#. type: Plain text
#: zsh.texi:36740
msgid "This is a description of all styles that are looked up."
msgstr "这是对所有查询样式的描述。"

#. type: t{#1}
#: zsh.texi:36743 zsh.texi:36744 zsh.texi:36994
#, no-wrap
msgid "formats"
msgstr "formats"

#. type: table
#: zsh.texi:36747
msgid "A list of formats, used when actionformats is not used (which is most of the time)."
msgstr "格式列表，用于不使用 actionformats 时（大多数情况下）。"

#. type: t{#1}
#: zsh.texi:36748 zsh.texi:36749 zsh.texi:36996
#, no-wrap
msgid "actionformats"
msgstr "actionformats"

#. type: table
#: zsh.texi:36753
msgid "A list of formats, used if there is a special action going on in your current repository; like an interactive rebase or a merge conflict."
msgstr "格式列表，用于当前版本库中正在进行的特殊操作，如交互式重置或合并冲突。"

#. type: t{#1}
#: zsh.texi:36754 zsh.texi:36755 zsh.texi:36998
#, no-wrap
msgid "branchformat"
msgstr "branchformat"

#. type: table
#: zsh.texi:36759
msgid "Some backends replace @t{%b} in the formats and actionformats styles above, not only by a branch name but also by a revision number. This style lets you modify how that string should look."
msgstr "在上述 formats 和 actionformats 样式中，有些后端不仅会用分支名称替换 @t{%b}，还会用版本号替换 @t{%b}。这种样式允许你修改该字符串的外观。"

#. type: t{#1}
#: zsh.texi:36760 zsh.texi:36761 zsh.texi:37000
#, no-wrap
msgid "nvcsformats"
msgstr "nvcsformats"

#. type: table
#: zsh.texi:36767
msgid ""
"These \"formats\" are set when we didn't detect a version control system for the current directory or @t{vcs_info} was disabled. This is useful if you want @t{vcs_info} to completely take over the "
"generation of your prompt. You would do something like @t{PS1='$@{vcs_info_msg_0_@}'} to accomplish that."
msgstr ""
"当我们没有检测到当前目录的版本控制系统或 @t{vcs_info} 被禁用时，就会设置这些 \"格式\"。如果你想让 @t{vcs_info} 完全接管提示符的生成，这一点非常有用。为此，你可以使用@t{PS1='$@{vcs_info_msg_0_@}'} 这样的方"
"法。"

#. type: t{#1}
#: zsh.texi:36768 zsh.texi:36769 zsh.texi:37002
#, no-wrap
msgid "hgrevformat"
msgstr "hgrevformat"

#. type: table
#: zsh.texi:36777
msgid ""
"@t{hg} uses both a hash and a revision number to reference a specific changeset in a repository. With this style you can format the revision string (see @t{branchformat}) to include either or both. It's "
"only useful when @t{get-revision} is true. Note, the full 40-character revision id is not available (except when using the @t{use-simple} option) because executing hg more than once per prompt is too "
"slow; you may customize this behavior using hooks."
msgstr ""
"@t{hg} 同时使用哈希值和版本号来引用版本库中的特定变更集。使用这个样式，你可以格式化版本号字符串（参见 @t{branchformat}），使其中之一或两者。只有当 @t{get-revision} 为 true 时才有用。需要注意的是，由于每次"
"提示符执行 hg 多于一次会导致速度过慢，因此无法使用完整的 40 个字符的修订版本 ID（使用 @t{use-simple} 选项时除外）；你可以使用钩子自定义此行为。"

#. type: t{#1}
#: zsh.texi:36778 zsh.texi:36779 zsh.texi:37004
#, no-wrap
msgid "max-exports"
msgstr "max-exports"

#. type: table
#: zsh.texi:36782
msgid "Defines the maximum number of @t{vcs_info_msg_*_} variables @t{vcs_info} will set."
msgstr "定义 @t{vcs_info} 将设置的 @t{vcs_info_msg_*_} 变量的最大数量。"

#. type: table
#: zsh.texi:36790
msgid ""
"A list of backends you want to use. Checked in the @t{-init-} context. If this list contains an item called @t{NONE} no backend is used at all and @t{vcs_info} will do nothing. If this list contains "
"@t{ALL}, @t{vcs_info} will use all known backends. Only with @t{ALL} in @t{enable} will the @t{disable} style have any effect. @t{ALL} and @t{NONE} are case insensitive."
msgstr ""
"要使用的后端列表。在 @t{-init-} 上下文中进行检查。如果该列表包含名为 @t{NONE} 的项，则不会使用任何后端，@t{vcs_info} 也不会做任何操作。如果该列表包含 @t{ALL}，@t{vcs_info} 将使用所有已知的后端。只有 "
"@t{enable} 中包含 @t{ALL} 时，@t{disable} 样式才会生效。@t{ALL} 和 @t{NONE} 不区分大小写。"

#. type: table
#: zsh.texi:36796
msgid "A list of VCSs you don't want @t{vcs_info} to test for repositories (checked in the @t{-init-} context, too). Only used if @t{enable} contains @t{ALL}."
msgstr "不想让 @t{vcs_info} 测试版本库的 VCS 列表（在 @t{-init-} 上下文中也会检查）。仅在 @t{enable} 包含 @t{ALL} 时使用。"

#. type: t{#1}
#: zsh.texi:36797 zsh.texi:36798 zsh.texi:37010
#, no-wrap
msgid "disable-patterns"
msgstr "disable-patterns"

#. type: table
#: zsh.texi:36802
msgid "A list of patterns that are checked against @t{$PWD}. If a pattern matches, @t{vcs_info} will be disabled. This style is checked in the @t{:vcs_info:-init-:*:-all-} context."
msgstr "根据 @t{$PWD} 检查的模式列表。如果一个模式匹配，@t{vcs_info} 将被禁用。此样式在 @t{:vcs_info:-init-:*:-all-} 上下文中进行检查。"

#. type: table
#: zsh.texi:36806
msgid "Say, @t{~/.zsh} is a directory under version control, in which you do not want @t{vcs_info} to be active, do:"
msgstr "假设 @t{~/.zsh} 是一个受版本控制的目录，您不希望 @t{vcs_info} 在其中处于活动状态，请执行此操作："

#. type: example
#: zsh.texi:36808
#, no-wrap
msgid "zstyle ':vcs_info:*' disable-patterns \"$@{(b)HOME@}/.zsh(|/*)\"\n"
msgstr "zstyle ':vcs_info:*' disable-patterns \"$@{(b)HOME@}/.zsh(|/*)\"\n"

#. type: t{#1}
#: zsh.texi:36810 zsh.texi:36811 zsh.texi:37038
#, no-wrap
msgid "use-quilt"
msgstr "use-quilt"

#. type: table
#: zsh.texi:36814
msgid "If enabled, the @t{quilt} support code is active in `addon' mode.  See @ref{vcs_info Quilt Support} for details."
msgstr "如果启用，@t{quilt} 支持代码将在 `插件' 模式下激活。 有关详情，请参阅 @ref{vcs_info Quilt 支持} 。"

#. type: t{#1}
#: zsh.texi:36815 zsh.texi:36816 zsh.texi:37040
#, no-wrap
msgid "quilt-standalone"
msgstr "quilt-standalone"

#. type: table
#: zsh.texi:36819
msgid "If enabled, `standalone' mode detection is attempted if no VCS is active in a given directory. See @ref{vcs_info Quilt Support} for details."
msgstr "如果启用，在指定目录中如果没有激活 VCS ，将尝试进行 `独立' 模式检测。有关详情，请参阅 @ref{vcs_info Quilt 支持} 。"

#. type: t{#1}
#: zsh.texi:36820 zsh.texi:36821 zsh.texi:37042
#, no-wrap
msgid "quilt-patch-dir"
msgstr "quilt-patch-dir"

#. type: table
#: zsh.texi:36824
msgid "Overwrite the value of the @t{$QUILT_PATCHES} environment variable. See @ref{vcs_info Quilt Support} for details."
msgstr "覆盖 @t{$QUILT_PATCHES} 环境变量的值。有关详情，请参阅 @ref{vcs_info Quilt 支持} 。"

#. type: t{#1}
#: zsh.texi:36825 zsh.texi:36826 zsh.texi:37044
#, no-wrap
msgid "quiltcommand"
msgstr "quiltcommand"

#. type: table
#: zsh.texi:36829
msgid "When @t{quilt} itself is called in quilt support, the value of this style is used as the command name."
msgstr "在 quilt 支持中调用 @t{quilt} 本身时，该样式的值将被用作命令名称。"

#. type: t{#1}
#: zsh.texi:36830 zsh.texi:36831 zsh.texi:37012
#, no-wrap
msgid "check-for-changes"
msgstr "check-for-changes"

#. type: table
#: zsh.texi:36837
msgid ""
"If enabled, this style causes the @t{%c} and @t{%u} format escapes to show when the working directory has uncommitted changes. The strings displayed by these escapes can be controlled via the "
"@t{stagedstr} and @t{unstagedstr} styles. The only backends that currently support this option are @t{git}, @t{hg}, and @t{bzr} (the latter two only support unstaged)."
msgstr ""
"启用该样式后，当工作目录中有未提交的更改时，将显示 @t{%c} 和 @t{%u} 格式转义符。可以通过 @t{stagedstr} 和 @t{unstagedstr} 样式控制这些转义字符显示的字符串。目前支持此选项的后端只有 @t{git}、@t{hg} 和 "
"@t{bzr}（后两者仅支持未提交的）。"

#. type: table
#: zsh.texi:36842
msgid "For this style to be evaluated with the @t{hg} backend, the @t{get-revision} style needs to be set and the @t{use-simple} style needs to be unset. The latter is the default; the former is not."
msgstr "要使用 @t{hg} 后端对该样式进行评估，需要设置 @t{get-revision} 样式，并取消设置 @t{use-simple} 样式。后者是默认设置，前者则不是。"

#. type: table
#: zsh.texi:36846
msgid "With the @t{bzr} backend, @emph{lightweight checkouts} only honor this style if the @t{use-server} style is set."
msgstr "使用 @t{bzr} 后端时，只有设置了 @t{use-server} 样式，@emph{lightweight checkouts} 才会采用这种样式。"

#. type: table
#: zsh.texi:36851
msgid "Note, the actions taken if this style is enabled are potentially expensive (read: they may be slow, depending on how big the current repository is).  Therefore, it is disabled by default."
msgstr "需要注意的是，如果启用该样式，所采取的操作可能会很昂贵（可能会很慢，这取决于当前版本库有多大）。 因此，默认情况下是禁用的。"

#. type: t{#1}
#: zsh.texi:36852 zsh.texi:36853 zsh.texi:37014
#, no-wrap
msgid "check-for-staged-changes"
msgstr "check-for-staged-changes"

#. type: table
#: zsh.texi:36858
msgid ""
"This style is like @t{check-for-changes}, but it never checks the worktree files, only the metadata in the @t{.$@{vcs@}} dir.  Therefore, this style initializes only the @t{%c} escape (with @t{stagedstr}) "
"but not the @t{%u} escape.  This style is faster than @t{check-for-changes}."
msgstr ""
"该样式与 @t{check-for-changes} 类似，但它从不检查工作树文件，只检查 @t{.$@{vcs@}} 目录中的元数据。 因此，该样式只初始化 @t{%c} 转义符（使用 @t{stagedstr}），而不初始化 @t{%u} 转义符。 该样式比 @t{check-"
"for-changes} 更快。"

#. type: table
#: zsh.texi:36862
msgid "In the @t{git} backend, this style checks for changes in the index.  Other backends do not currently implement this style."
msgstr "在 @t{git} 后端，该样式会检查索引中的更改。 其他后端目前还未实现此样式。"

#. type: table
#: zsh.texi:36865
msgid "This style is disabled by default."
msgstr "这个样式默认禁用。"

#. type: t{#1}
#: zsh.texi:36866 zsh.texi:36867 zsh.texi:37016
#, no-wrap
msgid "stagedstr"
msgstr "stagedstr"

#. type: table
#: zsh.texi:36870
msgid "This string will be used in the @t{%c} escape if there are staged changes in the repository."
msgstr "如果存储库中有暂存的更改，该字符串将用于 @t{%c} 转义。"

#. type: t{#1}
#: zsh.texi:36871 zsh.texi:36872 zsh.texi:37018
#, no-wrap
msgid "unstagedstr"
msgstr "unstagedstr"

#. type: table
#: zsh.texi:36875
msgid "This string will be used in the @t{%u} escape if there are unstaged changes in the repository."
msgstr "如果版本库中有未暂存的更改，该字符串将用于 @t{%u} 转义。"

#. type: table
#: zsh.texi:36881
msgid "This style causes @t{vcs_info} to use the supplied string as the command to use as the VCS's binary. Note, that setting this in '@t{:vcs_info:*}' is not a good idea."
msgstr "这种样式会导致 @t{vcs_info} 使用所提供的字符串作为 VCS 的二进制命令。需要注意的是，在 '@t{:vcs_info:*}' 中设置此参数并不是一个好主意。"

#. type: table
#: zsh.texi:36886
msgid "If the value of this style is empty (which is the default), the used binary name is the name of the backend in use (e.g. @t{svn} is used in an @t{svn} repository)."
msgstr "如果该样式的值为空（默认值），则使用的二进制名是正在使用的后端名称（例如 @t{svn} 用于 @t{svn} 版本库）。"

#. type: table
#: zsh.texi:36890
msgid "The @t{repo-root-name} part in the context is always the default @t{-all-} when this style is looked up."
msgstr "在查找此样式时，上下文中的 @t{repo-root-name} 部分总是默认的 @t{-all-}。"

#. type: table
#: zsh.texi:36896
msgid ""
"For example, this style can be used to use binaries from non-default installation directories. Assume, @t{git} is installed in /usr/bin but your sysadmin installed a newer version in /usr/local/bin. "
"Instead of changing the order of your @t{$PATH} parameter, you can do this:"
msgstr "例如，这种样式可用于使用非默认安装目录中的二进制文件。假设 @t{git} 安装在 /usr/bin，但系统管理员在 /usr/local/bin 安装了更新的版本。与其改变 @t{$PATH} 参数的顺序，不如这样做："

#. type: example
#: zsh.texi:36898
#, no-wrap
msgid "zstyle ':vcs_info:git:*:-all-' command /usr/local/bin/git\n"
msgstr "zstyle ':vcs_info:git:*:-all-' command /usr/local/bin/git\n"

#. type: t{#1}
#: zsh.texi:36900 zsh.texi:36901 zsh.texi:37022
#, no-wrap
msgid "use-server"
msgstr "use-server"

#. type: table
#: zsh.texi:36914
msgid ""
"This is used by the Perforce backend (@t{p4}) to decide if it should contact the Perforce server to find out if a directory is managed by Perforce.  This is the only reliable way of doing this, but runs "
"the risk of a delay if the server name cannot be found.  If the server (more specifically, the @var{host}@t{:}@var{port} pair describing the server) cannot be contacted, its name is put into the "
"associative array @t{vcs_info_p4_dead_servers} and is not contacted again during the session until it is removed by hand.  If you do not set this style, the @t{p4} backend is only usable if you have set "
"the environment variable @t{P4CONFIG} to a file name and have corresponding files in the root directories of each Perforce client.  See comments in the function @t{VCS_INFO_detect_p4} for more detail."
msgstr ""
"Perforce 后端（@t{p4}）使用它来决定是否要联系 Perforce 服务器，以查明某个目录是否由 Perforce 管理。 这是唯一可靠的方法，但如果找不到服务器名称，就会有延迟的风险。 如果无法联系到服务器（更具体地说，就是描述"
"服务器的 @var{host}@t{:}@var{port} 对），其名称就会被放入关联数组 @t{vcs_info_p4_dead_servers} ，并且在会话期间不会再被联系，直到被手动删除。 如果不设置此样式，只有将环境变量 @t{P4CONFIG} 设置为文件名，并"
"且在每个 Perforce 客户端的根目录中都有相应的文件时，才能使用 @t{p4} 后端。 详情请参见函数 @t{VCS_INFO_detect_p4} 中的注释。"

#. type: table
#: zsh.texi:36918
msgid "The Bazaar backend (@t{bzr}) uses this to permit contacting the server about lightweight checkouts, see the @t{check-for-changes} style."
msgstr "Bazaar 后端（@t{bzr}）使用此功能允许就轻量级检出联系服务器，参见 @t{check-for-changes} 样式。"

#. type: t{#1}
#: zsh.texi:36919 zsh.texi:36920 zsh.texi:37024
#, no-wrap
msgid "use-simple"
msgstr "use-simple"

#. type: table
#: zsh.texi:36928
msgid ""
"If there are two different ways of gathering information, you can select the simpler one by setting this style to true; the default is to use the not-that-simple code, which is potentially a lot slower "
"but might be more accurate in all possible cases. This style is used by the @t{bzr}, @t{hg}, and @t{git} backends. In the case of @t{hg} it will invoke the external hexdump program to parse the binary "
"dirstate cache file; this method will not return the local revision number."
msgstr ""
"如果有两种不同的信息收集方式，可以通过将此样式设置为 true 来选择更简单的一种；默认情况下使用不那么简单的代码，这可能会慢很多，但在所有可能的情况下都可能更准确。@t{bzr}、@t{hg} 和 @t{git} 后端都使用这种样"
"式。对于 @t{hg}，它将调用外部 hexdump 程序来解析二进制 dirstate 缓存文件；该方法不会返回本地版本号。"

#. type: t{#1}
#: zsh.texi:36929 zsh.texi:36930 zsh.texi:37026
#, no-wrap
msgid "get-revision"
msgstr "get-revision"

#. type: table
#: zsh.texi:36937
msgid ""
"If set to true, vcs_info goes the extra mile to figure out the revision of a repository's work tree (currently for the @t{git} and @t{hg} backends, where this kind of information is not always vital). For "
"@t{git}, the hash value of the currently checked out commit is available via the @t{%i} expansion. With @t{hg}, the local revision number and the corresponding global hash are available via @t{%i}."
msgstr ""
"如果设置为 true，vcs_info 会额外计算版本库工作树的修订版本（目前适用于 @t{git} 和 @t{hg} 后端，这类信息并不总是很重要）。对于 @t{git}，当前已检出提交的哈希值可通过 @t{%i} 扩展获得。对于 @t{hg}，则可通过 "
"@t{%i} 获取本地版本号和相应的全局哈希值。"

#. type: t{#1}
#: zsh.texi:36938 zsh.texi:36939 zsh.texi:37028
#, no-wrap
msgid "get-mq"
msgstr "get-mq"

#. type: table
#: zsh.texi:36942
msgid "If set to true, the @t{hg} backend will look for a Mercurial Queue (@t{mq})  patch directory. Information will be available via the `@t{%m}' replacement."
msgstr "如果设置为 true，@t{hg} 后端将查找 Mercurial Queue (@t{mq}) 补丁目录。信息将通过 `@t{%m}' 替换提供。"

#. type: t{#1}
#: zsh.texi:36943 zsh.texi:36944 zsh.texi:37030
#, no-wrap
msgid "get-bookmarks"
msgstr "get-bookmarks"

#. type: table
#: zsh.texi:36947
msgid "If set to true, the @t{hg} backend will try to get a list of current bookmarks. They will be available via the `@t{%m}' replacement."
msgstr "如果设置为 true，@t{hg} 后端将尝试获取当前书签的列表。这些书签将通过 `@t{%m}' 替换获得。"

#. type: table
#: zsh.texi:36952
msgid ""
"The default is to generate a comma-separated list of all bookmark names that refer to the currently checked out revision.  If a bookmark is active, its name is suffixed an asterisk and placed first in the "
"list."
msgstr "默认设置是生成一个以逗号分隔的列表，其中包含所有指向当前已检出修订版的书签名称。 如果某个书签处于活动状态，则其名称后缀星号，并置于列表首位。"

#. type: t{#1}
#: zsh.texi:36953 zsh.texi:36954 zsh.texi:37032
#, no-wrap
msgid "use-prompt-escapes"
msgstr "use-prompt-escapes"

#. type: table
#: zsh.texi:36958
msgid "Determines if we assume that the assembled string from @t{vcs_info} includes prompt escapes. (Used by @t{vcs_info_lastmsg}.)"
msgstr "决定是否假设 @t{vcs_info} 汇编的字符串包含提示符转义。(被 @t{vcs_info_lastmsg} 使用）。"

#. type: t{#1}
#: zsh.texi:36959 zsh.texi:36960 zsh.texi:37034
#, no-wrap
msgid "debug"
msgstr "debug"

#. type: table
#: zsh.texi:36963
msgid "Enable debugging output to track possible problems. Currently this style is only used by @t{vcs_info}'s hooks system."
msgstr "启用调试输出以跟踪可能出现的问题。目前只有 @t{vcs_info} 的钩子系统使用这种样式。"

#. type: t{#1}
#: zsh.texi:36964 zsh.texi:36965 zsh.texi:37036
#, no-wrap
msgid "hooks"
msgstr "hooks"

#. type: table
#: zsh.texi:36968
msgid "A list style that defines hook-function names. See @ref{vcs_info Hooks} below for details."
msgstr "定义钩子函数名称的样式列表。详情请参阅下面的 @ref{vcs_info 勾子} 。"

#. type: t{#1}
#: zsh.texi:36969 zsh.texi:36971 zsh.texi:37046
#, no-wrap
msgid "patch-format"
msgstr "patch-format"

#. type: t{#1}
#: zsh.texi:36970 zsh.texi:36972 zsh.texi:37048
#, no-wrap
msgid "nopatch-format"
msgstr "nopatch-format"

#. type: table
#: zsh.texi:36978
msgid ""
"This pair of styles format the patch information used by the @t{%m} expando in formats and actionformats for the @t{git} and @t{hg} backends.  The value is subject to certain @t{%}-expansions described "
"below.  The expanded value is made available in the global @t{backend_misc} array as @t{$@{backend_misc[patches]@}} (also if a @t{set-patch-format} hook is used)."
msgstr ""
"这对样式格式化了 @t{%m} 扩展在 @t{git} 和 @t{hg} 后端 formats 和 actionformats 中使用的补丁信息。 该值受下文所述的某些 @t{%} 扩展的限制。 扩展后的值将以 @t{$@{backend_misc[patches]@}} 的形式出现在全局 "
"@t{backend_misc} 数组中。(如果使用了 @t{set-patch-format} 钩子）。"

#. type: t{#1}
#: zsh.texi:36979 zsh.texi:36980 zsh.texi:37050
#, no-wrap
msgid "get-unapplied"
msgstr "get-unapplied"

#. type: table
#: zsh.texi:36983
msgid "This boolean style controls whether a backend should attempt to gather a list of unapplied patches (for example with Mercurial Queue patches)."
msgstr "该布尔样式控制后端是否应尝试收集未应用补丁的列表（例如 Mercurial 队列补丁）。"

#. type: table
#: zsh.texi:36986
msgid "Used by the @t{quilt}, @t{hg}, and @t{git} backends."
msgstr "由 @t{quilt}、@t{hg} 和 @t{git} 后端使用。"

#. type: Plain text
#: zsh.texi:36991
msgid "The default values for these styles in all contexts are:"
msgstr "在所有上下文中，这些样式的默认值是:"

#. type: table
#: zsh.texi:36996
msgid "\" (%s)-[%b]%u%c-\""
msgstr "\" (%s)-[%b]%u%c-\""

#. type: table
#: zsh.texi:36998
msgid "\" (%s)-[%b|%a]%u%c-\""
msgstr "\" (%s)-[%b|%a]%u%c-\""

#. type: table
#: zsh.texi:37000
msgid "\"%b:%r\" (for bzr, svn, svk and hg)"
msgstr "\"%b:%r\" (for bzr, svn, svk and hg)"

#. type: table
#: zsh.texi:37002
msgid "\"\""
msgstr "\"\""

#. type: table
#: zsh.texi:37004
msgid "\"%r:%h\""
msgstr "\"%r:%h\""

#. type: table
#: zsh.texi:37008
msgid "ALL"
msgstr "ALL"

#. type: table
#: zsh.texi:37010 zsh.texi:37012 zsh.texi:37038
msgid "(empty list)"
msgstr "(empty list)"

#. type: table
#: zsh.texi:37018
msgid "(string: \"S\")"
msgstr "(string: \"S\")"

#. type: table
#: zsh.texi:37020
msgid "(string: \"U\")"
msgstr "(string: \"U\")"

#. type: table
#: zsh.texi:37022
msgid "(empty string)"
msgstr "(empty string)"

#. type: table
#: zsh.texi:37044
msgid "empty - use @t{$QUILT_PATCHES}"
msgstr "empty - use @t{$QUILT_PATCHES}"

#. type: table
#: zsh.texi:37046
msgid "quilt"
msgstr "quilt"

#. type: var{#1}
#: zsh.texi:37048 zsh.texi:37050
msgid "backend dependent"
msgstr "backend dependent"

#. type: Plain text
#: zsh.texi:37057
msgid "In normal @t{formats} and @t{actionformats} the following replacements are done:"
msgstr "在正常的 @t{formats} 和 @t{actionformats} 中，会进行以下替换："

#. type: table
#: zsh.texi:37062
msgid "The VCS in use (git, hg, svn, etc.)."
msgstr "使用的 VCS（git、hg、svn 等）。"

#. type: table
#: zsh.texi:37064
msgid "Information about the current branch."
msgstr "有关当前分支的信息。"

#. type: table
#: zsh.texi:37067
msgid "An identifier that describes the action. Only makes sense in @t{actionformats}."
msgstr "描述操作的标识符。只有在 @t{actionformats} 中才有意义。"

#. type: table
#: zsh.texi:37070
msgid "The current revision number or identifier. For @t{hg} the @t{hgrevformat} style may be used to customize the output."
msgstr "当前版本号或标识符。对于 @t{hg}，可使用 @t{hgrevformat} 样式自定义输出。"

#. type: table
#: zsh.texi:37073
msgid "The string from the @t{stagedstr} style if there are staged changes in the repository."
msgstr "如果版本库中存在阶段性变更，则使用 @t{stagedstr} 样式中的字符串。"

#. type: t{#1}
#: zsh.texi:37073 zsh.texi:37151 zsh.texi:39753
#, no-wrap
msgid "%u"
msgstr "%u"

#. type: table
#: zsh.texi:37076
msgid "The string from the @t{unstagedstr} style if there are unstaged changes in the repository."
msgstr "如果版本库中存在未暂存的变更，则使用 @t{unstagedstr} 样式中的字符串。"

#. type: table
#: zsh.texi:37078
msgid "The base directory of the repository."
msgstr "版本库的基本目录。"

#. type: table
#: zsh.texi:37081
msgid "The repository name. If @t{%R} is @t{/foo/bar/repoXY}, @t{%r} is @t{repoXY}."
msgstr "版本库名称。如果 @t{%R} 是 @t{/foo/bar/repoXY}，@t{%r} 就是 @t{repoXY}。"

#. type: table
#: zsh.texi:37084
msgid "A subdirectory within a repository. If @t{$PWD} is @t{/foo/bar/repoXY/beer/tasty}, @t{%S} is @t{beer/tasty}."
msgstr "版本库中的一个子目录。如果 @t{$PWD} 是 @t{/foo/bar/repoXY/beer/tasty}，@t{%S} 就是 @t{beer/tasty}。"

#. type: table
#: zsh.texi:37089
msgid "A \"misc\" replacement. It is at the discretion of the backend to decide what this replacement expands to."
msgstr "\"杂项\" 替换。后台可自行决定将此替换扩展为哪些内容。"

#. type: table
#: zsh.texi:37097
msgid ""
"The @t{hg} and @t{git} backends use this expando to display patch information.  @t{hg} sources patch information from the @t{mq} extensions; @t{git} from in-progress @t{rebase} and @t{cherry-pick} "
"operations and from the @t{stgit} extension.  The @t{patch-format} and @t{nopatch-format} styles control the generated string.  The former is used when at least one patch from the patch queue has been "
"applied, and the latter otherwise."
msgstr ""
"@t{hg} 和 @t{git} 后端使用此扩展来显示补丁信息。 @t{hg} 从 @t{mq} 扩展获取补丁信息；@t{git} 从正在进行的 @t{rebase} 和 @t{cherry-pick} 操作以及 @t{stgit} 扩展获取补丁信息。 @t{patch-format} 和 @t{nopatch-"
"format} 样式控制生成的字符串。 前者在补丁队列中至少有一个补丁被应用时使用，后者在其他情况下使用。"

#. type: table
#: zsh.texi:37104
msgid ""
"The @t{hg} backend displays bookmark information in this expando (in addition to @t{mq} information).  See the @t{get-mq} and @t{get-bookmarks} styles.  Both of these styles may be enabled at the same "
"time.  If both are enabled, both resulting strings will be shown separated by a semicolon (that cannot currently be customized)."
msgstr ""
"@t{hg} 后端还会在此扩展中显示书签信息(除了 @t{mq} 信息外)。 请参阅 @t{get-mq} 和 @t{get-bookmarks} 样式。 这两种样式可同时启用。 如果同时启用这两种样式，生成的两个字符串都将以分号分隔（目前无法自定义）。"

#. type: table
#: zsh.texi:37108
msgid "The @t{quilt} `standalone' backend sets this expando to the same value as the @t{%Q} expando."
msgstr "@t{quilt} \"独立\" 后端，会将此扩展设置为与 @t{%Q} 扩展相同的值。"

#. type: t{#1}
#: zsh.texi:37109
#, no-wrap
msgid "%Q"
msgstr "%Q"

#. type: table
#: zsh.texi:37114
msgid ""
"Quilt series information.  When quilt is used (either in `addon' mode or as a `standalone' backend), this expando is set to the quilt series' @t{patch-format} string.  The @t{set-patch-format} hook and "
"@t{nopatch-format} style are honoured."
msgstr ""
"Quilt 系列信息。 当使用 quilt 时（无论是在 \"插件\" 模式下还是作为 \"独立\" 后端），该扩展项将被设置为 quilt 系列的 @t{patch-format} 字符串。 @t{set-patch-format} 钩子和 @t{nopatch-format} 样式将被保留。"

#. type: table
#: zsh.texi:37117
msgid "See @ref{vcs_info Quilt Support} below for details."
msgstr "有关详细信息，请参阅下面的 @ref{vcs_info Quilt 支持}。"

#. type: Plain text
#: zsh.texi:37122
msgid "In @t{branchformat} these replacements are done:"
msgstr "在 @t{branchformat} 中，这些替换已经完成："

#. type: table
#: zsh.texi:37128
msgid "The branch name. For @t{hg}, the branch name can include a topic name."
msgstr "分支名称。对于 @t{hg}，分支名称可以包括主题名称。"

#. type: table
#: zsh.texi:37131
msgid "The current revision number or the @t{hgrevformat} style for @t{hg}."
msgstr "当前版本号或 @t{hg} 的 @t{hgrevformat} 样式。"

#. type: Plain text
#: zsh.texi:37135
msgid "In @t{hgrevformat} these replacements are done:"
msgstr "在 @t{hgrevformat} 中，这些替换将被完成："

#. type: table
#: zsh.texi:37140
msgid "The current local revision number."
msgstr "当前本地修订号。"

#. type: table
#: zsh.texi:37142
msgid "The current global revision identifier."
msgstr "当前的全局修订标识符。"

#. type: Plain text
#: zsh.texi:37146
msgid "In @t{patch-format} and @t{nopatch-format} these replacements are done:"
msgstr "在 @t{patch-format} 和 @t{nopatch-format} 中，这些替换将被完成："

#. type: t{#1}
#: zsh.texi:37149
#, no-wrap
msgid "%p"
msgstr "%p"

#. type: table
#: zsh.texi:37151
msgid "The name of the top-most applied patch; may be overridden by the @t{applied-string} hook."
msgstr "最上层应用补丁的名称；可由 @t{applied-string} 钩子覆盖。"

#. type: table
#: zsh.texi:37153
msgid "The number of unapplied patches; may be overridden by the @t{unapplied-string} hook."
msgstr "未应用的补丁数量；可通过 @t{unapplied-string} 钩子覆盖。"

#. type: table
#: zsh.texi:37155
msgid "The number of applied patches."
msgstr "已应用补丁的数量。"

#. type: table
#: zsh.texi:37157
msgid "The number of unapplied patches."
msgstr "未应用的补丁数量。"

#. type: table
#: zsh.texi:37159
msgid "The number of all patches (@t{%a = %n + %c})."
msgstr "所有补丁的数量 (@t{%a = %n + %c})。"

#. type: t{#1}
#: zsh.texi:37159
#, no-wrap
msgid "%g"
msgstr "%g"

#. type: table
#: zsh.texi:37161
msgid "The names of active @t{mq} guards (@t{hg} backend)."
msgstr "活动 @t{mq} 守卫（@t{hg} 后端）的名称。"

#. type: table
#: zsh.texi:37163
msgid "The number of active @t{mq} guards (@t{hg} backend)."
msgstr "活动 @t{mq} 守卫（@t{hg} 后台）的数量。"

#. type: Plain text
#: zsh.texi:37168
msgid "Not all VCS backends have to support all replacements. For @t{nvcsformats} no replacements are performed at all, it is just a string."
msgstr "并非所有 VCS 后端都必须支持所有替换。对于 @t{nvcsformats}，根本不会进行替换，它只是一个字符串。"

#. type: node
#: zsh.texi:37170 zsh.texi:37193 zsh.texi:37314
#, no-wrap
msgid "vcs_info Quilt Support"
msgstr "vcs_info Quilt 支持"

#. type: subsection
#: zsh.texi:37172
#, no-wrap
msgid "Oddities"
msgstr "奇特现象"

#. type: Plain text
#: zsh.texi:37183
msgid ""
"If you want to use the @t{%b} (bold off) prompt expansion in @t{formats}, which expands @t{%b} itself, use @t{%%b}. That will cause the @t{vcs_info} expansion to replace @t{%%b} with @t{%b}, so that zsh's "
"prompt expansion mechanism can handle it. Similarly, to hand down @t{%b} from @t{branchformat}, use @t{%%%%b}. Sorry for this inconvenience, but it cannot be easily avoided. Luckily we do not clash with a "
"lot of prompt expansions and this only needs to be done for those."
msgstr ""
"如果要使用 @t{formats}中的 @t{%b}（粗体关闭）提示符扩展（它会扩展 @t{%b} 本身），请使用 @t{%%b}。这将导致 @t{vcs_info} 扩展用 @t{%b} 替换 @t{%%b} ，这样 zsh 的提示符扩展机制可以处理它。同样，要从 "
"@t{branchformat} 传递 @t{%b}，请使用 @t{%%%%b}。很抱歉给您带来不便，但这是无法轻易避免的。幸运的是，我们与很多提示符扩展并不冲突，因此只需要在这些情况下才这样做。"

#. type: Plain text
#: zsh.texi:37191
msgid ""
"When one of the @t{gen-applied-string}, @t{gen-unapplied-string}, and @t{set-patch-format} hooks is defined, applying @t{%}-escaping (`@t{foo=$@{foo//'%'/%%@}}') to the interpolated values for use in the "
"prompt is the responsibility of those hooks (jointly); when neither of those hooks is defined, @t{vcs_info} handles escaping by itself.  We regret this coupling, but it was required for backwards "
"compatibility."
msgstr ""
"当 @t{gen-applied-string}, @t{gen-unapplied-string} 和 @t{set-patch-format} 钩子中的一个被定义时，将 @t{%}-转义（ (`@t{foo=$@{foo//'%'/%%@}}') 应用到用于提示符的插值是这些钩子（共同）的责任；当这些钩子都未"
"被定义时，@t{vcs_info} 将自行处理转义。 我们对这种耦合感到遗憾，但这是向后兼容所必需的。"

#. type: node
#: zsh.texi:37193 zsh.texi:37314 zsh.texi:37375
#, no-wrap
msgid "vcs_info API"
msgstr "vcs_info API"

#. type: subsection
#: zsh.texi:37195
#, no-wrap
msgid "Quilt Support"
msgstr "Quilt 支持"

#. type: Plain text
#: zsh.texi:37206
msgid ""
"@cite{Quilt} is not a version control system, therefore this is not implemented as a backend. It can help keeping track of a series of patches. People use it to keep a set of changes they want to use on "
"top of software packages (which is tightly integrated into the package build process - the Debian project does this for a large number of packages). Quilt can also help individual developers keep track of "
"their own patches on top of real version control systems."
msgstr ""
"@cite{Quilt} 并不是一个版本控制系统，因此并没有作为后端实现。它可以帮助跟踪一系列补丁。人们可以用它来在软件包上顶部保存一组他们想要使用的修改（这与软件包的构建过程紧密结合 - Debian 项目就为大量软件包做了这"
"项工作）。Quilt 还能帮助个人开发者在真正的版本控制系统上跟踪自己的补丁。"

#. type: Plain text
#: zsh.texi:37211
msgid "The @t{vcs_info} integration tries to support both ways of using quilt by having two slightly different modes of operation: `addon' mode and `standalone' mode)."
msgstr "@t{vcs_info} 集成试图通过两种略有不同的操作模式（`addon' 模式和 `standalone' 模式）来支持两种使用 quilt 的方式。"

#. type: Plain text
#: zsh.texi:37215
msgid "Quilt integration is off by default; to enable it, set the @t{use-quilt} style, and add @t{%Q} to your @t{formats} or @t{actionformats} style:"
msgstr "Quilt 集成默认为关闭；要启用它，请设置 @t{use-quilt} 样式，并在 @t{formats} 或 @t{actionformats} 样式中添加 @t{%Q}："

#. type: example
#: zsh.texi:37217
#, no-wrap
msgid "zstyle ':vcs_info:*' use-quilt true\n"
msgstr "zstyle ':vcs_info:*' use-quilt true\n"

#. type: Plain text
#: zsh.texi:37224
msgid ""
"Styles looked up from the Quilt support code include `@t{.quilt-}@var{quilt-mode}' in the @var{vcs-string} part of the context, where @var{quilt-mode} is either @t{addon} or @t{standalone}.  Example: @t{:"
"vcs_info:git.quilt-addon:default:}@var{repo-root-name}."
msgstr ""
"从 Quilt 支持代码中查找的样式包括上下文中 @var{vcs-string} 部分的 `@t{.quilt-}@var{quilt-mode}' ，其中 @var{quilt-mode} 是 @t{addon} 或 @t{standalone}。 例如 @t{:vcs_info:git.quilt-addon:default:}"
"@var{repo-root-name}。"

#. type: Plain text
#: zsh.texi:37234
msgid ""
"For `addon' mode to become active @t{vcs_info} must have already detected a real version control system controlling the directory. If that is the case, a directory that holds quilt's patches needs to be "
"found. That directory is configurable via the `@t{QUILT_PATCHES}' environment variable. If that variable exists its value is used, otherwise the value `@t{patches}' is assumed. The value from "
"@t{$QUILT_PATCHES} can be overwritten using the `@t{quilt-patch-dir}' style. (Note: you can use @t{vcs_info} to keep the value of @t{$QUILT_PATCHES} correct all the time via the @t{post-quilt} hook)."
msgstr ""
"要使 `addon' 模式生效，@t{vcs_info} 必须已经检测到控制该目录的真正版本控制系统。如果是这种情况，则需要找到一个存放 quilt 补丁的目录。该目录可通过 `@t{QUILT_PATCHES}' 环境变量进行配置。如果存在该变量，则使"
"用其值，否则假定使用`@t{patches}' 值。@t{$QUILT_PATCHES}的值可以用 `@t{quilt-patch-dir}' 样式覆盖。(注：您可以通过 @t{post-quilt} 钩子使用 @t{vcs_info} 来保持 @t{$QUILT_PATCHES} 的值始终正确）。"

#. type: Plain text
#: zsh.texi:37241
msgid ""
"When the directory in question is found, quilt is assumed to be active. To gather more information, @t{vcs_info} looks for a directory called `.pc'; Quilt uses that directory to track its current state. "
"If this directory does not exist we know that quilt has not done anything to the working directory (read: no patches have been applied yet)."
msgstr ""
"当找到相关目录时，quilt 会被认为处于活动状态。为了收集更多信息，@t{vcs_info} 会查找名为 `.pc' 的目录；Quilt 会使用该目录来跟踪其当前状态。如果该目录不存在，我们就知道 quilt 还没有对工作目录做任何操作（还没"
"有打补丁）。"

#. type: Plain text
#: zsh.texi:37246
msgid ""
"If patches are applied, @t{vcs_info} will try to find out which. If you want to know which patches of a series are not yet applied, you need to activate the @t{get-unapplied} style in the appropriate "
"context."
msgstr "如果补丁已应用，@t{vcs_info} 将尝试找出哪些补丁已应用。如果想知道某个系列中哪些补丁尚未应用，则需要在适当的上下文中激活 @t{get-unapplied} 样式。"

#. type: Plain text
#: zsh.texi:37256
msgid ""
"@t{vcs_info} allows for very detailed control over how the gathered information is presented (see @ref{vcs_info Configuration} and @ref{vcs_info Hooks}), all of which are documented below. Note there are "
"a number of other patch tracking systems that work on top of a certain version control system (like @t{stgit} for @cite{git}, or @t{mq} for @cite{hg}); the configuration for systems like that are "
"generally configured the same way as the @cite{quilt} support."
msgstr ""
"@t{vcs_info} 允许对如何展示收集到的信息进行非常详细的控制（参见 @ref{vcs_info 配置} 和 @ref{vcs_info 勾子}），所有这些都将在下文中详细介绍。请注意，还有许多其他补丁跟踪系统是在特定版本控制系统之上运行的"
"（如 @t{stgit} 用于 @cite{git}，或 @t{mq} 用于 @cite{hg}）；此类系统的配置方式通常与 @cite{quilt} 支持的方式相同。"

#. type: Plain text
#: zsh.texi:37261
msgid ""
"If the @cite{quilt} support is working in `addon' mode, the produced string is available as a simple format replacement (@t{%Q} to be precise), which can be used in @t{formats} and @t{actionformats}; see "
"below for details)."
msgstr "如果 @cite{quilt} 支持在 `addon' 模式下工作，生成的字符串可作为简单的格式替换（准确地说，是 @t{%Q}），可用于 @t{formats} 和 @t{actionformats}；详情见下文）。"

#. type: Plain text
#: zsh.texi:37272
msgid ""
"If, on the other hand, the support code is working in `standalone' mode, @t{vcs_info} will pretend as if @t{quilt} were an actual version control system. That means that the version control system "
"identifier (which otherwise would be something like `svn' or `cvs') will be set to `@t{-quilt-}'. This has implications on the used style context where this identifier is the second element. @t{vcs_info} "
"will have filled in a proper value for the \"repository's\" root directory and the string containing the information about quilt's state will be available as the `misc' replacement (and @t{%Q} for "
"compatibility with `addon' mode)."
msgstr ""
"另一方面，如果支持代码是在 `standalone' 模式下工作，@t{vcs_info} 将假装 @t{quilt} 是一个真正的版本控制系统。这意味着版本控制系统标识符（否则会是类似于`svn' 或 `cvs'）将被设置为  `@t{-quilt-}'。这对所使用的"
"样式上下文有影响，在该样式上下文中，该标识符是第二个元素。@t{vcs_info} 将为 \"版本库 \"的根目录填入一个合适的值，包含被子状态信息的字符串将作为 `misc' 替换（以及 @t{%Q} 以兼容 `addon' 模式）。"

#. type: Plain text
#: zsh.texi:37281
msgid ""
"What is left to discuss is how `standalone' mode is detected. The detection itself is a series of searches for directories. You can have this detection enabled all the time in every directory that is not "
"otherwise under version control. If you know there is only a limited set of trees where you would like @t{vcs_info} to try and look for Quilt in `standalone' mode to minimise the amount of searching on "
"every call to @t{vcs_info}, there are a number of ways to do that:"
msgstr ""
"剩下要讨论的是如何检测 `standalone' 模式。检测本身就是对目录的一系列搜索。你可以在每个不受版本控制的目录中一直启用这种检测。如果你知道只有一组有限的目录树，你希望 @t{vcs_info} 在 `standalone' 模式下尝试查"
"找 Quilt 以最小化每次调用 @t{vcs_info} 时的搜索量，有几种方法可以实现这一目的："

#. type: Plain text
#: zsh.texi:37287
msgid ""
"Essentially, `standalone' mode detection is controlled by a style called `@t{quilt-standalone}'. It is a string style and its value can have different effects. The simplest values are: `@t{always}' to run "
"detection every time @t{vcs_info} is run, and `@t{never}' to turn the detection off entirely."
msgstr ""
"基本上， `standalone' 模式检测是由一种名为 `@t{quilt-standalone}' 的样式控制的。这是一个字符串样式，其值可以产生不同的效果。最简单的值是: `@t{always}' 表示每次运行 @t{vcs_info} 时都进行检测，`@t{never}' 表"
"示完全关闭检测。"

#. type: Plain text
#: zsh.texi:37293
msgid ""
"If the value of @t{quilt-standalone} is something else, it is interpreted differently. If the value is the name of a scalar variable the value of that variable is checked and that value is used in the "
"same `always'/`never' way as described above."
msgstr "如果 @t{quilt-standalone} 的值是其他值，则会有不同的解释。如果值是标量变量的名称，则会检查该变量的值，并以上述 `always'/`never' 的方式使用该值。"

#. type: Plain text
#: zsh.texi:37297
msgid "If the value of @t{quilt-standalone} is an array, the elements of that array are used as directory names under which you want the detection to be active."
msgstr "如果 @t{quilt-standalone} 的值是一个数组，则该数组的元素将用作您希望激活检测的目录名。"

#. type: Plain text
#: zsh.texi:37302
msgid "If @t{quilt-standalone} is an associative array, the keys are taken as directory names under which you want the detection to be active, but only if the corresponding value is the string `@t{true}'."
msgstr "如果 @t{quilt-standalone} 是一个关联数组，则键将作为您希望检测激活的目录名，但前提是相应的值是字符串 `@t{true}'。"

#. type: Plain text
#: zsh.texi:37308
msgid ""
"Last, but not least, if the value of @t{quilt-standalone} is the name of a function, the function is called without arguments and the return value decides whether detection should be active. A `0' return "
"value is true; a non-zero return value is interpreted as false."
msgstr ""
"最后但并非最不重要的一点是，如果 @t{quilt-standalone} 的值是一个函数的名称，那么该函数将不带参数地被调用，而返回值则决定检测是否应被激活。返回值为`0' 的表示为 \"true\"；返回值为非零的表示为 \"false\"。"

#. type: Plain text
#: zsh.texi:37312
msgid "Note, if there is both a function and a variable by the name of @t{quilt-standalone}, the function will take precedence."
msgstr "注意，如果同时存在名为 @t{quilt-standalone} 的函数和变量，则函数优先。"

#. type: node
#: zsh.texi:37314 zsh.texi:37375 zsh.texi:37398
#, no-wrap
msgid "vcs_info Variables"
msgstr "vcs_info 变量"

#. type: subsection
#: zsh.texi:37316
#, no-wrap
msgid "Function Descriptions (Public API)"
msgstr "函数说明（公共 API）"

#. type: findex
#: zsh.texi:37321
#, no-wrap
msgid "vcs_info"
msgstr "vcs_info"

#. type: item
#: zsh.texi:37322
#, no-wrap
msgid "@t{vcs_info} [@var{user-context}]"
msgstr "@t{vcs_info} [@var{user-context}]"

#. type: table
#: zsh.texi:37330
msgid ""
"The main function, that runs all backends and assembles all data into @t{$@{vcs_info_msg_*_@}}. This is the function you want to call from @t{precmd} if you want to include up-to-date information in your "
"prompt (see @ref{vcs_info Variables} below).  If an argument is given, that string will be used instead of @t{default} in the @var{user-context} field of the style context."
msgstr ""
"主函数，用于运行所有后端并将所有数据汇总到 @t{$@{vcs_info_msg_*_@}} 中。如果想在提示符中包含最新信息（参见下面的 @ref{vcs_info 变量}），就需要从 @t{precmd} 调用该函数。 如果给定了参数，则将在样式上下文的 "
"@var{user-context} 字段中使用该字符串，而不是 @t{default}。"

#. type: t{#1}
#: zsh.texi:37331 zsh.texi:37332
#, no-wrap
msgid "vcs_info_hookadd"
msgstr "vcs_info_hookadd"

#. type: table
#: zsh.texi:37338
msgid ""
"Statically registers a number of functions to a given hook. The hook needs to be given as the first argument; what follows is a list of hook-function names to register to the hook. The `@t{+vi-}' prefix "
"needs to be left out here. See @ref{vcs_info Hooks} below for details."
msgstr "向给定钩子静态注册多个函数。钩子需要作为第一个参数给出；接下来是要注册到钩子的钩子函数名称列表。此处应省略前缀 `@t{+vi-}' 。详情请参阅下面的 @ref{vcs_info 勾子} 。"

#. type: t{#1}
#: zsh.texi:37339 zsh.texi:37340
#, no-wrap
msgid "vcs_info_hookdel"
msgstr "vcs_info_hookdel"

#. type: table
#: zsh.texi:37349
msgid ""
"Remove hook-functions from a given hook. The hook needs to be given as the first non-option argument; what follows is a list of hook-function names to un-register from the hook. If `@t{-a}' is used as the "
"first argument, @t{all} occurrences of the functions are unregistered. Otherwise only the last occurrence is removed (if a function was registered to a hook more than once). The `@t{+vi-}' prefix needs to "
"be left out here.  See @ref{vcs_info Hooks} below for details."
msgstr ""
"从给定钩子中删除钩子函数。钩子需要作为第一个非选项参数给出；接下来是要从钩子中取消注册的钩子函数名称列表。如果第一个参数为 `@t{-a}' ，则 @t{所有} 出现的函数都将被取消注册。否则，只删除最后一次出现的函数"
"（如果一个函数在钩子上注册了不止一次）。此处应省略前缀  `@t{+vi-}'。 详情请参阅下面的 @ref{vcs_info 勾子} 。"

#. type: t{#1}
#: zsh.texi:37350 zsh.texi:37351
#, no-wrap
msgid "vcs_info_lastmsg"
msgstr "vcs_info_lastmsg"

#. type: table
#: zsh.texi:37356
msgid ""
"Outputs the current values of @t{$@{vcs_info_msg_*_@}}.  Takes into account the value of the @t{use-prompt-escapes} style in @t{':vcs_info:formats:command:-all-'}. It also only prints @t{max-exports} "
"values."
msgstr "输出 @t{$@{vcs_info_msg_*_@}} 的当前值。 会考虑 @t{':vcs_info:formats:command:-all-'} 中 @t{use-prompt-escapes} 样式的值。它还只打印 @t{max-exports} 值。"

#. type: findex
#: zsh.texi:37357
#, no-wrap
msgid "vcs_info_printsys"
msgstr "vcs_info_printsys"

#. type: item
#: zsh.texi:37358
#, no-wrap
msgid "@t{vcs_info_printsys} [@var{user-context}]"
msgstr "@t{vcs_info_printsys} [@var{user-context}]"

#. type: table
#: zsh.texi:37362
msgid "Prints a list of all supported version control systems. Useful to find out possible contexts (and which of them are enabled) or values for the @t{disable} style."
msgstr "打印所有支持的版本控制系统列表。可用于查找可能的上下文（以及其中哪些已启用）或 @t{disable} 样式的值。"

#. type: t{#1}
#: zsh.texi:37363 zsh.texi:37364
#, no-wrap
msgid "vcs_info_setsys"
msgstr "vcs_info_setsys"

#. type: table
#: zsh.texi:37368
msgid "Initializes @t{vcs_info}'s internal list of available backends. With this function, you can add support for new VCSs without restarting the shell."
msgstr "初始化 @t{vcs_info} 的可用后端的内部列表。使用该函数，您可以在不重启 shell 的情况下添加对新 VCS 的支持。"

#. type: Plain text
#: zsh.texi:37373
msgid "All functions named @t{VCS_INFO_*} are for internal use only."
msgstr "所有名为 @t{VCS_INFO_*} 的函数仅供内部使用。"

#. type: node
#: zsh.texi:37375 zsh.texi:37398 zsh.texi:37715
#, no-wrap
msgid "vcs_info Hooks"
msgstr "vcs_info 勾子"

#. type: subsection
#: zsh.texi:37377
#, no-wrap
msgid "Variable Description"
msgstr "变量说明"

#. type: item
#: zsh.texi:37382
#, no-wrap
msgid "@t{$@{vcs_info_msg_}@var{N}@t{_@}} (Note the trailing underscore)"
msgstr "@t{$@{vcs_info_msg_}@var{N}@t{_@}} (注意尾部的下划线)"

#. type: table
#: zsh.texi:37391
msgid ""
"Where @var{N} is an integer, e.g., @t{vcs_info_msg_0_}. These variables are the storage for the informational message the last @t{vcs_info} call has assembled. These are strongly connected to the "
"@t{formats}, @t{actionformats} and @t{nvcsformats} styles described above. Those styles are lists. The first member of that list gets expanded into @t{$@{vcs_info_msg_0_@}}, the second into "
"@t{$@{vcs_info_msg_1_@}} and the Nth into @t{$@{vcs_info_msg_N-1_@}}. (See the @t{max-exports} style above.)"
msgstr ""
"其中 @var{N} 是一个整数，例如 @t{vcs_info_msg_0_}。这些变量用于存储最后一次 @t{vcs_info} 调用所生成的信息。这些变量与上述 @t{formats}、@t{actionformats} 和 @t{nvcsformats} 样式密切相关。这些样式都是列表。"
"该列表的第一个成员会扩展为  @t{$@{vcs_info_msg_0_@}}，第二个成员会扩展为@t{$@{vcs_info_msg_1_@}} ，第 N 个成员会扩展为 @t{$@{vcs_info_msg_N-1_@}}。(参见上面的 @t{max-exports} 样式）。"

#. type: Plain text
#: zsh.texi:37396
msgid "All variables named @t{VCS_INFO_*} are for internal use only."
msgstr "所有名为 @t{VCS_INFO_*} 的变量仅供内部使用。"

#. type: subsection
#: zsh.texi:37400
#, no-wrap
msgid "Hooks in vcs_info"
msgstr "vcs_info 中的勾子"

#. type: Plain text
#: zsh.texi:37407
msgid "Hooks are places in @t{vcs_info} where you can run your own code. That code can communicate with the code that called it and through that, change the system's behaviour."
msgstr "钩子是 @t{vcs_info} 中可以运行自己代码的地方。这些代码可以与调用它的代码通信，从而改变系统的行为。"

#. type: Plain text
#: zsh.texi:37410
msgid "For configuration, hooks change the style context:"
msgstr "对于配置，钩子可更改样式上下文："

#. type: example
#: zsh.texi:37412
#, no-wrap
msgid ":vcs_info:@var{vcs-string}+@var{hook-name}:@var{user-context}:@var{repo-root-name}\n"
msgstr ":vcs_info:@var{vcs-string}+@var{hook-name}:@var{user-context}:@var{repo-root-name}\n"

#. type: Plain text
#: zsh.texi:37417
msgid "To register functions to a hook, you need to list them in the @t{hooks} style in the appropriate context."
msgstr "要向钩子注册函数，需要在适当的上下文中以 @t{hooks} 样式列出这些函数。"

#. type: example
#: zsh.texi:37422
#, no-wrap
msgid "zstyle ':vcs_info:*+foo:*' hooks bar baz\n"
msgstr "zstyle ':vcs_info:*+foo:*' hooks bar baz\n"

#. type: Plain text
#: zsh.texi:37429
msgid ""
"This registers functions to the hook `foo' for all backends. In order to avoid namespace problems, all registered function names are prepended by a `@t{+vi-}', so the actual functions called for the `foo' "
"hook are `@t{+vi-bar}' and `@t{+vi-baz}'."
msgstr ""
"This registers functions to the hook `foo' for all backends. In order to avoid namespace problems, all registered function names are prepended by a `@t{+vi-}', so the actual functions called for the `foo' "
"hook are `@t{+vi-bar}' and `@t{+vi-baz}'."

#. type: Plain text
#: zsh.texi:37435
msgid ""
"If you would like to register a function to a hook regardless of the current context, you may use the @t{vcs_info_hookadd} function. To remove a function that was added like that, the @t{vcs_info_hookdel} "
"function can be used."
msgstr "如果要将某个函数注册到钩子中，而不考虑当前上下文，可以使用 @t{vcs_info_hookadd} 函数。要移除这样添加的函数，可以使用 @t{vcs_info_hookdel} 函数。"

#. type: Plain text
#: zsh.texi:37440
msgid "If something seems weird, you can enable the `debug' boolean style in the proper context and the hook-calling code will print what it tried to execute and whether the function in question existed."
msgstr "如果有什么奇怪的地方，可以在适当的上下文中启用 `debug' 布尔样式，这样调用钩子的代码就会打印出试图执行的内容以及相关函数是否存在。"

#. type: Plain text
#: zsh.texi:37447
msgid ""
"When you register more than one function to a hook, all functions are executed one after another until one function returns non-zero or until all functions have been called. Context-sensitive hook "
"functions are executed @t{before} statically registered ones (the ones added by @t{vcs_info_hookadd})."
msgstr "如果向钩子注册了多个函数，所有函数将相继执行，直到其中一个函数返回非零或所有函数都被调用。对上下文敏感的钩子函数会在静态注册的函数（由 @t{vcs_info_hookadd} 添加的函数）@t{之前} 执行。"

#. type: Plain text
#: zsh.texi:37451
msgid "You may pass data between functions via an associative array, @t{user_data}.  For example:"
msgstr "您可以通过关联数组 @t{user_data} 在函数之间传递数据。 例如"

#. type: example
#: zsh.texi:37459
#, no-wrap
msgid ""
"+vi-git-myfirsthook()@{\n"
"    user_data[myval]=$myval\n"
"@}\n"
"+vi-git-mysecondhook()@{\n"
"    # do something with $@{user_data[myval]@}\n"
"@}\n"
msgstr ""
"+vi-git-myfirsthook()@{\n"
"    user_data[myval]=$myval\n"
"@}\n"
"+vi-git-mysecondhook()@{\n"
"    # do something with $@{user_data[myval]@}\n"
"@}\n"

#. type: Plain text
#: zsh.texi:37463
msgid "There are a number of variables that are special in hook contexts:"
msgstr "有一些变量在钩子上下文中比较特殊："

#. type: t{#1}
#: zsh.texi:37466
#, no-wrap
msgid "ret"
msgstr "ret"

#. type: table
#: zsh.texi:37471
msgid ""
"The return value that the hooks system will return to the caller. The default is an integer `zero'. If and how a changed @t{ret} value changes the execution of the caller depends on the specific hook. See "
"the hook documentation below for details."
msgstr "钩子系统将返回给调用者的返回值。默认值为整数 `zero'。如果 @t{ret} 值发生变化，调用者的执行将如何变化，取决于具体的钩子。详情请参见下面的钩子文档。"

#. type: t{#1}
#: zsh.texi:37472
#, no-wrap
msgid "hook_com"
msgstr "hook_com"

#. type: table
#: zsh.texi:37475
msgid "An associated array which is used for bidirectional communication from the caller to hook functions. The used keys depend on the specific hook."
msgstr "关联数组，用于从调用方到钩子函数的双向通信。使用的键取决于具体的钩子。"

#. type: table
#: zsh.texi:37479
msgid "The active context of the hook. Functions that wish to change this variable should make it local scope first."
msgstr "钩子的活动上下文。希望更改此变量的函数应首先将其设置为本地作用域。"

#. type: t{#1}
#: zsh.texi:37480
#, no-wrap
msgid "vcs"
msgstr "vcs"

#. type: table
#: zsh.texi:37483
msgid "The current VCS after it was detected. The same values as in the enable/disable style are used. Available in all hooks except @t{start-up}."
msgstr "检测到 VCS 后的当前 VCS。使用与 enable/disable 样式相同的值。可用于除 @t{start-up} 以外的所有钩子。"

#. type: Plain text
#: zsh.texi:37488
msgid "Finally, the full list of currently available hooks:"
msgstr "最后，是当前可用钩子的完整列表："

#. type: t{#1}
#: zsh.texi:37491
#, no-wrap
msgid "start-up"
msgstr "start-up"

#. type: table
#: zsh.texi:37497
msgid ""
"Called after starting @t{vcs_info} but before the VCS in this directory is determined. It can be used to deactivate @t{vcs_info} temporarily if necessary. When @t{ret} is set to @t{1}, @t{vcs_info} aborts "
"and does nothing; when set to @t{2}, @t{vcs_info} sets up everything as if no version control were active and exits."
msgstr ""
"在 @t{vcs_info} 启动后，但在确定该目录中的 VCS 之前调用。必要时，它可用于暂时停用 @t{vcs_info}。当 @t{ret} 设置为 @t{1} 时，@t{vcs_info} 会终止并不执行任何操作；当 @t{ret} 设置为 @t{2} 时，@t{vcs_info} 会"
"将一切设置为未激活版本控制，并退出。"

#. type: t{#1}
#: zsh.texi:37498
#, no-wrap
msgid "pre-get-data"
msgstr "pre-get-data"

#. type: table
#: zsh.texi:37500
msgid "Same as @t{start-up} but after the VCS was detected."
msgstr "与 @t{start-up} 相同，但在检测到 VCS 之后。"

#. type: t{#1}
#: zsh.texi:37501
#, no-wrap
msgid "gen-hg-bookmark-string"
msgstr "gen-hg-bookmark-string"

#. type: table
#: zsh.texi:37504
msgid "Called in the Mercurial backend when a bookmark string is generated; the @t{get-revision} and @t{get-bookmarks} styles must be true."
msgstr "生成书签字符串时在 Mercurial 后台调用；@t{get-revision} 和 @t{get-bookmarks} 样式必须为 true。"

#. type: table
#: zsh.texi:37508
msgid "This hook gets the names of the Mercurial bookmarks that @t{vcs_info} collected from `hg'."
msgstr "此钩子获取 @t{vcs_info} 从 `hg'中收集的 Mercurial 书签的名称。"

#. type: table
#: zsh.texi:37512
msgid "If a bookmark is active, the key @t{$@{hook_com[hg-active-bookmark]@}} is set to its name.  The key is otherwise unset."
msgstr "如果书签处于活动状态，则键 @t{$@{hook_com[hg-active-bookmark]@}} 将被设置为其名称。 否则，键值会被取消设置。"

#. type: table
#: zsh.texi:37518
msgid ""
"When setting @t{ret} to non-zero, the string in @t{$@{hook_com[hg-bookmark-string]@}} will be used in the @t{%m} escape in @t{formats} and @t{actionformats} and will be available in the global "
"@t{backend_misc} array as @t{$@{backend_misc[bookmarks]@}}."
msgstr ""
"当 @t{ret} 设置为非零时，@t{$@{hook_com[hg-bookmark-string]@}} 中的字符串将被用于 @t{formats} 和 @t{actionformats} 中的 @t{%m} 转义，并将作为 @t{$@{backend_misc[bookmarks]@}} 出现在全局 @t{backend_misc} 数"
"组中。"

#. type: t{#1}
#: zsh.texi:37519
#, no-wrap
msgid "gen-applied-string"
msgstr "gen-applied-string"

#. type: table
#: zsh.texi:37524
msgid ""
"Called in the @t{git} (with @t{stgit} or during rebase or merge), and @t{hg} (with @t{mq}) backends and in @t{quilt} support when the @t{applied-string} is generated; the @t{use-quilt} zstyle must be true "
"for @t{quilt} (the @t{mq} and @t{stgit} backends are active by default)."
msgstr ""
"在 @t{git}（使用 @t{stgit}，或在 rebase 或合并过程中）和 @t{hg}（使用 @t{mq}）后端以及 @t{quilt} 支持中生成 @t{applied-string} 时调用；对于 @t{quilt}，@t{use-quilt} zstyle 必须为 true（@t{mq} 和 @t{stgit} "
"后端默认为激活状态）。"

#. type: table
#: zsh.texi:37529
msgid "The arguments to this hook describe applied patches in the opposite order, which means that the first argument is the top-most patch and so forth."
msgstr "该钩子的参数以相反的顺序描述应用的补丁，即第一个参数是最上面的补丁，以此类推。"

#. type: table
#: zsh.texi:37537
msgid ""
"When the patches' log messages can be extracted, those are embedded within each argument after a space, so each argument is of the form `@var{patch-name} @var{first line of the log message}', where "
"@var{patch-name} contains no whitespace. The @t{mq} backend passes arguments of the form `@var{patch name}', with possible embedded spaces, but without extracting the patch's log message."
msgstr ""
"当可以提取补丁的日志信息时，这些消息嵌入在空格后的每个参数中，因此每个参数的形式为 `@var{patch-name} @var{first line of the log message}', 其中 @var{patch-name} 不含空格。@var{日志信息的第一行}'，其中 "
"@var{patch-name} 不含空格。@t{mq} 后端传递的参数形式为\"@var{补丁名称}\"，可能包含空格，但不会提取补丁的日志信息。"

#. type: table
#: zsh.texi:37545
msgid ""
"When setting @t{ret} to non-zero, the string in @t{$@{hook_com[applied-string]@}} will be available as @t{%p} in the @t{patch-format} and @t{nopatch-format} styles.  This hook is, in concert with @t{set-"
"patch-format}, responsible for @t{%}-escaping that value for use in the prompt.  (See @ref{vcs_info Oddities}.)"
msgstr ""
"当 @t{ret} 设置为非零时， @t{$@{hook_com[applied-string]@}} 中的字符串将以 @t{%p} 的形式出现在 @t{patch-format} 和 @t{nopatch-format} 样式中。 该钩子与 @t{set-patch-format} 一起负责 @t{%}-转义，以便在提示"
"符中使用该值（参见 @ref{vcs_info 奇特现象}）。"

#. type: table
#: zsh.texi:37550 zsh.texi:37576 zsh.texi:37677
msgid "The @t{quilt} backend passes to this hook the inputs @t{$@{hook_com[quilt-patches-dir]@}} and, if it has been determined, @t{$@{hook_com[quilt-pc-dir]@}}."
msgstr "@t{quilt} 后端将输入传递给此钩子，其中包括 @t{$@{hook_com[quilt-patches-dir]@}} 输入，如果已确定的话，还包括@t{$@{hook_com[quilt-pc-dir]@}} 输入。"

#. type: t{#1}
#: zsh.texi:37551
#, no-wrap
msgid "gen-unapplied-string"
msgstr "gen-unapplied-string"

#. type: table
#: zsh.texi:37555
msgid ""
"Called in the @t{git} (with @t{stgit} or during rebase), and @t{hg} (with @t{mq}) backend and in @t{quilt} support when the @t{unapplied-string} is generated; the @t{get-unapplied} style must be true."
msgstr "当 @t{unapplied-string} 生成时，在 @t{git}（使用 @t{stgit}）和 @t{hg}（使用 @t{mq}）后端以及 @t{quilt} 支持中调用；@t{get-unapplied}样式必须为 true。"

#. type: table
#: zsh.texi:37560
msgid "This hook gets the names of all unapplied patches which @t{vcs_info} in order, which means that the first argument is the patch next-in-line to be applied and so forth."
msgstr "此钩子按顺序获取 @t{vcs_info} 中所有未应用补丁的名称，这意味着第一个参数是下一个要应用的补丁，以此类推。"

#. type: table
#: zsh.texi:37563
msgid "The format of each argument is as for @t{gen-applied-string}, above."
msgstr "每个参数的格式与上述 @t{gen-applied-string} 相同。"

#. type: table
#: zsh.texi:37571
msgid ""
"When setting @t{ret} to non-zero, the string in @t{$@{hook_com[unapplied-string]@}} will be available as @t{%u} in the @t{patch-format} and @t{nopatch-format} styles.  This hook is, in concert with @t{set-"
"patch-format}, responsible for @t{%}-escaping that value for use in the prompt.  (See @ref{vcs_info Oddities}.)"
msgstr ""
"当 @t{ret} 设置为非零时， @t{$@{hook_com[unapplied-string]@}} 中的字符串将以 @t{%u} 的形式出现在 @t{patch-format} 和 @t{nopatch-format} 样式中。 该钩子与 @t{set-patch-format} 一起负责 @t{%}-转义，以便在提"
"示符中使用该值（参见 @ref{vcs_info 奇特现象}）。"

#. type: t{#1}
#: zsh.texi:37577
#, no-wrap
msgid "gen-mqguards-string"
msgstr "gen-mqguards-string"

#. type: table
#: zsh.texi:37580
msgid "Called in the @t{hg} backend when @t{guards-string} is generated; the @t{get-mq} style must be true (default)."
msgstr "在 @t{hg} 后台生成 @t{guards-string} 时调用；@t{get-mq} 样式必须为 true（默认）。"

#. type: table
#: zsh.texi:37583
msgid "This hook gets the names of any active @t{mq} guards."
msgstr "此钩子会获取任何活动的 @t{mq} 守卫（guards)的名称。"

#. type: table
#: zsh.texi:37588
msgid "When setting @t{ret} to non-zero, the string in @t{$@{hook_com[guards-string]@}} will be used in the @t{%g} escape in the @t{patch-format} and @t{nopatch-format} styles."
msgstr "当 @t{ret} 设置为非零时， @t{$@{hook_com[guards-string]@}} 中的字符串将在 @t{patch-format} 和 @t{nopatch-format} 样式的 @t{%g} 转义中使用。"

#. type: t{#1}
#: zsh.texi:37589
#, no-wrap
msgid "no-vcs"
msgstr "no-vcs"

#. type: table
#: zsh.texi:37591
msgid "This hooks is called when no version control system was detected."
msgstr "当检测不到版本控制系统时，会调用此钩子。"

#. type: table
#: zsh.texi:37594
msgid "The `@t{hook_com}' parameter is not used."
msgstr " `@t{hook_com}' 参数未被使用。"

#. type: t{#1}
#: zsh.texi:37595
#, no-wrap
msgid "post-backend"
msgstr "post-backend"

#. type: table
#: zsh.texi:37597
msgid "Called as soon as the backend has finished collecting information."
msgstr "后台完成信息收集后立即调用。"

#. type: table
#: zsh.texi:37600
msgid "The `@t{hook_com}' keys available are as for the @t{set-message} hook."
msgstr " `@t{hook_com}' 键与 @t{set-message} 钩子相同。"

#. type: t{#1}
#: zsh.texi:37601
#, no-wrap
msgid "post-quilt"
msgstr "post-quilt"

#. type: table
#: zsh.texi:37607
msgid ""
"Called after the @t{quilt} support is done. The following information is passed as arguments to the hook: 1. the quilt-support mode (`addon' or `standalone'); 2. the directory that contains the patch "
"series; 3. the directory that holds quilt's status information (the `.pc' directory) or the string @t{\"-nopc-\"} if that directory wasn't found."
msgstr ""
"在 @t{quilt} 支持完成后调用。钩子将传递以下信息作为参数：1. quilt 支持模式（`addon' 或 `standalone'）；2. 包含补丁系列的目录；3. 保存 quilt 状态信息的目录（ `.pc' 目录），如果未找到该目录，则传递字符串 "
"@t{\"-nopc-\"}。"

#. type: table
#: zsh.texi:37610
msgid "The `hook_com' parameter is not used."
msgstr "`hook_com' 参数未被使用。"

#. type: t{#1}
#: zsh.texi:37611
#, no-wrap
msgid "set-branch-format"
msgstr "set-branch-format"

#. type: table
#: zsh.texi:37614
msgid "Called before `@t{branchformat}' is set. The only argument to the hook is the format that is configured at this point."
msgstr "在设置 `@t{branchformat}' 之前调用。钩子的唯一参数是此时配置的格式。"

#. type: table
#: zsh.texi:37619
msgid ""
"The `@t{hook_com}' keys considered are `@t{branch}' and `@t{revision}'.  They are set to the values figured out so far by @t{vcs_info} and any change will be used directly when the actual replacement is "
"done."
msgstr " `@t{hook_com}' 键是 `@t{branch}' 和 `@t{revision}'。 它们将被设置为 @t{vcs_info} 目前得出的值，任何更改都将在实际替换时直接使用。"

#. type: table
#: zsh.texi:37624
msgid "If @t{ret} is set to non-zero, the string in @t{$@{hook_com[branch-replace]@}} will be used unchanged as the `@t{%b}' replacement in the variables set by @t{vcs_info}."
msgstr "如果 @t{ret} 设置为非零， @t{$@{hook_com[branch-replace]@}} 中的字符串将被原封不动地用作 @t{vcs_info} 设置的变量中 `@t{%b}' 的替换。"

#. type: t{#1}
#: zsh.texi:37625
#, no-wrap
msgid "set-hgrev-format"
msgstr "set-hgrev-format"

#. type: table
#: zsh.texi:37628
msgid "Called before a `@t{hgrevformat}' is set. The only argument to the hook is the format that is configured at this point."
msgstr "在设置 `@t{hgrevformat}' 之前调用。钩子的唯一参数是此时配置的格式。"

#. type: table
#: zsh.texi:37633
msgid ""
"The `@t{hook_com}' keys considered are `@t{hash}' and `@t{localrev}'.  They are set to the values figured out so far by @t{vcs_info} and any change will be used directly when the actual replacement is "
"done."
msgstr " `@t{hook_com}' 键考虑的是 `@t{hash}' 和 `@t{localrev}'。 它们被设置为 @t{vcs_info} 目前计算出的值，任何更改都将在实际替换时直接使用。"

#. type: table
#: zsh.texi:37638
msgid "If @t{ret} is set to non-zero, the string in @t{$@{hook_com[rev-replace]@}} will be used unchanged as the `@t{%i}' replacement in the variables set by @t{vcs_info}."
msgstr "如果 @t{ret} 设置为非零， @t{$@{hook_com[rev-replace]@}} 中的字符串将被原封不动地用作 @t{vcs_info} 设置的变量中 `@t{%i}' 的替换。"

#. type: t{#1}
#: zsh.texi:37639
#, no-wrap
msgid "pre-addon-quilt"
msgstr "pre-addon-quilt"

#. type: table
#: zsh.texi:37643
msgid ""
"This hook is used when @t{vcs_info}'s quilt functionality is active in \"addon\" mode (quilt used on top of a real version control system). It is activated right before any quilt specific action is taken."
msgstr "当 @t{vcs_info} 的 quilt 功能在 \"插件\"模式（ quilt 用于真正的版本控制系统之上）下激活时，就会使用此钩子。该钩子会在执行任何与 quilt 相关的操作之前被激活。"

#. type: table
#: zsh.texi:37647
msgid "Setting the `@t{ret}' variable in this hook to a non-zero value avoids any quilt specific actions from being run at all."
msgstr "将此钩子中的 `@t{ret}' 变量设置为非零值，可避免运行任何 quilt 特定操作。"

#. type: t{#1}
#: zsh.texi:37648
#, no-wrap
msgid "set-patch-format"
msgstr "set-patch-format"

#. type: table
#: zsh.texi:37652
msgid "This hook is used to control some of the possible expansions in @t{patch-format} and @t{nopatch-format} styles with patch queue systems such as quilt, mqueue and the like."
msgstr "此钩子用于控制像quilt、mqueue等补丁队列系统中 @t{patch-format} 和 @t{nopatch-format} 样式中的某些可能扩展。"

#. type: table
#: zsh.texi:37655
msgid "This hook is used in the @t{git}, @t{hg} and @t{quilt} backends."
msgstr "该钩子用于 @t{git}、@t{hg} 和 @t{quilt} 后端。"

#. type: table
#: zsh.texi:37661
msgid ""
"The hook allows the control of the @t{%p} (@t{$@{hook_com[applied]@}}) and @t{%u} (@t{$@{hook_com[unapplied]@}}) expansion in all backends that use the hook. With the mercurial backend, the @t{%g} "
"(@t{$@{hook_com[guards]@}}) expansion is controllable in addition to that."
msgstr "钩子允许控制所有使用钩子的后端中的 @t{%p} (@t{$@{hook_com[applied]@}}) 和 @t{%u} (@t{$@{hook_com[unapplied]@}}) 扩展。对于 mercurial 后端，除此以外还可控制 @t{%g} (@t{$@{hook_com[guards]@}}) 扩展。"

#. type: table
#: zsh.texi:37666
msgid "If @t{ret} is set to non-zero, the string in @t{$@{hook_com[patch-replace]@}} will be used unchanged instead of an expanded format from @t{patch-format} or @t{nopatch-format}."
msgstr "如果 @t{ret} 设置为非零，则将不加修改地使用 @t{$@{hook_com[patch-replace]@}} 中的字符串，而不是 @t{patch-format} 或 @t{nopatch-format} 中的扩展格式。"

#. type: table
#: zsh.texi:37672
msgid ""
"This hook is, in concert with the @t{gen-applied-string} or @t{gen-unapplied-string} hooks if they are defined, responsible for @t{%}-escaping the final @t{patch-format} value for use in the prompt.  (See "
"@ref{vcs_info Oddities}.)"
msgstr "该钩子与 @t{gen-applied-string} 或 @t{gen-unapplied-string} 钩子（如果定义了这两个钩子）共同负责 @t{%}-转义，以便最终的 @t{patch-format} 值用于提示符中（请参阅 @ref{vcs_info 奇特现象}）。"

#. type: t{#1}
#: zsh.texi:37678
#, no-wrap
msgid "set-message"
msgstr "set-message"

#. type: table
#: zsh.texi:37683
msgid ""
"Called each time before a `@t{vcs_info_msg_}@var{N}@t{_}' message is set.  It takes two arguments; the first being the `@var{N}' in the message variable name, the second is the currently configured "
"@t{formats} or @t{actionformats}."
msgstr "每次在设置 `@t{vcs_info_msg_}@var{N}@t{_}' 信息前调用。 它需要两个参数：第一个参数是信息变量名中的 `@var{N}' ，第二个参数是当前配置的 @t{formats} 或 @t{actionformats}。"

#. type: table
#: zsh.texi:37692
msgid ""
"There are a number of `@t{hook_com}' keys, that are used here: `@t{action}', `@t{branch}', `@t{base}', `@t{base-name}', `@t{subdir}', `@t{staged}', `@t{unstaged}', `@t{revision}', `@t{misc}', `@t{vcs}' "
"and one `@t{miscN}' entry for each backend-specific data field (@t{N} starting at zero). They are set to the values figured out so far by @t{vcs_info} and any change will be used directly when the actual "
"replacement is done."
msgstr ""
"这里使用了许多 `@t{hook_com}' 键：`@t{action}', `@t{branch}', `@t{base}', `@t{base-name}', `@t{subdir}', `@t{staged}', `@t{unstaged}', `@t{revision}', `@t{misc}', `@t{vcs}' 以及每个特定后端数据字段的一个 "
"`@t{miscN}' 条目（@t{N}从 0 开始）。它们将被设置为 @t{vcs_info} 目前计算出的值，任何更改都将在实际替换时直接使用。"

#. type: table
#: zsh.texi:37700
msgid ""
"Since this hook is triggered multiple times (once for each configured @t{formats} or @t{actionformats}), each of the `@t{hook_com}' keys mentioned above (except for the @t{miscN} entries) has an "
"`@t{_orig}' counterpart, so even if you changed a value to your liking you can still get the original value in the next run. Changing the `@t{_orig}' values is probably not a good idea."
msgstr ""
"由于该钩子会被多次触发（每个配置的 @t{formats} 或 @t{actionformats} 都会触发一次），因此上文提到的每个 `@t{hook_com}' 键（@t{miscN} 条目除外）都有一个对应的 `@t{_orig}'，所以即使你按照自己的喜好修改了某个"
"值，在下一次运行时仍然可以得到原来的值。更改 `@t{_orig}' 值可能不是一个好主意。"

#. type: table
#: zsh.texi:37705
msgid "If @t{ret} is set to non-zero, the string in @t{$@{hook_com[message]@}} will be used unchanged as the message by @t{vcs_info}."
msgstr "如果@t{ret}设置为非零值，则@t{vcs_info}将使用 @t{$@{hook_com[message]@}} 中的字符串作为消息，不会进行更改。"

#. type: Plain text
#: zsh.texi:37713
msgid "If all of this sounds rather confusing, take a look at @ref{vcs_info Examples} and also in the @t{Misc/vcs_info-examples} file in the Zsh source.  They contain some explanatory code."
msgstr "如果这一切听起来令人困惑，请查看 @ref{vcs_info 示例} 以及 Zsh 源代码中的 @t{Misc/vcs_info-examples} 文件。 它们包含一些解释性代码。"

#. type: Plain text
#: zsh.texi:37722
msgid "Don't use @t{vcs_info} at all (even though it's in your prompt):"
msgstr "完全不要使用 @t{vcs_info}（即使它在你的提示符中）："

#. type: example
#: zsh.texi:37724
#, no-wrap
msgid "zstyle ':vcs_info:*' enable NONE\n"
msgstr "zstyle ':vcs_info:*' enable NONE\n"

#. type: Plain text
#: zsh.texi:37728
msgid "Disable the backends for @t{bzr} and @t{svk}:"
msgstr "禁用 @t{bzr} 和 @t{svk} 的后端："

#. type: example
#: zsh.texi:37730
#, no-wrap
msgid "zstyle ':vcs_info:*' disable bzr svk\n"
msgstr "zstyle ':vcs_info:*' disable bzr svk\n"

#. type: Plain text
#: zsh.texi:37734
msgid "Disable everything @emph{but} @t{bzr} and @t{svk}:"
msgstr "禁用 @emph{除} @t{bzr} 和 @t{svk} 外的所有功能："

#. type: example
#: zsh.texi:37736
#, no-wrap
msgid "zstyle ':vcs_info:*' enable bzr svk\n"
msgstr "zstyle ':vcs_info:*' enable bzr svk\n"

#. type: Plain text
#: zsh.texi:37740
msgid "Provide a special formats for @t{git}:"
msgstr "为 @t{git} 提供了一种特殊格式："

#. type: example
#: zsh.texi:37743
#, no-wrap
msgid ""
"zstyle ':vcs_info:git:*' formats       ' GIT, BABY! [%b]'\n"
"zstyle ':vcs_info:git:*' actionformats ' GIT ACTION! [%b|%a]'\n"
msgstr ""
"zstyle ':vcs_info:git:*' formats       ' GIT, BABY! [%b]'\n"
"zstyle ':vcs_info:git:*' actionformats ' GIT ACTION! [%b|%a]'\n"

#. type: Plain text
#: zsh.texi:37755
msgid ""
"All @t{%x} expansion in all sorts of formats (@t{formats}, @t{actionformats}, @t{branchformat}, you name it) are done using the `@t{zformat}' builtin from the `@t{zsh/zutil}' module. That means you can do "
"everything with these @t{%x} items what zformat supports. In particular, if you want something that is really long to have a fixed width, like a hash in a mercurial branchformat, you can do this: "
"@t{%12.12i}. That'll shrink the 40 character hash to its 12 leading characters. The form is actually `@t{%}@var{min}@t{.}@var{max}@t{x}'. More is possible.  See @ref{The zsh/zutil Module} for details."
msgstr ""
"所有格式（@t{formats}、@t{actionformats}、@t{branchformat}等）的 @t{%x} 扩展都是通过 `@t{zsh/zutil}' 模块中的 `@t{zformat}' 内置程序完成的。这意味着你可以用这些 @t{%x} 项做任何 zformat 支持的事情。特别是，"
"如果你希望很长的内容有固定的宽度，比如 多变的  branchformat 中的哈希值，你可以这样做： @t{%12.12i}。这样就能将 40 个字符的哈希值缩减为 12 个前导字符。形式实际上是 `@t{%}@var{min}@t{.}@var{max}@t{x}' 。还可"
"以有更多。 详情请参见 @ref{zsh/zutil 模块}。"

#. type: Plain text
#: zsh.texi:37758
msgid "Use the quicker @t{bzr} backend"
msgstr "使用更快的 @t{bzr} 后端"

#. type: example
#: zsh.texi:37760
#, no-wrap
msgid "zstyle ':vcs_info:bzr:*' use-simple true\n"
msgstr "zstyle ':vcs_info:bzr:*' use-simple true\n"

#. type: Plain text
#: zsh.texi:37764
msgid "If you do use @t{use-simple}, please report if it does `the-right-thing[tm]'."
msgstr "如果使用 @t{use-simple}，请报告它是否做了 `the-right-thing[tm]'。"

#. type: Plain text
#: zsh.texi:37767
msgid "Display the revision number in yellow for @t{bzr} and @t{svn}:"
msgstr "以黄色显示 @t{bzr} 和 @t{svn} 的版本号："

#. type: example
#: zsh.texi:37770
#, no-wrap
msgid ""
"zstyle ':vcs_info:(svn|bzr):*' \\ \n"
"       branchformat '%b%%F@{yellow@}:%r'\n"
msgstr ""
"zstyle ':vcs_info:(svn|bzr):*' \\ \n"
"       branchformat '%b%%F@{yellow@}:%r'\n"

#. type: Plain text
#: zsh.texi:37775
msgid "The doubled percent sign is explained in @ref{vcs_info Oddities}."
msgstr "@ref{vcs_info 奇特现象} 中解释了双百分号。"

#. type: Plain text
#: zsh.texi:37778
msgid "Alternatively, one can use the raw colour codes directly:"
msgstr "或者，也可以直接使用原始颜色代码："

#. type: example
#: zsh.texi:37783
#, no-wrap
msgid ""
"zstyle ':vcs_info:(svn|bzr):*' \\ \n"
"       branchformat '%b%@{'$@{fg[yellow]@}'%@}:%r'\n"
msgstr ""
"zstyle ':vcs_info:(svn|bzr):*' \\ \n"
"       branchformat '%b%@{'$@{fg[yellow]@}'%@}:%r'\n"

#. type: Plain text
#: zsh.texi:37789
msgid ""
"Normally when a variable is interpolated into a format string, the variable needs to be @t{%}-escaped. In this example we skipped that because we assume the value of @t{$@{fg[yellow]@}} doesn't contain "
"any @t{%} signs."
msgstr "通常情况下，当变量被插值到格式字符串中时，需要对变量进行 @t{%} 转义。在本例中，我们跳过了这一步骤，因为我们假定  @t{$@{fg[yellow]@}} 的值不包含任何 @t{%} 符号。"

#. type: Plain text
#: zsh.texi:37793
msgid "Make sure you enclose the color codes in @t{%@{}@var{...}@t{%@}} if you want to use the string provided by @t{vcs_info} in prompts."
msgstr "如果要在提示符中使用 @t{vcs_info} 提供的字符串，请确保将颜色代码括在 @t{%@{}@var{...}@t{%@}} 中。"

#. type: Plain text
#: zsh.texi:37796
msgid "Here is how to print the VCS information as a command (not in a prompt):"
msgstr "下面介绍如何以命令形式（而不是在提示符中）打印 VCS 信息："

#. type: example
#: zsh.texi:37798
#, no-wrap
msgid "vcsi() @{ vcs_info interactive; vcs_info_lastmsg @}\n"
msgstr "vcsi() @{ vcs_info interactive; vcs_info_lastmsg @}\n"

#. type: Plain text
#: zsh.texi:37803
msgid "This way, you can even define different formats for output via @t{vcs_info_lastmsg} in the '@t{:vcs_info:*:interactive:*}' namespace."
msgstr "这样，您甚至可以通过 `@t{:vcs_info:*:interactive:*}'命名空间中的 @t{vcs_info_lastmsg} 来定义不同的输出格式。"

#. type: Plain text
#: zsh.texi:37808
msgid "Now as promised, some code that uses hooks: say, you'd like to replace the string `svn' by `subversion' in @t{vcs_info}'s @t{%s} @t{formats} replacement."
msgstr "现在，正如承诺的那样，一些使用钩子的代码：比如，你想在 @t{vcs_info} 的 @t{%s} @t{formats} 中用 `subversion' 替换字符串 `svn' 。"

#. type: Plain text
#: zsh.texi:37812
msgid "First, we will tell @t{vcs_info} to call a function when populating the message variables with the gathered information:"
msgstr "首先，我们要告诉 @t{vcs_info} 在用收集到的信息补全消息变量时调用一个函数："

#. type: example
#: zsh.texi:37814
#, no-wrap
msgid "zstyle ':vcs_info:*+set-message:*' hooks svn2subversion\n"
msgstr "zstyle ':vcs_info:*+set-message:*' hooks svn2subversion\n"

#. type: Plain text
#: zsh.texi:37820
msgid "Nothing happens. Which is reasonable, since we didn't define the actual function yet. To see what the hooks subsystem is trying to do, enable the `@t{debug}' style:"
msgstr "什么也不会发生。这是合理的，因为我们还没有定义实际函数。要查看钩子子系统正在尝试做什么，请启用 `@t{debug}' 样式："

#. type: example
#: zsh.texi:37822
#, no-wrap
msgid "zstyle ':vcs_info:*+*:*' debug true\n"
msgstr "zstyle ':vcs_info:*+*:*' debug true\n"

#. type: Plain text
#: zsh.texi:37829
msgid ""
"That should give you an idea what is going on. Specifically, the function that we are looking for is `@t{+vi-svn2subversion}'. Note, the `@t{+vi-}' prefix. So, everything is in order, just as documented. "
"When you are done checking out the debugging output, disable it again:"
msgstr "这应该能让你知道发生了什么。具体来说，我们要找的函数是 `@t{+vi-svn2subversion}'。注意，前缀是 `@t{+vi-}' 。所以，一切都井然有序，就像文档中描述的那样。检查完调试输出后，再次禁用它："

#. type: example
#: zsh.texi:37831
#, no-wrap
msgid "zstyle ':vcs_info:*+*:*' debug false\n"
msgstr "zstyle ':vcs_info:*+*:*' debug false\n"

#. type: Plain text
#: zsh.texi:37835
msgid "Now, let's define the function:"
msgstr "现在，我们来定义函数："

#. type: example
#: zsh.texi:37840
#, no-wrap
msgid ""
"function +vi-svn2subversion() @{\n"
"    [[ $@{hook_com[vcs_orig]@} == svn ]] && hook_com[vcs]=subversion\n"
"@}\n"
msgstr ""
"function +vi-svn2subversion() @{\n"
"    [[ $@{hook_com[vcs_orig]@} == svn ]] && hook_com[vcs]=subversion\n"
"@}\n"

#. type: Plain text
#: zsh.texi:37847
msgid ""
"Simple enough. And it could have even been simpler, if only we had registered our function in a less generic context. If we do it only in the `@t{svn}' backend's context, we don't need to test which the "
"active backend is:"
msgstr "足够简单。如果我们在不那么通用的上下文中注册我们的函数，它甚至可以更简单。如果我们只在 `@t{svn}' 后端上下文中注册，就不需要测试哪个后端处于活动状态："

#. type: example
#: zsh.texi:37849
#, no-wrap
msgid "zstyle ':vcs_info:svn+set-message:*' hooks svn2subversion\n"
msgstr "zstyle ':vcs_info:svn+set-message:*' hooks svn2subversion\n"

#. type: example
#: zsh.texi:37855
#, no-wrap
msgid ""
"function +vi-svn2subversion() @{\n"
"    hook_com[vcs]=subversion\n"
"@}\n"
msgstr ""
"function +vi-svn2subversion() @{\n"
"    hook_com[vcs]=subversion\n"
"@}\n"

#. type: Plain text
#: zsh.texi:37860
msgid "And finally a little more elaborate example, that uses a hook to create a customised bookmark string for the @t{hg} backend."
msgstr "最后是一个更复杂的示例，使用钩子为 @t{hg} 后台创建自定义书签字符串。"

#. type: Plain text
#: zsh.texi:37863
msgid "Again, we start off by registering a function:"
msgstr "同样，我们先注册一个函数："

#. type: example
#: zsh.texi:37865
#, no-wrap
msgid "zstyle ':vcs_info:hg+gen-hg-bookmark-string:*' hooks hgbookmarks\n"
msgstr "zstyle ':vcs_info:hg+gen-hg-bookmark-string:*' hooks hgbookmarks\n"

#. type: Plain text
#: zsh.texi:37869
msgid "And then we define the `@t{+vi-hgbookmarks}' function:"
msgstr "然后我们定义 `@t{+vi-hgbookmarks}' 函数："

#. type: example
#: zsh.texi:37895
#, no-wrap
msgid ""
"function +vi-hgbookmarks() @{\n"
"    # The default is to connect all bookmark names by\n"
"    # commas. This mixes things up a little.\n"
"    # Imagine, there's one type of bookmarks that is\n"
"    # special to you. Say, because it's *your* work.\n"
"    # Those bookmarks look always like this: \"sh/*\"\n"
"    # (because your initials are sh, for example).\n"
"    # This makes the bookmarks string use only those\n"
"    # bookmarks. If there's more than one, it\n"
"    # concatenates them using commas.\n"
"    # The bookmarks returned by `hg' are available in\n"
"    # the function's positional parameters.\n"
"    local s=\"$@{(Mj:,:)@@:#sh/*@}\"\n"
"    # Now, the communication with the code that calls\n"
"    # the hook functions is done via the hook_com[]\n"
"    # hash. The key at which the `gen-hg-bookmark-string'\n"
"    # hook looks is `hg-bookmark-string'. So:\n"
"    hook_com[hg-bookmark-string]=$s\n"
"    # And to signal that we want to use the string we\n"
"    # just generated, set the special variable `ret' to\n"
"    # something other than the default zero:\n"
"    ret=1\n"
"    return 0\n"
"@}\n"
msgstr ""
"function +vi-hgbookmarks() @{\n"
"    # The default is to connect all bookmark names by\n"
"    # commas. This mixes things up a little.\n"
"    # Imagine, there's one type of bookmarks that is\n"
"    # special to you. Say, because it's *your* work.\n"
"    # Those bookmarks look always like this: \"sh/*\"\n"
"    # (because your initials are sh, for example).\n"
"    # This makes the bookmarks string use only those\n"
"    # bookmarks. If there's more than one, it\n"
"    # concatenates them using commas.\n"
"    # The bookmarks returned by `hg' are available in\n"
"    # the function's positional parameters.\n"
"    local s=\"$@{(Mj:,:)@@:#sh/*@}\"\n"
"    # Now, the communication with the code that calls\n"
"    # the hook functions is done via the hook_com[]\n"
"    # hash. The key at which the `gen-hg-bookmark-string'\n"
"    # hook looks is `hg-bookmark-string'. So:\n"
"    hook_com[hg-bookmark-string]=$s\n"
"    # And to signal that we want to use the string we\n"
"    # just generated, set the special variable `ret' to\n"
"    # something other than the default zero:\n"
"    ret=1\n"
"    return 0\n"
"@}\n"

#. type: Plain text
#: zsh.texi:37901
msgid "Some longer examples and code snippets which might be useful are available in the examples file located at Misc/vcs_info-examples in the Zsh source directory."
msgstr "Zsh 源代码目录下 Misc/vcs_info-examples 中的示例文件提供了一些较长的示例和可能有用的代码片段。"

#. type: Plain text
#: zsh.texi:37904
msgid "This concludes our guided tour through zsh's @t{vcs_info}."
msgstr "至此，我们的 zsh 的 @t{vcs_info} 之旅就结束了。"

#. type: node
#: zsh.texi:37906 zsh.texi:38080 zsh.texi:38082 zsh.texi:39808
#, no-wrap
msgid "ZLE Functions"
msgstr "ZLE 函数"

#. type: Plain text
#: zsh.texi:37930
msgid ""
"You should make sure all the functions from the @t{Functions/Prompts} directory of the source distribution are available; they all begin with the string `@t{prompt_}' except for the special function "
"`@t{promptinit}'.  You also need the `@t{colors}' and `@t{add-zsh-hook}' functions from @t{Functions/Misc}.  All these functions may already be installed on your system; if not, you will need to find them "
"and copy them.  The directory should appear as one of the elements of the @t{fpath} array (this should already be the case if they were installed), and at least the function @t{promptinit} should be "
"autoloaded; it will autoload the rest.  Finally, to initialize the use of the system you need to call the @t{promptinit} function.  The following code in your @t{.zshrc} will arrange for this; assume the "
"functions are stored in the directory @t{~/myfns}:"
msgstr ""
"您应确保源代码发布版 @t{Functions/Prompts} 目录中的所有函数都可用；除了特殊函数 `@t{promptinit}'，它们都以字符串 `@t{prompt_}' 开头。 你还需要 @t{Functions/Misc} 中的 `@t{colors}' 和 `@t{add-zsh-hook}' 函"
"数。 您的系统可能已经安装了所有这些函数；如果没有，则需要找到并复制它们。 目录应作为 @t{fpath} 数组的元素之一出现（如果已经安装，则应如此），至少 @t{promptinit} 函数应自动加载，其余函数将自动加载。 最后，"
"要初始化系统的使用，需要调用 @t{promptinit} 函数。 假设函数存储在 @t{~/myfns} 目录中，则 @t{.zshrc} 中的以下代码将为此做出安排："

#. type: example
#: zsh.texi:37936
#, no-wrap
msgid ""
"fpath=(~/myfns $fpath)\n"
"autoload -U promptinit\n"
"promptinit\n"
msgstr ""
"fpath=(~/myfns $fpath)\n"
"autoload -U promptinit\n"
"promptinit\n"

#. type: subsection
#: zsh.texi:37940
#, no-wrap
msgid "Theme Selection"
msgstr "主题选择"

#. type: Plain text
#: zsh.texi:37947
msgid "Use the @t{prompt} command to select your preferred theme.  This command may be added to your @t{.zshrc} following the call to @t{promptinit} in order to start zsh with a theme already selected."
msgstr "使用 @t{prompt} 命令选择您喜欢的主题。 可以在调用 @t{promptinit} 之后将此命令添加到 @t{.zshrc} 中，以便在已选择主题的情况下启动 zsh。"

#. type: item
#: zsh.texi:37950
#, no-wrap
msgid "@t{prompt} [ @t{-c} | @t{-l} ]"
msgstr "@t{prompt} [ @t{-c} | @t{-l} ]"

#. type: itemx
#: zsh.texi:37951
#, no-wrap
msgid "@t{prompt} [ @t{-p} | @t{-h} ] [ @var{theme} ... ]"
msgstr "@t{prompt} [ @t{-p} | @t{-h} ] [ @var{theme} ... ]"

#. type: itemx
#: zsh.texi:37952
#, no-wrap
msgid "@t{prompt} [ @t{-s} ] @var{theme} [ @var{arg} ... ]"
msgstr "@t{prompt} [ @t{-s} ] @var{theme} [ @var{arg} ... ]"

#. type: table
#: zsh.texi:37958
msgid ""
"Set or examine the prompt theme.  With no options and a @var{theme} argument, the theme with that name is set as the current theme.  The available themes are determined at run time; use the @t{-l} option "
"to see a list.  The special @var{theme} `@t{random}' selects at random one of the available themes and sets your prompt to that."
msgstr ""
"设置或检查提示符主题。 在没有任何选项和 @var{theme} 参数的情况下，以该名称命名的主题将被设置为当前主题。 可用主题在运行时确定；使用 @t{-l} 选项可查看列表。 特殊的 @var{theme} `@t{random}' 会从可用主题中随"
"机选择一个，并将提示符设置为该主题。"

#. type: table
#: zsh.texi:37963
msgid "In some cases the @var{theme} may be modified by one or more arguments, which should be given after the theme name.  See the help for each theme for descriptions of these arguments."
msgstr "在某些情况下，@var{theme} 可能会被一个或多个参数修改，这些参数应在主题名称后给出。 有关这些参数的说明，请参阅每个主题的帮助。"

#. type: table
#: zsh.texi:37966
msgid "Options are:"
msgstr "选项是:"

#. type: table
#: zsh.texi:37971
msgid "Show the currently selected theme and its parameters, if any."
msgstr "显示当前选择的主题及其参数（如果有）。"

#. type: table
#: zsh.texi:37973
msgid "List all available prompt themes."
msgstr "列出所有可用的提示符主题。"

#. type: table
#: zsh.texi:37976
msgid "Preview the theme named by @var{theme}, or all themes if no @var{theme} is given."
msgstr "预览由 @var{theme} 命名的主题，如果没有给出 @var{theme} 则预览所有主题。"

#. type: table
#: zsh.texi:37979
msgid "Show help for the theme named by @var{theme}, or for the @t{prompt} function if no @var{theme} is given."
msgstr "显示由 @var{theme} 命名的主题的帮助，如果未给出 @var{theme} 则显示 @t{prompt} 函数的帮助。"

#. type: table
#: zsh.texi:37981
msgid "Set @var{theme} as the current theme and save state."
msgstr "将 @var{theme} 设置为当前主题并保存状态。"

#. type: item
#: zsh.texi:37983
#, no-wrap
msgid "@t{prompt_}@var{theme}@t{_setup}"
msgstr "@t{prompt_}@var{theme}@t{_setup}"

#. type: table
#: zsh.texi:37989
msgid ""
"Each available @var{theme} has a setup function which is called by the @t{prompt} function to install that theme.  This function may define other functions as necessary to maintain the prompt, including "
"functions used to preview the prompt or provide help for its use.  You should not normally call a theme's setup function directly."
msgstr ""
"每个可用的 @var{theme} 都有一个设置函数，由 @t{prompt} 函数调用来安装该主题。 该函数可根据维护提示符的需要定义其他函数，包括用于预览提示符或提供使用帮助的函数。 通常情况下，不应直接调用主题的设置函数。"

#. type: subsection
#: zsh.texi:37994
#, no-wrap
msgid "Utility Themes"
msgstr "实用主题"

#. type: t{#1}
#: zsh.texi:37999
#, no-wrap
msgid "prompt off"
msgstr "prompt off"

#. type: table
#: zsh.texi:38002
msgid "The theme `@t{off}' sets all the prompt variables to minimal values with no special effects."
msgstr "主题 `@t{off}' 会将所有提示符变量设置为没有特殊效果的最小值。"

#. type: t{#1}
#: zsh.texi:38003
#, no-wrap
msgid "prompt default"
msgstr "prompt default"

#. type: table
#: zsh.texi:38006
msgid "The theme `@t{default}' sets all prompt variables to the same state as if an interactive zsh was started with no initialization files."
msgstr "主题 `@t{default}' 会将所有提示符变量设置为与启动无初始化文件的交互式 zsh 相同的状态。"

#. type: t{#1}
#: zsh.texi:38007
#, no-wrap
msgid "prompt restore"
msgstr "prompt restore"

#. type: table
#: zsh.texi:38011
msgid ""
"The special theme `@t{restore}' erases all theme settings and sets prompt variables to their state before the first time the `@t{prompt}' function was run, provided each theme has properly defined its "
"cleanup (see below)."
msgstr "特殊主题 `@t{restore}' 会清除所有主题设置，并将提示符变量设置为首次运行 `@t{prompt}' 函数前的状态，前提是每个主题都已正确定义了其清理方式（见下文）。"

#. type: table
#: zsh.texi:38015
msgid "Note that you can undo `@t{prompt off}' and `@t{prompt default}' with `@t{prompt restore}', but a second restore does not undo the first."
msgstr "请注意，可以通过 `@t{prompt restore}'来撤销  `@t{prompt off}' 和 `@t{prompt default}' ，但第二次还原不会撤销第一次。"

#. type: subsection
#: zsh.texi:38020
#, no-wrap
msgid "Writing Themes"
msgstr "编写主题"

#. type: Plain text
#: zsh.texi:38030
msgid ""
"The first step for adding your own theme is to choose a name for it, and create a file `@t{prompt_@var{name}_setup}' in a directory in your @t{fpath}, such as @t{~/myfns} in the example above.  The file "
"should at minimum contain assignments for the prompt variables that your theme wishes to modify.  By convention, themes use @t{PS1}, @t{PS2}, @t{RPS1}, etc., rather than the longer @t{PROMPT} and "
"@t{RPROMPT}."
msgstr ""
"添加自己主题的第一步是为其取名，并在 @t{fpath} 目录下创建文件 `@t{prompt_@var{name}_setup}' ，如上例中的 @t{~/myfns}。 该文件至少应包含主题希望修改的提示符变量的赋值。 按照惯例，主题使用 @t{PS1}、@t{PS2}、"
"@t{RPS1} 等，而不是更长的 @t{PROMPT} 和 @t{RPROMPT}。"

#. type: Plain text
#: zsh.texi:38036
msgid ""
"The file is autoloaded as a function in the current shell context, so it may contain any necessary commands to customize your theme, including defining additional functions.  To make some complex tasks "
"easier, your setup function may also do any of the following:"
msgstr "该文件将作为当前 shell 上下文中的一个函数自动加载，因此其中可能包含自定义主题所需的任何命令，包括定义其他函数。 为了简化一些复杂的任务，您的设置函数还可以执行以下任何操作："

#. type: item
#: zsh.texi:38039
#, no-wrap
msgid "Assign @t{prompt_opts}"
msgstr "为 @t{prompt_opts} 赋值"

#. type: table
#: zsh.texi:38045
msgid ""
"The array @t{prompt_opts} may be assigned any of @t{\"bang\"}, @t{\"cr\"}, @t{\"percent\"}, @t{\"sp\"}, and/or @t{\"subst\"} as values.  The corresponding setopts (@t{promptbang}, etc.) are turned on, all "
"other prompt-related options are turned off.  The @t{prompt_opts} array preserves setopts even beyond the scope of @t{localoptions}, should your function need that."
msgstr ""
"数组 @t{prompt_opts} 的值可以是 @t{\"bang\"}、@t{\"cr\"}、@t{\"percent\"}、@t{\"sp\"} 和/或 @t{\"subst\"}。 相应的 setopts（@t{promptbang} 等）被打开，所有其他与提示符相关的选项被关闭。 如果您的函数需要，"
"@t{prompt_opts} 数组甚至会在 @t{localoptions} 的范围之外保留 setopts。"

#. type: item
#: zsh.texi:38046
#, no-wrap
msgid "Modify hooks"
msgstr "修改勾子"

#. type: table
#: zsh.texi:38051
msgid ""
"Use of @t{add-zsh-hook} and @t{add-zle-hook-widget} is recommended (see the @cite{Manipulating Hook Functions} section above).  All hooks that follow the naming pattern @t{prompt_}@var{theme}@t{_}"
"@var{hook} are automatically removed when the prompt theme changes or is disabled."
msgstr "建议使用 @t{add-zsh-hook} 和 @t{add-zle-hook-widget}（参见上文 @cite{操作勾子函数} 部分）。 所有遵循命名模式 @t{prompt_}@var{theme}@t{_}@var{hook} 的钩子都会在提示符主题更改或禁用时自动移除。"

#. type: item
#: zsh.texi:38052
#, no-wrap
msgid "Declare cleanup"
msgstr "声明清理"

#. type: table
#: zsh.texi:38055
msgid "If your function makes any other changes that should be undone when the theme is disabled, your setup function may call"
msgstr "如果您的函数进行了任何其他更改，而这些更改在主题禁用时应该被撤销，那么您的设置函数可能会调用"

#. type: example
#: zsh.texi:38059
#, no-wrap
msgid "prompt_cleanup @var{command}\n"
msgstr "prompt_cleanup @var{command}\n"

#. type: table
#: zsh.texi:38065
msgid "where @var{command} should be suitably quoted.  If your theme is ever disabled or replaced by another, @var{command} is executed with @t{eval}.  You may declare more than one such cleanup hook."
msgstr "其中 @var{command} 应适当加引号。 如果您的主题被禁用或被另一个替换，@var{command} 将与 @t{eval} 一起执行。 您可以声明多个这样的清理钩子。"

#. type: item
#: zsh.texi:38066
#, no-wrap
msgid "Define preview"
msgstr "定义预览"

#. type: table
#: zsh.texi:38071
msgid ""
"Define or autoload a function @t{prompt_}@var{name}@t{_preview} to display a simulated version of your prompt.  A simple default previewer is defined by @t{promptinit} for themes that do not define their "
"own.  This preview function is called by `@t{prompt -p}'."
msgstr "定义或自动加载函数 @t{prompt_}@var{name}@t{_preview}，以显示模拟版本的提示符。 @t{promptinit} 为未定义预览器的主题定义了一个简单的默认预览器。 该预览函数由 `@t{prompt -p}' 调用。"

#. type: item
#: zsh.texi:38072
#, no-wrap
msgid "Provide help"
msgstr "提供帮助"

#. type: table
#: zsh.texi:38076
msgid "Define or autoload a function @t{prompt_}@var{name}@t{_help} to display documentation or help text for your theme.  This help function is called by `@t{prompt -h}'."
msgstr "定义或自动加载函数 @t{prompt_}@var{name}@t{_help} ，以显示你主题的文档或帮助文本。 该帮助函数由 `@t{prompt -h}' 调用。"

#. type: node
#: zsh.texi:38080 zsh.texi:39808 zsh.texi:39810 zsh.texi:39908
#, no-wrap
msgid "Exception Handling"
msgstr "异常处理"

#. type: subsection
#: zsh.texi:38087
#, no-wrap
msgid "Widgets"
msgstr "小部件"

#. type: Plain text
#: zsh.texi:38094
msgid ""
"These functions all implement user-defined ZLE widgets (see @ref{Zsh Line Editor}) which can be bound to keystrokes in interactive shells.  To use them, your @t{.zshrc} should contain lines of the form"
msgstr "这些函数都实现了用户定义的 ZLE 小部件（请参阅 @ref{Zsh 行编辑器}），可与交互式 shell 中的按键绑定。 要使用它们，您的 @t{.zshrc} 应包含以下格式的行"

#. type: example
#: zsh.texi:38099
#, no-wrap
msgid ""
"autoload @var{function}\n"
"zle -N @var{function}\n"
msgstr ""
"autoload @var{function}\n"
"zle -N @var{function}\n"

#. type: Plain text
#: zsh.texi:38104
msgid "followed by an appropriate @t{bindkey} command to associate the function with a key sequence.  Suggested bindings are described below."
msgstr "后接适当的 @t{bindkey} 命令，将函数与按键序列关联起来。 建议的绑定说明如下。"

#. type: item
#: zsh.texi:38107
#, no-wrap
msgid "bash-style word functions"
msgstr "bash 风格字函数"

#. type: table
#: zsh.texi:38112
msgid ""
"If you are looking for functions to implement moving over and editing words in the manner of bash, where only alphanumeric characters are considered word characters, you can use the functions described in "
"the next section.  The following is sufficient:"
msgstr "如果您正在寻找以 bash 的方式移动和编辑单词的函数（在 bash 中，只有字母数字字符才被视为单词字符），您可以使用下一节中描述的函数。 以下函数就足够了："

#. type: example
#: zsh.texi:38117
#, no-wrap
msgid ""
"autoload -U select-word-style\n"
"select-word-style bash\n"
msgstr ""
"autoload -U select-word-style\n"
"select-word-style bash\n"

#. type: tindex
#: zsh.texi:38121
#, no-wrap
msgid "forward-word-match"
msgstr "forward-word-match"

#. type: tindex
#: zsh.texi:38122
#, no-wrap
msgid "backward-word-match"
msgstr "backward-word-match"

#. type: tindex
#: zsh.texi:38123
#, no-wrap
msgid "kill-word-match"
msgstr "kill-word-match"

#. type: tindex
#: zsh.texi:38124
#, no-wrap
msgid "backward-kill-word-match"
msgstr "backward-kill-word-match"

#. type: tindex
#: zsh.texi:38125
#, no-wrap
msgid "transpose-words-match"
msgstr "transpose-words-match"

#. type: tindex
#: zsh.texi:38126
#, no-wrap
msgid "capitalize-word-match"
msgstr "capitalize-word-match"

#. type: tindex
#: zsh.texi:38127
#, no-wrap
msgid "up-case-word-match"
msgstr "up-case-word-match"

#. type: tindex
#: zsh.texi:38128
#, no-wrap
msgid "down-case-word-match"
msgstr "down-case-word-match"

#. type: t{#1}
#: zsh.texi:38129 zsh.texi:38555 zsh.texi:38556
#, no-wrap
msgid "delete-whole-word-match"
msgstr "delete-whole-word-match"

#. type: tindex
#: zsh.texi:38130
#, no-wrap
msgid "select-word-match"
msgstr "select-word-match"

#. type: tindex
#: zsh.texi:38131
#, no-wrap
msgid "select-word-style"
msgstr "select-word-style"

#. type: tindex
#: zsh.texi:38132
#, no-wrap
msgid "match-word-context"
msgstr "match-word-context"

#. type: item
#: zsh.texi:38134
#, no-wrap
msgid "@t{forward-word-match}, @t{backward-word-match}"
msgstr "@t{forward-word-match}, @t{backward-word-match}"

#. type: itemx
#: zsh.texi:38135
#, no-wrap
msgid "@t{kill-word-match}, @t{backward-kill-word-match}"
msgstr "@t{kill-word-match}, @t{backward-kill-word-match}"

#. type: itemx
#: zsh.texi:38136
#, no-wrap
msgid "@t{transpose-words-match}, @t{capitalize-word-match}"
msgstr "@t{transpose-words-match}, @t{capitalize-word-match}"

#. type: itemx
#: zsh.texi:38137
#, no-wrap
msgid "@t{up-case-word-match}, @t{down-case-word-match}"
msgstr "@t{up-case-word-match}, @t{down-case-word-match}"

#. type: itemx
#: zsh.texi:38138
#, no-wrap
msgid "@t{delete-whole-word-match}, @t{select-word-match}"
msgstr "@t{delete-whole-word-match}, @t{select-word-match}"

#. type: itemx
#: zsh.texi:38139
#, no-wrap
msgid "@t{select-word-style}, @t{match-word-context}, @t{match-words-by-style}"
msgstr "@t{select-word-style}, @t{match-word-context}, @t{match-words-by-style}"

#. type: table
#: zsh.texi:38147
msgid ""
"The first eight `@t{-match}' functions are drop-in replacements for the builtin widgets without the suffix.  By default they behave in a similar way.  However, by the use of styles and the function "
"@t{select-word-style}, the way words are matched can be altered. @t{select-word-match} is intended to be used as a text object in vi mode but with custom word styles. For comparison, the widgets described "
"in @ref{Text Objects} use fixed definitions of words, compatible with the @t{vim} editor."
msgstr ""
"前八个 `@t{-match}' 函数可以直接替换不带后缀的内置小部件。 默认情况下，它们的行为方式类似。 不过，通过使用样式和函数 @t{select-word-style}，可以改变单词的匹配方式。@t{select-word-match}的目的是在 vi 模式下"
"作为文本对象使用，但可自定义单词样式。相比之下，@ref{文本对象} 中描述的小部件使用固定的单词定义，与 @t{vim} 编辑器兼容。"

#. type: table
#: zsh.texi:38155
msgid ""
"The simplest way of configuring the functions is to use @t{select-word-style}, which can either be called as a normal function with the appropriate argument, or invoked as a user-defined widget that will "
"prompt for the first character of the word style to be used.  The first time it is invoked, the first eight @t{-match} functions will automatically replace the builtin versions, so they do not need to be "
"loaded explicitly."
msgstr ""
"配置这些函数的最简单方法是使用 @t{select-word-style}，它既可以作为一个普通函数与适当的参数一起调用，也可以作为一个用户定义的小部件调用，该部件会提示要使用的单词样式的第一个字符。 首次调用时，前八个 @t{-"
"match} 函数将自动替换内置版本，因此无需明确加载。"

#. type: table
#: zsh.texi:38159
msgid "The word styles available are as follows.  Only the first character is examined."
msgstr "可用的单词样式如下。 只检查第一个字符。"

#. type: t{#1}
#: zsh.texi:38162
#, no-wrap
msgid "bash"
msgstr "bash"

#. type: table
#: zsh.texi:38164
msgid "Word characters are alphanumeric characters only."
msgstr "单词字符仅限字母数字字符。"

#. type: t{#1}
#: zsh.texi:38165 zsh.texi:38210
#, no-wrap
msgid "normal"
msgstr "normal"

#. type: table
#: zsh.texi:38169
msgid "As in normal shell operation: word characters are alphanumeric characters plus any characters present in the string given by the parameter @t{$WORDCHARS}."
msgstr "与正常的 shell 操作一样：单词字符是字母数字字符加上参数 @t{$WORDCHARS} 给出的字符串中的任何字符。"

#. type: t{#1}
#: zsh.texi:38170 zsh.texi:38222
#, no-wrap
msgid "shell"
msgstr "shell"

#. type: table
#: zsh.texi:38173
msgid "Words are complete shell command arguments, possibly including complete quoted strings, or any tokens special to the shell."
msgstr "单词是完整的 shell 命令参数，可能包括完整的加引号字符串或 shell 特有的任何标记。"

#. type: t{#1}
#: zsh.texi:38174 zsh.texi:38227
#, no-wrap
msgid "whitespace"
msgstr "whitespace"

#. type: table
#: zsh.texi:38176
msgid "Words are any set of characters delimited by whitespace."
msgstr "单词是以空格分隔的任意一组字符。"

#. type: table
#: zsh.texi:38179
msgid "Restore the default settings; this is usually the same as `@t{normal}'."
msgstr "恢复默认设置；通常与 `@t{normal}'相同。"

#. type: table
#: zsh.texi:38192
msgid ""
"All but `@t{default}' can be input as an upper case character, which has the same effect but with subword matching turned on.  In this case, words with upper case characters are treated specially: each "
"separate run of upper case characters, or an upper case character followed by any number of other characters, is considered a word.  The style @t{subword-range} can supply an alternative character range "
"to the default `@t{[:upper:]}'; the value of the style is treated as the contents of a `@t{[}@var{...}@t{]}' pattern (note that the outer brackets should not be supplied, only those surrounding named "
"ranges)."
msgstr ""
"除 `@t{default}' 外，其他所有字符都可以作为大写字符输入，其效果与开启子字匹配时相同。 在这种情况下，带有大写字符的单词会被特殊处理：每一个单独的大写字符，或一个大写字符后跟任意数量的其他字符，都会被视为一"
"个单词。 样式 @t{subword-range} 可以为默认的 `@t{[:upper:]}' 提供一个替代字符范围；该样式的值将被视为`@t{[}@var{...}@t{]}' 模式的内容（注意，不应提供外层括号，只应提供围绕命名范围的括号）。"

#. type: table
#: zsh.texi:38203
msgid ""
"More control can be obtained using the @t{zstyle} command, as described in @ref{The zsh/zutil Module}.  Each style is looked up in the context @t{:zle:}@var{widget} where @var{widget} is the name of the "
"user-defined widget, not the name of the function implementing it, so in the case of the definitions supplied by @t{select-word-style} the appropriate contexts are @t{:zle:forward-word}, and so on.  The "
"function @t{select-word-style} itself always defines styles for the context `@t{:zle:*}' which can be overridden by more specific (longer) patterns as well as explicit contexts."
msgstr ""
"如 @ref{zsh/zutil 模块} 所述，使用 @t{zstyle} 命令可以获得更多控制权。 每种样式都在 @t{:zle:}@var{widget} 上下文中查找，其中 @var{widget} 是用户定义的 小部件的名称，而不是实现该小部件的函数的名称，因此在 "
"@t{select-word-style} 提供定义的情况下，相应的上下文是 @t{:zle:forward-word}，以此类推。 函数 @t{select-word-style} 本身总是为上下文 `@t{:zle:*}' 定义样式，这些样式可以被更具体（更长）的模式和显式上下文覆"
"盖。"

#. type: table
#: zsh.texi:38207
msgid "The style @t{word-style} specifies the rules to use.  This may have the following values."
msgstr "样式 @t{word-style} 指定要使用的规则。 它可以有以下值。"

#. type: table
#: zsh.texi:38213
msgid "Use the standard shell rules, i.e. alphanumerics and @t{$WORDCHARS}, unless overridden by the styles @t{word-chars} or @t{word-class}."
msgstr "使用标准 shell 规则，即字母数字和 @t{$WORDCHARS}，除非被 @t{word-chars} 或 @t{word-class} 样式覆盖。"

#. type: t{#1}
#: zsh.texi:38214
#, no-wrap
msgid "specified"
msgstr "specified"

#. type: table
#: zsh.texi:38217
msgid "Similar to @t{normal}, but @emph{only} the specified characters, and not also alphanumerics, are considered word characters."
msgstr "与 @t{normal}类似，但 @emph{只} 将指定的字符（而不是字母数字）视为单词字符。"

#. type: t{#1}
#: zsh.texi:38218
#, no-wrap
msgid "unspecified"
msgstr "unspecified"

#. type: table
#: zsh.texi:38221
msgid "The negation of specified.  The given characters are those which will @emph{not} be considered part of a word."
msgstr "指定的否定。 给出的字符将 @emph{不} 被视为单词的一部分。"

#. type: table
#: zsh.texi:38226
msgid "Words are obtained by using the syntactic rules for generating shell command arguments.  In addition, special tokens which are never command arguments such as `@t{()}' are also treated as words."
msgstr "单词是通过使用生成 shell 命令参数的语法规则获得的。 此外，诸如 `@t{()}' 等从来都不是命令参数的特殊标记也会被视为单词。"

#. type: table
#: zsh.texi:38229
msgid "Words are whitespace-delimited strings of characters."
msgstr "单词是以空白字符分隔的字符串。"

#. type: table
#: zsh.texi:38243
msgid ""
"The first three of those rules usually use @t{$WORDCHARS}, but the value in the parameter can be overridden by the style @t{word-chars}, which works in exactly the same way as @t{$WORDCHARS}.  In "
"addition, the style @t{word-class} uses character class syntax to group characters and takes precedence over @t{word-chars} if both are set.  The @t{word-class} style does not include the surrounding "
"brackets of the character class; for example, `@t{-:[:alnum:]}' is a valid @t{word-class} to include all alphanumerics plus the characters `@t{-}' and `@t{:}'.  Be careful including `@t{]}', `@t{^}' and "
"`@t{-}' as these are special inside character classes."
msgstr ""
"前三条规则通常使用 @t{$WORDCHARS}，但参数中的值可以被样式 @t{word-chars} 改写，其工作方式与 @t{$WORDCHARS} 完全相同。 此外，@t{word-class} 样式使用字符类语法对字符进行分组，如果同时设置了 @t{word-chars} "
"和 @t{word-class}，则 @t{word-class}优先于 @t{word-chars}。 @t{word-class} 样式不包括字符类周围的括号；例如，`@t{-:[:alnum:]}' 是一个有效的 @t{word-class}，用以包括所有字母数字以及字符 `@t{-}' 和 "
"`@t{:}'。 包含 `@t{]}', `@t{^}' 和 `@t{-}' 时要注意，因为它们是字符类内部的特殊字符。"

#. type: table
#: zsh.texi:38247
msgid "@t{word-style} may also have `@t{-subword}' appended to its value to turn on subword matching, as described above."
msgstr "如上所述，@t{word-style} 也可以附加 `@t{-subword}' ，以开启子词匹配。"

#. type: table
#: zsh.texi:38254
msgid ""
"The style @t{skip-chars} is mostly useful for @t{transpose-words} and similar functions.  If set, it gives a count of characters starting at the cursor position which will not be considered part of the "
"word and are treated as space, regardless of what they actually are.  For example, if"
msgstr "@t{skip-chars} 样式主要用于 @t{transpose-words} 和类似函数。 如果设置了该样式，它将给出从光标位置开始的字符计数，这些字符将不被视为单词的一部分，并被视为空格，而不管它们实际上是什么。 例如，如果"

#. type: example
#: zsh.texi:38258
#, no-wrap
msgid "zstyle ':zle:transpose-words' skip-chars 1\n"
msgstr "zstyle ':zle:transpose-words' skip-chars 1\n"

#. type: table
#: zsh.texi:38264
msgid ""
"has been set, and @t{transpose-words-match} is called with the cursor on the @var{X} of @t{foo}@var{X}@t{bar}, where @var{X} can be any character, then the resulting expression is @t{bar}@var{X}@t{foo}."
msgstr "已设置，且 @t{transpose-words-match} 被调用时光标位于 @t{foo}@var{X}@t{bar} 的 @var{X} 上，其中 @var{X} 可以是任何字符，那么结果表达式为 @t{bar}@var{X}@t{foo}。"

#. type: table
#: zsh.texi:38277
msgid ""
"Finer grained control can be obtained by setting the style @t{word-context} to an array of pairs of entries.  Each pair of entries consists of a @var{pattern} and a @var{subcontext}.  The shell argument "
"the cursor is on is matched against each @var{pattern} in turn until one matches; if it does, the context is extended by a colon and the corresponding @var{subcontext}.  Note that the test is made against "
"the original word on the line, with no stripping of quotes.  Special handling is done between words: the current context is examined and if it contains the string @t{between} the word is set to a single "
"space; else if it is contains the string @t{back}, the word before the cursor is considered, else the word after cursor is considered. Some examples are given below."
msgstr ""
"通过将 @t{word-context} 样式设置为成对条目的数组，可以实现更精细的控制。 每对条目由 @var{pattern} 和 @var{subcontext} 组成。 光标所在的 shell 参数依次与每个 @var{pattern} 匹配，直到有一个匹配为止；如果匹"
"配，则用冒号和相应的 @var{subcontext} 扩展上下文。 请注意，测试是针对行中的原始单词进行的，不会去掉引号。 单词之间会进行特殊处理：检查当前上下文，如果其中包含字符串 @t{between}，则将单词设置为单个空格；否"
"则，如果其中包含字符串 @t{back}，则考虑光标前的单词，否则考虑光标后的单词。下面给出了一些示例。"

#. type: table
#: zsh.texi:38288
msgid ""
"The style @t{skip-whitespace-first} is only used with the @t{forward-word} widget.  If it is set to true, then @t{forward-word} skips any non-word-characters, followed by any non-word-characters: this is "
"similar to the behaviour of other word-orientated widgets, and also that used by other editors, however it differs from the standard zsh behaviour.  When using @t{select-word-style} the widget is set in "
"the context @t{:zle:*} to @t{true} if the word style is @t{bash} and @t{false} otherwise.  It may be overridden by setting it in the more specific context @t{:zle:forward-word*}."
msgstr ""
"@t{skip-whitespace-first} 样式仅用于 @t{forward-word} 小部件。如果设置为 true，那么 @t{forward-word} 将跳过任何非单词字符，然后跟着任何非单词字符：这类似于其他面向单词的小部件的行为，也类似于其他编辑器使用"
"的行为，但与标准的 zsh 行为不同。这与其他以单词为导向的小部件以及其他编辑器的行为类似，但与标准的 zsh 行为不同。 使用 @t{select-word-style} 时，如果单词样式为 @t{bash}，则小部件在上下文 @t{:zle:*} 中被设置"
"为 @t{true}，否则为 @t{false}。 可以通过在更具体的上下文 @t{:zle:forward-word*} 中进行设置来覆盖该设置。"

#. type: table
#: zsh.texi:38297
msgid ""
"It is possible to create widgets with specific behaviour by defining a new widget implemented by the appropriate generic function, then setting a style for the context of the specific widget.  For "
"example, the following defines a widget @t{backward-kill-space-word} using @t{backward-kill-word-match}, the generic widget implementing @t{backward-kill-word} behaviour, and ensures that the new widget "
"always implements space-delimited behaviour."
msgstr ""
"通过定义一个由相应泛型函数实现的新小部件，然后为特定小部件的上下文设置样式，就可以创建具有特定行为的小部件。 例如，下面使用 @t{backward-kill-word-match}（实现 @t{backward-kill-word} 行为的通用部件）定义了"
"一个小部件 @t{backward-kill-space-word} ，并确保新小部件始终实现空格分隔行为。"

#. type: example
#: zsh.texi:38302
#, no-wrap
msgid ""
"zle -N backward-kill-space-word backward-kill-word-match\n"
"zstyle :zle:backward-kill-space-word word-style space\n"
msgstr ""
"zle -N backward-kill-space-word backward-kill-word-match\n"
"zstyle :zle:backward-kill-space-word word-style space\n"

#. type: table
#: zsh.texi:38306
msgid "The widget @t{backward-kill-space-word} can now be bound to a key."
msgstr "小部件 @t{backward-kill-space-word} 现在可以与按键绑定。"

#. type: table
#: zsh.texi:38310
msgid "Here are some further examples of use of the styles, actually taken from the simplified interface in @t{select-word-style}:"
msgstr "以下是一些更进一步的样式使用示例，实际上是从 @t{select-word-style} 中简化的接口中提取的。"

#. type: example
#: zsh.texi:38315
#, no-wrap
msgid ""
"zstyle ':zle:*' word-style standard\n"
"zstyle ':zle:*' word-chars @value{dsq}\n"
msgstr ""
"zstyle ':zle:*' word-style standard\n"
"zstyle ':zle:*' word-chars @value{dsq}\n"

#. type: table
#: zsh.texi:38321
msgid "Implements bash-style word handling for all widgets, i.e. only alphanumerics are word characters; equivalent to setting the parameter @t{WORDCHARS} empty for the given context."
msgstr "为所有小部件实现类似于 Bash 风格的单词处理，即只有字母数字字符被视为单词字符；等效于在给定上下文中将参数 @t{WORDCHARS} 设置为空。"

#. type: example
#: zsh.texi:38325
#, no-wrap
msgid "style ':zle:*kill*' word-style space\n"
msgstr "style ':zle:*kill*' word-style space\n"

#. type: table
#: zsh.texi:38330
msgid "Uses space-delimited words for widgets with the word `kill' in the name.  Neither of the styles @t{word-chars} nor @t{word-class} is used in this case."
msgstr "对名称中含有 `kill' 一词的小部件使用以空格分隔的单词。 在这种情况下，不会使用 @t{word-chars} 或 @t{word-class} 样式。"

#. type: table
#: zsh.texi:38334
msgid "Here are some examples of use of the @t{word-context} style to extend the context."
msgstr "下面是一些使用 @t{word-context} 样式扩展上下文的示例。"

#. type: example
#: zsh.texi:38342
#, no-wrap
msgid ""
"zstyle ':zle:*' word-context \\ \n"
"       \"*/*\" filename \"[[:space:]]\" whitespace\n"
"zstyle ':zle:transpose-words:whitespace' word-style shell\n"
"zstyle ':zle:transpose-words:filename' word-style normal\n"
"zstyle ':zle:transpose-words:filename' word-chars @value{dsq}\n"
msgstr ""
"zstyle ':zle:*' word-context \\ \n"
"       \"*/*\" filename \"[[:space:]]\" whitespace\n"
"zstyle ':zle:transpose-words:whitespace' word-style shell\n"
"zstyle ':zle:transpose-words:filename' word-style normal\n"
"zstyle ':zle:transpose-words:filename' word-chars @value{dsq}\n"

#. type: table
#: zsh.texi:38351
msgid ""
"This provides two different ways of using @t{transpose-words} depending on whether the cursor is on whitespace between words or on a filename, here any word containing a @t{/}.  On whitespace, complete "
"arguments as defined by standard shell rules will be transposed.  In a filename, only alphanumerics will be transposed.  Elsewhere, words will be transposed using the default style for @t{:zle:transpose-"
"words}."
msgstr ""
"这提供了两种使用 @t{transpose-words} 的不同方法，取决于光标是在单词之间的空白处还是在文件名上，这里是指包含 @t{/} 的任何单词。 在空白处，标准 shell 规则定义的完整参数将被转置。 在文件名中，只有字母数字会被"
"换码。 在其他地方，将使用 @t{:zle:transpose-words} 的默认样式转置单词。"

#. type: table
#: zsh.texi:38367
msgid ""
"The word matching and all the handling of @t{zstyle} settings is actually implemented by the function @t{match-words-by-style}.  This can be used to create new user-defined widgets.  The calling function "
"should set the local parameter @t{curcontext} to @t{:zle:}@var{widget}, create the local parameter @t{matched_words} and call @t{match-words-by-style} with no arguments.  On return, @t{matched_words} will "
"be set to an array with the elements: (1) the start of the line (2) the word before the cursor (3) any non-word characters between that word and the cursor (4) any non-word character at the cursor "
"position plus any remaining non-word characters before the next word, including all characters specified by the @t{skip-chars} style, (5) the word at or following the cursor (6) any non-word characters "
"following that word (7) the remainder of the line.  Any of the elements may be an empty string; the calling function should test for this to decide whether it can perform its function."
msgstr ""
"词匹配和 @t{zstyle} 设置的所有处理实际上都是通过函数 @t{match-words-by-style} 实现的。 该函数可用于创建新的用户自定义小部件。 调用函数应将本地参数 @t{curcontext} 设置为 @t{:zle:}@var{widget}，创建本地参数 "
"@t{matched_words} 并调用 @t{match-words-by-style} (不带参数)。 返回时，@t{matched_words} 将被设置为一个包含以下元素的数组： (1）行的起始位置；（2）光标前的单词；（3）该单词与光标之间的任何非单词字符；（4）"
"光标位置上的任何非单词字符以及下一个单词前的任何剩余非单词字符，包括 @t{skip-chars} 样式指定的所有字符；（5）光标处或光标后的单词；（6）该单词后的任何非单词字符；（7）行的剩余部分。 其中任何一个元素都可能"
"是空字符串；调用函数应对此进行测试，以决定是否可以执行其功能。"

#. type: table
#: zsh.texi:38379
msgid ""
"If the variable @t{matched_words} is defined by the caller to @t{match-words-by-style} as an associative array (@t{local -A matched_words}), then the seven values given above should be retrieved from it "
"as elements named @t{start}, @t{word-before-cursor}, @t{ws-before-cursor}, @t{ws-after-cursor}, @t{word-after-cursor}, @t{ws-after-word}, and @t{end}.  In addition the element @t{is-word-start} is 1 if "
"the cursor is on the start of a word or subword, or on white space before it (the cases can be distinguished by testing the @t{ws-after-cursor} element) and 0 otherwise.  This form is recommended for "
"future compatibility."
msgstr ""
"如果 @t{match-words-by-style} 的调用者将变量 @t{matched_words} 定义为关联数组(@t{local -A matched_words})，那么上面给出的七个值应当从这个数组中获取，元素名为 @t{start}、@t{word-before-cursor}、@t{ws-"
"before-cursor}、@t{ws-after-cursor}、@t{word-after-cursor}、@t{ws-after-word} 和 @t{end} 。 此外，如果光标位于单词或子单词的起始位置，或位于单词或子单词之前的空白处（可通过测试 @t{ws-after-cursor} 元素来区"
"分这两种情况），则 @t{is-word-start} 元素的值为 1，否则为 0。 为了今后的兼容性，建议使用这种形式。"

#. type: table
#: zsh.texi:38383
msgid "It is possible to pass options with arguments to @t{match-words-by-style} to override the use of styles.  The options are:"
msgstr "可以将带参数的选项传递给 @t{match-words-by-style}，以覆盖样式的使用。 选项包括："

#. type: var{#1}
#: zsh.texi:38386
msgid "word-style"
msgstr "word-style"

#. type: var{#1}
#: zsh.texi:38388
msgid "skip-chars"
msgstr "skip-chars"

#. type: var{#1}
#: zsh.texi:38390
msgid "word-class"
msgstr "word-class"

#. type: var{#1}
#: zsh.texi:38392
msgid "word-chars"
msgstr "word-chars"

#. type: var{#1}
#: zsh.texi:38394
msgid "subword-range"
msgstr "subword-range"

#. type: table
#: zsh.texi:38399
msgid "For example, @t{match-words-by-style -w shell -c 0} may be used to extract the command argument around the cursor."
msgstr "例如， @t{match-words-by-style -w shell -c 0} 可用于提取光标周围的命令参数。"

#. type: table
#: zsh.texi:38404
msgid "The @t{word-context} style is implemented by the function @t{match-word-context}.  This should not usually need to be called directly."
msgstr "@t{word-context} 样式由函数 @t{match-word-context} 实现。 通常不需要直接调用该函数。"

#. type: t{#1}
#: zsh.texi:38405 zsh.texi:38406
#, no-wrap
msgid "bracketed-paste-magic"
msgstr "bracketed-paste-magic"

#. type: table
#: zsh.texi:38412
msgid ""
"The @t{bracketed-paste} widget (see @ref{Miscellaneous} in @ref{Standard Widgets})  inserts pasted text literally into the editor buffer rather than interpret it as keystrokes.  This disables some common "
"usages where the self-insert widget is replaced in order to accomplish some extra processing.  An example is the contributed @t{url-quote-magic} widget described below."
msgstr ""
"@t{bracketed-paste} 小部件（请参阅 @ref{标准小部件} 中的 @ref{杂项}）会将粘贴的文本字面值直接插入编辑器缓冲区，而不是将其解释为按键。 这就禁用了一些常见的用法，即替换自插入部件以完成一些额外的处理。 下面介"
"绍的 @t{url-quote-magic} 小部件就是一个例子。"

#. type: table
#: zsh.texi:38417
msgid ""
"The @t{bracketed-paste-magic} widget is meant to replace @t{bracketed-paste} with a wrapper that re-enables these self-insert actions, and other actions as selected by zstyles.  Therefore this widget is "
"installed with"
msgstr "@t{bracketed-paste-magic} 小部件旨在用一个封装器取代 @t{bracketed-paste}，重新启用这些 self-insert 操作以及 zstyles 选择的其他操作。 因此，安装该小部件时应"

#. type: example
#: zsh.texi:38421
#, no-wrap
msgid ""
"autoload -Uz bracketed-paste-magic\n"
"zle -N bracketed-paste bracketed-paste-magic\n"
msgstr ""
"autoload -Uz bracketed-paste-magic\n"
"zle -N bracketed-paste bracketed-paste-magic\n"

#. type: table
#: zsh.texi:38426
msgid "Other than enabling some widget processing, @t{bracketed-paste-magic} attempts to replicate @t{bracketed-paste} as faithfully as possible."
msgstr "除了启用一些小部件处理外，@t{bracketed-paste-magic} 尝试尽可能忠实地复制 @t{bracketed-paste}。"

#. type: table
#: zsh.texi:38430
msgid "The following zstyles may be set to control processing of pasted text.  All are looked up in the context `@t{:bracketed-paste-magic}'."
msgstr "可以设置以下 zstyles 来控制粘贴文本的处理。 所有样式均在上下文 `@t{:bracketed-paste-magic}' 中查找。"

#. type: t{#1}
#: zsh.texi:38433
#, no-wrap
msgid "active-widgets"
msgstr "active-widgets"

#. type: table
#: zsh.texi:38438
msgid ""
"A list of patterns matching widget names that should be activated during the paste.  All other key sequences are processed as self-insert-unmeta.  The default is `@t{self-*}' so any user-defined widgets "
"named with that prefix are active along with the builtin self-insert."
msgstr "与粘贴时应激活的小部件名称相匹配的模式列表。 所有其他按键序列都将作为 self-inert-unmeta 处理。 默认值为 `@t{self-*}' ，因此任何以该前缀命名的用户自定义小部件都会与内置的 self-insert 一起激活。"

#. type: table
#: zsh.texi:38444
msgid ""
"If this style is not set (explicitly deleted) or set to an empty value, no widgets are active and the pasted text is inserted literally.  If the value includes `@t{undefined-key}', any unknown sequences "
"are discarded from the pasted text."
msgstr "如果未设置此样式（显式删除）或设置为空值，则不会激活任何小部件，粘贴的文本将按字面意思插入。 如果值中包含 `@t{undefined-key}'，粘贴文本中的未知序列将被丢弃。"

#. type: t{#1}
#: zsh.texi:38445
#, no-wrap
msgid "inactive-keys"
msgstr "inactive-keys"

#. type: table
#: zsh.texi:38449
msgid ""
"The inverse of @t{active-widgets}, a list of key sequences that always use @t{self-insert-unmeta} even when bound to an active widget.  Note that this is a list of literal key sequences, not patterns."
msgstr "@t{active-widgets} 的反义词，是一个键序列列表，即使绑定到活动小部件上，也始终使用 @t{self-insert-unmeta}。 请注意，这是一个字面键序列列表，而不是模式。"

#. type: t{#1}
#: zsh.texi:38450
#, no-wrap
msgid "paste-init"
msgstr "paste-init"

#. type: table
#: zsh.texi:38458
msgid ""
"A list of function names, called in widget context (but not as widgets).  The functions are called in order until one of them returns a non-zero status.  The parameter `@t{PASTED}' contains the initial "
"state of the pasted text.  All other ZLE parameters such as `@t{BUFFER}' have their normal values and side-effects, and full history is available, so for example @t{paste-init} functions may move words "
"from @t{BUFFER} into @t{PASTED} to make those words visible to the @t{active-widgets}."
msgstr ""
"函数名称列表，在小部件上下文中调用（但不作为小部件）。 这些函数按顺序调用，直到其中一个函数返回非零状态。 参数 `@t{PASTED}' 包含粘贴文本的初始状态。 所有其他 ZLE 参数（如 `@t{BUFFER}' ）都有其正常值和副作"
"用，并且可以使用完整的历史记录，因此，例如， @t{paste-init} 函数可以将 @t{BUFFER} 中的字词移动到 @t{PASTED} 中，使 @t{active-widgets} 可以看到这些字词。"

#. type: table
#: zsh.texi:38462
msgid "A non-zero return from a @t{paste-init} function does @emph{not} prevent the paste itself from proceeding."
msgstr "如果 @t{paste-init} 函数的返回值为非 0，则 @emph{不会} 阻止粘贴本身继续进行。"

#. type: table
#: zsh.texi:38466
msgid "Loading @t{bracketed-paste-magic} defines @t{backward-extend-paste}, a helper function for use in @t{paste-init}."
msgstr "加载 @t{bracketed-paste-magic} 定义了 @t{backward-extend-paste}，这是一个在 @t{paste-init} 中使用的辅助函数。"

#. type: example
#: zsh.texi:38471
#, no-wrap
msgid ""
"zstyle :bracketed-paste-magic paste-init \\ \n"
"       backward-extend-paste\n"
msgstr ""
"zstyle :bracketed-paste-magic paste-init \\ \n"
"       backward-extend-paste\n"

#. type: table
#: zsh.texi:38478
msgid ""
"When a paste would insert into the middle of a word or append text to a word already on the line, @t{backward-extend-paste} moves the prefix from @t{LBUFFER} into @t{PASTED} so that the @t{active-widgets} "
"see the full word so far.  This may be useful with @t{url-quote-magic}."
msgstr ""
"当粘贴会插入到一个单词的中间或将文本附加到已在行上的单词时，@t{backward-extend-paste} 会将 @t{LBUFFER} 中的前缀移到 @t{PASTED} 中，这样 @t{active-widgets} 就能看到完整的单词了。 这与 @t{url-quote-magic} 一"
"起可能有用。"

#. type: t{#1}
#: zsh.texi:38479
#, no-wrap
msgid "paste-finish"
msgstr "paste-finish"

#. type: table
#: zsh.texi:38484
msgid ""
"Another list of function names called in order until one returns non-zero.  These functions are called @emph{after} the pasted text has been processed by the @t{active-widgets}, but @emph{before} it is "
"inserted into `@t{BUFFER}'.  ZLE parameters have their normal values and side-effects."
msgstr ""
"另一个按顺序调用的函数名列表，直到其中一个函数的返回值不为零。 在 @t{active-widgets} 处理完粘贴的文本 @emph{后}，但在将其插入 `@t{BUFFER}' @emph{之前}，@emph{after} 会调用这些函数。 ZLE 参数具有正常值和副"
"作用。"

#. type: table
#: zsh.texi:38488
msgid "A non-zero return from a @t{paste-finish} function does @emph{not} prevent the paste itself from proceeding."
msgstr "如果 @t{paste-finish} 函数的返回值非零，则 @emph{不会} 阻止粘贴本身继续进行。"

#. type: table
#: zsh.texi:38492
msgid "Loading @t{bracketed-paste-magic} also defines @t{quote-paste}, a helper function for use in @t{paste-finish}."
msgstr "加载 @t{bracketed-paste-magic} 时还定义了 @t{quote-paste}，这是一个用于 @t{paste-finish} 的辅助函数。"

#. type: example
#: zsh.texi:38499
#, no-wrap
msgid ""
"zstyle :bracketed-paste-magic paste-finish \\ \n"
"       quote-paste\n"
"zstyle :bracketed-paste-magic:finish quote-style \\ \n"
"       qqq\n"
msgstr ""
"zstyle :bracketed-paste-magic paste-finish \\ \n"
"       quote-paste\n"
"zstyle :bracketed-paste-magic:finish quote-style \\ \n"
"       qqq\n"

#. type: table
#: zsh.texi:38505
msgid "When the pasted text is inserted into @t{BUFFER}, it is quoted per the @t{quote-style} value.  To forcibly turn off the built-in numeric prefix quoting of @t{bracketed-paste}, use:"
msgstr "当粘贴的文本插入 @t{BUFFER} 时，会根据 @t{quote-style} 值进行加引号处理。 要强制关闭 @t{bracketed-paste} 的内置数字前缀引号，请使用:"

#. type: example
#: zsh.texi:38510
#, no-wrap
msgid ""
"zstyle :bracketed-paste-magic:finish quote-style \\ \n"
"       none\n"
msgstr ""
"zstyle :bracketed-paste-magic:finish quote-style \\ \n"
"       none\n"

#. type: table
#: zsh.texi:38520
msgid ""
"@emph{Important:} During @t{active-widgets} processing of the paste (after @t{paste-init} and before @t{paste-finish}), @t{BUFFER} starts empty and history is restricted, so cursor motions, etc., may not "
"pass outside of the pasted content.  Text assigned to @t{BUFFER} by the active widgets is copied back into @t{PASTED} before @t{paste-finish}."
msgstr ""
"@emph{Important:} 在 @t{active-widgets} 处理粘贴过程中（@t{paste-init} 之后、@t{paste-finish} 之前），@t{BUFFER} 开始为空，且历史记录受到限制，因此光标移动等操作可能不会超出粘贴内容的范围。 活动小部件分配"
"给 @t{BUFFER} 的文本会在 @t{paste-finish} 之前复制回 @t{PASTED} 中。"

#. type: t{#1}
#: zsh.texi:38521 zsh.texi:38522
#, no-wrap
msgid "copy-earlier-word"
msgstr "copy-earlier-word"

#. type: table
#: zsh.texi:38528
msgid ""
"This widget works like a combination of @t{insert-last-word} and @t{copy-prev-shell-word}.  Repeated invocations of the widget retrieve earlier words on the relevant history line.  With a numeric argument "
"@var{N}, insert the @var{N}th word from the history line; @var{N} may be negative to count from the end of the line."
msgstr ""
"该小部件的工作原理类似于 @t{insert-last-word} 和 @t{copy-prev-shell-word} 的组合。 重复调用该小部件可检索相关历史行中较早的字词。 通过数字参数 @var{N}，插入历史行中第 @var{N} 个字；@var{N} 可以是负数，从行"
"末开始计算。"

#. type: table
#: zsh.texi:38533
msgid "If @t{insert-last-word} has been used to retrieve the last word on a previous history line, repeated invocations will replace that word with earlier words from the same line."
msgstr "如果 @t{insert-last-word} 已被用于检索上一行历史记录中的最后一个单词，则重复调用时将用同一行中较早的单词替换该单词。"

#. type: table
#: zsh.texi:38539
msgid ""
"Otherwise, the widget applies to words on the line currently being edited.  The @t{widget} style can be set to the name of another widget that should be called to retrieve words.  This widget must accept "
"the same three arguments as @t{insert-last-word}."
msgstr "否则，小部件适用于当前正在编辑的行上的单词。 @t{widget} 样式可以设置为另一个小部件的名称，该小部件应被调用来获取单词。 该小部件必须接受与 @t{insert-last-word} 相同的三个参数。"

#. type: t{#1}
#: zsh.texi:38540 zsh.texi:38541
#, no-wrap
msgid "cycle-completion-positions"
msgstr "cycle-completion-positions"

#. type: table
#: zsh.texi:38549
msgid ""
"After inserting an unambiguous string into the command line, the new function based completion system may know about multiple places in this string where characters are missing or differ from at least one "
"of the possible matches.  It will then place the cursor on the position it considers to be the most interesting one, i.e. the one where one can disambiguate between as many matches as possible with as "
"little typing as possible."
msgstr ""
"在命令行中插入一个无歧义的字符串后，新的基于函数的补全系统可能会知道这个字符串中有多个地方缺少字符或至少与一个可能的匹配字符不同。 然后，系统会将光标放在它认为最有趣的位置上，即可以用尽可能少的键入在尽可能"
"多的匹配字符之间进行消歧的位置。"

#. type: table
#: zsh.texi:38554
msgid "This widget allows the cursor to be easily moved to the other interesting spots.  It can be invoked repeatedly to cycle between all positions reported by the completion system."
msgstr "通过这个小部件，可以轻松地将光标移动到其他感兴趣的位置。 可以反复调用它，在补全系统报告的所有位置之间循环。"

#. type: table
#: zsh.texi:38560
msgid ""
"This is another function which works like the @t{-match} functions described immediately above, i.e. using styles to decide the word boundaries.  However, it is not a replacement for any existing function."
msgstr "这是另一个函数，其工作原理与上文描述的 @t{-match} 函数类似，即使用样式来决定单词边界。 不过，它不能替代任何现有函数。"

#. type: table
#: zsh.texi:38567
msgid ""
"The basic behaviour is to delete the word around the cursor.  There is no numeric argument handling; only the single word around the cursor is considered.  If the widget contains the string @t{kill}, the "
"removed text will be placed in the cutbuffer for future yanking.  This can be obtained by defining @t{kill-whole-word-match} as follows:"
msgstr ""
"基本操作是删除光标周围的单词。 不处理数字参数；只考虑光标周围的单字。 如果小部件中包含字符串 @t{kill}，则删除的文本将被放入剪切缓冲区，以便将来提取。 这可以通过定义 @t{kill-whole-word-match} 来实现："

#. type: example
#: zsh.texi:38571
#, no-wrap
msgid "zle -N kill-whole-word-match delete-whole-word-match\n"
msgstr "zle -N kill-whole-word-match delete-whole-word-match\n"

#. type: table
#: zsh.texi:38575
msgid "and then binding the widget @t{kill-whole-word-match}."
msgstr "然后绑定小部件 @t{kill-whole-word-match}。"

#. type: tindex
#: zsh.texi:38576
#, no-wrap
msgid "down-line-or-beginning-search"
msgstr "down-line-or-beginning-search"

#. type: tindex
#: zsh.texi:38577
#, no-wrap
msgid "up-line-or-beginning-search"
msgstr "up-line-or-beginning-search"

#. type: item
#: zsh.texi:38578
#, no-wrap
msgid "@t{up-line-or-beginning-search}, @t{down-line-or-beginning-search}"
msgstr "@t{up-line-or-beginning-search}, @t{down-line-or-beginning-search}"

#. type: table
#: zsh.texi:38586
msgid ""
"These widgets are similar to the builtin functions @t{up-line-or-search} and @t{down-line-or-search}: if in a multiline buffer they move up or down within the buffer, otherwise they search for a history "
"line matching the start of the current line.  In this case, however, they search for a line which matches the current line up to the current cursor position, in the manner of @t{history-beginning-search-"
"backward} and @t{-forward}, rather than the first word on the line."
msgstr ""
"这些小部件类似于内置函数 @t{up-line-or-search} 和 @t{down-line-or-search}：如果在多行缓冲区内，它们会在缓冲区内向上或向下移动，否则它们会搜索与当前行起始位置相匹配的历史行。 不过，在这种情况下，它们会按照 "
"@t{history-beginning-search-backward} 和 @t{-forward} 的方式，搜索与当前行直至当前光标位置相匹配的行，而不是该行的第一个单词。"

#. type: table
#: zsh.texi:38590
msgid "Edit the command line using your visual editor, as in @t{ksh}."
msgstr "使用可视化编辑器编辑命令行，如在 @t{ksh}。"

#. type: example
#: zsh.texi:38594
#, no-wrap
msgid "bindkey -M vicmd v edit-command-line\n"
msgstr "bindkey -M vicmd v edit-command-line\n"

#. type: table
#: zsh.texi:38600
msgid "The editor to be used can also be specified using the @t{editor} style in the context of the widget. It is specified as an array of command and arguments:"
msgstr "也可以在小部件的上下文中使用 @t{editor} 样式指定要使用的编辑器。编辑器以命令和参数数组的形式指定："

#. type: example
#: zsh.texi:38604
#, no-wrap
msgid "zstyle :zle:edit-command-line editor gvim -f\n"
msgstr "zstyle :zle:edit-command-line editor gvim -f\n"

#. type: t{#1}
#: zsh.texi:38606 zsh.texi:38607
#, no-wrap
msgid "expand-absolute-path"
msgstr "expand-absolute-path"

#. type: table
#: zsh.texi:38611
msgid ""
"Expand the file name under the cursor to an absolute path, resolving symbolic links.  Where possible, the initial path segment is turned into a named directory or reference to a user's home directory."
msgstr "将光标下的文件名扩展为绝对路径，解析符号链接。 在可能的情况下，将开头路径段转换为命名目录或用户主目录的引用。"

#. type: tindex
#: zsh.texi:38612
#, no-wrap
msgid "history-beginning-search-backward-end"
msgstr "history-beginning-search-backward-end"

#. type: tindex
#: zsh.texi:38613
#, no-wrap
msgid "history-beginning-search-forward-end"
msgstr "history-beginning-search-forward-end"

#. type: t{#1}
#: zsh.texi:38614
#, no-wrap
msgid "history-search-end"
msgstr "history-search-end"

#. type: table
#: zsh.texi:38623
msgid ""
"This function implements the widgets @t{history-beginning-search-backward-end} and @t{history-beginning-search-forward-end}.  These commands work by first calling the corresponding builtin widget (see "
"@ref{History Control}) and then moving the cursor to the end of the line.  The original cursor position is remembered and restored before calling the builtin widget a second time, so that the same search "
"is repeated to look farther through the history."
msgstr ""
"该函数实现了小部件 @t{history-beginning-search-backward-end} 和 @t{history-beginning-search-forward-end}。 这些命令的工作方式是，首先调用相应的内置小部件（参见 @ref{历史控制}），然后将光标移动到行尾。 在第"
"二次调用内置小部件之前，光标的原始位置会被记住并恢复，这样就可以重复同样的搜索，在历史记录中查找更远的位置。"

#. type: table
#: zsh.texi:38627
msgid "Although you @t{autoload} only one function, the commands to use it are slightly different because it implements two widgets."
msgstr "虽然只 @t{autoload} 一个函数，但使用它的命令略有不同，因为它实现了两个小部件。"

#. type: example
#: zsh.texi:38636
#, no-wrap
msgid ""
"zle -N history-beginning-search-backward-end \\ \n"
"       history-search-end\n"
"zle -N history-beginning-search-forward-end \\ \n"
"       history-search-end\n"
"bindkey '\\e^P' history-beginning-search-backward-end\n"
"bindkey '\\e^N' history-beginning-search-forward-end\n"
msgstr ""
"zle -N history-beginning-search-backward-end \\ \n"
"       history-search-end\n"
"zle -N history-beginning-search-forward-end \\ \n"
"       history-search-end\n"
"bindkey '\\e^P' history-beginning-search-backward-end\n"
"bindkey '\\e^N' history-beginning-search-forward-end\n"

#. type: t{#1}
#: zsh.texi:38638 zsh.texi:38639
#, no-wrap
msgid "history-beginning-search-menu"
msgstr "history-beginning-search-menu"

#. type: table
#: zsh.texi:38647
msgid ""
"This function implements yet another form of history searching.  The text before the cursor is used to select lines from the history, as for @t{history-beginning-search-backward} except that all matches "
"are shown in a numbered menu.  Typing the appropriate digits inserts the full history line.  Note that leading zeroes must be typed (they are only shown when necessary for removing ambiguity).  The entire "
"history is searched; there is no distinction between forwards and backwards."
msgstr ""
"该函数实现了另一种形式的历史搜索。 光标前的文本用于从历史记录中选择行，与 @t{history-beginning-search-backward} 相同，但所有匹配行都显示在一个编号菜单中。 输入相应的数字可插入完整的历史行。 请注意，必须输"
"入前导零（只有在需要消除歧义时才会显示）。 整个历史记录都会被搜索；没有向前和向后之分。"

#. type: table
#: zsh.texi:38652
msgid "With a numeric argument, the search is not anchored to the start of the line; the string typed by the use may appear anywhere in the line in the history."
msgstr "使用数字参数时，搜索不固定在行的起始位置；用户键入的字符串可以出现在历史记录行中的任何位置。"

#. type: table
#: zsh.texi:38659
msgid ""
"If the widget name contains `@t{-end}' the cursor is moved to the end of the line inserted.  If the widget name contains `@t{-space}' any space in the text typed is treated as a wildcard and can match "
"anything (hence a leading space is equivalent to giving a numeric argument).  Both forms can be combined, for example:"
msgstr ""
"如果小部件名称中包含 `@t{-end}' ，光标就会移动到插入行的末尾。 如果小部件名称中包含 `@t{-space}' ，则输入文本中的任何空格都将被视为通配符，可以匹配任何内容（因此前导空格等同于给出一个数字参数）。 两种形式"
"可以结合使用，例如:"

#. type: example
#: zsh.texi:38664
#, no-wrap
msgid ""
"zle -N history-beginning-search-menu-space-end \\ \n"
"       history-beginning-search-menu\n"
msgstr ""
"zle -N history-beginning-search-menu-space-end \\ \n"
"       history-beginning-search-menu\n"

#. type: t{#1}
#: zsh.texi:38666 zsh.texi:38669
#, no-wrap
msgid "history-pattern-search"
msgstr "history-pattern-search"

#. type: tindex
#: zsh.texi:38667
#, no-wrap
msgid "history-pattern-search-backward"
msgstr "history-pattern-search-backward"

#. type: tindex
#: zsh.texi:38668
#, no-wrap
msgid "history-pattern-search-forward"
msgstr "history-pattern-search-forward"

#. type: table
#: zsh.texi:38677
msgid ""
"The function @t{history-pattern-search} implements widgets which prompt for a pattern with which to search the history backwards or forwards.  The pattern is in the usual zsh format, however the first "
"character may be @t{^} to anchor the search to the start of the line, and the last character may be @t{$} to anchor the search to the end of the line.  If the search was not anchored to the end of the "
"line the cursor is positioned just after the pattern found."
msgstr ""
"函数 @t{history-pattern-search} 实现了一个小部件，可提示以前向或后向搜索历史记录的模式。 模式采用常用的 zsh 格式，但第一个字符可以是 @t{^}，以便将搜索锚定到行的开始，最后一个字符可以是 @t{$}，以便将搜索锚"
"定到行的结束。 如果搜索没有锚定到行的末尾，光标就会定位在找到的模式之后。"

#. type: table
#: zsh.texi:38681
msgid "The commands to create bindable widgets are similar to those in the example immediately above:"
msgstr "创建可绑定小部件的命令与上面例子中的命令类似："

#. type: example
#: zsh.texi:38687
#, no-wrap
msgid ""
"autoload -U history-pattern-search\n"
"zle -N history-pattern-search-backward history-pattern-search\n"
"zle -N history-pattern-search-forward history-pattern-search\n"
msgstr ""
"autoload -U history-pattern-search\n"
"zle -N history-pattern-search-backward history-pattern-search\n"
"zle -N history-pattern-search-forward history-pattern-search\n"

#. type: t{#1}
#: zsh.texi:38689 zsh.texi:38691
#, no-wrap
msgid "incarg"
msgstr "incarg"

#. type: vindex
#: zsh.texi:38690
#, no-wrap
msgid "incarg, use of"
msgstr "incarg, use of"

#. type: table
#: zsh.texi:38698
msgid ""
"Typing the keystrokes for this widget with the cursor placed on or to the left of an integer causes that integer to be incremented by one.  With a numeric argument, the number is incremented by the amount "
"of the argument (decremented if the numeric argument is negative).  The shell parameter @t{incarg} may be set to change the default increment to something other than one."
msgstr ""
"在光标位于一个整数上或其左侧时输入该小部件的按键，会使该整数递增 1。 如果输入的是数字参数，则数字会按参数的大小递增（如果数字参数为负数，则数字会递减）。 可以设置 shell 参数 @t{incarg}，将默认增量改为 1 以"
"外的值。"

#. type: example
#: zsh.texi:38702
#, no-wrap
msgid "bindkey '^X+' incarg\n"
msgstr "bindkey '^X+' incarg\n"

#. type: t{#1}
#: zsh.texi:38704 zsh.texi:38705
#, no-wrap
msgid "incremental-complete-word"
msgstr "incremental-complete-word"

#. type: table
#: zsh.texi:38713
msgid ""
"This allows incremental completion of a word.  After starting this command, a list of completion choices can be shown after every character you type, which you can delete with @t{^H} or @t{DEL}.  Pressing "
"return accepts the completion so far and returns you to normal editing (that is, the command line is @emph{not} immediately executed).  You can hit @t{TAB} to do normal completion, @t{^G} to abort back to "
"the state when you started, and @t{^D} to list the matches."
msgstr ""
"这样就可以递增补全一个单词。 启动此命令后，每输入一个字符后都会显示一个补全选项列表，您可以用 @t{^H} 或 @t{DEL} 删除这些选项。 按回车键可接受到目前为止的补全，并返回正常编辑状态（即命令行 @emph{不会} 立即"
"执行）。 您可以按 @t{TAB} 进行正常补全，按 @t{^G} 终止返回开始时的状态，按 @t{^D} 列出匹配结果。"

#. type: table
#: zsh.texi:38716
msgid "This works only with the new function based completion system."
msgstr "这只适用于新的基于函数的补全系统。"

#. type: example
#: zsh.texi:38720
#, no-wrap
msgid "bindkey '^Xi' incremental-complete-word\n"
msgstr "bindkey '^Xi' incremental-complete-word\n"

#. type: table
#: zsh.texi:38732
msgid ""
"This function allows you to compose characters that don't appear on the keyboard to be inserted into the command line.  The command is followed by two keys corresponding to ASCII characters (there is no "
"prompt).  For accented characters, the two keys are a base character followed by a code for the accent, while for other special characters the two characters together form a mnemonic for the character to "
"be inserted.  The two-character codes are a subset of those given by RFC 1345 (see for example @t{@uref{http://www.faqs.org/rfcs/rfc1345.html}})."
msgstr ""
"使用该函数可以将键盘上没有的字符编辑插入命令行。 命令后面有两个与 ASCII 字符相对应的键（没有提示符）。 对于重音字符，这两个键是一个基本字符，后面是一个重音代码，而对于其他特殊字符，这两个字符共同构成要插入"
"字符的助记符。 双字符代码是 RFC 1345 提供的代码的子集（例如 @t{@uref{http://www.faqs.org/rfcs/rfc1345.html}} 中的例子）。"

#. type: table
#: zsh.texi:38740
msgid ""
"The function may optionally be followed by up to two characters which replace one or both of the characters read from the keyboard; if both characters are supplied, no input is read.  For example, "
"@t{insert-composed-char a:} can be used within a widget to insert an a with umlaut into the command line.  This has the advantages over use of a literal character that it is more portable."
msgstr ""
"函数后面可以选择最多两个字符，用来替换从键盘读取的一个或两个字符；如果两个字符都有，则不读取输入。 例如，@t{insert-composed-char a:} 可以在小部件中使用，在命令行中插入带元音的 a。 与使用字面字符相比，这种"
"方法的优点是更可移植。"

#. type: table
#: zsh.texi:38746
msgid ""
"For best results zsh should have been built with support for multibyte characters (configured with @t{--enable-multibyte}); however, the function works for the limited range of characters available in "
"single-byte character sets such as ISO-8859-1."
msgstr "为达到最佳效果，zsh 应编译为支持多字节字符（使用 @t{--enable-multibyte} 进行配置）；不过，该功能适用于 ISO-8859-1 等单字节字符集中的有限字符范围。"

#. type: table
#: zsh.texi:38753
msgid ""
"The character is converted into the local representation and inserted into the command line at the cursor position.  (The conversion is done within the shell, using whatever facilities the C library "
"provides.)  With a numeric argument, the character and its code are previewed in the status line"
msgstr "该字符被转换为本地表示法，并插入光标位置的命令行中。 (转换在 shell 中进行，使用 C 库提供的任何功能）。 对于数字参数，字符及其代码将在状态行中预览"

#. type: table
#: zsh.texi:38758
msgid "The function may be run outside zle in which case it prints the character (together with a newline) to standard output.  Input is still read from keystrokes."
msgstr "这个函数可以在zle之外运行，在这种情况下，它会将字符（连同换行符）打印到标准输出。输入仍然来自按键输入。"

#. type: table
#: zsh.texi:38762
msgid "See @t{insert-unicode-char} for an alternative way of inserting Unicode characters using their hexadecimal character number."
msgstr "请参阅 @t{insert-unicode-char}，了解使用十六进制字符编号插入 Unicode 字符的另一种方法。"

#. type: table
#: zsh.texi:38769
msgid ""
"The set of accented characters is reasonably complete up to Unicode character U+0180, the set of special characters less so.  However, it is very sporadic from that point.  Adding new characters is easy, "
"however; see the function @t{define-composed-chars}.  Please send any additions to @t{zsh-workers@@zsh.org}."
msgstr ""
"在 Unicode 字符 U+0180 之前，重音字符集相当完整，而特殊字符集则不那么完整。 不过，从那个位置起就非常零散了。 不过，添加新字符很容易，请参见函数 @t{define-composed-chars}。 如有任何添加，请发送至 @t{zsh-"
"workers@@zsh.org}。"

#. type: table
#: zsh.texi:38773
msgid "The codes for the second character when used to accent the first are as follows.  Note that not every character can take every accent."
msgstr "第二个字符与第一个字符重读时的代码如下。 请注意，并非每个字符都可以使用重音。"

#. type: table
#: zsh.texi:38776
msgid "Grave."
msgstr "重音符号（如 \"à\"）。"

#. type: t{#1}
#: zsh.texi:38776
#, no-wrap
msgid "'"
msgstr "'"

#. type: table
#: zsh.texi:38778
msgid "Acute."
msgstr "重音符号（如 \"á\"）。"

#. type: t{#1}
#: zsh.texi:38778
#, no-wrap
msgid ">"
msgstr ">"

#. type: table
#: zsh.texi:38780
msgid "Circumflex."
msgstr "圆周率。"

#. type: table
#: zsh.texi:38783
msgid "Tilde.  (This is not @t{~} as RFC 1345 does not assume that character is present on the keyboard.)"
msgstr "波浪符（如\"ñ\"）。 (这不是 @t{~}，因为 RFC 1345 并不假定键盘上存在该字符）。"

#. type: table
#: zsh.texi:38785
msgid "Macron.  (A horizontal bar over the base character.)"
msgstr " Macron（如\"ā\"）。(在基本字符上加一横杠）。"

#. type: t{#1}
#: zsh.texi:38785
#, no-wrap
msgid "("
msgstr "("

#. type: table
#: zsh.texi:38787
msgid "Breve.  (A shallow dish shape over the base character.)"
msgstr "Breve（如\"ă\"）。(一个浅盘形状的底座上的字符）。"

#. type: table
#: zsh.texi:38790
msgid "Dot above the base character, or in the case of @t{i} no dot, or in the case of @t{L} and @t{l} a centered dot."
msgstr "基本字符上方的点，或者 @t{i} 中没有点，或者 @t{L} 和 @t{l} 中居中的点。"

#. type: table
#: zsh.texi:38792
msgid "Diaeresis (Umlaut)."
msgstr "Umlaut，也称为 Diaeresis（两点）是一种放置在元音字母上方的双点符号，用于表示发音的变化或分隔两个相邻的元音。（如\"ä\")"

#. type: table
#: zsh.texi:38794
msgid "Cedilla."
msgstr "Cedilla（如\"ç\" ）。（放置在字符底部的小尾巴符号）"

#. type: table
#: zsh.texi:38796
msgid "Underline, however there are currently no underlined characters."
msgstr "下划线，但目前没有下划线字符。"

#. type: table
#: zsh.texi:38798
msgid "Stroke through the base character."
msgstr "笔画贯穿基本字符。"

#. type: t{#1}
#: zsh.texi:38798
#, no-wrap
msgid "\""
msgstr "\""

#. type: table
#: zsh.texi:38800
msgid "Double acute (only supported on a few letters)."
msgstr "Double acute 是一种放置在字符上方的双重尖音符号，用于表示某些语言中特定字母的发音变化。(如ő）"

#. type: t{#1}
#: zsh.texi:38800
#, no-wrap
msgid ";"
msgstr ";"

#. type: table
#: zsh.texi:38803
msgid "Ogonek.  (A little forward facing hook at the bottom right of the character.)"
msgstr "Ogonek 是一种放置在字符底部右侧的小型前向挂钩符号，看起来像一个向前弯曲的小钩子。（如\"ǫ\")"

#. type: t{#1}
#: zsh.texi:38803
#, no-wrap
msgid "<"
msgstr "<"

#. type: table
#: zsh.texi:38805
msgid "Caron.  (A little v over the letter.)"
msgstr "Caron，是一种放置在字符上方的小型折线符号，看起来像一个小 V 字母。(如\"č\")"

#. type: table
#: zsh.texi:38807
msgid "Circle over the base character."
msgstr "在基本字符上画圆圈。"

#. type: table
#: zsh.texi:38809
msgid "Hook over the base character."
msgstr "在基本字符上挂钩。"

#. type: t{#1}
#: zsh.texi:38809
#, no-wrap
msgid "9"
msgstr "9"

#. type: table
#: zsh.texi:38811
msgid "Horn over the base character."
msgstr "在基本字符上加 \"号角\"。"

#. type: table
#: zsh.texi:38820
msgid ""
"The most common characters from the Arabic, Cyrillic, Greek and Hebrew alphabets are available; consult RFC 1345 for the appropriate sequences.  In addition, a set of two letter codes not in RFC 1345 are "
"available for the double-width characters corresponding to ASCII characters from @t{!} to @t{~} (0x21 to 0x7e) by preceding the character with @t{^}, for example @t{^A} for a double-width @t{A}."
msgstr ""
"阿拉伯文、西里尔文、希腊文和希伯来文字母中最常见的字符均可使用；有关适当的序列，请查阅 RFC 1345。 此外，还有一组 RFC 1345 中没有的双字母代码，可用于与 ASCII 字符 @t{!} 至 @t{~} （0x21 至 0x7e）相对应的双倍"
"宽度字符，方法是在字符前加上 @t{^}，例如 @t{^A} 表示双倍宽度的 @t{A}。"

#. type: table
#: zsh.texi:38823
msgid "The following other two-character sequences are understood."
msgstr "还可以理解以下其他双字符序列。"

#. type: item
#: zsh.texi:38826
#, no-wrap
msgid "ASCII characters"
msgstr "ASCII 字符"

#. type: table
#: zsh.texi:38828
msgid "These are already present on most keyboards:"
msgstr "这些大多数键盘上都有："

#. type: t{#1}
#: zsh.texi:38829
#, no-wrap
msgid "<("
msgstr "<("

#. type: table
#: zsh.texi:38831
msgid "Left square bracket"
msgstr "左方括号"

#. type: t{#1}
#: zsh.texi:38831
#, no-wrap
msgid "//"
msgstr "//"

#. type: table
#: zsh.texi:38833
msgid "Backslash (solidus)"
msgstr "反斜线（实线）"

#. type: t{#1}
#: zsh.texi:38833
#, no-wrap
msgid ")>"
msgstr ")>"

#. type: table
#: zsh.texi:38835
msgid "Right square bracket"
msgstr "右方括号"

#. type: t{#1}
#: zsh.texi:38835
#, no-wrap
msgid "(!"
msgstr "(!"

#. type: table
#: zsh.texi:38837
msgid "Left brace (curly bracket)"
msgstr "左括号（大括号）"

#. type: table
#: zsh.texi:38839
msgid "Vertical bar (pipe symbol)"
msgstr "竖条（管道符号）"

#. type: t{#1}
#: zsh.texi:38839
#, no-wrap
msgid "!)"
msgstr "!)"

#. type: table
#: zsh.texi:38841
msgid "Right brace (curly bracket)"
msgstr "右括号（大括号）"

#. type: t{#1}
#: zsh.texi:38841
#, no-wrap
msgid "'?"
msgstr "'?"

#. type: table
#: zsh.texi:38843
msgid "Tilde"
msgstr "波浪号（ `~' ）"

#. type: item
#: zsh.texi:38845
#, no-wrap
msgid "Special letters"
msgstr "特殊字母"

#. type: table
#: zsh.texi:38847
msgid "Characters found in various variants of the Latin alphabet:"
msgstr "拉丁字母的各种变体中出现的字符："

#. type: t{#1}
#: zsh.texi:38848
#, no-wrap
msgid "ss"
msgstr "ss"

#. type: table
#: zsh.texi:38850
msgid "Eszett (scharfes S)"
msgstr "Eszett，又称为 \"scharfes S\"（尖的 S），是德语中的一种特殊字符"

#. type: item
#: zsh.texi:38850
#, no-wrap
msgid "@t{D-}, @t{d-}"
msgstr "@t{D-}, @t{d-}"

#. type: table
#: zsh.texi:38852
msgid "Eth"
msgstr "Eth（Ɖ）是国际音标和一些非英语文字中使用的一个字符，表示发音为浊齿擦音的辅音。"

#. type: item
#: zsh.texi:38852
#, no-wrap
msgid "@t{TH}, @t{th}"
msgstr "@t{TH}, @t{th}"

#. type: table
#: zsh.texi:38854
msgid "Thorn"
msgstr "Thorn（Þ，þ）是一种字母，最初出现在古英语和北欧语言中"

#. type: t{#1}
#: zsh.texi:38854
#, no-wrap
msgid "kk"
msgstr "kk"

#. type: table
#: zsh.texi:38856
msgid "Kra"
msgstr "Kra"

#. type: table
#: zsh.texi:38856 zsh.texi:38858
#, no-wrap
msgid "'n"
msgstr "'n"

#. type: item
#: zsh.texi:38858
#, no-wrap
msgid "@t{NG}, @t{ng}"
msgstr "@t{NG}, @t{ng}"

#. type: table
#: zsh.texi:38860
msgid "Ng"
msgstr "Ng"

#. type: item
#: zsh.texi:38860
#, no-wrap
msgid "@t{OI}, @t{oi}"
msgstr "@t{OI}, @t{oi}"

#. type: table
#: zsh.texi:38862
msgid "Oi"
msgstr "Oi"

#. type: table
#: zsh.texi:38862 zsh.texi:38864
#, no-wrap
msgid "yr"
msgstr "yr"

#. type: t{#1}
#: zsh.texi:38864
#, no-wrap
msgid "ED"
msgstr "ED"

#. type: table
#: zsh.texi:38866
msgid "ezh"
msgstr "ezh"

#. type: item
#: zsh.texi:38868
#, no-wrap
msgid "Currency symbols"
msgstr "货币符号"

#. type: t{#1}
#: zsh.texi:38870
#, no-wrap
msgid "Ct"
msgstr "Ct"

#. type: table
#: zsh.texi:38872
msgid "Cent"
msgstr "美分"

#. type: t{#1}
#: zsh.texi:38872
#, no-wrap
msgid "Pd"
msgstr "Pd"

#. type: table
#: zsh.texi:38874
msgid "Pound sterling (also lira and others)"
msgstr "英镑（也包括里拉和其他货币）"

#. type: t{#1}
#: zsh.texi:38874
#, no-wrap
msgid "Cu"
msgstr "Cu"

#. type: table
#: zsh.texi:38876
msgid "Currency"
msgstr "货币"

#. type: t{#1}
#: zsh.texi:38876
#, no-wrap
msgid "Ye"
msgstr "Ye"

#. type: table
#: zsh.texi:38878
msgid "Yen"
msgstr "日元"

#. type: t{#1}
#: zsh.texi:38878
#, no-wrap
msgid "Eu"
msgstr "Eu"

#. type: table
#: zsh.texi:38880
msgid "Euro (N.B. not in RFC 1345)"
msgstr "欧元（注：不在 RFC 1345 中）"

#. type: item
#: zsh.texi:38882
#, no-wrap
msgid "Punctuation characters"
msgstr "标点符号"

#. type: table
#: zsh.texi:38886
msgid "References to \"right\" quotes indicate the shape (like a 9 rather than 6)  rather than their grammatical use.  (For example, a \"right\" low double quote is used to open quotations in German.)"
msgstr "指右引号，表示引号的形状（如 9 而不是 6），而不是语法用法。 (例如，在德语中，右 低双引号用于开始引用）。"

#. type: t{#1}
#: zsh.texi:38887
#, no-wrap
msgid "!I"
msgstr "!I"

#. type: table
#: zsh.texi:38889
msgid "Inverted exclamation mark"
msgstr "倒置的感叹号"

#. type: t{#1}
#: zsh.texi:38889
#, no-wrap
msgid "BB"
msgstr "BB"

#. type: table
#: zsh.texi:38891
msgid "Broken vertical bar"
msgstr "断开的竖条"

#. type: t{#1}
#: zsh.texi:38891
#, no-wrap
msgid "SE"
msgstr "SE"

#. type: table
#: zsh.texi:38893
msgid "Section"
msgstr "部分"

#. type: t{#1}
#: zsh.texi:38893
#, no-wrap
msgid "Co"
msgstr "Co"

#. type: table
#: zsh.texi:38895
msgid "Copyright"
msgstr "版权"

#. type: table
#: zsh.texi:38897
msgid "Spanish feminine ordinal indicator"
msgstr "西班牙文阴性序号指示符"

#. type: t{#1}
#: zsh.texi:38897
#, no-wrap
msgid "<<"
msgstr "<<"

#. type: table
#: zsh.texi:38899
msgid "Left guillemet"
msgstr "左栅栏"

#. type: table
#: zsh.texi:38901
msgid "Soft hyphen"
msgstr "软连字符"

#. type: t{#1}
#: zsh.texi:38901
#, no-wrap
msgid "Rg"
msgstr "Rg"

#. type: table
#: zsh.texi:38903
msgid "Registered trade mark"
msgstr "注册商标"

#. type: t{#1}
#: zsh.texi:38903
#, no-wrap
msgid "PI"
msgstr "PI"

#. type: table
#: zsh.texi:38905
msgid "Pilcrow (paragraph)"
msgstr "Pilcrow（¶）是一个标点符号，通常表示段落的开头或分隔不同段落。"

#. type: table
#: zsh.texi:38907
msgid "Spanish masculine ordinal indicator"
msgstr "西班牙文阳性序号指示符"

#. type: t{#1}
#: zsh.texi:38907
#, no-wrap
msgid ">>"
msgstr ">>"

#. type: table
#: zsh.texi:38909
msgid "Right guillemet"
msgstr "右栅栏"

#. type: t{#1}
#: zsh.texi:38909
#, no-wrap
msgid "?I"
msgstr "?I"

#. type: table
#: zsh.texi:38911
msgid "Inverted question mark"
msgstr "倒置问号"

#. type: table
#: zsh.texi:38913
msgid "Hyphen"
msgstr "连字符"

#. type: table
#: zsh.texi:38915
msgid "En dash"
msgstr "En dash是一个连字符，长度通常等于所用字体的字母 \"n\" 的宽度"

#. type: table
#: zsh.texi:38917
msgid "Em dash"
msgstr "Em dash是一个长破折号，长度通常等于所用字体的字母 \"M\" 的宽度"

#. type: table
#: zsh.texi:38919
msgid "Horizontal bar"
msgstr "一种水平线条或横线"

#. type: t{#1}
#: zsh.texi:38919
#, no-wrap
msgid ":3"
msgstr ":3"

#. type: table
#: zsh.texi:38921
msgid "Vertical ellipsis"
msgstr "垂直省略号"

#. type: t{#1}
#: zsh.texi:38921
#, no-wrap
msgid ".3"
msgstr ".3"

#. type: table
#: zsh.texi:38923
msgid "Horizontal midline ellipsis"
msgstr "水平中线省略号"

#. type: t{#1}
#: zsh.texi:38923
#, no-wrap
msgid "!2"
msgstr "!2"

#. type: table
#: zsh.texi:38925
msgid "Double vertical line"
msgstr "双竖线"

#. type: t{#1}
#: zsh.texi:38925
#, no-wrap
msgid "=2"
msgstr "=2"

#. type: table
#: zsh.texi:38927
msgid "Double low line"
msgstr "双下划线"

#. type: t{#1}
#: zsh.texi:38927
#, no-wrap
msgid "'6"
msgstr "'6"

#. type: table
#: zsh.texi:38929
msgid "Left single quote"
msgstr "左单引号"

#. type: t{#1}
#: zsh.texi:38929
#, no-wrap
msgid "'9"
msgstr "'9"

#. type: table
#: zsh.texi:38931
msgid "Right single quote"
msgstr "右单引号"

#. type: t{#1}
#: zsh.texi:38931
#, no-wrap
msgid ".9"
msgstr ".9"

#. type: table
#: zsh.texi:38933
msgid "\"Right\" low quote"
msgstr "右低引"

#. type: t{#1}
#: zsh.texi:38933
#, no-wrap
msgid "9'"
msgstr "9'"

#. type: table
#: zsh.texi:38935
msgid "Reversed \"right\" quote"
msgstr "反右引号"

#. type: t{#1}
#: zsh.texi:38935
#, no-wrap
msgid "\"6"
msgstr "\"6"

#. type: table
#: zsh.texi:38937
msgid "Left double quote"
msgstr "左双引号"

#. type: t{#1}
#: zsh.texi:38937
#, no-wrap
msgid "\"9"
msgstr "\"9"

#. type: table
#: zsh.texi:38939
msgid "Right double quote"
msgstr "右双引号"

#. type: t{#1}
#: zsh.texi:38939
#, no-wrap
msgid ":9"
msgstr ":9"

#. type: table
#: zsh.texi:38941
msgid "\"Right\" low double quote"
msgstr "\"Right\" low double quote"

#. type: t{#1}
#: zsh.texi:38941
#, no-wrap
msgid "9\""
msgstr "9\""

#. type: table
#: zsh.texi:38943
msgid "Reversed \"right\" double quote"
msgstr "反右双引号"

#. type: t{#1}
#: zsh.texi:38943
#, no-wrap
msgid "/-"
msgstr "/-"

#. type: table
#: zsh.texi:38945
msgid "Dagger"
msgstr "一种印刷符号（†）"

#. type: t{#1}
#: zsh.texi:38945
#, no-wrap
msgid "/="
msgstr "/="

#. type: table
#: zsh.texi:38947
msgid "Double dagger"
msgstr "一种印刷符号（‡）"

#. type: item
#: zsh.texi:38949
#, no-wrap
msgid "Mathematical symbols"
msgstr "数学符号"

#. type: t{#1}
#: zsh.texi:38951
#, no-wrap
msgid "DG"
msgstr "DG"

#. type: table
#: zsh.texi:38953
msgid "Degree"
msgstr "度"

#. type: item
#: zsh.texi:38953
#, no-wrap
msgid "@t{-2}, @t{+-}, @t{-+}"
msgstr "@t{-2}, @t{+-}, @t{-+}"

#. type: table
#: zsh.texi:38955
msgid "- sign, +/- sign, -/+ sign"
msgstr "- sign, +/- sign, -/+ sign"

#. type: t{#1}
#: zsh.texi:38955
#, no-wrap
msgid "2S"
msgstr "2S"

#. type: table
#: zsh.texi:38957
msgid "Superscript 2"
msgstr "上标2"

#. type: t{#1}
#: zsh.texi:38957
#, no-wrap
msgid "3S"
msgstr "Superscript 2"

#. type: table
#: zsh.texi:38959
msgid "Superscript 3"
msgstr "上标3"

#. type: t{#1}
#: zsh.texi:38959
#, no-wrap
msgid "1S"
msgstr "1S"

#. type: table
#: zsh.texi:38961
msgid "Superscript 1"
msgstr "上标1"

#. type: t{#1}
#: zsh.texi:38961
#, no-wrap
msgid "My"
msgstr "My"

#. type: table
#: zsh.texi:38963
msgid "Micro"
msgstr "微"

#. type: t{#1}
#: zsh.texi:38963
#, no-wrap
msgid ".M"
msgstr ".M"

#. type: table
#: zsh.texi:38965
msgid "Middle dot"
msgstr "中点，\"·\"号"

#. type: t{#1}
#: zsh.texi:38965
#, no-wrap
msgid "14"
msgstr "14"

#. type: table
#: zsh.texi:38967
msgid "Quarter"
msgstr "刻"

#. type: t{#1}
#: zsh.texi:38967
#, no-wrap
msgid "12"
msgstr "12"

#. type: table
#: zsh.texi:38969
msgid "Half"
msgstr "半"

#. type: t{#1}
#: zsh.texi:38969
#, no-wrap
msgid "34"
msgstr "34"

#. type: table
#: zsh.texi:38971
msgid "Three quarters"
msgstr "3刻"

#. type: t{#1}
#: zsh.texi:38971
#, no-wrap
msgid "*X"
msgstr "*X"

#. type: table
#: zsh.texi:38973
msgid "Multiplication"
msgstr "乘号"

#. type: t{#1}
#: zsh.texi:38973
#, no-wrap
msgid "-:"
msgstr "-:"

#. type: table
#: zsh.texi:38975
msgid "Division"
msgstr "除号"

#. type: t{#1}
#: zsh.texi:38975
#, no-wrap
msgid "%0"
msgstr "%0"

#. type: table
#: zsh.texi:38977
msgid "Per mille"
msgstr "千分号"

#. type: item
#: zsh.texi:38977
#, no-wrap
msgid "@t{FA}, @t{TE}, @t{/0}"
msgstr "@t{FA}, @t{TE}, @t{/0}"

#. type: table
#: zsh.texi:38979
msgid "For all, there exists, empty set"
msgstr "对所有, 存在的, 空集"

#. type: item
#: zsh.texi:38979
#, no-wrap
msgid "@t{dP}, @t{DE}, @t{NB}"
msgstr "@t{dP}, @t{DE}, @t{NB}"

#. type: table
#: zsh.texi:38982
msgid "Partial derivative, delta (increment), del (nabla)"
msgstr "偏导数, delta（增量）, del（纳布拉）"

#. type: item
#: zsh.texi:38982
#, no-wrap
msgid "@t{(-}, @t{-)}"
msgstr "@t{(-}, @t{-)}"

#. type: table
#: zsh.texi:38984
msgid "Element of, contains"
msgstr "元素, 包含"

#. type: item
#: zsh.texi:38984
#, no-wrap
msgid "@t{*P}, @t{+Z}"
msgstr "@t{*P}, @t{+Z}"

#. type: table
#: zsh.texi:38986
msgid "Product, sum"
msgstr "产品, 总合"

#. type: item
#: zsh.texi:38986
#, no-wrap
msgid "@t{*-}, @t{Ob}, @t{Sb}"
msgstr "@t{*-}, @t{Ob}, @t{Sb}"

#. type: table
#: zsh.texi:38988
msgid "Asterisk, ring, bullet"
msgstr "星号, 圆环, 子弹"

#. type: item
#: zsh.texi:38988
#, no-wrap
msgid "@t{RT}, @t{0(}, @t{00}"
msgstr "@t{RT}, @t{0(}, @t{00}"

#. type: table
#: zsh.texi:38990
msgid "Root sign, proportional to, infinity"
msgstr "根号, 比例, 无穷大"

#. type: item
#: zsh.texi:38992
#, no-wrap
msgid "Other symbols"
msgstr "其它符号"

#. type: item
#: zsh.texi:38994
#, no-wrap
msgid "@t{cS}, @t{cH}, @t{cD}, @t{cC}"
msgstr "@t{cS}, @t{cH}, @t{cD}, @t{cC}"

#. type: table
#: zsh.texi:38997
msgid "Card suits: spades, hearts, diamonds, clubs"
msgstr "花色：黑桃, 红心, 方块, 梅花"

#. type: item
#: zsh.texi:38997
#, no-wrap
msgid "@t{Md}, @t{M8}, @t{M2}, @t{Mb}, @t{Mx}, @t{MX}"
msgstr "@t{Md}, @t{M8}, @t{M2}, @t{Mb}, @t{Mx}, @t{MX}"

#. type: table
#: zsh.texi:39001
msgid "Musical notation: crotchet (quarter note), quaver (eighth note), semiquavers (sixteenth notes), flag sign, natural sign, sharp sign"
msgstr "音乐符号：四分音符、八分音符、十六分音符、旗号、自然符号、升号符号"

#. type: item
#: zsh.texi:39001
#, no-wrap
msgid "@t{Fm}, @t{Ml}"
msgstr "@t{Fm}, @t{Ml}"

#. type: table
#: zsh.texi:39003
msgid "Female, male"
msgstr "女性, 男性"

#. type: item
#: zsh.texi:39005
#, no-wrap
msgid "Accents on their own"
msgstr "重音"

#. type: t{#1}
#: zsh.texi:39007
#, no-wrap
msgid "'>"
msgstr "'>"

#. type: table
#: zsh.texi:39009
msgid "Circumflex (same as caret, @t{^})"
msgstr "插入符号（与caret相同，@t{^}）"

#. type: t{#1}
#: zsh.texi:39009
#, no-wrap
msgid "'!"
msgstr "'!"

#. type: table
#: zsh.texi:39011
msgid "Grave (same as backtick, @t{`})"
msgstr "重音符号（与反引号相同，@t{`})"

#. type: t{#1}
#: zsh.texi:39011
#, no-wrap
msgid "',"
msgstr "',"

#. type: table
#: zsh.texi:39013
msgid "Cedilla"
msgstr "小尾巴符号Cedilla"

#. type: t{#1}
#: zsh.texi:39013
#, no-wrap
msgid "':"
msgstr "':"

#. type: table
#: zsh.texi:39015
msgid "Diaeresis (Umlaut)"
msgstr "分音符Diaeresis (Umlaut)"

#. type: t{#1}
#: zsh.texi:39015
#, no-wrap
msgid "'m"
msgstr "'m"

#. type: table
#: zsh.texi:39017
msgid "Macron"
msgstr "长音符（Macron）"

#. type: t{#1}
#: zsh.texi:39017
#, no-wrap
msgid "''"
msgstr "''"

#. type: table
#: zsh.texi:39019
msgid "Acute"
msgstr "尖音符Acute"

#. type: t{#1}
#: zsh.texi:39023 zsh.texi:39024
#, no-wrap
msgid "insert-files"
msgstr "insert-files"

#. type: table
#: zsh.texi:39028
msgid "This function allows you type a file pattern, and see the results of the expansion at each step.  When you hit return, all expansions are inserted into the command line."
msgstr "该函数允许您键入文件模式，并查看每一步的扩展结果。 按回车键后，所有扩展结果都会插入命令行。"

#. type: example
#: zsh.texi:39032
#, no-wrap
msgid "bindkey '^Xf' insert-files\n"
msgstr "bindkey '^Xf' insert-files\n"

#. type: t{#1}
#: zsh.texi:39034 zsh.texi:39035
#, no-wrap
msgid "insert-unicode-char"
msgstr "insert-unicode-char"

#. type: table
#: zsh.texi:39041
msgid ""
"When first executed, the user inputs a set of hexadecimal digits.  This is terminated with another call to @t{insert-unicode-char}.  The digits are then turned into the corresponding Unicode character.  "
"For example, if the widget is bound to @t{^XU}, the character sequence `@t{^XU 4 c ^XU}' inserts @t{L} (Unicode U+004c)."
msgstr ""
"首次执行时，用户输入一组十六进制数字。 最后再调用 @t{insert-unicode-char} 以终止。 然后，这些数字会被转换成相应的 Unicode 字符。 例如，如果小部件绑定到 @t{^XU}，则字符序列 `@t{^XU 4 c ^XU}' 会插入 @t{L}"
"（Unicode U+004c）。"

#. type: table
#: zsh.texi:39045
msgid "See @t{insert-composed-char} for a way of inserting characters using a two-character mnemonic."
msgstr "有关使用双字符助记符插入字符的方法，请参阅 @t{insert-composed-char}。"

#. type: tindex
#: zsh.texi:39046
#, no-wrap
msgid "narrow-to-region"
msgstr "narrow-to-region"

#. type: t{#1}
#: zsh.texi:39047 zsh.texi:39052
#, no-wrap
msgid "narrow-to-region-invisible"
msgstr "narrow-to-region-invisible"

#. type: item
#: zsh.texi:39049
#, no-wrap
msgid "@t{narrow-to-region }[ @t{-p} @var{pre} ] [ @t{-P} @var{post} ]"
msgstr "@t{narrow-to-region }[ @t{-p} @var{pre} ] [ @t{-P} @var{post} ]"

#. type: itemx
#: zsh.texi:39050
#, no-wrap
msgid "@t{@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ }[ @t{-S} @var{statepm} | @t{-R} @var{statepm} | [ @t{-l} @var{lbufvar} ] [ @t{-r} @var{rbufvar} ] ]"
msgstr "@t{@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ }[ @t{-S} @var{statepm} | @t{-R} @var{statepm} | [ @t{-l} @var{lbufvar} ] [ @t{-r} @var{rbufvar} ] ]"

#. type: itemx
#: zsh.texi:39051
#, no-wrap
msgid "@t{@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ }[ @t{-n} ] [ @var{start} @var{end} ]"
msgstr "@t{@ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ @ }[ @t{-n} ] [ @var{start} @var{end} ]"

#. type: table
#: zsh.texi:39055
msgid "Narrow the editable portion of the buffer to the region between the cursor and the mark, which may be in either order.  The region may not be empty."
msgstr "将缓冲区的可编辑部分缩小到光标和标记之间的区域，该区域可以是任一顺序。 该区域不能为空。"

#. type: table
#: zsh.texi:39062
msgid ""
"@t{narrow-to-region} may be used as a widget or called as a function from a user-defined widget; by default, the text outside the editable area remains visible.  A @t{recursive-edit} is performed and the "
"original widening status is then restored.  Various options and arguments are available when it is called as a function."
msgstr ""
"@t{narrow-to-region} 可以作为一个小部件使用，也可以作为用户定义的小部件中的函数调用；默认情况下，可编辑区域外的文字仍然可见。 执行 @t{recursive-edit} 后，将恢复原来的加宽状态。 以函数形式调用时，有多种选项"
"和参数可供选择。"

#. type: table
#: zsh.texi:39067
msgid "The options @t{-p} @var{pretext} and @t{-P} @var{posttext} may be used to replace the text before and after the display for the duration of the function; either or both may be an empty string."
msgstr "选项 @t{-p} @var{pretext} 和 @t{-P} @var{posttext} 可用于在函数执行期间替换显示前后的文本；任一选项或两个选项都可以是空字符串。"

#. type: table
#: zsh.texi:39072
msgid "If the option @t{-n} is also given, @var{pretext} or @var{posttext} will only be inserted if there is text before or after the region respectively which will be made invisible."
msgstr "如果同时给出选项 @t{-n}，@var{pretext} 或 @var{posttext} 将仅在区域之前或之后有文本时插入，而这些文本将被隐藏(区域内文本）。"

#. type: table
#: zsh.texi:39076
msgid "Two numeric arguments may be given which will be used instead of the cursor and mark positions."
msgstr "可以给出两个数字参数，它们将代替光标和标记位置。"

#. type: table
#: zsh.texi:39091
msgid ""
"The option @t{-S} @var{statepm} is used to narrow according to the other options while saving the original state in the parameter with name @var{statepm}, while the option @t{-R} @var{statepm} is used to "
"restore the state from the parameter; note in both cases the @emph{name} of the parameter is required.  In the second case, other options and arguments are irrelevant.  When this method is used, no "
"@t{recursive-edit} is performed; the calling widget should call this function with the option @t{-S}, perform its own editing on the command line or pass control to the user via `@t{zle recursive-edit}', "
"then call this function with the option @t{-R}.  The argument @var{statepm} must be a suitable name for an ordinary parameter, except that parameters beginning with the prefix @t{_ntr_} are reserved for "
"use within @t{narrow-to-region}.  Typically the parameter will be local to the calling function."
msgstr ""
"选项 @t{-S} @var{statepm} 用于根据其他选项缩小范围，同时将原始状态保存在名称为 @var{statepm} 的参数中，而选项 @t{-R} @var{statepm} 则用于从参数中恢复状态。而 @t{-R} 选项则用于从参数中恢复状态；请注意，这两"
"种情况下都需要使用参数的 @emph{name}。 在第二种情况下，其他选项和参数无关紧要。 使用此方法时，不执行 @t{recursive-edit} ；调用的小部件应使用选项 @t{-S} 调用此函数，在命令行上执行自己的编辑或通过 `@t{zle "
"recursive-edit}' 将控制权传递给用户，然后使用选项 @t{-R} 调用此函数。 参数 @var{statepm} 必须是普通参数的合适名称，但以 @t{_ntr_} 开头的参数被保留给 @t{narrow-to-region} 使用。 通常情况下，该参数是调用函数"
"的本地参数。"

#. type: table
#: zsh.texi:39098
msgid ""
"The options @t{-l} @var{lbufvar} and @t{-r} @var{rbufvar} may be used to specify parameters where the widget will store the resulting text from the operation.  The parameter @var{lbufvar} will contain "
"@t{LBUFFER} and @var{rbufvar} will contain @t{RBUFFER}.  Neither of these two options may be used with @t{-S} or @t{-R}."
msgstr ""
"选项 @t{-l} @var{lbufvar} 和 @t{-r} @var{rbufvar} 可用于指定参数，小部件将在其中存储操作产生的文本。 参数 @var{lbufvar} 将包含 @t{LBUFFER}，而 @var{rbufvar} 将包含 @t{RBUFFER}。 这两个选项都不能与 @t{-S} "
"或 @t{-R} 一起使用。"

#. type: table
#: zsh.texi:39103
msgid "@t{narrow-to-region-invisible} is a simple widget which calls @t{narrow-to-region} with arguments which replace any text outside the region with `@t{...}'.  It does not take any arguments."
msgstr "@t{narrow-to-region-invisible} 是一个简单的小部件，它调用带有参数的 @t{narrow-to-region}，用 `@t{...}' 替换区域外的任何文本。 它不需要任何参数。"

#. type: table
#: zsh.texi:39108
msgid ""
"The display is restored (and the widget returns) upon any zle command which would usually cause the line to be accepted or aborted.  Hence an additional such command is required to accept or abort the "
"current line."
msgstr "任何 zle 命令通常都会导致该行被接受或终止，此时显示会恢复（小部件会返回）。 因此，要接受或终止当前行，还需要额外的此类命令。"

#. type: table
#: zsh.texi:39112
msgid "The return status of both widgets is zero if the line was accepted, else non-zero."
msgstr "如果该行被接受，则两个小部件的返回状态都为 0，否则为非 0。"

#. type: table
#: zsh.texi:39115
msgid "Here is a trivial example of a widget using this feature."
msgstr "下面是一个使用该功能的小部件的微不足道的例子。"

#. type: example
#: zsh.texi:39121
#, no-wrap
msgid ""
"local state\n"
"narrow-to-region -p $'Editing restricted region\\n' \\ \n"
"  -P @value{dsq} -S state\n"
"zle recursive-edit\n"
"narrow-to-region -R state\n"
msgstr ""
"local state\n"
"narrow-to-region -p $'Editing restricted region\\n' \\ \n"
"  -P @value{dsq} -S state\n"
"zle recursive-edit\n"
"narrow-to-region -R state\n"

#. type: t{#1}
#: zsh.texi:39123 zsh.texi:39125
#, no-wrap
msgid "predict-on"
msgstr "predict-on"

#. type: t{#1}
#: zsh.texi:39124 zsh.texi:39156
#, no-wrap
msgid "predict-off"
msgstr "predict-off"

#. type: table
#: zsh.texi:39135
msgid ""
"This set of functions implements predictive typing using history search.  After @t{predict-on}, typing characters causes the editor to look backward in the history for the first line beginning with what "
"you have typed so far.  After @t{predict-off}, editing returns to normal for the line found.  In fact, you often don't even need to use @t{predict-off}, because if the line doesn't match something in the "
"history, adding a key performs standard completion, and then inserts itself if no completions were found.  However, editing in the middle of a line is liable to confuse prediction; see the @t{toggle} "
"style below."
msgstr ""
"这个函数集使用历史搜索实现预测键入。 在 @t{predict-on} 之后，键入字符会导致编辑器在历史记录中向后(backward)查找与迄今键入内容相同的第一行。 @t{predict-off}后，编辑器会恢复正常，查找到哪一行就编辑哪一行。 "
"事实上，很多时候甚至不需要使用 @t{predict-off}，因为如果该行与历史记录中的内容不匹配，添加键就会执行标准补全，如果没有找到补全，就会插入其本身。 不过，在行中间编辑可能会混淆预测；请参阅下面的 @t{toggle} 样"
"式。"

#. type: table
#: zsh.texi:39143
msgid ""
"With the function based completion system (which is needed for this), you should be able to type @t{TAB} at almost any point to advance the cursor to the next @value{dsbq}interesting@value{dsq} character "
"position (usually the end of the current word, but sometimes somewhere in the middle of the word).  And of course as soon as the entire line is what you want, you can accept with return, without needing "
"to move the cursor to the end first."
msgstr ""
"有了基于函数的补全系统（这是需要的），你应该可以在几乎任何地方输入 @t{TAB}，将光标推进到下一个 @value{dsbq}有趣的@value{dsq} 字符位置（通常是当前单词的末尾，但有时也会在单词中间的某个地方）。 当然，只要整"
"行都是您想要的，您就可以用回车接受，而无需先将光标移到末尾。"

#. type: table
#: zsh.texi:39147
msgid "The first time @t{predict-on} is used, it creates several additional widget functions:"
msgstr "首次使用 @t{predict-on} 时，会创建几个额外的小部件函数："

#. type: t{#1}
#: zsh.texi:39150
#, no-wrap
msgid "delete-backward-and-predict"
msgstr "delete-backward-and-predict"

#. type: table
#: zsh.texi:39153
msgid "Replaces the @t{backward-delete-char} widget.  You do not need to bind this yourself."
msgstr "替换 @t{backward-delete-char} 小部件。 您无需自行绑定。"

#. type: t{#1}
#: zsh.texi:39153
#, no-wrap
msgid "insert-and-predict"
msgstr "insert-and-predict"

#. type: table
#: zsh.texi:39156
msgid "Implements predictive typing by replacing the @t{self-insert} widget.  You do not need to bind this yourself."
msgstr "通过替换 @t{self-insert} 小部件实现预测键入。 您无需自行绑定。"

#. type: table
#: zsh.texi:39158
msgid "Turns off predictive typing."
msgstr "关闭预测键入功能。"

#. type: table
#: zsh.texi:39163
msgid "Although you @t{autoload} only the @t{predict-on} function, it is necessary to create a keybinding for @t{predict-off} as well."
msgstr "虽然只 @t{autoload} 了 @t{predict-on} 函数，但也有必要为 @t{predict-off} 创建一个按键绑定。"

#. type: example
#: zsh.texi:39170
#, no-wrap
msgid ""
"zle -N predict-on\n"
"zle -N predict-off\n"
"bindkey '^X^Z' predict-on\n"
"bindkey '^Z' predict-off\n"
msgstr ""
"zle -N predict-on\n"
"zle -N predict-off\n"
"bindkey '^X^Z' predict-on\n"
"bindkey '^Z' predict-off\n"

#. type: t{#1}
#: zsh.texi:39172 zsh.texi:39173
#, no-wrap
msgid "read-from-minibuffer"
msgstr "read-from-minibuffer"

#. type: table
#: zsh.texi:39183
msgid ""
"This is most useful when called as a function from inside a widget, but will work correctly as a widget in its own right.  It prompts for a value below the current command line; a value may be input using "
"all of the standard zle operations (and not merely the restricted set available when executing, for example, @t{execute-named-cmd}).  The value is then returned to the calling function in the parameter "
"@t{$REPLY} and the editing buffer restored to its previous state.  If the read was aborted by a keyboard break (typically @t{^G}), the function returns status 1 and @t{$REPLY} is not set."
msgstr ""
"当作为一个小部件内部的函数调用时最有用，但作为一个小部件本身也能正常工作。 它在当前命令行下方提示输入一个值；可以使用所有标准的 zle 操作（而不仅仅是在执行时所选的有限集合, 例如,@t{execute-named-cmd} ）输入"
"一个值。 然后，数值会通过参数 @t{$REPLY} 返回给调用函数，编辑缓冲区也会恢复到之前的状态。 如果键盘中断（通常为 @t{^G}）导致读取中止，函数将返回状态 1，且不设置 @t{$REPLY}。"

#. type: table
#: zsh.texi:39191
msgid ""
"If one argument is supplied to the function it is taken as a prompt, otherwise `@t{? }' is used.  If two arguments are supplied, they are the prompt and the initial value of @t{$LBUFFER}, and if a third "
"argument is given it is the initial value of @t{$RBUFFER}.  This provides a default value and starting cursor placement.  Upon return the entire buffer is the value of @t{$REPLY}."
msgstr ""
"如果为函数提供了一个参数，则将其作为提示符，否则使用 `@t{? }' 。 如果提供两个参数，它们分别是提示符和 @t{$LBUFFER} 的初始值，如果提供第三个参数，则是 @t{$RBUFFER} 的初始值。 这提供了默认值和光标的起始位"
"置。 返回时，整个缓冲区就是 @t{$REPLY} 的值。"

#. type: table
#: zsh.texi:39199
msgid ""
"One option is available: `@t{-k} @var{num}' specifies that @var{num} characters are to be read instead of a whole line.  The line editor is not invoked recursively in this case, so depending on the "
"terminal settings the input may not be visible, and only the input keys are placed in @t{$REPLY}, not the entire buffer.  Note that unlike the @t{read} builtin @var{num} must be given; there is no default."
msgstr ""
"有一个选项可用： `@t{-k} @var{num}' 指定读取 @var{num} 个字符而不是整行。 在这种情况下，行编辑器不会递归调用，因此根据终端设置，输入可能不可见，而且只有输入键被放入 @t{$REPLY}，而不是整个缓冲区。 需要注意"
"的是，与 @t{read} 内置函数不同的是，必须给出 @var{num}；没有默认值。"

#. type: table
#: zsh.texi:39204
msgid "The name is a slight misnomer, as in fact the shell's own minibuffer is not used.  Hence it is still possible to call @t{executed-named-cmd} and similar functions while reading a value."
msgstr "这个名字有点名不副实，因为事实上并没有使用 shell 自身的 minibuffer。 因此，在读取数值时，仍然可以调用 @t{executed-named-cmd} 和类似函数。"

#. type: tindex
#: zsh.texi:39205
#, no-wrap
msgid "replace-argument"
msgstr "replace-argument"

#. type: tindex
#: zsh.texi:39206
#, no-wrap
msgid "replace-argument-edit"
msgstr "replace-argument-edit"

#. type: item
#: zsh.texi:39207
#, no-wrap
msgid "@t{replace-argument}, @t{replace-argument-edit}"
msgstr "@t{replace-argument}, @t{replace-argument-edit}"

#. type: table
#: zsh.texi:39212
msgid ""
"The function @t{replace-argument} can be used to replace a command line argument in the current command line or, if the current command line is empty, in the last command line executed (the new command "
"line is not executed).  Arguments are as delimited by standard shell syntax,"
msgstr "函数 @t{replace-argument}可用于替换当前命令行中的命令行参数，如果当前命令行为空，则替换最后执行的命令行中的参数（新命令行不执行）。 参数按标准 shell 语法分隔、"

#. type: table
#: zsh.texi:39217
msgid "If a numeric argument is given, that specifies the argument to be replaced.  0 means the command name, as in history expansion.  A negative numeric argument counts backward from the last word."
msgstr "如果给出数字参数，则表示要替换的参数。 0 表示命令名称，如在历史扩展中。 负数参数从最后一个字开始倒数。"

#. type: table
#: zsh.texi:39221
msgid "If no numeric argument is given, the current argument is replaced; this is the last argument if the previous history line is being used."
msgstr "如果没有给出数字参数，则替换当前参数；如果使用的是上一行历史记录，则替换最后一个参数。"

#. type: table
#: zsh.texi:39224
msgid "The function prompts for a replacement argument."
msgstr "函数提示要求替换参数。"

#. type: table
#: zsh.texi:39227
msgid "If the widget contains the string @t{edit}, for example is defined as"
msgstr "如果小部件包含 @t{edit} 字符串，例如定义为"

#. type: example
#: zsh.texi:39231
#, no-wrap
msgid "zle -N replace-argument-edit replace-argument\n"
msgstr "zle -N replace-argument-edit replace-argument\n"

#. type: table
#: zsh.texi:39237
msgid "then the function presents the current value of the argument for editing, otherwise the editing buffer for the replacement is initially empty."
msgstr "则函数会显示参数的当前值供编辑，否则替换的编辑缓冲区初始为空。"

#. type: tindex
#: zsh.texi:39238
#, no-wrap
msgid "replace-string"
msgstr "replace-string"

#. type: tindex
#: zsh.texi:39239
#, no-wrap
msgid "replace-string-again"
msgstr "replace-string-again"

#. type: tindex
#: zsh.texi:39240
#, no-wrap
msgid "replace-pattern"
msgstr "replace-pattern"

#. type: itemx
#: zsh.texi:39242
#, no-wrap
msgid "@t{replace-string-again}, @t{replace-pattern-again}"
msgstr "@t{replace-string-again}, @t{replace-pattern-again}"

#. type: table
#: zsh.texi:39247
msgid ""
"The function @t{replace-string} implements three widgets.  If defined under the same name as the function, it prompts for two strings; the first (source) string will be replaced by the second everywhere "
"it occurs in the line editing buffer."
msgstr "函数 @t{replace-string} 实现了三个小部件。 如果与函数同名定义，它将提示两个字符串；第一个（源）字符串将在行编辑缓冲区中出现的任何地方被第二个字符串替换。"

#. type: table
#: zsh.texi:39261
msgid ""
"If the widget name contains the word `@t{pattern}', for example by defining the widget using the command `@t{zle -N replace-pattern replace-string}', then the matching is performed using zsh patterns.  "
"All zsh extended globbing patterns can be used in the source string; note that unlike filename generation the pattern does not need to match an entire word, nor do glob qualifiers have any effect.  In "
"addition, the replacement string can contain parameter or command substitutions.  Furthermore, a `@t{&}' in the replacement string will be replaced with the matched source string, and a backquoted digit "
"`@t{\\}@var{N}' will be replaced by the @var{N}th parenthesised expression matched.  The form `@t{\\@{}@var{N}@t{@}}' may be used to protect the digit from following digits."
msgstr ""
"如果小部件名称包含 `@t{pattern}'，例如使用命令 `@t{zle -N replace-pattern replace-string}' 定义小部件，那么匹配将使用 zsh 模式进行。 源字符串中可以使用所有 zsh 扩展的 globbing 模式；需要注意的是，与文件名"
"生成不同，模式不需要匹配整个单词，glob 限定符也没有任何作用。 此外，替换字符串可以包含参数或命令替换。 另外，替换字符串中的 `@t{&}' 将被替换为匹配的源字符串，反引号数字 `@t{\\}@var{N}' 将被替换为匹配的第 "
"@var{N} 个带括号的表达式。 可以使用 `@t{\\@{}@var{N}@t{@}}' 形式来保护数字不受后面数字的影响。"

#. type: table
#: zsh.texi:39268
msgid ""
"If the widget instead contains the word `@t{regex}' (or `@t{regexp}'), then the matching is performed using regular expressions, respecting the setting of the option @t{RE_MATCH_PCRE} (see the description "
"of the function @t{regexp-replace} below).  The special replacement facilities described above for pattern matching are available."
msgstr "如果小部件中包含 `@t{regex}' (或 `@t{regexp}')，则使用正则表达式进行匹配，并遵守选项 @t{RE_MATCH_PCRE} 的设置（参见下文对函数 @t{regexp-replace} 的描述）。 上述用于模式匹配的特殊替换功能也可以使用。"

#. type: table
#: zsh.texi:39276
msgid ""
"By default the previous source or replacement string will not be offered for editing.  However, this feature can be activated by setting the style @t{edit-previous} in the context @t{:zle:}@var{widget} "
"(for example, @t{:zle:replace-string}) to @t{true}.  In addition, a positive numeric argument forces the previous values to be offered, a negative or zero argument forces them not to be."
msgstr ""
"默认情况下，前一个源字符串或替换字符串不会提供给编辑。 不过，可以通过将上下文 @t{:zle:}@var{widget} （例如 @t{:zle:replace-string}）中的 @t{edit-previous} 样式设置为 @t{true}，来激活这一功能。 此外，正数参"
"数会强制提供前一个值，负数或零参数则不会。"

#. type: table
#: zsh.texi:39284
msgid ""
"The function @t{replace-string-again} can be used to repeat the previous replacement; no prompting is done.  As with @t{replace-string}, if the name of the widget contains the word `@t{pattern}' or "
"`@t{regex}', pattern or regular expression matching is performed, else a literal string replacement.  Note that the previous source and replacement text are the same whether pattern, regular expression or "
"string matching is used."
msgstr ""
"函数 @t{replace-string-again} 可用于重复之前的替换；不做提示。 与 @t{replace-string} 一样，如果小部件的名称包含 `@t{pattern}' 或 `@t{regex}'，则执行模式匹配或正则表达式匹配，否则执行字面字符串替换。 请注"
"意，无论使用模式匹配、正则表达式匹配还是字符串匹配，前面的源文本和替换文本都是一样的。"

#. type: table
#: zsh.texi:39290
msgid ""
"In addition, @t{replace-string} shows the previous replacement above the prompt, so long as there was one during the current session; if the source string is empty, that replacement will be repeated "
"without the widget prompting for a replacement string."
msgstr "此外，只要在当前会话期间有替换，@t{replace-string} 就会在提示符上方显示上一次的替换；如果源字符串为空，该替换将被重复，小部件不会替换字符串提示。"

#. type: table
#: zsh.texi:39293
msgid "For example, starting from the line:"
msgstr "例如，从这行开始"

#. type: example
#: zsh.texi:39297
#, no-wrap
msgid "print This line contains fan and fond\n"
msgstr "print This line contains fan and fond\n"

#. type: table
#: zsh.texi:39303
msgid "and invoking @t{replace-pattern} with the source string `@t{f(?)n}' and the replacement string `@t{c\\1r}' produces the not very useful line:"
msgstr "用源字符串 `@t{f(?)n}' 调用 @t{replace-pattern}，替换字符串为 `@t{c\\1r}' ，会产生一行不太有用的内容："

#. type: example
#: zsh.texi:39307
#, no-wrap
msgid "print This line contains car and cord\n"
msgstr "print This line contains car and cord\n"

#. type: table
#: zsh.texi:39314
msgid ""
"The range of the replacement string can be limited by using the @t{narrow-to-region-invisible} widget.  One limitation of the current version is that @t{undo} will cycle through changes to the replacement "
"and source strings before undoing the replacement itself."
msgstr "可以使用 @t{narrow-to-region-invisible} 小部件来限制替换字符串的范围。 当前版本的一个限制是，@t{undo} 在撤销替换之前，会循环浏览替换和源字符串的更改。"

#. type: t{#1}
#: zsh.texi:39315 zsh.texi:39316
#, no-wrap
msgid "send-invisible"
msgstr "send-invisible"

#. type: table
#: zsh.texi:39326
msgid ""
"This is similar to read-from-minibuffer in that it may be called as a function from a widget or as a widget of its own, and interactively reads input from the keyboard.  However, the input being typed is "
"concealed and a string of asterisks (`@t{*}') is shown instead.  The value is saved in the parameter @t{$INVISIBLE} to which a reference is inserted into the editing buffer at the restored cursor "
"position.  If the read was aborted by a keyboard break (typically @t{^G}) or another escape from editing such as @t{push-line}, @t{$INVISIBLE} is set to empty and the original buffer is restored unchanged."
msgstr ""
"它与 read-from-minibuffer 类似，可以作为一个小部件中的函数或小部件本身来调用，并以交互方式读取键盘上的输入。 不过，输入的内容会被隐藏，取而代之的是显示一串星号（`@t{*}'）。 该值将保存在参数 @t{$INVISIBLE} "
"中，并在恢复的光标位置将其引用插入编辑缓冲区。 如果由于键盘中断（通常为 @t{^G}）或其他退出编辑的操作（如 @t{push-line}）而中止了读取，@t{$INVISIBLE} 将被设置为空，并恢复原始缓冲区，保持不变。"

#. type: table
#: zsh.texi:39334
msgid ""
"If one argument is supplied to the function it is taken as a prompt, otherwise `@t{Non-echoed text: }' is used (as in emacs).  If a second and third argument are supplied they are used to begin and end "
"the reference to @t{$INVISIBLE} that is inserted into the buffer.  The default is to open with @t{$@{}, then @t{INVISIBLE}, and close with @t{@}}, but many other effects are possible."
msgstr ""
"如果为函数提供了一个参数，则将其作为提示符，否则使用`@t{Non-echoed text: }' （与 emacs 中相同）。 如果提供了第二个和第三个参数，它们将用于开始和结束插入缓冲区的 @t{$INVISIBLE} 引用。 默认是以 @t{$@{} 开"
"始，然后是 @t{INVISIBLE}，最后用 @t{@}} 关闭，但也可以实现其他多种效果。"

#. type: t{#1}
#: zsh.texi:39335 zsh.texi:39336
#, no-wrap
msgid "smart-insert-last-word"
msgstr "smart-insert-last-word"

#. type: table
#: zsh.texi:39338
msgid "This function may replace the @t{insert-last-word} widget, like so:"
msgstr "这个函数可以替代 @t{insert-last-word} 小部件，就像这样："

#. type: example
#: zsh.texi:39342
#, no-wrap
msgid "zle -N insert-last-word smart-insert-last-word\n"
msgstr "zle -N insert-last-word smart-insert-last-word\n"

#. type: table
#: zsh.texi:39348
msgid ""
"With a numeric argument, or when passed command line arguments in a call from another widget, it behaves like @t{insert-last-word}, except that words in comments are ignored when @t{INTERACTIVE_COMMENTS} "
"is set."
msgstr "如果使用数字参数，或在调用其他小部件时传递命令行参数，其行为与 @t{insert-last-word} 类似，但如果设置了 @t{INTERACTIVE_COMMENTS}，注释中的单词将被忽略。"

#. type: table
#: zsh.texi:39357
msgid ""
"Otherwise, the rightmost @value{dsbq}interesting@value{dsq} word from the previous command is found and inserted.  The default definition of @value{dsbq}interesting@value{dsq} is that the word contains at "
"least one alphabetic character, slash, or backslash.  This definition may be overridden by use of the @t{match} style.  The context used to look up the style is the widget name, so usually the context is "
"@t{:insert-last-word}.  However, you can bind this function to different widgets to use different patterns:"
msgstr ""
"否则，将查找并插入上一条命令中最右边的 @value{dsbq}interesting@value{dsq} 字词。 @value{dsbq}interesting@value{dsq} 的默认定义是，单词至少包含一个字母、斜线或反斜线字符。 使用 @t{match} 样式可以覆盖这一定"
"义。 用于查找样式的上下文是小部件名称，因此上下文通常是 @t{:insert-last-word}。 不过，您可以将此函数绑定到不同的小部件，以使用不同的模式："

#. type: example
#: zsh.texi:39363
#, no-wrap
msgid ""
"zle -N insert-last-assignment smart-insert-last-word\n"
"zstyle :insert-last-assignment match '[[:alpha:]][][[:alnum:]]#=*'\n"
"bindkey '\\e=' insert-last-assignment\n"
msgstr ""
"zle -N insert-last-assignment smart-insert-last-word\n"
"zstyle :insert-last-assignment match '[[:alpha:]][][[:alnum:]]#=*'\n"
"bindkey '\\e=' insert-last-assignment\n"

#. type: table
#: zsh.texi:39370
msgid ""
"If no interesting word is found and the @t{auto-previous} style is set to a true value, the search continues upward through the history.  When @t{auto-previous} is unset or false (the default), the widget "
"must be invoked repeatedly in order to search earlier history lines."
msgstr "如果未找到感兴趣的单词，且 @t{auto-previous} 样式设置为 true 值，则搜索将继续在历史中向上进行。 如果 @t{auto-previous} 未设置或设置为 false（默认值），则必须反复调用小部件才能搜索到更早的历史行。"

#. type: t{#1}
#: zsh.texi:39371 zsh.texi:39372
#, no-wrap
msgid "transpose-lines"
msgstr "transpose-lines"

#. type: table
#: zsh.texi:39376
msgid "Only useful with a multi-line editing buffer; the lines here are lines within the current on-screen buffer, not history lines.  The effect is similar to the function of the same name in Emacs."
msgstr "仅对多行编辑缓冲区有用；此处的行是当前屏幕缓冲区内的行，而不是历史行。 其效果类似于 Emacs 中的同名函数。"

#. type: table
#: zsh.texi:39382
msgid ""
"Transpose the current line with the previous line and move the cursor to the start of the next line.  Repeating this (which can be done by providing a positive numeric argument) has the effect of moving "
"the line above the cursor down by a number of lines."
msgstr "将当前行与上一行平移，并将光标移到下一行的开始位置。 重复上述操作（可以通过提供一个正数参数来实现）的效果是将光标上方的行向下移动若干行。"

#. type: table
#: zsh.texi:39389
msgid ""
"With a negative numeric argument, requires two lines above the cursor.  These two lines are transposed and the cursor moved to the start of the previous line.  Using a numeric argument less than -1 has "
"the effect of moving the line above the cursor up by minus that number of lines."
msgstr "如果参数为负数，则需要在光标上方的两行。 这两行将被移位，光标将移至上一行的起始位置。 使用小于-1 的数字参数的效果是将光标上方的行向上移动减去该数的行数。"

#. type: t{#1}
#: zsh.texi:39390 zsh.texi:39391
#, no-wrap
msgid "url-quote-magic"
msgstr "url-quote-magic"

#. type: table
#: zsh.texi:39397
msgid ""
"This widget replaces the built-in @t{self-insert} to make it easier to type URLs as command line arguments.  As you type, the input character is analyzed and, if it may need quoting, the current word is "
"checked for a URI scheme.  If one is found and the current word is not already in quotes, a backslash is inserted before the input character."
msgstr ""
"这个小部件取代了内置的 @t{self-insert}，使输入 URL 作为命令行参数变得更容易。 输入时，系统会分析输入字符，如果需要加引号，则会检查当前单词是否包含 URI 方案。 如果发现有URI方案，且当前单词尚未加引号，则会在"
"输入字符前插入反斜杠。"

#. type: table
#: zsh.texi:39400
msgid "Styles to control quoting behavior:"
msgstr "控制引号行为的样式："

#. type: t{#1}
#: zsh.texi:39403
#, no-wrap
msgid "url-metas"
msgstr "url-metas"

#. type: table
#: zsh.texi:39411
msgid ""
"This style is looked up in the context `@t{:url-quote-magic:}@var{scheme}' (where @var{scheme} is that of the current URL, e.g. \"@t{ftp}\").  The value is a string listing the characters to be treated as "
"globbing metacharacters when appearing in a URL using that scheme.  The default is to quote all zsh extended globbing characters, excluding '@t{<}' and '@t{>}' but including braces (as in brace "
"expansion).  See also @t{url-seps}."
msgstr ""
"该样式在上下文`@t{:url-quote-magic:}@var{scheme}' 中查找（其中 @var{scheme} 是当前 URL 的模式，例如\"@t{ftp}\"）。 值是一个字符串，其中列出了在使用该模式的 URL 中出现时应作为 globbing 元字符处理的字符。 默"
"认引用(quote)所有 zsh 扩展 globbing 字符，不包括 '@t{<}' 和 '@t{>}' ，但包括大括号（如大括号扩展）。 另请参阅 @t{url-seps}。"

#. type: t{#1}
#: zsh.texi:39412
#, no-wrap
msgid "url-seps"
msgstr "url-seps"

#. type: table
#: zsh.texi:39418
msgid ""
"Like @t{url-metas}, but lists characters that should be considered command separators, redirections, history references, etc.  The default is to quote the standard set of shell separators, excluding those "
"that overlap with the extended globbing characters, but including '@t{<}' and '@t{>}' and the first character of @t{$histchars}."
msgstr ""
"与 @t{url-metas} 类似，但列出了应视为命令分隔符、重定向、历史引用等的字符。 默认引用标准的 shell 分隔符集，不包括与扩展 globbing 字符重叠的字符，但包括 '@t{<}' 和 '@t{>}' 以及 @t{$histchars} 的第一个字符。"

#. type: t{#1}
#: zsh.texi:39419
#, no-wrap
msgid "url-globbers"
msgstr "url-globbers"

#. type: table
#: zsh.texi:39430
msgid ""
"This style is looked up in the context `@t{:url-quote-magic}'.  The values form a list of command names that are expected to do their own globbing on the URL string.  This implies that they are aliased to "
"use the `@t{noglob}' modifier.  When the first word on the line matches one of the values @emph{and} the URL refers to a local file (see @t{url-local-schema}), only the @t{url-seps} characters are quoted; "
"the @t{url-metas} are left alone, allowing them to affect command-line parsing, completion, etc.  The default values are a literal `@t{noglob}' plus (when the @t{zsh/parameter} module is available) any "
"commands aliased to the helper function `@t{urlglobber}' or its alias `@t{globurl}'."
msgstr ""
"该样式在上下文 `@t{:url-quote-magic}' 中查找。 这些值构成了一个命令名称列表，这些命令名称应自行对 URL 字符串进行 globbing。 这意味着它们被别名为使用 `@t{noglob}' 修饰符。 当一行中的第一个单词与这些值之一匹"
"配, @emph{并且} URL 指向本地文件（参见 @t{url-local-schema}），只有 @t{url-seps} 字符会被加引号；而 @t{url-metas} 则不会被加引，允许它们影响命令行解析、补全等。 默认值是字面意义上的`@t{noglob}' 加上（当 "
"@t{zsh/parameter} 模块可用时）别名到辅助函数 `@t{urlglobber}' 或其别名 `@t{globurl}' 的所有命令。"

#. type: t{#1}
#: zsh.texi:39431
#, no-wrap
msgid "url-local-schema"
msgstr "url-local-schema"

#. type: table
#: zsh.texi:39438
msgid ""
"This style is always looked up in the context `@t{:urlglobber}', even though it is used by both url-quote-magic and urlglobber.  The values form a list of URI schema that should be treated as referring to "
"local files by their real local path names, as opposed to files which are specified relative to a web-server-defined document root.  The defaults are \"@t{ftp}\" and \"@t{file}\"."
msgstr ""
"尽管 url-quote-magic 和 urlglobber 都使用这种样式，但它总是在上下文 `@t{:urlglobber}' 中查找。 这些值构成了一个 URI 模式(schema)列表，这些模式应被视为是指向本地文件的真实本地路径名，而不是指相对于网络服务"
"器定义的文档根目录的文件。 默认值为 \"@t{ftp}\" 和 \"@t{file}\"。"

#. type: t{#1}
#: zsh.texi:39439
#, no-wrap
msgid "url-other-schema"
msgstr "url-other-schema"

#. type: table
#: zsh.texi:39447
msgid ""
"Like @t{url-local-schema}, but lists all other URI schema upon which @t{urlglobber} and @t{url-quote-magic} should act.  If the URI on the command line does not have a scheme appearing either in this list "
"or in @t{url-local-schema}, it is not magically quoted.  The default values are \"@t{http}\", \"@t{https}\", and \"@t{ftp}\".  When a scheme appears both here and in @t{url-local-schema}, it is quoted "
"differently depending on whether the command name appears in @t{url-globbers}."
msgstr ""
"类似于 @t{url-local-schema}，但列出了 @t{urlglobber} 和 @t{url-quote-magic} 应执行的所有其他 URI 模式(schema)。 如果命令行中的 URI 模式没有出现在该列表或 @t{url-local-schema} 中，则不会被神奇地加引号。 默"
"认值为\"@t{http}\"、\"@t{https}\"和\"@t{ftp}\"。 当某一模式同时出现在此处和 @t{url-local-schema} 中时，将根据命令名称是否出现在 @t{url-globbers} 中，以不同方式加引号。"

#. type: table
#: zsh.texi:39455
msgid ""
"Loading @t{url-quote-magic} also defines a helper function `@t{urlglobber}' and aliases `@t{globurl}' to `@t{noglob urlglobber}'.  This function takes a local URL apart, attempts to pattern-match the "
"local file portion of the URL path, and then puts the results back into URL format again."
msgstr ""
"加载 @t{url-quote-magic} 还定义了一个辅助函数 `@t{urlglobber}' ，并将 `@t{globurl}' 别名为 `@t{noglob urlglobber}'。 该函数拆分本地 URL，尝试对 URL 路径中的本地文件部分进行模式匹配，然后将结果重新放回 URL "
"格式。"

#. type: t{#1}
#: zsh.texi:39456 zsh.texi:39457
#, no-wrap
msgid "vi-pipe"
msgstr "vi-pipe"

#. type: table
#: zsh.texi:39463
msgid ""
"This function reads a movement command from the keyboard and then prompts for an external command. The part of the buffer covered by the movement is piped to the external command and then replaced by the "
"command's output. If the movement command is bound to vi-pipe, the current line is used."
msgstr "此函数从键盘读取移动命令，然后提示外部命令。移动所覆盖的缓冲区部分被管道输送到外部命令，然后被命令的输出所取代。如果移动命令与 vi- 绑定，则使用当前行。"

#. type: table
#: zsh.texi:39467
msgid "The function serves as an example for reading a vi movement command from within a user-defined widget."
msgstr "该函数作为从用户定义的小部件中读取 vi 移动命令的示例。"

#. type: table
#: zsh.texi:39475
msgid ""
"This function is a drop-in replacement for the builtin widget @t{which-command}.  It has enhanced behaviour, in that it correctly detects whether or not the command word needs to be expanded as an alias; "
"if so, it continues tracing the command word from the expanded alias until it reaches the command that will be executed."
msgstr "该函数可直接替换内置小部件 @t{which-command}。 它的功能有所增强，能正确检测命令字是否需要扩展为别名；如果需要，则会从扩展后的别名继续追踪命令字，直到找到要执行的命令。"

#. type: table
#: zsh.texi:39480
msgid ""
"The style @t{whence} is available in the context @t{:zle:$WIDGET}; this may be set to an array to give the command and options that will be used to investigate the command word found.  The default is "
"@t{whence -c}."
msgstr "@t{whence} 样式在上下文 @t{:zle:$WIDGET} 中可用；可将其设置为数组，以给出用于调查找到的命令字的命令和选项。 默认值为 @t{whence -c}。"

#. type: t{#1}
#: zsh.texi:39481 zsh.texi:39482
#, no-wrap
msgid "zcalc-auto-insert"
msgstr "zcalc-auto-insert"

#. type: table
#: zsh.texi:39493
msgid ""
"This function is useful together with the @t{zcalc} function described in @ref{Mathematical Functions}.  It should be bound to a key representing a binary operator such as `@t{+}', `@t{-}', `@t{*}' or "
"`@t{/}'.  When running in zcalc, if the key occurs at the start of the line or immediately following an open parenthesis, the text @t{\"ans \"} is inserted before the representation of the key itself.  "
"This allows easy use of the answer from the previous calculation in the current line.  The text to be inserted before the symbol typed can be modified by setting the variable @t{ZCALC_AUTO_INSERT_PREFIX}."
msgstr ""
"该函数与 @ref{数学函数} 中描述的 @t{zcalc} 函数一起使用很有用。 它应该绑定到一个代表二元运算符的键上，例如 `@t{+}', `@t{-}', `@t{*}' 或  `@t{/}' 。 在 zcalc 中运行时，如果关键字出现在行的开头或紧跟在开括号"
"之后，则在关键字本身的表示之前插入文本 @t{\"ans\"}。 这样可以方便地在当前行中使用前一个计算的答案。 输入符号前插入的文本可以通过设置变量 @t{ZCALC_AUTO_INSERT_PREFIX} 进行修改。"

#. type: table
#: zsh.texi:39497
msgid "Hence, for example, typing `@t{+12}' followed by return adds 12 to the previous result."
msgstr "因此，举例来说，输入 `@t{+12}'，然后回车，就会在前面的结果上加上 12。"

#. type: table
#: zsh.texi:39501
msgid "If zcalc is in RPN mode (@t{-r} option) the effect of this binding is automatically suppressed as operators alone on a line are meaningful."
msgstr "如果 zcalc 处于 RPN 模式（@t{-r} 选项），该绑定的效果将被自动抑制，因为一行中单独的运算符是有意义的。"

#. type: table
#: zsh.texi:39504
msgid "When not in zcalc, the key simply inserts the symbol itself."
msgstr "当不在 zcalc 中时，按键只是插入符号本身。"

#. type: Plain text
#: zsh.texi:39516
msgid "These functions are useful in constructing widgets.  They should be loaded with `@t{autoload -U} @var{function}' and called as indicated from user-defined widgets."
msgstr "这些函数在构建小部件时非常有用。 应使用 `@t{autoload -U} @var{function}' 加载这些函数，并根据用户自定义 widget 的指示调用它们。"

#. type: t{#1}
#: zsh.texi:39519 zsh.texi:39520
#, no-wrap
msgid "split-shell-arguments"
msgstr "split-shell-arguments"

#. type: table
#: zsh.texi:39530
msgid ""
"This function splits the line currently being edited into shell arguments and whitespace.  The result is stored in the array @t{reply}.  The array contains all the parts of the line in order, starting "
"with any whitespace before the first argument, and finishing with any whitespace after the last argument.  Hence (so long as the option @t{KSH_ARRAYS} is not set)  whitespace is given by odd indices in "
"the array and arguments by even indices.  Note that no stripping of quotes is done; joining together all the elements of @t{reply} in order is guaranteed to produce the original line."
msgstr ""
"该函数将当前正在编辑的行分割为 shell 参数和空白。 结果存储在数组 @t{reply} 中。 该数组按顺序包含该行的所有部分，从第一个参数之前的空白处开始，到最后一个参数之后的空白处结束。 因此（只要未设置 "
"@t{KSH_ARRAYS} 选项），数组中的奇数索引表示空白，偶数索引表示参数。 需要注意的是，数组中的引号不会被删除；将 @t{reply} 中的所有元素按顺序连接在一起，可以保证产生原始行。"

#. type: table
#: zsh.texi:39536
msgid ""
"The parameter @t{REPLY} is set to the index of the word in @t{reply} which contains the character after the cursor, where the first element has index 1.  The parameter @t{REPLY2} is set to the index of "
"the character under the cursor in that word, where the first character has index 1."
msgstr "参数 @t{REPLY} 设置为 @t{reply} 中包含光标后字符的字的索引，其中第一个元素的索引为 1。 参数 @t{REPLY2} 将被设置为该字词中光标下字符的索引，其中第一个字符的索引为 1。"

#. type: table
#: zsh.texi:39540
msgid "Hence @t{reply}, @t{REPLY} and @t{REPLY2} should all be made local to the enclosing function."
msgstr "因此，@t{reply}、@t{REPLY} 和 @t{REPLY2} 都应本地化到封闭函数中。"

#. type: table
#: zsh.texi:39544
msgid "See the function @t{modify-current-argument}, described below, for an example of how to call this function."
msgstr "有关如何调用该函数的示例，请参阅下文介绍的函数 @t{modify-current-argument}。"

#. type: tindex
#: zsh.texi:39545
#, no-wrap
msgid "modify-current-argument"
msgstr "modify-current-argument"

#. type: item
#: zsh.texi:39546
#, no-wrap
msgid "@t{modify-current-argument} [ @var{expr-using-}@t{$ARG} | @var{func} ]"
msgstr "@t{modify-current-argument} [ @var{expr-using-}@t{$ARG} | @var{func} ]"

#. type: table
#: zsh.texi:39550
msgid ""
"This function provides a simple method of allowing user-defined widgets to modify the command line argument under the cursor (or immediately to the left of the cursor if the cursor is between arguments)."
msgstr "该函数提供了一种简单的方法，允许用户定义的小部件修改光标下的命令行参数（如果光标位于参数之间，则紧靠光标左侧）。"

#. type: table
#: zsh.texi:39556
msgid ""
"The argument can be an expression which when evaluated operates on the shell parameter @t{ARG}, which will have been set to the command line argument under the cursor.  The expression should be suitably "
"quoted to prevent it being evaluated too early."
msgstr "参数可以是一个表达式，该表达式在求值时，在 shell 参数 @t{ARG} 上进行操作，而 shell 参数 @t{ARG} 已被设置为光标下的命令行参数。 表达式应适当加引号，以防止过早求值。"

#. type: table
#: zsh.texi:39563
msgid ""
"Alternatively, if the argument does not contain the string @t{ARG}, it is assumed to be a shell function, to which the current command line argument is passed as the only argument.  The function should "
"set the variable @t{REPLY} to the new value for the command line argument.  If the function returns non-zero status, so does the calling function."
msgstr "或者，如果参数不包含 @t{ARG} 字符串，则假定它是一个 shell 函数，当前命令行参数是唯一的参数。 函数应将变量 @t{REPLY} 设置为命令行参数的新值。 如果函数返回非零状态，则调用函数也返回非零状态。"

#. type: table
#: zsh.texi:39568
msgid "For example, a user-defined widget containing the following code converts the characters in the argument under the cursor into all upper case:"
msgstr "例如，包含以下代码的用户自定义小部件会将光标下参数中的字符转换为全大写："

#. type: example
#: zsh.texi:39572
#, no-wrap
msgid "modify-current-argument '$@{(U)ARG@}'\n"
msgstr "modify-current-argument '$@{(U)ARG@}'\n"

#. type: table
#: zsh.texi:39578
msgid "The following strips any quoting from the current word (whether backslashes or one of the styles of quotes), and replaces it with single quoting throughout:"
msgstr "下面的命令会删除当前单词中的任何引号（无论是反斜线还是引号样式之一），代之以整个单引号："

#. type: example
#: zsh.texi:39582
#, no-wrap
msgid "modify-current-argument '$@{(qq)$@{(Q)ARG@}@}'\n"
msgstr "modify-current-argument '$@{(qq)$@{(Q)ARG@}@}'\n"

#. type: table
#: zsh.texi:39587
msgid "The following performs directory expansion on the command line argument and replaces it by the absolute path:"
msgstr "下面的命令会对命令行参数执行目录扩展，并用绝对路径取而代之："

#. type: example
#: zsh.texi:39595
#, no-wrap
msgid ""
"expand-dir() @{\n"
"  REPLY=$@{~1@}\n"
"  REPLY=$@{REPLY:a@}\n"
"@}\n"
"modify-current-argument expand-dir\n"
msgstr ""
"expand-dir() @{\n"
"  REPLY=$@{~1@}\n"
"  REPLY=$@{REPLY:a@}\n"
"@}\n"
"modify-current-argument expand-dir\n"

#. type: table
#: zsh.texi:39600
msgid "In practice the function @t{expand-dir} would probably not be defined within the widget where @t{modify-current-argument} is called."
msgstr "实际上，函数 @t{expand-dir} 很可能不会在调用 @t{modify-current-argument} 的小部件中定义。"

#. type: Plain text
#: zsh.texi:39613
msgid ""
"The behavior of several of the above widgets can be controlled by the use of the @t{zstyle} mechanism.  In particular, widgets that interact with the completion system pass along their context to any "
"completions that they invoke."
msgstr "上述几个小部件的行为可以通过使用 @t{zstyle} 机制来控制。 特别是，与补全系统交互的小部件会将它们的上下文传递给它们调用的任何补全。"

#. type: kindex
#: zsh.texi:39616
#, no-wrap
msgid "break-keys, widget style"
msgstr "break-keys, 小部件样式"

#. type: t{#1}
#: zsh.texi:39617
#, no-wrap
msgid "break-keys"
msgstr "break-keys"

#. type: table
#: zsh.texi:39624
msgid ""
"This style is used by the @t{incremental-complete-word} widget. Its value should be a pattern, and all keys matching this pattern will cause the widget to stop incremental completion without the key "
"having any further effect. Like all styles used directly by @t{incremental-complete-word}, this style is looked up using the context `@t{:incremental}'."
msgstr ""
"该样式由 @t{incremental-complete-word} 小部件使用。它的值应该是一个模式，所有与该模式匹配的键都将导致小部件停止增量补全，而该键不会有任何进一步的影响。与 @t{incremental-complete-word} 直接使用的所有样式一"
"样，该样式通过上下文 `@t{:incremental}' 进行查找。"

#. type: table
#: zsh.texi:39633
msgid ""
"The @t{incremental-complete-word} and @t{insert-and-predict} widgets set up their top-level context name before calling completion.  This allows one to define different sets of completer functions for "
"normal completion and for these widgets.  For example, to use completion, approximation and correction for normal completion, completion and correction for incremental completion and only completion for "
"prediction one could use:"
msgstr ""
"@t{incremental-complete-word} 和 @t{insert-and-predict} 小部件会在调用补全之前设置其顶级上下文名称。 这样就可以为普通补全和这些小部件定义不同的补全函数集。 例如，要在正常补全中使用补全、近似和修正，在增量"
"补全中使用补全和修正，在预测中只使用补全，可以使用:"

#. type: example
#: zsh.texi:39642
#, no-wrap
msgid ""
"zstyle ':completion:*' completer \\ \n"
"        _complete _correct _approximate\n"
"zstyle ':completion:incremental:*' completer \\ \n"
"        _complete _correct\n"
"zstyle ':completion:predict:*' completer \\ \n"
"        _complete\n"
msgstr ""
"zstyle ':completion:*' completer \\ \n"
"        _complete _correct _approximate\n"
"zstyle ':completion:incremental:*' completer \\ \n"
"        _complete _correct\n"
"zstyle ':completion:predict:*' completer \\ \n"
"        _complete\n"

#. type: table
#: zsh.texi:39652
msgid ""
"It is a good idea to restrict the completers used in prediction, because they may be automatically invoked as you type.  The @t{_list} and @t{_menu} completers should never be used with prediction.  The "
"@t{_approximate}, @t{_correct}, @t{_expand}, and @t{_match} completers may be used, but be aware that they may change characters anywhere in the word behind the cursor, so you need to watch carefully that "
"the result is what you intended."
msgstr ""
"限制预测中使用的补全器是个好主意，因为它们可能会在输入时自动调用。 @t{_list} 和 @t{_menu} 补全器绝对不能用于预测。 可以使用 @t{_approximate}、@t{_correct}、@t{_expand} 和 @t{_match} 补全器，但要注意它们可"
"能会更改光标后单词中任何位置的字符，因此需要仔细观察结果是否与您的预期一致。"

#. type: kindex
#: zsh.texi:39653
#, no-wrap
msgid "cursor, completion style"
msgstr "cursor, 补全样式"

#. type: t{#1}
#: zsh.texi:39654
#, no-wrap
msgid "cursor"
msgstr "cursor"

#. type: table
#: zsh.texi:39658
msgid "The @t{insert-and-predict} widget uses this style, in the context `@t{:predict}', to decide where to place the cursor after completion has been tried.  Values are:"
msgstr "@t{insert-and-predict}小部件在上下文 `@t{:predict}' 中使用这种样式，以决定在尝试补全后将光标置于何处。 值为:"

#. type: table
#: zsh.texi:39665
msgid ""
"The cursor is left where it was when completion finished, but only if it is after a character equal to the one just inserted by the user.  If it is after another character, this value is the same as "
"`@t{key}'."
msgstr "光标会留在补全完成时的位置，但前提是光标必须位于与用户刚刚插入的字符相同的字符之后。 如果光标位于其他字符之后，则该值与 `@t{key}' 相同。"

#. type: t{#1}
#: zsh.texi:39666
#, no-wrap
msgid "key"
msgstr "key"

#. type: table
#: zsh.texi:39674
msgid ""
"The cursor is left after the @var{n}th occurrence of the character just inserted, where @var{n} is the number of times that character appeared in the word before completion was attempted.  In short, this "
"has the effect of leaving the cursor after the character just typed even if the completion code found out that no other characters need to be inserted at that position."
msgstr ""
"光标会停留在刚刚插入的字符的第 @var{n} 次出现之后，其中 @var{n} 是尝试补全之前该字符在单词中出现的次数。 简而言之，这样做的效果是，即使补全代码发现在该位置不需要插入其他字符，光标也会留在刚刚输入的字符之"
"后。"

#. type: table
#: zsh.texi:39680
msgid "Any other value for this style unconditionally leaves the cursor at the position where the completion code left it."
msgstr "该样式的任何其他值都会无条件地将光标停留在补全代码离开的位置。"

#. type: kindex
#: zsh.texi:39681
#, no-wrap
msgid "list, widget style"
msgstr "list, 小部件样式"

#. type: table
#: zsh.texi:39686
msgid ""
"When using the @t{incremental-complete-word} widget, this style says if the matches should be listed on every key press (if they fit on the screen).  Use the context prefix `@t{:completion:incremental}'."
msgstr "当使用 @t{incremental-complete-word} 小部件时，该样式表示是否应在每次按键时列出匹配项（如果它们适合显示在屏幕上）。 使用上下文前缀 `@t{:completion:incremental}'。"

#. type: table
#: zsh.texi:39692
msgid ""
"The @t{insert-and-predict} widget uses this style to decide if the completion should be shown even if there is only one possible completion.  This is done if the value of this style is the string "
"@t{always}.  In this case the context is `@t{:predict}' (@emph{not} `@t{:completion:predict}')."
msgstr ""
"@t{insert-and-predict}小部件使用这种样式来决定是否显示补全，即使只有一种可能的补全。 如果该样式的值是字符串 @t{always}，则会显示补全。 在这种情况下，上下文为`@t{:predict}' （@emph{不是} `@t{:completion:"
"predict}'）。"

#. type: kindex
#: zsh.texi:39693
#, no-wrap
msgid "match, widget style"
msgstr "match, 小部件样式"

#. type: table
#: zsh.texi:39700
msgid ""
"This style is used by @t{smart-insert-last-word} to provide a pattern (using full @t{EXTENDED_GLOB} syntax) that matches an interesting word.  The context is the name of the widget to which @t{smart-"
"insert-last-word} is bound (see above).  The default behavior of @t{smart-insert-last-word} is equivalent to:"
msgstr ""
"该样式由 @t{smart-insert-last-word} 使用，用于提供与有趣的单词相匹配的模式（使用完整的 @t{EXTENDED_GLOB} 语法）。 上下文是 @t{smart-insert-last-word} 所绑定的小部件的名称（见上文）。 @t{smart-insert-last-"
"word} 的默认行为相当于:"

#. type: example
#: zsh.texi:39704
#, no-wrap
msgid "zstyle :insert-last-word match '*[[:alpha:]/\\\\]*'\n"
msgstr "zstyle :insert-last-word match '*[[:alpha:]/\\\\]*'\n"

#. type: table
#: zsh.texi:39708
msgid "However, you might want to include words that contain spaces:"
msgstr "但是，您可能希望包含含有空格的单词："

#. type: example
#: zsh.texi:39712
#, no-wrap
msgid "zstyle :insert-last-word match '*[[:alpha:][:space:]/\\\\]*'\n"
msgstr "zstyle :insert-last-word match '*[[:alpha:][:space:]/\\\\]*'\n"

#. type: table
#: zsh.texi:39716
msgid "Or include numbers as long as the word is at least two characters long:"
msgstr "或者包含数字，只要单词至少有两个字符长："

#. type: example
#: zsh.texi:39720
#, no-wrap
msgid "zstyle :insert-last-word match '*([[:digit:]]?|[[:alpha:]/\\\\])*'\n"
msgstr "zstyle :insert-last-word match '*([[:digit:]]?|[[:alpha:]/\\\\])*'\n"

#. type: table
#: zsh.texi:39724
msgid "The above example causes redirections like \"2>\" to be included."
msgstr "上述示例会导致包含 \"2>\" 等重定向。"

#. type: kindex
#: zsh.texi:39725
#, no-wrap
msgid "prompt, widget style"
msgstr "prompt, 小部件样式"

#. type: table
#: zsh.texi:39731
msgid ""
"The @t{incremental-complete-word} widget shows the value of this style in the status line during incremental completion.  The string value may contain any of the following substrings in the manner of the "
"@t{PS1} and other prompt parameters:"
msgstr "@t{incremental-complete-word} 小部件会在递增补全期间在状态行中显示该样式的值。 字符串值可以按照 @t{PS1} 和其他提示符参数的方式包含以下任意子串："

#. type: table
#: zsh.texi:39737
msgid "Replaced by the name of the completer function that generated the matches (without the leading underscore)."
msgstr "替换为生成匹配的补全函数名称（不含前导下划线）。"

#. type: table
#: zsh.texi:39743
msgid ""
"When the @t{list} style is set, replaced by `@t{...}' if the list of matches is too long to fit on the screen and with an empty string otherwise.  If the @t{list} style is `false' or not set, `@t{%l}' is "
"always removed."
msgstr "当 @t{list} 样式被设置时，如果匹配列表太长而无法在屏幕上显示，则替换为 `@t{...}' ，否则替换为空字符串。 如果 @t{list} 样式为 `false' 或未设置，则始终删除 `@t{%l}' 。"

#. type: table
#: zsh.texi:39746
msgid "Replaced by the number of matches generated."
msgstr "用生成的匹配数代替。"

#. type: table
#: zsh.texi:39752
msgid ""
"Replaced by `@t{-no match-}', `@t{-no prefix-}', or an empty string if there is no completion matching the word on the line, if the matches have no common prefix different from the word on the line, or if "
"there is such a common prefix, respectively."
msgstr "如果没有与该行单词匹配的补全，如果匹配的单词没有与该行单词不同的共同前缀，或者如果有这样的共同前缀，则分别用 `@t{-no match-}', `@t{-no prefix-}' 或空字符串替换。"

#. type: table
#: zsh.texi:39756
msgid "Replaced by the unambiguous part of all matches, if there is any, and if it is different from the word on the line."
msgstr "如果该部分与该行上的词不同，替换为所有匹配词中的不明确部分（如果有的话）。"

#. type: table
#: zsh.texi:39761
msgid "Like `@t{break-keys}', this uses the `@t{:incremental}' context."
msgstr "与 `@t{break-keys}' 一样，它使用 `@t{:incremental}' 上下文。"

#. type: kindex
#: zsh.texi:39762
#, no-wrap
msgid "stop-keys, widget style"
msgstr "stop-keys, 小部件样式"

#. type: t{#1}
#: zsh.texi:39763
#, no-wrap
msgid "stop-keys"
msgstr "stop-keys"

#. type: table
#: zsh.texi:39769
msgid ""
"This style is used by the @t{incremental-complete-word} widget.  Its value is treated similarly to the one for the @t{break-keys} style (and uses the same context: `@t{:incremental}').  However, in this "
"case all keys matching the pattern given as its value will stop incremental completion and will then execute their usual function."
msgstr ""
"该样式由 @t{incremental-complete-word} 小部件使用。 其值的处理方式与 @t{break-keys} 样式类似（并使用相同的上下文：`@t{:incremental}'）。 不过，在这种情况下，所有与作为其值给出的模式匹配的键都将停止增量补"
"全，然后执行它们的常规功能。"

#. type: kindex
#: zsh.texi:39770
#, no-wrap
msgid "toggle, widget style"
msgstr "toggle, 小部件样式"

#. type: t{#1}
#: zsh.texi:39771
#, no-wrap
msgid "toggle"
msgstr "toggle"

#. type: table
#: zsh.texi:39779
msgid ""
"This boolean style is used by @t{predict-on} and its related widgets in the context `@t{:predict}'.  If set to one of the standard `true' values, predictive typing is automatically toggled off in "
"situations where it is unlikely to be useful, such as when editing a multi-line buffer or after moving into the middle of a line and then deleting a character.  The default is to leave prediction turned "
"on until an explicit call to @t{predict-off}."
msgstr ""
"该布尔样式由 @t{predict-on} 及其相关小部件在上下文 `@t{:predict}' 中使用。 如果将其设置为标准的 `true' 值之一，则预测键入功能会在不太可能有用的情况下自动关闭，例如编辑多行缓冲区时，或移动到行中间并删除一个"
"字符后。 默认情况下，在明确调用 @t{predict-off} 之前，预测键入都是打开的。"

#. type: kindex
#: zsh.texi:39780
#, no-wrap
msgid "verbose, widget style"
msgstr "verbose, 小部件样式"

#. type: table
#: zsh.texi:39787
msgid ""
"This boolean style is used by @t{predict-on} and its related widgets in the context `@t{:predict}'.  If set to one of the standard `true' values, these widgets display a message below the prompt when the "
"predictive state is toggled.  This is most useful in combination with the @t{toggle} style.  The default does not display these messages."
msgstr ""
"该布尔样式由 @t{predict-on} 及其相关小部件在上下文 `@t{:predict}' 中使用。 如果设置为标准的 `true' 值之一，这些小部件就会在切换预测状态时在提示符下方显示一条信息。 这在与 @t{toggle} 样式结合使用时最为有"
"用。 默认情况下不显示这些信息。"

#. type: kindex
#: zsh.texi:39788
#, no-wrap
msgid "widget, widget style"
msgstr "widget, 小部件样式"

#. type: t{#1}
#: zsh.texi:39789
#, no-wrap
msgid "widget"
msgstr "widget"

#. type: table
#: zsh.texi:39795
msgid ""
"This style is similar to the @t{command} style: For widget functions that use @t{zle} to call other widgets, this style can sometimes be used to override the widget which is called.  The context for this "
"style is the name of the calling widget (@emph{not} the name of the calling function, because one function may be bound to multiple widget names)."
msgstr ""
"这种样式类似于 @t{command} 样式： 对于使用 @t{zle} 调用其他小部件的小部件函数，有时可以使用这种样式来覆盖被调用的小部件。 此样式的上下文是调用小部件的名称（@emph{不}是调用函数的名称，因为一个函数可能绑定多"
"个小部件名称）。"

#. type: example
#: zsh.texi:39799
#, no-wrap
msgid "zstyle :copy-earlier-word widget smart-insert-last-word\n"
msgstr "zstyle :copy-earlier-word widget smart-insert-last-word\n"

#. type: table
#: zsh.texi:39804
msgid "Check the documentation for the calling widget or function to determine whether the @t{widget} style is used."
msgstr "请查看调用的小部件或函数的文档，以确定是否使用 @t{widget} 样式。"

#. type: node
#: zsh.texi:39808 zsh.texi:39908 zsh.texi:39910 zsh.texi:40326
#, no-wrap
msgid "MIME Functions"
msgstr "MIME 函数"

#. type: Plain text
#: zsh.texi:39816
msgid "Two functions are provided to enable zsh to provide exception handling in a form that should be familiar from other languages."
msgstr "提供了两个函数，使 zsh 能够以其他语言相熟的形式提供异常处理。"

#. type: findex
#: zsh.texi:39819
#, no-wrap
msgid "throw"
msgstr "throw"

#. type: item
#: zsh.texi:39820
#, no-wrap
msgid "@t{throw} @var{exception}"
msgstr "@t{throw} @var{exception}"

#. type: table
#: zsh.texi:39827
msgid ""
"The function @t{throw} throws the named @var{exception}.  The name is an arbitrary string and is only used by the @t{throw} and @t{catch} functions.  An exception is for the most part treated the same as "
"a shell error, i.e. an unhandled exception will cause the shell to abort all processing in a function or script and to return to the top level in an interactive shell."
msgstr ""
"函数 @t{throw} 会抛出名为 @var{exception} 的异常。 该名称是一个任意字符串，仅用于 @t{throw} 和 @t{catch} 函数。 在大多数情况下，异常与 shell 错误的处理方式相同，即未处理的异常将导致 shell 中止函数或脚本中"
"的所有处理，并返回交互式 shell 的顶层。"

#. type: item
#: zsh.texi:39828
#, no-wrap
msgid "@t{catch} @var{exception-pattern}"
msgstr "@t{catch} @var{exception-pattern}"

#. type: table
#: zsh.texi:39840
msgid ""
"The function @t{catch} returns status zero if an exception was thrown and the pattern @var{exception-pattern} matches its name.  Otherwise it returns status 1.  @var{exception-pattern} is a standard shell "
"pattern, respecting the current setting of the @t{EXTENDED_GLOB} option.  An alias @t{catch} is also defined to prevent the argument to the function from matching filenames, so patterns may be used "
"unquoted.  Note that as exceptions are not fundamentally different from other shell errors it is possible to catch shell errors by using an empty string as the exception name.  The shell variable "
"@t{CAUGHT} is set by @t{catch} to the name of the exception caught.  It is possible to rethrow an exception by calling the @t{throw} function again once an exception has been caught."
msgstr ""
"函数 @t{catch} 的返回状态为 0，前提是有异常抛出，且模式 @var{exception-pattern} 与异常名称相匹配。 否则返回状态 1。 @var{exception-pattern} 是标准的 shell 模式，与 @t{EXTENDED_GLOB} 选项的当前设置一致。 此"
"外，还定义了一个别名 @t{catch}，以防止函数参数匹配文件名，因此可以不加引号地使用模式。 需要注意的是，由于异常与其他 shell 错误没有本质区别，因此可以使用空字符串作为异常名称来捕获 shell 错误。 shell 变量 "
"@t{CAUGHT} 将被 @t{catch} 设置为捕获的异常名称。 捕获异常后，可以再次调用 @t{throw} 函数来重新抛出异常。"

#. type: findex
#: zsh.texi:39840
#, no-wrap
msgid "catch"
msgstr "catch"

#. type: Plain text
#: zsh.texi:39850
msgid ""
"The functions are designed to be used together with the @t{always} construct described in @ref{Complex Commands}.  This is important as only this construct provides the required support for exceptions.  A "
"typical example is as follows."
msgstr "这些函数旨在与 @ref{复杂命令} 中描述的 @t{always} 结构一起使用。 这一点非常重要，因为只有这种结构才能为异常提供所需的支持。 下面是一个典型示例。"

#. type: example
#: zsh.texi:39867
#, no-wrap
msgid ""
"@{\n"
"  # \"try\" block\n"
"  # ... nested code here calls \"throw MyExcept\"\n"
"@} always @{\n"
"  # \"always\" block\n"
"  if catch MyExcept; then\n"
"    print \"Caught exception MyExcept\"\n"
"  elif catch @value{dsq}; then\n"
"    print \"Caught a shell error.  Propagating...\"\n"
"    throw @value{dsq}\n"
"  fi\n"
"  # Other exceptions are not handled but may be caught further\n"
"  # up the call stack.\n"
"@}\n"
msgstr ""
"@{\n"
"  # \"try\" block\n"
"  # ... nested code here calls \"throw MyExcept\"\n"
"@} always @{\n"
"  # \"always\" block\n"
"  if catch MyExcept; then\n"
"    print \"Caught exception MyExcept\"\n"
"  elif catch @value{dsq}; then\n"
"    print \"Caught a shell error.  Propagating...\"\n"
"    throw @value{dsq}\n"
"  fi\n"
"  # Other exceptions are not handled but may be caught further\n"
"  # up the call stack.\n"
"@}\n"

#. type: Plain text
#: zsh.texi:39872
msgid "If all exceptions should be caught, the following idiom might be preferable."
msgstr "如果所有异常都应被捕获，下面的习语可能更合适。"

#. type: example
#: zsh.texi:39889
#, no-wrap
msgid ""
"@{\n"
"  # ... nested code here throws an exception\n"
"@} always @{\n"
"  if catch *; then\n"
"    case $CAUGHT in\n"
"      (MyExcept)\n"
"      print \"Caught my own exception\"\n"
"      ;;\n"
"      (*)\n"
"      print \"Caught some other exception\"\n"
"      ;;\n"
"    esac\n"
"  fi\n"
"@}\n"
msgstr ""
"@{\n"
"  # ... nested code here throws an exception\n"
"@} always @{\n"
"  if catch *; then\n"
"    case $CAUGHT in\n"
"      (MyExcept)\n"
"      print \"Caught my own exception\"\n"
"      ;;\n"
"      (*)\n"
"      print \"Caught some other exception\"\n"
"      ;;\n"
"    esac\n"
"  fi\n"
"@}\n"

#. type: Plain text
#: zsh.texi:39897
msgid ""
"In common with exception handling in other languages, the exception may be thrown by code deeply nested inside the `try' block.  However, note that it must be thrown inside the current shell, not in a "
"subshell forked for a pipeline, parenthesised current-shell construct, or some form of command or process substitution."
msgstr ""
"与其他语言的异常处理一样，异常也可以由深度嵌套在 `try' 代码块中的代码抛出。 但要注意的是，异常必须在当前 shell 中抛出，而不是在为管道、加括号的当前 shell 结构或某种形式的命令或进程替换而分叉的子 shell 中抛"
"出。"

#. type: Plain text
#: zsh.texi:39906
msgid ""
"The system internally uses the shell variable @t{EXCEPTION} to record the name of the exception between throwing and catching.  One drawback of this scheme is that if the exception is not handled the "
"variable @t{EXCEPTION} remains set and may be incorrectly recognised as the name of an exception if a shell error subsequently occurs.  Adding @t{unset EXCEPTION} at the start of the outermost layer of "
"any code that uses exception handling will eliminate this problem."
msgstr ""
"系统内部使用 shell 变量 @t{EXCEPTION} 来记录抛出和捕获之间的异常名称。 这种方案的一个缺点是，如果异常未被处理，变量 @t{EXCEPTION} 将保持设置，如果随后出现 shell 错误，可能会被错误地识别为异常名称。 在任何"
"使用异常处理的代码的最外层开头添加 @t{unset EXCEPTION} 就可以解决这个问题。"

#. type: node
#: zsh.texi:39908 zsh.texi:40326 zsh.texi:40328 zsh.texi:40615
#, no-wrap
msgid "Mathematical Functions"
msgstr "数学函数"

#. type: Plain text
#: zsh.texi:39917
msgid "Three functions are available to provide handling of files recognised by extension, for example to dispatch a file @t{text.ps} when executed as a command to an appropriate viewer."
msgstr "有三个函数可用于处理扩展名识别的文件，例如，在作为命令执行时，将文件 @t{text.ps} 分派给适当的查看器。"

#. type: findex
#: zsh.texi:39921
#, no-wrap
msgid "zsh-mime-handler"
msgstr "zsh-mime-handler"

#. type: item
#: zsh.texi:39922
#, no-wrap
msgid "@t{zsh-mime-setup} [ @t{-fv} ] [ @t{-l} [ @var{suffix} ... ] ]"
msgstr "@t{zsh-mime-setup} [ @t{-fv} ] [ @t{-l} [ @var{suffix} ... ] ]"

#. type: itemx
#: zsh.texi:39923
#, no-wrap
msgid "@t{zsh-mime-handler} [ @t{-l} ] @var{command argument} ..."
msgstr "@t{zsh-mime-handler} [ @t{-l} ] @var{command argument} ..."

#. type: table
#: zsh.texi:39929
msgid ""
"These two functions use the files @t{~/.mime.types} and @t{/etc/mime.types}, which associate types and extensions, as well as @t{~/.mailcap} and @t{/etc/mailcap} files, which associate types and the "
"programs that handle them.  These are provided on many systems with the Multimedia Internet Mail Extensions."
msgstr ""
"这两个函数使用 @t{~/.mime.types} 和 @t{/etc/mime.types} 文件，它们将类型和扩展名联系起来；还使用 @t{~/.mailcap} 和 @t{/etc/mailcap} 文件，它们将类型和处理这些类型的程序联系起来。 这些，通过多媒体互联网邮件"
"扩展（Multimedia Internet Mail Extensions），在许多系统中都有提供。"

#. type: table
#: zsh.texi:39936
msgid ""
"To enable the system, the function @t{zsh-mime-setup} should be autoloaded and run.  This allows files with extensions to be treated as executable; such files be completed by the function completion "
"system.  The function @t{zsh-mime-handler} should not need to be called by the user."
msgstr "要启用该系统，应自动加载并运行函数 @t{zsh-mime-setup}。 这样，带有扩展名的文件就会被视为可执行文件，并由函数补全系统补全。 用户无需调用 @t{zsh-mime-handler} 函数。"

#. type: table
#: zsh.texi:39940
msgid "The system works by setting up suffix aliases with `@t{alias -s}'.  Suffix aliases already installed by the user will not be overwritten."
msgstr "该系统通过使用 `@t{alias -s}' 设置后缀别名来运行。 用户已安装的后缀别名不会被覆盖。"

#. type: table
#: zsh.texi:39945
msgid "For suffixes defined in lower case, upper case variants will also automatically be handled (e.g. @t{PDF} is automatically handled if handling for the suffix @t{pdf} is defined), but not vice versa."
msgstr "对于以小写定义的后缀，大写变体也将自动得到处理（例如，如果定义了对后缀 @t{pdf} 的处理，则 @t{PDF} 将自动得到处理），但反之不成立。"

#. type: table
#: zsh.texi:39951
msgid ""
"Repeated calls to @t{zsh-mime-setup} do not override the existing mapping between suffixes and executable files unless the option @t{-f} is given.  Note, however, that this does not override existing "
"suffix aliases assigned to handlers other than @t{zsh-mime-handler}."
msgstr "除非给出 @t{-f} 选项，否则重复调用 @t{zsh-mime-setup} 不会覆盖后缀和可执行文件之间的现有映射。 但请注意，这不会覆盖分配给 @t{zsh-mime-handler} 以外的处理程序的现有后缀别名。"

#. type: table
#: zsh.texi:39958
msgid ""
"Calling @t{zsh-mime-setup} with the option @t{-l} lists the existing mappings without altering them.  Suffixes to list (which may contain pattern characters that should be quoted from immediate "
"interpretation on the command line) may be given as additional arguments, otherwise all suffixes are listed."
msgstr "使用选项 @t{-l} 调用 @t{zsh-mime-setup} 会列出现有的映射，但不会更改它们。 要列出的后缀（可能包含模式字符，在命令行中应加注引号以避免直接解释）可以作为附加参数给出，否则将列出所有后缀。"

#. type: table
#: zsh.texi:39962
msgid "Calling @t{zsh-mime-setup} with the option @t{-v} causes verbose output to be shown during the setup operation."
msgstr "使用选项 @t{-v} 调用 @t{zsh-mime-setup} 会在设置(setup)操作过程中显示冗长输出。"

#. type: table
#: zsh.texi:39967
msgid "The system respects the @t{mailcap} flags @t{needsterminal} and @t{copiousoutput}; see mailcap(4) or mailcap(5)  (the man page's name varies across platforms)."
msgstr "系统尊守 @t{mailcap} 标志 @t{needsterminal} 和 @t{copiousoutput}；请参阅 mailcap(4) 或 mailcap(5)（不同平台的手册页名称不同）。"

#. type: table
#: zsh.texi:39976
msgid ""
"The functions use the following styles, which are defined with the @t{zstyle} builtin command (@ref{The zsh/zutil Module}).  They should be defined before @t{zsh-mime-setup} is run.  The contexts used all "
"start with @t{:mime:}, with additional components in some cases.  It is recommended that a trailing @t{*} (suitably quoted) be appended to style patterns in case the system is extended in future.  Some "
"examples are given below."
msgstr ""
"函数使用以下样式，这些样式通过 @t{zstyle} 内置命令（@ref{zsh/zutil 模块}）定义。 它们应在 @t{zsh-mime-setup} 运行前定义。 使用的上下文均以 @t{:mime:} 开头，在某些情况下还会使用附加组件。 建议在样式模式后加"
"上 @t{*}（适当加引号），以防系统将来扩展。 下面给出了一些例子。"

#. type: table
#: zsh.texi:39988
msgid ""
"For files that have multiple suffixes, e.g. @t{.pdf.gz}, where the context includes the suffix it will be looked up starting with the longest possible suffix until a match for the style is found.  For "
"example, if @t{.pdf.gz} produces a match for the handler, that will be used; otherwise the handler for @t{.gz} will be used.  Note that, owing to the way suffix aliases work, it is always required that "
"there be a handler for the shortest possible suffix, so in this example @t{.pdf.gz} can only be handled if @t{.gz} is also handled (though not necessarily in the same way).  Alternatively, if no handling "
"for @t{.gz} on its own is needed, simply adding the command"
msgstr ""
"对于有多个后缀的文件，例如 @t{.pdf.gz}，如果上下文包含后缀，则将从可能的最长后缀开始查找，直到找到与样式匹配的后缀。 例如，如果 @t{.pdf.gz} 产生了与处理程序匹配的后缀，则使用该后缀；否则将使用 @t{.gz} 的处"
"理程序。 需要注意的是，由于后缀别名的工作方式，总是要求为尽可能短的后缀提供处理程序， 因此在本例中，只有在 @t{.gz} 也被处理（但处理方式不一定相同）的情况下，@t{.pdf.gz} 才能被处理。 另外，如果不需要处理 "
"@t{.gz} 本身，只需添加命令"

#. type: example
#: zsh.texi:39992
#, no-wrap
msgid "alias -s gz=zsh-mime-handler\n"
msgstr "alias -s gz=zsh-mime-handler\n"

#. type: table
#: zsh.texi:39997
msgid "to the initialisation code is sufficient; @t{.gz} will not be handled on its own, but may be in combination with other suffixes."
msgstr "初始化代码已经足够了；@t{.gz} 不会单独处理，但可能会与其他后缀一起处理。"

#. type: kindex
#: zsh.texi:40000
#, no-wrap
msgid "current-shell, MIME style"
msgstr "current-shell, MIME style"

#. type: t{#1}
#: zsh.texi:40001
#, no-wrap
msgid "current-shell"
msgstr "current-shell"

#. type: table
#: zsh.texi:40006
msgid ""
"If this boolean style is true, the mailcap handler for the context in question is run using the @t{eval} builtin instead of by starting a new @t{sh} process.  This is more efficient, but may not work in "
"the occasional cases where the mailcap handler uses strict POSIX syntax."
msgstr "如果该布尔值为 true，相关上下文的 mailcap 处理程序将使用 @t{eval} 内置程序运行，而不是启动一个新的 @t{sh} 进程。 这种方式效率更高，但在 mailcap 处理程序使用严格 POSIX 语法的情况下偶尔可能无法运行。"

#. type: kindex
#: zsh.texi:40007
#, no-wrap
msgid "disown, MIME style"
msgstr "disown, MIME style"

#. type: table
#: zsh.texi:40014
msgid ""
"If this boolean style is true, mailcap handlers started in the background will be disowned, i.e. not subject to job control within the parent shell.  Such handlers nearly always produce their own windows, "
"so the only likely harmful side effect of setting the style is that it becomes harder to kill jobs from within the shell."
msgstr ""
"如果该布尔样式为 true，那么在后台启动的mailcap处理程序将被从Shell的作业控制中移除，即不受父 shell 中作业的控制。 此类处理程序几乎总是产生自己的窗口，因此设置该样式唯一可能产生的有害副作用是，从Shell内部更"
"难以终止这些作业。"

#. type: kindex
#: zsh.texi:40015
#, no-wrap
msgid "execute-as-is, MIME style"
msgstr "execute-as-is, MIME style"

#. type: t{#1}
#: zsh.texi:40016
#, no-wrap
msgid "execute-as-is"
msgstr "execute-as-is"

#. type: table
#: zsh.texi:40026
msgid ""
"This style gives a list of patterns to be matched against files passed for execution with a handler program.  If the file matches the pattern, the entire command line is executed in its current form, with "
"no handler.  This is useful for files which might have suffixes but nonetheless be executable in their own right.  If the style is not set, the pattern @t{*(*) *(/)} is used; hence executable files are "
"executed directly and not passed to a handler, and the option @t{AUTO_CD} may be used to change to directories that happen to have MIME suffixes."
msgstr ""
"该样式提供了一个模式列表，用于匹配与处理程序一起传递执行的文件。 如果文件与模式匹配，则整个命令行将以当前形式执行，不使用处理程序。 这对可能有后缀但本身仍可执行的文件非常有用。 如果未设置样式，则使用 "
"@t{*(*) *(/)} 模式；因此，可执行文件将直接执行，而不会传递给处理程序，并且可以使用选项 @t{AUTO_CD} 来更改碰巧带有 MIME 后缀的目录。"

#. type: kindex
#: zsh.texi:40027
#, no-wrap
msgid "execute-never, MIME style"
msgstr "execute-never, MIME style"

#. type: t{#1}
#: zsh.texi:40028
#, no-wrap
msgid "execute-never"
msgstr "execute-never"

#. type: table
#: zsh.texi:40036
msgid ""
"This style is useful in combination with @t{execute-as-is}.  It is set to an array of patterns corresponding to full paths to files that should never be treated as executable, even if the file passed to "
"the MIME handler matches @t{execute-as-is}.  This is useful for file systems that don't handle execute permission or that contain executables from another operating system.  For example, if @t{/mnt/"
"windows} is a Windows mount, then"
msgstr ""
"该样式可与 @t{execute-as-is} 结合使用。 它被设置为与文件全路径相对应的模式数组，即使传递给 MIME 处理程序的文件符合 @t{execute-as-is}，这些文件也不应被视为可执行文件。 这对于不处理执行权限或包含来自其他操作"
"系统的可执行文件的文件系统非常有用。 例如，如果 @t{/mnt/windows} 是 Windows 挂载点，那么"

#. type: example
#: zsh.texi:40040
#, no-wrap
msgid "zstyle ':mime:*' execute-never '/mnt/windows/*'\n"
msgstr "zstyle ':mime:*' execute-never '/mnt/windows/*'\n"

#. type: table
#: zsh.texi:40051
msgid ""
"will ensure that any files found in that area will be executed as MIME types even if they are executable.  As this example shows, the complete file name is matched against the pattern, regardless of how "
"the file was passed to the handler.  The file is resolved to a full path using the @t{:P} modifier described in @ref{Modifiers}; this means that symbolic links are resolved where possible, so that links "
"into other file systems behave in the correct fashion."
msgstr ""
"将确保在该区域找到的任何文件都将作为 MIME 类型执行，即使这些文件是可执行的。 如本例所示，完整的文件名将与模式相匹配，无论文件是如何传递给处理程序的。 文件将使用 @ref{修饰符} 中描述的 @t{:P} 修饰符解析为完"
"整路径；这意味着尽可能解析符号链接，以便以正确的方式链接到其他文件系统。"

#. type: kindex
#: zsh.texi:40052
#, no-wrap
msgid "file-path, MIME style"
msgstr "file-path, MIME style"

#. type: t{#1}
#: zsh.texi:40053
#, no-wrap
msgid "file-path"
msgstr "file-path"

#. type: table
#: zsh.texi:40063
msgid ""
"Used if the style @t{find-file-in-path} is true for the same context.  Set to an array of directories that are used for searching for the file to be handled; the default is the command path given by the "
"special parameter @t{path}.  The shell option @t{PATH_DIRS} is respected; if that is set, the appropriate path will be searched even if the name of the file to be handled as it appears on the command line "
"contains a `@t{/}'.  The full context is @t{:mime:.}@var{suffix}@t{:}, as described for the style @t{handler}."
msgstr ""
"当 @t{find-file-in-path} 样式在同样的上下文中为真时使用。 设置为用于搜索待处理文件的目录数组；默认为特殊参数 @t{path} 指定的命令路径。shell 选项 @t{PATH_DIRS} 会被遵从； 如果设置了 shell 选项 "
"@t{PATH_DIRS}，即使要处理的文件名在命令行中包含 `@t{/}'，也会搜索相应的路径。 完整的上下文为  @t{:mime:.}@var{suffix}@t{:}，如 @t{handler} 样式所述。"

#. type: kindex
#: zsh.texi:40064
#, no-wrap
msgid "find-file-in-path, MIME style"
msgstr "find-file-in-path, MIME style"

#. type: t{#1}
#: zsh.texi:40065
#, no-wrap
msgid "find-file-in-path"
msgstr "find-file-in-path"

#. type: table
#: zsh.texi:40075
msgid ""
"If set, allows files whose names do not contain absolute paths to be searched for in the command path or the path specified by the @t{file-path} style.  If the file is not found in the path, it is looked "
"for locally (whether or not the current directory is in the path); if it is not found locally, the handler will abort unless the @t{handle-nonexistent} style is set.  Files found in the path are tested as "
"described for the style @t{execute-as-is}.  The full context is @t{:mime:.}@var{suffix}@t{:}, as described for the style @t{handler}."
msgstr ""
"如果设置，则允许在命令路径或 @t{file-path} 样式指定的路径中搜索名称不包含绝对路径的文件。 如果在路径中找不到文件，将在本地查找（无论当前目录是否在路径中）；如果在本地找不到文件，除非设置了 @t{handle-"
"nonexistent} 样式，否则处理程序将终止。 路径中找到的文件将按照 @t{execute-as-is} 样式进行测试。 完整上下文为 @t{:mime:.}@var{suffix}@t{:}，如 @t{handler} 样式所述。"

#. type: kindex
#: zsh.texi:40076
#, no-wrap
msgid "flags, MIME style"
msgstr "flags, MIME style"

#. type: t{#1}
#: zsh.texi:40077 zsh.texi:40129
#, no-wrap
msgid "flags"
msgstr "flags"

#. type: table
#: zsh.texi:40080
msgid "Defines flags to go with a handler; the context is as for the @t{handler} style, and the format is as for the flags in @t{mailcap}."
msgstr "定义处理程序的标志；上下文与 @t{handler} 样式相同，格式与 @t{mailcap} 中的标志相同。"

#. type: kindex
#: zsh.texi:40081
#, no-wrap
msgid "handle-nonexistent, MIME style"
msgstr "handle-nonexistent, MIME style"

#. type: t{#1}
#: zsh.texi:40082
#, no-wrap
msgid "handle-nonexistent"
msgstr "handle-nonexistent"

#. type: table
#: zsh.texi:40092
msgid ""
"By default, arguments that don't correspond to files are not passed to the MIME handler in order to prevent it from intercepting commands found in the path that happen to have suffixes.  This style may be "
"set to an array of extended glob patterns for arguments that will be passed to the handler even if they don't exist.  If it is not explicitly set it defaults to @t{[[:alpha:]]#:/*} which allows URLs to be "
"passed to the MIME handler even though they don't exist in that format in the file system.  The full context is @t{:mime:.}@var{suffix}@t{:}, as described for the style @t{handler}."
msgstr ""
"默认情况下，与文件不对应的参数不会传递给 MIME 处理程序，以防止它拦截路径中恰好有后缀的命令。 该样式可设置为一个扩展 glob 模式数组，用于将参数（即使不存在）传递给处理程序。 如果未明确设置，则默认为 @t{[[:"
"alpha:]]#:/*}，允许将 URL 传递给 MIME 处理程序，即使这些 URL 在文件系统中并不存在该格式。 完整的上下文为 @t{:mime:.}@var{suffix}@t{:}，如 @t{handler} 样式所述。"

#. type: kindex
#: zsh.texi:40093
#, no-wrap
msgid "handler, MIME style"
msgstr "handler, MIME style"

#. type: t{#1}
#: zsh.texi:40094
#, no-wrap
msgid "handler"
msgstr "handler"

#. type: table
#: zsh.texi:40103
msgid ""
"Specifies a handler for a suffix; the suffix is given by the context as @t{:mime:.}@var{suffix}@t{:}, and the format of the handler is exactly that in @t{mailcap}.  Note in particular the `@t{.}' and "
"trailing colon to distinguish this use of the context.  This overrides any handler specified by the @t{mailcap} files.  If the handler requires a terminal, the @t{flags} style should be set to include the "
"word @t{needsterminal}, or if the output is to be displayed through a pager (but not if the handler is itself a pager), it should include @t{copiousoutput}."
msgstr ""
"指定后缀的处理程序；后缀由上下文给出，如 @t{:mime:.}@var{suffix}@t{:}，处理程序的格式与 @t{mailcap} 中的格式完全相同。 请特别注意 `@t{.}' 和后面的冒号，以区分这种上下文用法。 这将覆盖 @t{mailcap} 文件指定"
"的任何处理程序。 如果处理程序需要终端，则 @t{flags} 样式应设置为包含 @t{needsterminal} 字样；如果输出要通过分页程序显示（但如果处理程序本身就是分页程序，则不需要），则应包含 @t{copiousoutput}。"

#. type: kindex
#: zsh.texi:40104
#, no-wrap
msgid "mailcap, MIME style"
msgstr "mailcap, MIME style"

#. type: t{#1}
#: zsh.texi:40105
#, no-wrap
msgid "mailcap"
msgstr "mailcap"

#. type: table
#: zsh.texi:40110
msgid ""
"A list of files in the format of @t{~/.mailcap} and @t{/etc/mailcap} to be read during setup, replacing the default list which consists of those two files.  The context is @t{:mime:}.  A @t{+} in the list "
"will be replaced by the default files."
msgstr "在设置过程中读取的 @t{~/.mailcap} 和 @t{/etc/mailcap} 格式的文件列表，取代默认的由这两个文件组成的列表。 上下文为 @t{:mime:}。 列表中的 @t{+} 将被默认文件替换。"

#. type: kindex
#: zsh.texi:40111
#, no-wrap
msgid "mailcap-priorities, MIME style"
msgstr "mailcap-priorities, MIME style"

#. type: t{#1}
#: zsh.texi:40112
#, no-wrap
msgid "mailcap-priorities"
msgstr "mailcap-priorities"

#. type: table
#: zsh.texi:40118
msgid ""
"This style is used to resolve multiple mailcap entries for the same MIME type.  It consists of an array of the following elements, in descending order of priority; later entries will be used if earlier "
"entries are unable to resolve the entries being compared.  If none of the tests resolve the entries, the first entry encountered is retained."
msgstr ""
"该样式用于解析同一 MIME 类型的多个 mailcap 条目。 它由下列元素组成的数组构成，按优先级降序排列；如果前面的条目无法解析正在比较的条目，后面的条目将被使用。 如果所有测试都无法解析条目，则保留遇到的第一个条"
"目。"

#. type: table
#: zsh.texi:40124
msgid "The order of files (entries in the @t{mailcap} style) read.  Earlier files are preferred.  (Note this does not resolve entries in the same file.)"
msgstr "读取文件（@t{mailcap}样式中的条目）的顺序。较早的文件优先。 (请注意，这并不能解决[resolve]同一文件中的条目）。"

#. type: t{#1}
#: zsh.texi:40125
#, no-wrap
msgid "priority"
msgstr "priority"

#. type: table
#: zsh.texi:40128
msgid "The priority flag from the mailcap entry.  The priority is an integer from 0 to 9 with the default value being 5."
msgstr "mailcap 条目中的优先级标志。 优先级是一个从 0 到 9 的整数，默认值为 5。"

#. type: table
#: zsh.texi:40132
msgid "The test given by the @t{mailcap-prio-flags} option is used to resolve entries."
msgstr "@t{mailcap-prio-flags} 选项给出的测试用于解析条目。"

#. type: t{#1}
#: zsh.texi:40133
#, no-wrap
msgid "place"
msgstr "place"

#. type: table
#: zsh.texi:40136
msgid "Later entries are preferred; as the entries are strictly ordered, this test always succeeds."
msgstr "较晚的条目优先；由于条目是严格有序的，因此该测试总是成功的。"

#. type: table
#: zsh.texi:40142
msgid "Note that as this style is handled during initialisation, the context is always @t{:mime:}, with no discrimination by suffix."
msgstr "请注意，由于这种样式是在初始化过程中处理的，因此上下文总是 @t{:mime:}，没有后缀区分。"

#. type: kindex
#: zsh.texi:40143
#, no-wrap
msgid "mailcap-prio-flags, MIME style"
msgstr "mailcap-prio-flags, MIME style"

#. type: t{#1}
#: zsh.texi:40144
#, no-wrap
msgid "mailcap-prio-flags"
msgstr "mailcap-prio-flags"

#. type: table
#: zsh.texi:40152
msgid ""
"This style is used when the keyword @t{flags} is encountered in the list of tests specified by the @t{mailcap-priorities} style.  It should be set to a list of patterns, each of which is tested against "
"the flags specified in the mailcap entry (in other words, the sets of assignments found with some entries in the mailcap file).  Earlier patterns in the list are preferred to later ones, and matched "
"patterns are preferred to unmatched ones."
msgstr ""
"当在 @t{mailcap-priorities} 样式指定的测试列表中遇到关键字 @t{flags} 时，就会使用这种样式。 应将其设置为一个模式列表，每个模式都要根据 mailcap 条目中指定的标志（换句话说，在 mailcap 文件的某些条目中发现的"
"赋值集）进行测试。 列表中较早的模式优先于较晚的模式，匹配的模式优先于不匹配的模式。"

#. type: kindex
#: zsh.texi:40153
#, no-wrap
msgid "mime-types, MIME style"
msgstr "mime-types, MIME style"

#. type: t{#1}
#: zsh.texi:40154
#, no-wrap
msgid "mime-types"
msgstr "mime-types"

#. type: table
#: zsh.texi:40159
msgid ""
"A list of files in the format of @t{~/.mime.types} and @t{/etc/mime.types} to be read during setup, replacing the default list which consists of those two files.  The context is @t{:mime:}.  A @t{+} in "
"the list will be replaced by the default files."
msgstr "在设置过程中读取的 @t{~/.mime.types} 和 @t{/etc/mime.types} 格式的文件列表，取代默认的由这两个文件组成的列表。上下文为 @t{:mime:}。 列表中的 @t{+} 将被默认文件替换。"

#. type: kindex
#: zsh.texi:40160
#, no-wrap
msgid "never-background, MIME style"
msgstr "never-background, MIME style"

#. type: t{#1}
#: zsh.texi:40161
#, no-wrap
msgid "never-background"
msgstr "never-background"

#. type: table
#: zsh.texi:40166
msgid ""
"If this boolean style is set, the handler for the given context is always run in the foreground, even if the flags provided in the mailcap entry suggest it need not be (for example, it doesn't require a "
"terminal)."
msgstr "如果设置了这个布尔样式，给定上下文的处理程序将始终在前台运行，即使 mailcap 条目中提供的标志表明不需要这样做（例如，它不需要终端）。"

#. type: kindex
#: zsh.texi:40167
#, no-wrap
msgid "pager, MIME style"
msgstr "pager, MIME style"

#. type: t{#1}
#: zsh.texi:40168 zsh.texi:41248
#, no-wrap
msgid "pager"
msgstr "pager"

#. type: table
#: zsh.texi:40173
msgid ""
"If set, will be used instead of @t{$PAGER} or @t{more} to handle suffixes where the @t{copiousoutput} flag is set.  The context is as for @t{handler}, i.e. @t{:mime:.}@var{suffix}@t{:} for handling a file "
"with the given @var{suffix}."
msgstr "如果设置，将代替 @t{$PAGER} 或 @t{more} 来处理设置了 @t{copiousoutput} 标志的后缀。 上下文与 @t{handler} 相同，即 @t{:mime:.}@var{suffix}@t{:} 用于处理带有给定 @var{suffix} 的文件。"

#. type: example
#: zsh.texi:40184
#, no-wrap
msgid ""
"zstyle ':mime:*' mailcap ~/.mailcap /usr/local/etc/mailcap\n"
"zstyle ':mime:.txt:' handler less %s\n"
"zstyle ':mime:.txt:' flags needsterminal\n"
msgstr ""
"zstyle ':mime:*' mailcap ~/.mailcap /usr/local/etc/mailcap\n"
"zstyle ':mime:.txt:' handler less %s\n"
"zstyle ':mime:.txt:' flags needsterminal\n"

#. type: table
#: zsh.texi:40192
msgid ""
"When @t{zsh-mime-setup} is subsequently run, it will look for @t{mailcap} entries in the two files given.  Files of suffix @t{.txt} will be handled by running `@t{less} @var{file.txt}'.  The flag "
"@t{needsterminal} is set to show that this program must run attached to a terminal."
msgstr ""
"随后运行 @t{zsh-mime-setup} 时，它会在给出的两个文件中查找 @t{mailcap} 条目。 后缀名为 @t{.txt} 的文件将通过运行 `@t{less} @var{file.txt}'来处理。 设置 @t{needsterminal} 标志是为了表明该程序必须连接终端运"
"行。"

#. type: table
#: zsh.texi:40197
msgid "As there are several steps to dispatching a command, the following should be checked if attempting to execute a file by extension @t{.}@var{ext} does not have the expected effect."
msgstr "由于调度命令有多个步骤，如果尝试执行扩展名为 @t{.}@var{ext} 的文件而没有达到预期效果，则应检查以下内容。"

#. type: table
#: zsh.texi:40206
msgid ""
"The command `@t{alias -s} @var{ext}' should show `@t{ps=zsh-mime-handler}'.  If it shows something else, another suffix alias was already installed and was not overwritten.  If it shows nothing, no "
"handler was installed: this is most likely because no handler was found in the @t{.mime.types} and @t{mailcap} combination for @t{.ext} files.  In that case, appropriate handling should be added to @t{~/."
"mime.types} and @t{mailcap}."
msgstr ""
"命令 `@t{alias -s} @var{ext}' 应显示 `@t{ps=zsh-mime-handler}'。 如果显示其他内容，则说明已安装了另一个后缀别名，且未被覆盖。 如果没有显示任何内容，则说明没有安装处理程序：这很可能是因为在 @t{.mime.types} "
"和 @t{mailcap} 组合中没有为 @t{.ext} 文件找到处理程序。 在这种情况下，应在 @t{~/.mime.types} 和 @t{mailcap} 中添加适当的处理程序。"

#. type: table
#: zsh.texi:40218
msgid ""
"If the extension is handled by @t{zsh-mime-handler} but the file is not opened correctly, either the handler defined for the type is incorrect, or the flags associated with it are in appropriate.  Running "
"@t{zsh-mime-setup -l} will show the handler and, if there are any, the flags.  A @t{%s} in the handler is replaced by the file (suitably quoted if necessary).  Check that the handler program listed lists "
"and can be run in the way shown.  Also check that the flags @t{needsterminal} or @t{copiousoutput} are set if the handler needs to be run under a terminal; the second flag is used if the output should be "
"sent to a pager.  An example of a suitable @t{mailcap} entry for such a program is:"
msgstr ""
"如果扩展名由 @t{zsh-mime-handler} 处理，但文件却无法正确打开，要么是为该类型定义的处理程序不正确，要么是与之相关的标志不合适。 运行 @t{zsh-mime-setup -l} 将显示处理程序和标志（如果有）。 处理程序中的 "
"@t{%s} 将被文件替换（必要时适当加引号）。 检查列出的处理程序是否按所示方式运行。 如果处理程序需要在终端下运行，还应检查是否设置了 @t{needsterminal} 或 @t{copiousoutput} 标志；如果输出应发送到分页程序"
"(pager)，则使用第二个标志。 以下是此类程序的适合 @t{mailcap} 条目的示例："

#. type: example
#: zsh.texi:40222
#, no-wrap
msgid "text/html; /usr/bin/lynx '%s'; needsterminal\n"
msgstr "text/html; /usr/bin/lynx '%s'; needsterminal\n"

#. type: table
#: zsh.texi:40230
msgid ""
"Running `@t{zsh-mime-handler -l} @var{command line}' prints the command line that would be executed, simplified to remove the effect of any flags, and quoted so that the output can be run as a complete "
"zsh command line.  This is used by the completion system to decide how to complete after a file handled by @t{zsh-mime-setup}."
msgstr ""
"运行 `@t{zsh-mime-handler -l} @var{command line}' 会打印出将要执行的命令行，经过简化以去除任何标志的影响，并加上引号，以便输出（内容）可以作为完整的 zsh 命令行运行。 补全系统使用此命令行来决定如何在 "
"@t{zsh-mime-setup} 处理文件后补全。"

#. type: t{#1}
#: zsh.texi:40231 zsh.texi:40232
#, no-wrap
msgid "pick-web-browser"
msgstr "pick-web-browser"

#. type: table
#: zsh.texi:40235
msgid "This function is separate from the two MIME functions described above and can be assigned directly to a suffix:"
msgstr "该函数独立于上述两个 MIME 函数，可直接分配给后缀："

#. type: example
#: zsh.texi:40240
#, no-wrap
msgid ""
"autoload -U pick-web-browser\n"
"alias -s html=pick-web-browser\n"
msgstr ""
"autoload -U pick-web-browser\n"
"alias -s html=pick-web-browser\n"

#. type: table
#: zsh.texi:40246
msgid "It is provided as an intelligent front end to dispatch a web browser.  It may be run as either a function or a shell script.  The status 255 is returned if no browser could be started."
msgstr "它是作为智能前端提供的，用于调度网络浏览器。它可以作为函数或 shell 脚本运行。 如果无法启动浏览器，则返回状态 255。"

#. type: table
#: zsh.texi:40249
msgid "Various styles are available to customize the choice of browsers:"
msgstr "有多种样式可供选择，以便自定义浏览器："

#. type: t{#1}
#: zsh.texi:40252
#, no-wrap
msgid "browser-style"
msgstr "browser-style"

#. type: table
#: zsh.texi:40255
msgid "The value of the style is an array giving preferences in decreasing order for the type of browser to use.  The values of elements may be"
msgstr "样式的值是一个数组，按照浏览器类型的递减顺序给出首选项。 元素的值可以是"

#. type: t{#1}
#: zsh.texi:40258
#, no-wrap
msgid "running"
msgstr "running"

#. type: table
#: zsh.texi:40266
msgid ""
"Use a GUI browser that is already running when an X Window display is available.  The browsers listed in the @t{x-browsers} style are tried in order until one is found; if it is, the file will be "
"displayed in that browser, so the user may need to check whether it has appeared.  If no running browser is found, one is not started.  Browsers other than Firefox, Opera and Konqueror are assumed to "
"understand the Mozilla syntax for opening a URL remotely."
msgstr ""
"当 X 窗口显示可用时，使用已在运行的图形用户界面浏览器。 @t{x-browsers} 样式中列出的浏览器将依次尝试，直到找到一个为止；如果找到了，文件将在该浏览器中显示，因此用户可能需要检查它是否已经出现。 如果没有找到"
"正在运行的浏览器，则不会启动该浏览器。 除 Firefox、Opera 和 Konqueror 外，其他浏览器都被假定为能理解 Mozilla 远程打开 URL 的语法。"

#. type: table
#: zsh.texi:40272
msgid ""
"Start a new GUI browser when an X Window display is available.  Search for the availability of one of the browsers listed in the @t{x-browsers} style and start the first one that is found.  No check is "
"made for an already running browser."
msgstr "当 X 窗口显示可用时，启动一个新的图形用户界面浏览器。 搜索 @t{x-browsers} 样式中列出的浏览器是否可用，然后启动找到的第一个浏览器。 不会检查是否有已运行的浏览器。"

#. type: t{#1}
#: zsh.texi:40273
#, no-wrap
msgid "tty"
msgstr "tty"

#. type: table
#: zsh.texi:40277
msgid "Start a terminal-based browser.  Search for the availability of one of the browsers listed in the @t{tty-browsers} style and start the first one that is found."
msgstr "启动终端浏览器 。搜索 @t{tty-browsers} 样式中列出的浏览器是否可用，然后启动找到的第一个浏览器。"

#. type: table
#: zsh.texi:40282
msgid "If the style is not set the default @t{running x tty} is used."
msgstr "如果未设置样式，则使用默认的 @t{running x tty}。"

#. type: t{#1}
#: zsh.texi:40283
#, no-wrap
msgid "x-browsers"
msgstr "x-browsers"

#. type: table
#: zsh.texi:40290
msgid ""
"An array in decreasing order of preference of browsers to use when running under the X Window System.  The array consists of the command name under which to start the browser.  They are looked up in the "
"context @t{:mime:} (which may be extended in future, so appending `@t{*}' is recommended).  For example,"
msgstr "在 X 窗口系统下运行时，按优先级递减的浏览器数组。 数组包括启动浏览器的命令名称。 它们是在 @t{:mime:} 的上下文中查找的（将来可能会扩展，因此建议在 @t{:mime:} 中添加 `@t{*}' ）。 例如,"

#. type: example
#: zsh.texi:40294
#, no-wrap
msgid "zstyle ':mime:*' x-browsers opera konqueror firefox\n"
msgstr "zstyle ':mime:*' x-browsers opera konqueror firefox\n"

#. type: table
#: zsh.texi:40301
msgid ""
"specifies that @t{pick-web-browser} should first look for a running instance of Opera, Konqueror or Firefox, in that order, and if it fails to find any should attempt to start Opera.  The default is "
"@t{firefox mozilla netscape opera konqueror}."
msgstr "指定 @t{pick-web-browser}应首先依次查找 Opera、Konqueror 或 Firefox 的运行实例，如果未找到，则尝试启动 Opera。 默认值为 @t{firefox mozilla netscape opera konqueror}。"

#. type: t{#1}
#: zsh.texi:40302
#, no-wrap
msgid "tty-browsers"
msgstr "tty-browsers"

#. type: table
#: zsh.texi:40306
msgid "An array similar to @t{x-browsers}, except that it gives browsers to use when no X Window display is available.  The default is @t{elinks links lynx}."
msgstr "与 @t{x-browsers} 类似的数组，但它提供了在没有 X 窗口显示时使用的浏览器。 默认值为 @t{elinks links lynx}。"

#. type: table
#: zsh.texi:40320
msgid ""
"If it is set this style is used to pick the command used to open a page for a browser.  The context is @t{:mime:browser:new:$browser:} to start a new browser or @t{:mime:browser:running:$browser:} to open "
"a URL in a browser already running on the current X display, where @t{$browser} is the value matched in the @t{x-browsers} or @t{tty-browsers} style.  The escape sequence @t{%b} in the style's value will "
"be replaced by the browser, while @t{%u} will be replaced by the URL.  If the style is not set, the default for all new instances is equivalent to @t{%b %u} and the defaults for using running browsers are "
"equivalent to the values @t{kfmclient openURL %u} for Konqueror, @t{firefox -new-tab %u} for Firefox, @t{opera -newpage %u} for Opera, and @t{%b -remote \"openUrl(%u)\"} for all others."
msgstr ""
"如果设置了该样式，就可以选择用于打开浏览器页面的命令。 上下文为  @t{:mime:browser:new:$browser:} ，用于启动新浏览器；或  @t{:mime:browser:running:$browser:} ，用于在当前 X 显示器上已运行的浏览器中打开 "
"URL，其中 @t{$browser} 是 @t{x-browsers} 或 @t{tty-browsers} 样式中匹配的值。 样式值中的转义序列 @t{%b} 将被浏览器替换，而 @t{%u} 将被 URL 替换。 如果未设置样式，所有新实例的默认值相当于 @t{%b %u}，而使用"
"运行中浏览器的默认值相当于 Konqueror 的 @t{kfmclient openURL %u}、Firefox 的 @t{firefox -new-tab %u}、Opera 的 @t{opera -newpage %u}，以及所有其他浏览器的 @t{%b -remote \"openUrl(%u)\"} 值。"

#. type: node
#: zsh.texi:40326 zsh.texi:40615 zsh.texi:40617 zsh.texi:40673
#, no-wrap
msgid "User Configuration Functions"
msgstr "用户配置函数"

#. type: item
#: zsh.texi:40334
#, no-wrap
msgid "@t{zcalc} [ @t{-erf} ] [ @var{expression} ... ]"
msgstr "@t{zcalc} [ @t{-erf} ] [ @var{expression} ... ]"

#. type: table
#: zsh.texi:40339
msgid "A reasonably powerful calculator based on zsh's arithmetic evaluation facility.  The syntax is similar to that of formulae in most programming languages; see @ref{Arithmetic Evaluation} for details."
msgstr "一个基于 zsh 算术运算工具的相当强大的计算器。 其语法与大多数编程语言中的公式类似；详情请参见 @ref{算术求值}。"

#. type: table
#: zsh.texi:40348
msgid ""
"Non-programmers should note that, as in many other programming languages, expressions involving only integers (whether constants without a `@t{.}', variables containing such constants as strings, or "
"variables declared to be integers) are by default evaluated using integer arithmetic, which is not how an ordinary desk calculator operates.  To force floating point operation, pass the option @t{-f}; see "
"further notes below."
msgstr ""
"非编程人员应注意，与许多其他编程语言一样，只涉及整数的表达式（无论是不带 `@t{.}' 的常量、包含这样字符串常量的变量，还是声明为整数的变量）默认使用整数运算，这与普通台式计算器的操作方式不同。 要强制使用浮点"
"运算，可通过选项 @t{-f}；请参阅下面的进一步说明。"

#. type: table
#: zsh.texi:40357
msgid ""
"If the file @t{~/.zcalcrc} exists it will be sourced inside the function once it is set up and about to process the command line.  This can be used, for example, to set shell options; @t{emulate -L zsh} "
"and @t{setopt extendedglob} are in effect at this point.  Any failure to source the file if it exists is treated as fatal.  As with other initialisation files, the directory @t{$ZDOTDIR} is used instead "
"of @t{$HOME} if it is set."
msgstr ""
"如果 @t{~/.zcalcrc} 文件存在，一旦函数建立并准备处理命令行，就会在函数内部引入该文件。 例如，这可以用来设置 shell 选项；@t{emulate -L zsh} 和 @t{setopt extendedglob} 此时生效。 任何在存在文件的情况下未能引"
"入文件的失败都被视为致命的。与其他初始化文件一样，如果设置了目录 @t{$ZDOTDIR} ，则使用该目录而不是@t{$HOME}。"

#. type: table
#: zsh.texi:40364
msgid ""
"The mathematical library @t{zsh/mathfunc} will be loaded if it is available; see @ref{The zsh/mathfunc Module}.  The mathematical functions correspond to the raw system libraries, so trigonometric "
"functions are evaluated using radians, and so on."
msgstr "如果数学库 @t{zsh/mathfunc} 可用，它将被加载；请参阅 @ref{zsh/mathfunc 模块}。 数学函数与原始系统库相对应，因此三角函数使用弧度求值，等等。"

#. type: table
#: zsh.texi:40374
msgid ""
"Each line typed is evaluated as an expression.  The prompt shows a number, which corresponds to a positional parameter where the result of that calculation is stored.  For example, the result of the "
"calculation on the line preceded by `@t{4> }' is available as @t{$4}.  The last value calculated is available as @t{ans}.  Full command line editing, including the history of previous calculations, is "
"available; the history is saved in the file @t{~/.zcalc_history}.  To exit, enter a blank line or type `@t{:q}' on its own (`@t{q}' is allowed for historical compatibility)."
msgstr ""
"输入的每一行都作为一个表达式进行计算。 提示符会显示一个数字，该数字与存储计算结果的位置参数相对应。 例如，以 `@t{4> }' 开头的一行的计算结果以 @t{$4} 的形式提供。 最后一个计算值以 @t{ans} 的形式提供。 可以"
"使用完整的命令行编辑功能，包括以前的计算历史；历史记录保存在 @t{~/.zcalc_history} 文件中。 要退出，请输入空行或单独输入 `@t{:q}'（为了历史兼容性，允许输入 `@t{q}'）。"

#. type: table
#: zsh.texi:40382
msgid ""
"A line ending with a single backslash is treated in the same fashion as it is in command line editing: the backslash is removed, the function prompts for more input (the prompt is preceded by `@t{...}' to "
"indicate this), and the lines are combined into one to get the final result.  In addition, if the input so far contains more open than close parentheses @t{zcalc} will prompt for more input."
msgstr ""
"以单个反斜杠结束的行的处理方式与命令行编辑相同：删除反斜杠，函数提示输入更多内容（提示符前有 `@t{...}' 表示），然后将各行合并为一行，得到最终结果。 此外，如果目前输入的开括号多于闭括号，@t{zcalc} 将提示要"
"求输入更多内容。"

#. type: table
#: zsh.texi:40387
msgid "If arguments are given to @t{zcalc} on start up, they are used to prime the first few positional parameters.  A visual indication of this is given when the calculator starts."
msgstr "如果在 @t{zcalc} 启动时给定了参数，那么这些参数将被用于初始化前几个位置参数。 计算器启动时会给出直观提示。"

#. type: table
#: zsh.texi:40398
msgid ""
"The constants @t{PI} (3.14159...) and @t{E} (2.71828...) are provided.  Parameter assignment is possible, but note that all parameters will be put into the global namespace unless the @t{:local} special "
"command is used.  The function creates local variables whose names start with @t{_}, so users should avoid doing so.  The variables @t{ans} (the last answer) and @t{stack} (the stack in RPN mode) may be "
"referred to directly; @t{stack} is an array but elements of it are numeric.  Various other special variables are used locally with their standard meaning, for example @t{compcontext}, @t{match}, "
"@t{mbegin}, @t{mend}, @t{psvar}."
msgstr ""
"提供常量 @t{PI} (3.14159...) 和 @t{E}  (2.71828...)。 可以进行参数赋值，但需要注意的是，除非使用 @t{:local} 特殊命令，否则所有参数都将放入全局命名空间。 函数会创建名称以 @t{_} 开头的局部变量，因此用户应避"
"免这样做。 变量 @t{ans}（最后一个回应）和 @t{stack}（RPN 模式下的堆栈）可以直接引用；@t{stack} 是一个数组，但其中的元素是数字。其他各种特殊变量在本地使用时都有其标准含义，例如 @t{compcontext}、@t{match}、"
"@t{mbegin}、@t{mend}、@t{psvar}。"

#. type: table
#: zsh.texi:40403
msgid "The output base can be initialised by passing the option `@t{-#}@var{base}', for example `@t{zcalc -#16}' (the `@t{#}' may have to be quoted, depending on the globbing options set)."
msgstr "输出基数可以通过传递选项 `@t{-#}@var{base}' 来初始化，例如 `@t{zcalc -#16}'（ `@t{#}' 可能需要加引号，取决于设置的 globbing 选项）。"

#. type: table
#: zsh.texi:40408
msgid "If the option `@t{-e}' is set, the function runs non-interactively: the arguments are treated as expressions to be evaluated as if entered interactively line by line."
msgstr "如果设置了选项 `@t{-e}' ，函数将以非交互方式运行：参数被视为表达式，如同逐行交互输入一样进行计算。"

#. type: table
#: zsh.texi:40413
msgid "If the option `@t{-f}' is set, all numbers are treated as floating point, hence for example the expression `@t{3/4}' evaluates to 0.75 rather than 0.  Options must appear in separate words."
msgstr "如果设置了选项 `@t{-f}' ，所有数字都将被视为浮点数，因此例如表达式 `@t{3/4}' 的值为 0.75，而不是 0。 选项必须以单独的词出现。"

#. type: table
#: zsh.texi:40417
msgid "If the option `@t{-r}' is set, RPN (Reverse Polish Notation) mode is entered.  This has various additional properties:"
msgstr "如果设置了选项 `@t{-r}' ，则会进入 RPN（反波兰语符号）模式。 该模式具有多种附加属性："

#. type: item
#: zsh.texi:40418
#, no-wrap
msgid "Stack"
msgstr "栈"

#. type: table
#: zsh.texi:40421
msgid "Evaluated values are maintained in a stack; this is contained in an array named @t{stack} with the most recent value in @t{$@{stack[1]@}}."
msgstr "计算值保存在一个堆栈中；堆栈包含在一个名为 @t{stack} 的数组中，最新值保存在 @t{$@{stack[1]@}} 中。"

#. type: item
#: zsh.texi:40422
#, no-wrap
msgid "Operators and functions"
msgstr "操作符和函数"

#. type: table
#: zsh.texi:40429
msgid ""
"If the line entered matches an operator (@t{+}, @t{-}, @t{*}, @t{/}, @t{**}, @t{^}, @t{|} or @t{&}) or a function supplied by the @t{zsh/mathfunc} library, the bottom element or elements of the stack are "
"popped to use as the argument or arguments.  The higher elements of stack (least recent) are used as earlier arguments.  The result is then pushed into @t{$@{stack[1]@}}."
msgstr ""
"如果输入的行与运算符（@t{+}、@t{-}、@t{*}、@t{/}、@t{**}、@t{^}、@t{|} 或 @t{&}）或 @t{zsh/mathfunc} 库提供的函数相匹配，则会弹出堆栈的底部元素作为参数。 堆栈中较高的元素（最近的元素）会被用作较早的参数。 "
"然后将结果推入 @t{$@{stack[1]@}}。"

#. type: item
#: zsh.texi:40430
#, no-wrap
msgid "Expressions"
msgstr "表达式"

#. type: table
#: zsh.texi:40434
msgid "Other expressions are evaluated normally, printed, and added to the stack as numeric values.  The syntax within expressions on a single line is normal shell arithmetic (not RPN)."
msgstr "其他表达式将正常求值、打印并作为数值加入堆栈。 单行上的表达式语法是正常的 shell 运算（而不是 RPN）。"

#. type: item
#: zsh.texi:40435
#, no-wrap
msgid "Stack listing"
msgstr "栈列表"

#. type: table
#: zsh.texi:40441
msgid ""
"If an integer follows the option @t{-r} with no space, then on every evaluation that many elements of the stack, where available, are printed instead of just the most recent result.  Hence, for example, "
"@t{zcalc -r4} shows @t{$stack[4]} to @t{$stack[1]} each time results are printed."
msgstr ""
"如果选项 @t{-r} 后面的整数没有空格，那么在每次运算时，堆栈中的所有元素（如果有的话）都会被打印出来，而不是只打印最近的结果。因此，例如 @t{zcalc -r4} 在每次打印结果时将 @t{$stack[4]} 显示为 @t{$stack[1]}。"

#. type: item
#: zsh.texi:40442
#, no-wrap
msgid "Duplication: @t{=}"
msgstr "复制： @t{=}"

#. type: table
#: zsh.texi:40445
msgid "The pseudo-operator @t{=} causes the most recent element of the stack to be duplicated onto the stack."
msgstr "伪操作符 @t{=} 会将栈中最近的元素复制到栈上。"

#. type: t{#1}
#: zsh.texi:40446
#, no-wrap
msgid "pop"
msgstr "pop"

#. type: table
#: zsh.texi:40449
msgid "The pseudo-function @t{pop} causes the most recent element of the stack to be popped.  A `@t{>}' on its own has the same effect."
msgstr "伪函数 @t{pop} 将弹出堆栈中最近的元素。 单独使用 `@t{>}' 也有同样的效果。"

#. type: item
#: zsh.texi:40450
#, no-wrap
msgid "@t{>}@var{ident}"
msgstr "@t{>}@var{ident}"

#. type: table
#: zsh.texi:40455
msgid ""
"The expression @t{>} followed (with no space) by a shell identifier causes the most recent element of the stack to be popped and assigned to the variable with that name.  The variable is local to the "
"@t{zcalc} function."
msgstr "表达式 @t{>}（不带空格）后跟 shell 标识符，会导致弹出堆栈中最近的元素，并赋值给该名称的变量。 该变量是 @t{zcalc} 函数的局部变量。"

#. type: item
#: zsh.texi:40456
#, no-wrap
msgid "@t{<}@var{ident}"
msgstr "@t{<}@var{ident}"

#. type: table
#: zsh.texi:40462
msgid ""
"The expression @t{<} followed (with no space) by a shell identifier causes the value of the variable with that name to be pushed onto the stack.  @var{ident} may be an integer, in which case the previous "
"result with that number (as shown before the @t{>} in the standard @t{zcalc} prompt) is put on the stack."
msgstr ""
"表达式 @t{<} 后面（没有空格）跟一个 shell 标识符，会将该标识符名的变量的值推入堆栈。 @var{ident} 可以是一个整数，在这种情况下，带有该数字的前一个结果（如标准 @t{zcalc} 提示符中 @t{>} 之前所示）会被放入堆"
"栈。"

#. type: item
#: zsh.texi:40463
#, no-wrap
msgid "Exchange: @t{xy}"
msgstr "Exchange: @t{xy}"

#. type: table
#: zsh.texi:40466
msgid "The pseudo-function @t{xy} causes the most recent two elements of the stack to be exchanged.  `@t{<>}' has the same effect."
msgstr "伪函数 @t{xy} 会交换堆栈中最近的两个元素。 `@t{<>}' 具有相同的效果。"

#. type: table
#: zsh.texi:40475
msgid ""
"The prompt is configurable via the parameter @t{ZCALCPROMPT}, which undergoes standard prompt expansion.  The index of the current entry is stored locally in the first element of the array @t{psvar}, "
"which can be referred to in @t{ZCALCPROMPT} as `@t{%1v}'.  The default prompt is `@t{%1v> }'."
msgstr "提示符可通过参数 @t{ZCALCPROMPT} 进行配置，并进行标准的提示符扩展。 当前条目的索引存储在本地数组 @t{psvar} 的第一个元素中，可在 @t{ZCALCPROMPT} 中称为引用为 `@t{%1v}'。 默认提示符为 `@t{%1v> }'。"

#. type: table
#: zsh.texi:40480
msgid "The variable @t{ZCALC_ACTIVE} is set within the function and can be tested by nested functions; it has the value @t{rpn} if RPN mode is active, else 1."
msgstr "变量 @t{ZCALC_ACTIVE} 在函数内部设置，可以通过嵌套函数进行测试；如果 RPN 模式处于激活状态，则变量值为 @t{rpn}，否则为 1。"

#. type: table
#: zsh.texi:40485
msgid ""
"A few special commands are available; these are introduced by a colon.  For backward compatibility, the colon may be omitted for certain commands.  Completion is available if @t{compinit} has been run."
msgstr "有一些特殊命令可用；这些命令以冒号开头。 为了向后兼容，某些命令可以省略冒号。 如果运行了 @t{compinit}，则可以进行。"

#. type: table
#: zsh.texi:40489
msgid "The output precision may be specified within zcalc by special commands familiar from many calculators."
msgstr "输出精度可以在 zcalc 中通过许多计算器常用的特殊命令来指定。"

#. type: t{#1}
#: zsh.texi:40490
#, no-wrap
msgid ":norm"
msgstr ":norm"

#. type: table
#: zsh.texi:40493
msgid "The default output format.  It corresponds to the printf @t{%g} specification.  Typically this shows six decimal digits."
msgstr "默认输出格式。 它与 printf @t{%g} 规范相对应。 通常显示六位小数。"

#. type: item
#: zsh.texi:40494
#, no-wrap
msgid "@t{:sci} @var{digits}"
msgstr "@t{:sci} @var{digits}"

#. type: table
#: zsh.texi:40498
msgid ""
"Scientific notation, corresponding to the printf @t{%g} output format with the precision given by @var{digits}.  This produces either fixed point or exponential notation depending on the value output."
msgstr "科学计数法，对应 printf @t{%g} 输出格式，精度由 @var{digits} 给定。 根据输出值的不同，会产生定点或指数符号。"

#. type: item
#: zsh.texi:40499
#, no-wrap
msgid "@t{:fix} @var{digits}"
msgstr "@t{:fix} @var{digits}"

#. type: table
#: zsh.texi:40502
msgid "Fixed point notation, corresponding to the printf @t{%f} output format with the precision given by @var{digits}."
msgstr "定点符号，对应 printf @t{%f} 输出格式，精度由 @var{digits} 给出。"

#. type: item
#: zsh.texi:40503
#, no-wrap
msgid "@t{:eng} @var{digits}"
msgstr "@t{:eng} @var{digits}"

#. type: table
#: zsh.texi:40506
msgid "Exponential notation, corresponding to the printf @t{%E} output format with the precision given by @var{digits}."
msgstr "指数符号，对应 printf @t{%E} 输出格式，精度由 @var{digits} 给出。"

#. type: t{#1}
#: zsh.texi:40507
#, no-wrap
msgid ":raw"
msgstr ":raw"

#. type: table
#: zsh.texi:40511
msgid "Raw output: this is the default form of the output from a math evaluation.  This may show more precision than the number actually possesses."
msgstr "原始输出：这是数学运算输出的默认形式。 它显示的精度可能高于实际数字。"

#. type: table
#: zsh.texi:40516
msgid "Other special commands:"
msgstr "其他特殊命令："

#. type: item
#: zsh.texi:40517
#, no-wrap
msgid "@t{:!}@var{line...}"
msgstr "@t{:!}@var{line...}"

#. type: table
#: zsh.texi:40521
msgid "Execute @var{line...} as a normal shell command line.  Note that it is executed in the context of the function, i.e. with local variables.  Space is optional after @t{:!}."
msgstr "将 @var{line...} 作为普通 shell 命令行执行。 请注意，它是在函数的上下文中执行的，即与局部变量一起执行。 @t{:!} 后面的空格是可选项。"

#. type: item
#: zsh.texi:40522
#, no-wrap
msgid "@t{:local} @var{arg} ..."
msgstr "@t{:local} @var{arg} ..."

#. type: table
#: zsh.texi:40526
msgid "Declare variables local to the function.  Other variables may be used, too, but they will be taken from or put into the global scope."
msgstr "声明函数的局部变量。 也可以使用其他变量，但这些变量将从全局作用域中获取或放到全局作用域中。"

#. type: item
#: zsh.texi:40527
#, no-wrap
msgid "@t{:function} @var{name} [ @var{body} ]"
msgstr "@t{:function} @var{name} [ @var{body} ]"

#. type: table
#: zsh.texi:40532
msgid ""
"Define a mathematical function or (with no @var{body}) delete it.  @t{:function} may be abbreviated to @t{:func} or simply @t{:f}.  The @var{name} may contain the same characters as a shell function "
"name.  The function is defined using @t{zmathfuncdef}, see below."
msgstr ""
"定义一个数学函数，或（在没有 @var{body} 的情况下）删除该函数。 @t{:function} 可以缩写为 @t{:func}，或简化为 @t{:f}。 @var{name} 可以包含与 shell 函数名相同的字符。 函数使用 @t{zmathfuncdef} 进行定义，见下"
"文。"

#. type: table
#: zsh.texi:40535
msgid "Note that @t{zcalc} takes care of all quoting.  Hence for example:"
msgstr "请注意，@t{zcalc} 会处理所有引号。 因此，举例来说"

#. type: example
#: zsh.texi:40539
#, no-wrap
msgid ":f cube $1 * $1 * $1\n"
msgstr ":f cube $1 * $1 * $1\n"

#. type: table
#: zsh.texi:40549
msgid ""
"defines a function to cube the sole argument.  Functions so defined, or indeed any functions defined directly or indirectly using @t{functions -M}, are available to execute by typing only the name on the "
"line in RPN mode; this pops the appropriate number of arguments off the stack to pass to the function, i.e. 1 in the case of the example @t{cube} function.  If there are optional arguments only the "
"mandatory arguments are supplied by this means."
msgstr ""
"定义的函数的唯一参数。 如此定义的函数，或者任何直接或间接使用 @t{functions -M} 定义的函数，在 RPN 模式下只需在行上键入名称即可执行；这将从堆栈中弹出适当数量的参数传递给函数，例如,在 @t{cube} 函数的示例中"
"为 1。 如果有可选参数，则只提供必选参数。"

#. type: item
#: zsh.texi:40550
#, no-wrap
msgid "@t{[#}@var{base}@t{]}"
msgstr "@t{[#}@var{base}@t{]}"

#. type: table
#: zsh.texi:40559
msgid ""
"This is not a special command, rather part of normal arithmetic syntax; however, when this form appears on a line by itself the default output radix is set to @var{base}.  Use, for example, `@t{[#16]}' to "
"display hexadecimal output preceded by an indication of the base, or `@t{[##16]}' just to display the raw number in the given base.  Bases themselves are always specified in decimal. `@t{[#]}' restores "
"the normal output format.  Note that setting an output base suppresses floating point output; use `@t{[#]}' to return to normal operation."
msgstr ""
"这不是一条特殊的命令，而是正常算术语法的一部分；不过，当该形式单独出现在一行中时，默认输出基数(radix)将设置为 @var{base}。 例如，使用 `@t{[#16]}' 显示十六进制输出，并在前面标明基数，或使用`@t{[##16]}' 只显"
"示以给定基数表示的原始数字。 基数本身总是以十进制指定。`@t{[#]}' 则恢复正常的输出格式。 注意，设置输出基数会抑制浮点输出；使用 `@t{[#]}' 可恢复正常操作。"

#. type: item
#: zsh.texi:40560
#, no-wrap
msgid "@t{$}@var{var}"
msgstr "@t{$}@var{var}"

#. type: table
#: zsh.texi:40563
msgid "Print out the value of var literally; does not affect the calculation.  To use the value of var, omit the leading `@t{$}'."
msgstr "按字面意思打印 var 的值，不影响计算。 要使用 var 的值，请省略前导句 `@t{$}'。"

#. type: table
#: zsh.texi:40568
msgid "See the comments in the function for a few extra tips."
msgstr "请参阅函数中的注释，了解一些额外的提示。"

#. type: findex
#: zsh.texi:40569
#, no-wrap
msgid "max"
msgstr "max"

#. type: findex
#: zsh.texi:40570
#, no-wrap
msgid "min"
msgstr "min"

#. type: findex
#: zsh.texi:40571
#, no-wrap
msgid "sum"
msgstr "sum"

#. type: t{#1}
#: zsh.texi:40572 zsh.texi:40576
#, no-wrap
msgid "zmathfunc"
msgstr "zmathfunc"

#. type: item
#: zsh.texi:40573
#, no-wrap
msgid "@t{min(}@var{arg}@t{, ...)}"
msgstr "@t{min(}@var{arg}@t{, ...)}"

#. type: itemx
#: zsh.texi:40574
#, no-wrap
msgid "@t{max(}@var{arg}@t{, ...)}"
msgstr "@t{max(}@var{arg}@t{, ...)}"

#. type: itemx
#: zsh.texi:40575
#, no-wrap
msgid "@t{sum(}@var{arg}@t{, ...)}"
msgstr "@t{sum(}@var{arg}@t{, ...)}"

#. type: table
#: zsh.texi:40581
msgid ""
"The function @t{zmathfunc} defines the three mathematical functions @t{min}, @t{max}, and @t{sum}.  The functions @t{min} and @t{max} take one or more arguments.  The function @t{sum} takes zero or more "
"arguments.  Arguments can be of different types (ints and floats)."
msgstr "函数 @t{zmathfunc} 定义了三个数学函数 @t{min}、@t{max} 和 @t{sum}。 函数 @t{min} 和 @t{max} 接受一个或多个参数。 函数 @t{sum} 接受 0 个或多个参数。 参数可以是不同类型（整数和浮点数）。"

#. type: table
#: zsh.texi:40585
msgid "Not to be confused with the @t{zsh/mathfunc} module, described in @ref{The zsh/mathfunc Module}."
msgstr "不要与 @t{zsh/mathfunc} 模块混淆，该模块在 @ref{zsh/mathfunc 模块} 中有所描述。"

#. type: findex
#: zsh.texi:40586
#, no-wrap
msgid "zmathfuncdef"
msgstr "zmathfuncdef"

#. type: item
#: zsh.texi:40587
#, no-wrap
msgid "@t{zmathfuncdef} [ @var{mathfunc} [ @var{body} ] ]"
msgstr "@t{zmathfuncdef} [ @var{mathfunc} [ @var{body} ] ]"

#. type: table
#: zsh.texi:40589
msgid "A convenient front end to @t{functions -M}."
msgstr "@t{functions -M} 的便捷前端。"

#. type: table
#: zsh.texi:40602
msgid ""
"With two arguments, define a mathematical function named @var{mathfunc} which can be used in any form of arithmetic evaluation.  @var{body} is a mathematical expression to implement the function.  It may "
"contain references to position parameters @t{$1}, @t{$2}, ...  to refer to mandatory parameters and @t{$@{1:-}@var{defvalue}@t{@}} ...  to refer to optional parameters.  Note that the forms must be "
"strictly adhered to for the function to calculate the correct number of arguments.  The implementation is held in a shell function named @t{zsh_math_func_}@var{mathfunc}; usually the user will not need to "
"refer to the shell function directly.  Any existing function of the same name is silently replaced."
msgstr ""
"使用两个参数，定义一个名为 @var{mathfunc} 的数学函数，该函数可用于任何形式的算术运算。 @var{body} 是实现函数的数学表达式。 它可以引用位置参数 @t{$1}、@t{$2}, ... 来表示必选参数， @t{$@{1:-}@var{defvalue}"
"@t{@}} ... 来表示可选参数。请注意，必须严格遵守这些形式，函数才能计算出正确的参数数目。 函数的实现被保存在一个名为 @t{zsh_math_func_}@var{mathfunc} 的 shell 函数中；通常用户不需要直接引用 shell 函数。 任何"
"现有的同名函数都会被静默替换。"

#. type: table
#: zsh.texi:40606
msgid "With one argument, remove the mathematical function @var{mathfunc} as well as the shell function implementation."
msgstr "使用一个参数，删除数学函数 @var{mathfunc} 以及 shell 函数的实现。"

#. type: table
#: zsh.texi:40611
msgid "With no arguments, list all @var{mathfunc} functions in a form suitable for restoring the definition.  The functions have not necessarily been defined by @t{zmathfuncdef}."
msgstr "在没有参数的情况下，以适合还原定义的形式列出所有 @var{mathfunc} 函数。 这些函数不一定由 @t{zmathfuncdef} 定义。"

#. type: Plain text
#: zsh.texi:40626
msgid ""
"The @t{zsh/newuser} module comes with a function to aid in configuring shell options for new users.  If the module is installed, this function can also be run by hand.  It is available even if the "
"module's default behaviour, namely running the function for a new user logging in without startup files, is inhibited."
msgstr "@t{zsh/newuser} 模块自带一个函数，用于帮助新用户配置 shell 选项。 如果安装了该模块，也可以手动运行该函数。 即使模块的默认行为（即为没有启动文件的新用户登录运行该函数）被禁止，也可以使用该函数。"

#. type: item
#: zsh.texi:40629
#, no-wrap
msgid "@t{zsh-newuser-install} [ @t{-f} ]"
msgstr "@t{zsh-newuser-install} [ @t{-f} ]"

#. type: table
#: zsh.texi:40635
msgid ""
"The function presents the user with various options for customizing their initialization scripts.  Currently only @t{~/.zshrc} is handled.  @t{$ZDOTDIR/.zshrc} is used instead if the parameter @t{ZDOTDIR} "
"is set; this provides a way for the user to configure a file without altering an existing @t{.zshrc}."
msgstr "该函数为用户提供了多种自定义初始化脚本的选项。 目前只处理 @t{~/.zshrc}。 如果设置了参数 @t{ZDOTDIR}，则会使用 @t{$ZDOTDIR/.zshrc}；这为用户提供了一种无需更改现有 @t{.zshrc} 即可配置文件的方法。"

#. type: table
#: zsh.texi:40642
msgid ""
"By default the function exits immediately if it finds any of the files @t{.zshenv}, @t{.zprofile}, @t{.zshrc}, or @t{.zlogin} in the appropriate directory.  The option @t{-f} is required in order to force "
"the function to continue.  Note this may happen even if @t{.zshrc} itself does not exist."
msgstr ""
"默认情况下，如果在相应目录中找到 @t{.zshenv}、@t{.zprofile}、@t{.zshrc} 或 @t{.zlogin}，则函数会立即退出。 需要使用选项 @t{-f} 才能强制函数继续执行。 请注意，即使 @t{.zshrc} 本身不存在，也可能出现这种情"
"况。"

#. type: table
#: zsh.texi:40646
msgid "As currently configured, the function will exit immediately if the user has root privileges; this behaviour cannot be overridden."
msgstr "按照目前的配置，如果用户拥有 root 权限，函数将立即退出；该行为不可重写。"

#. type: table
#: zsh.texi:40652
msgid ""
"Once activated, the function's behaviour is supposed to be self-explanatory.  Menus are present allowing the user to alter the value of options and parameters.  Suggestions for improvements are always "
"welcome."
msgstr "一旦激活，函数的行为应该是不言自明的。 菜单出现以允许用户更改选项和参数的值。 欢迎提出改进建议。"

#. type: table
#: zsh.texi:40661
msgid ""
"When the script exits, the user is given the opportunity to save the new file or not; changes are not irreversible until this point.  However, the script is careful to restrict changes to the file only to "
"a group marked by the lines `@t{# Lines configured by zsh-newuser-install}' and `@t{# End of lines configured by zsh-newuser-install}'.  In addition, the old version of @t{.zshrc} is saved to a file with "
"the suffix @t{.zni} appended."
msgstr ""
"脚本退出时，用户有机会选择是否保存新文件；在此之前，更改并不是不可逆的。 不过，脚本会注意把更改限制在 `@t{# Lines configured by zsh-newuser-install}' 和 `@t{# End of lines configured by zsh-newuser-"
"install}' 这两行标记的组内。 此外，旧版本的 @t{.zshrc} 会保存到一个后缀名为 @t{.zni} 的文件中。"

#. type: table
#: zsh.texi:40669
msgid ""
"If the function edits an existing @t{.zshrc}, it is up to the user to ensure that the changes made will take effect.  For example, if control usually returns early from the existing @t{.zshrc} the lines "
"will not be executed; or a later initialization file may override options or parameters, and so on.  The function itself does not attempt to detect any such conflicts."
msgstr ""
"如果函数编辑了现有的 @t{.zshrc}，用户必须确保所做的更改会生效。 例如，如果控制权通常会提前从现有的 @t{.zshrc} 中返回，那么这些行将不会被执行；或者稍后的初始化文件可能会覆盖选项或参数，等等。 函数本身并不试"
"图检测任何此类冲突。"

#. type: Plain text
#: zsh.texi:40682
msgid ""
"There are a large number of helpful functions in the @t{Functions/Misc} directory of the zsh distribution.  Most are very simple and do not require documentation here, but a few are worthy of special "
"mention."
msgstr "在 zsh 发行版的 @t{Functions/Misc} 目录中有大量有用的函数。 大多数函数都非常简单，不需要在此提供文档，但有几个函数值得特别一提。"

#. type: subsection
#: zsh.texi:40685
#, no-wrap
msgid "Descriptions"
msgstr "说明"

#. type: table
#: zsh.texi:40696
msgid ""
"This function initializes several associative arrays to map color names to (and from) the ANSI standard eight-color terminal codes.  These are used by the prompt theme system (@ref{Prompt Themes}).  You "
"seldom should need to run @t{colors} more than once."
msgstr "该函数初始化多个关联数组，用于将颜色名称映射到（或从）ANSI 标准八色终端代码。 提示符主题系统（@ref{提示符主题}）将使用这些颜色。 您很少需要多次运行 @t{colors}。"

#. type: table
#: zsh.texi:40706
msgid ""
"The eight base colors are: @t{black}, @t{red}, @t{green}, @t{yellow}, @t{blue}, @t{magenta}, @t{cyan}, and @t{white}.  Each of these has codes for foreground and background.  In addition there are seven "
"intensity attributes: @t{bold}, @t{faint}, @t{standout}, @t{underline}, @t{blink}, @t{reverse}, and @t{conceal}.  Finally, there are seven codes used to negate attributes: @t{none} (reset all attributes "
"to the defaults), @t{normal} (neither bold nor faint), @t{no-standout}, @t{no-underline}, @t{no-blink}, @t{no-reverse}, and @t{no-conceal}."
msgstr ""
"八种基础色是@t{black}, @t{red}, @t{green}, @t{yellow}, @t{blue}, @t{magenta}, @t{cyan}和 @t{white}。 每个属性都有前景和背景代码。 此外，还有七个强度属性： @t{bold}, @t{faint}, @t{standout}, @t{underline}, "
"@t{blink}, @t{reverse}, 和 @t{conceal}。 最后，有七个代码用于否定属性： @t{none} （将所有属性重置为默认值）、@t{normal}（既不加粗也不模糊）、@t{no-standout}、@t{no-underline}、@t{no-blink}、@t{no-reverse}"
"和 @t{no-conceal}。"

#. type: table
#: zsh.texi:40709
msgid "Some terminals do not support all combinations of colors and intensities."
msgstr "某些终端不支持所有颜色和强度组合。"

#. type: table
#: zsh.texi:40712
msgid "The associative arrays are:"
msgstr "关联数组是:"

#. type: t{#1}
#: zsh.texi:40715
#, no-wrap
msgid "color"
msgstr "color"

#. type: t{#1}
#: zsh.texi:40716
#, no-wrap
msgid "colour"
msgstr "colour"

#. type: table
#: zsh.texi:40723
msgid ""
"Map all the color names to their integer codes, and integer codes to the color names.  The eight base names map to the foreground color codes, as do names prefixed with `@t{fg-}', such as `@t{fg-red}'.  "
"Names prefixed with `@t{bg-}', such as `@t{bg-blue}', refer to the background codes.  The reverse mapping from code to color yields base name for foreground codes and the @t{bg-} form for backgrounds."
msgstr ""
"将所有颜色名称映射到其整数代码，并将整数代码映射到颜色名称。 八个基本名称映射到前景色代码，名称的前缀为 `@t{fg-}' ，如 `@t{fg-red}'。 名称前缀为 `@t{bg-}' 的，如 `@t{bg-blue}' ，则表示背景颜色代码。 从代码"
"到颜色的反向映射产生前景代码的基本名称和背景代码的 @t{bg-} 形式。"

#. type: table
#: zsh.texi:40727
msgid "Although it is a misnomer to call them `colors', these arrays also map the other fourteen attributes from names to codes and codes to names."
msgstr "虽然将它们称为 `颜色' 有些名不副实，但这些数组也将其他 14 个属性从名称映射到代码，并将代码映射到名称。"

#. type: t{#1}
#: zsh.texi:40729
#, no-wrap
msgid "fg_bold"
msgstr "fg_bold"

#. type: t{#1}
#: zsh.texi:40730
#, no-wrap
msgid "fg_no_bold"
msgstr "fg_no_bold"

#. type: table
#: zsh.texi:40734
msgid ""
"Map the eight basic color names to ANSI terminal escape sequences that set the corresponding foreground text properties.  The @t{fg} sequences change the color without changing the eight intensity "
"attributes."
msgstr "将八种基本颜色名称映射到 ANSI 终端转义序列，以设置相应的前景文本属性。 @t{fg} 序列在不改变八个强度属性的情况下改变颜色。"

#. type: t{#1}
#: zsh.texi:40736
#, no-wrap
msgid "bg_bold"
msgstr "bg_bold"

#. type: t{#1}
#: zsh.texi:40737
#, no-wrap
msgid "bg_no_bold"
msgstr "bg_no_bold"

#. type: table
#: zsh.texi:40741
msgid ""
"Map the eight basic color names to ANSI terminal escape sequences that set the corresponding background properties.  The @t{bg} sequences change the color without changing the eight intensity attributes."
msgstr "将八种基本颜色名称映射到设置相应背景属性的 ANSI 终端转义序列。 @t{bg} 序列可在不改变八个强度属性的情况下改变颜色。"

#. type: table
#: zsh.texi:40748
msgid "In addition, the scalar parameters @t{reset_color} and @t{bold_color} are set to the ANSI terminal escapes that turn off all attributes and turn on bold intensity, respectively."
msgstr "此外，标量参数 @t{reset_color} 和 @t{bold_color} 被设置为 ANSI 终端转义符，分别用于关闭所有属性和打开粗体强度。"

#. type: findex
#: zsh.texi:40749
#, no-wrap
msgid "fned"
msgstr "fned"

#. type: item
#: zsh.texi:40750
#, no-wrap
msgid "@t{fned} [ @t{-x} @var{num} ] @var{name}"
msgstr "@t{fned} [ @t{-x} @var{num} ] @var{name}"

#. type: table
#: zsh.texi:40754
msgid "Same as @t{zed -f}.  This function does not appear in the zsh distribution, but can be created by linking @t{zed} to the name @t{fned} in some directory in your @t{fpath}."
msgstr "与 @t{zed -f} 相同。 此函数未出现在 zsh 发行版中，但可以通过将 @t{zed} 链接到 @t{fpath} 中某个目录下的 @t{fned} 来创建。"

#. type: findex
#: zsh.texi:40755
#, no-wrap
msgid "histed"
msgstr "histed"

#. type: item
#: zsh.texi:40756
#, no-wrap
msgid "@t{histed} [ [ @var{name} ] @var{size} ]"
msgstr "@t{histed} [ [ @var{name} ] @var{size} ]"

#. type: table
#: zsh.texi:40760
msgid "Same as @t{zed -h}.  This function does not appear in the zsh distribution, but can be created by linking @t{zed} to the name @t{histed} in some directory in your @t{fpath}."
msgstr "与 @t{zed -h} 相同。 此函数未出现在 zsh 发行版中，但可以通过将 @t{zed} 链接到 @t{fpath} 中某个目录下的 @t{histed} 名称来创建。"

#. type: findex
#: zsh.texi:40761
#, no-wrap
msgid "is-at-least"
msgstr "is-at-least"

#. type: item
#: zsh.texi:40762
#, no-wrap
msgid "@t{is-at-least} @var{needed} [ @var{present} ]"
msgstr "@t{is-at-least} @var{needed} [ @var{present} ]"

#. type: table
#: zsh.texi:40769
msgid ""
"Perform a greater-than-or-equal-to comparison of two strings having the format of a zsh version number; that is, a string of numbers and text with segments separated by dots or dashes.  If the "
"@var{present} string is not provided, @t{$ZSH_VERSION} is used.  Segments are paired left-to-right in the two strings with leading non-number parts ignored.  If one string has fewer segments than the "
"other, the missing segments are considered zero."
msgstr ""
"对两个字符串进行 `大于等于' 比较，这两个字符串的格式为 zsh 版本号，即由数字和文本组成的字符串，以点或破折号分隔。 如果未提供 @var{present} 字符串，则使用 @t{$ZSH_VERSION}。 两个字符串中的段落从左到右配对，"
"忽略前导的非数字部分。 如果一个字符串的段数少于另一个字符串，则缺失的段视为零。"

#. type: table
#: zsh.texi:40773
msgid "This is useful in startup files to set options and other state that are not available in all versions of zsh."
msgstr "这在启动文件中非常有用，可用于设置选项和其他状态（这些选项和状态在所有版本的 zsh 中都不可用）。"

#. type: example
#: zsh.texi:40779
#, no-wrap
msgid ""
"is-at-least 3.1.6-15 && setopt NO_GLOBAL_RCS\n"
"is-at-least 3.1.0 && setopt HIST_REDUCE_BLANKS\n"
"is-at-least 2.6-17 || print \"You can't use is-at-least here.\"\n"
msgstr ""
"is-at-least 3.1.6-15 && setopt NO_GLOBAL_RCS\n"
"is-at-least 3.1.0 && setopt HIST_REDUCE_BLANKS\n"
"is-at-least 2.6-17 || print \"You can't use is-at-least here.\"\n"

#. type: findex
#: zsh.texi:40781
#, no-wrap
msgid "nslookup"
msgstr "nslookup"

#. type: item
#: zsh.texi:40782
#, no-wrap
msgid "@t{nslookup} [ @var{arg} ... ]"
msgstr "@t{nslookup} [ @var{arg} ... ]"

#. type: table
#: zsh.texi:40790
msgid ""
"This wrapper function for the @t{nslookup} command requires the @t{zsh/zpty} module (see @ref{The zsh/zpty Module}).  It behaves exactly like the standard @t{nslookup} except that it provides customizable "
"prompts (including a right-side prompt) and completion of nslookup commands, host names, etc. (if you use the function-based completion system).  Completion styles may be set with the context prefix `@t{:"
"completion:nslookup}'."
msgstr ""
"@t{nslookup} 命令的封装函数需要 @t{zsh/zpty} 模块（参见 @ref{zsh/zpty 模块}）。 除了提供可定制的提示符（包括右侧提示符）和 nslookup 命令、主机名等的补全（如果使用基于函数的补全系统）外，它的行为与标准 "
"@t{nslookup} 完全相同。 可以使用上下文前缀 `@t{:completion:nslookup}' 设置补全样式。"

#. type: table
#: zsh.texi:40793
msgid "See also the @t{pager}, @t{prompt} and @t{rprompt} styles below."
msgstr "另请参阅下面的 @t{pager}、@t{prompt} 和 @t{rprompt} 样式。"

#. type: findex
#: zsh.texi:40794
#, no-wrap
msgid "regexp-replace"
msgstr "regexp-replace"

#. type: item
#: zsh.texi:40795
#, no-wrap
msgid "@t{regexp-replace} @var{var} @var{regexp} @var{replace}"
msgstr "@t{regexp-replace} @var{var} @var{regexp} @var{replace}"

#. type: table
#: zsh.texi:40802
msgid ""
"Use regular expressions to perform a global search and replace operation on a variable.  POSIX extended regular expressions (ERE) are used, unless the option @t{RE_MATCH_PCRE} has been set, in which case "
"Perl-compatible regular expressions are used (this requires the shell to be linked against the @t{pcre} library)."
msgstr "使用正则表达式对变量执行全局搜索和替换操作。 使用 POSIX 扩展正则表达式（ERE），除非设置了 @t{RE_MATCH_PCRE} 选项，这时将使用 Perl 兼容的正则表达式（这要求 shell 与 @t{pcre} 库链接）。"

#. type: table
#: zsh.texi:40808
msgid ""
"@var{var} is the name of the variable containing the string to be matched.  The variable will be modified directly by the function.  The variables @t{MATCH}, @t{MBEGIN}, @t{MEND}, @t{match}, @t{mbegin}, "
"@t{mend} should be avoided as these are used by the regular expression code."
msgstr "@var{var} 是包含要匹配字符串的变量名。 函数将直接修改该变量。 应避免使用变量 @t{MATCH}、@t{MBEGIN}、@t{MEND}、@t{match}、@t{mbegin}、@t{mend}，因为这些变量会被正则表达式使用。"

#. type: table
#: zsh.texi:40811
msgid "@var{regexp} is the regular expression to match against the string."
msgstr "@var{regexp} 是要与字符串匹配的正则表达式。"

#. type: table
#: zsh.texi:40816
msgid ""
"@var{replace} is the replacement text.  This can contain parameter, command and arithmetic expressions which will be replaced: in particular, a reference to @t{$MATCH} will be replaced by the text matched "
"by the pattern."
msgstr "@var{replace} 是替换文本。 它可以包含将被替换的参数、命令和算术表达式：特别是，对 @t{$MATCH} 的引用将被模式匹配的文本替换。"

#. type: table
#: zsh.texi:40819
msgid "The return status is 0 if at least one match was performed, else 1."
msgstr "如果至少进行了一次匹配，则返回状态为 0，否则为 1。"

#. type: table
#: zsh.texi:40823
msgid "Note that if using POSIX EREs, the @t{^} or word boundary operators (where available) may not work properly."
msgstr "请注意，如果使用 POSIX EREs，@t{^} 或字边界运算符（如果有）可能无法正常工作。"

#. type: item
#: zsh.texi:40825
#, no-wrap
msgid "@t{run-help} @var{cmd}"
msgstr "@t{run-help} @var{cmd}"

#. type: table
#: zsh.texi:40829
msgid "This function is designed to be invoked by the @t{run-help} ZLE widget, in place of the default alias.  See `Accessing On-Line Help' (@ref{Utilities}) for setup instructions."
msgstr "该函数可由 @t{run-help} ZLE 小部件调用，以取代默认的别名。有关设置说明，请参阅 `获取在线帮助'（@ref{实用程序}）。"

#. type: table
#: zsh.texi:40833
msgid "In the discussion which follows, if @var{cmd} is a file system path, it is first reduced to its rightmost component (the file name)."
msgstr "在接下来的讨论中，如果 @var{cmd} 是一个文件系统路径，则首先将其简化为最右边的部分（文件名）。"

#. type: table
#: zsh.texi:40842
msgid ""
"Help is first sought by looking for a file named @var{cmd} in the directory named by the @t{HELPDIR} parameter.  If no file is found, an assistant function, alias, or command named @t{run-help-@var{cmd}} "
"is sought.  If found, the assistant is executed with the rest of the current command line (everything after the command name @var{cmd}) as its arguments.  When neither file nor assistant is found, the "
"external command `@t{man} @var{cmd}' is run."
msgstr ""
"首先会在 @t{HELPDIR} 参数指定的目录下查找名为 @var{cmd} 的文件，以获得帮助。 如果没有找到文件，则会查找名为 @t{run-help-@var{cmd}} 的辅助函数、别名或命令。 如果找到，将以当前命令行的其余部分（命令名 "
"@var{cmd} 后面的所有内容）作为参数执行该辅助函数。 如果既未找到文件也未找到辅助函数，则执行外部命令 `@t{man} @var{cmd}' 。"

#. type: table
#: zsh.texi:40845
msgid "An example assistant for the \"ssh\" command:"
msgstr "\"ssh\" 命令的助手示例："

#. type: example
#: zsh.texi:40861
#, no-wrap
msgid ""
"run-help-ssh() @{\n"
"    emulate -LR zsh\n"
"    local -a args\n"
"    # Delete the \"-l username\" option\n"
"    zparseopts -D -E -a args l:\n"
"    # Delete other options, leaving: host command\n"
"    args=($@{@@:#-*@})\n"
"    if [[ $@{#args@} -lt 2 ]]; then\n"
"        man ssh\n"
"    else\n"
"        run-help $args[2]\n"
"    fi\n"
"@}\n"
msgstr ""
"run-help-ssh() @{\n"
"    emulate -LR zsh\n"
"    local -a args\n"
"    # Delete the \"-l username\" option\n"
"    zparseopts -D -E -a args l:\n"
"    # Delete other options, leaving: host command\n"
"    args=($@{@@:#-*@})\n"
"    if [[ $@{#args@} -lt 2 ]]; then\n"
"        man ssh\n"
"    else\n"
"        run-help $args[2]\n"
"    fi\n"
"@}\n"

#. type: table
#: zsh.texi:40867
msgid ""
"Several of these assistants are provided in the @t{Functions/Misc} directory.  These must be autoloaded, or placed as executable scripts in your search path, in order to be found and used by @t{run-help}."
msgstr "@t{Functions/Misc} 目录中提供了多个此类助手。 这些辅助工具必须自动加载，或作为可执行脚本放在搜索路径中，以便 @t{run-help} 查找和使用。"

#. type: t{#1}
#: zsh.texi:40870 zsh.texi:40878
#, no-wrap
msgid "run-help-btrfs"
msgstr "run-help-btrfs"

#. type: t{#1}
#: zsh.texi:40871 zsh.texi:40879
#, no-wrap
msgid "run-help-git"
msgstr "run-help-git"

#. type: t{#1}
#: zsh.texi:40872 zsh.texi:40880
#, no-wrap
msgid "run-help-ip"
msgstr "run-help-ip"

#. type: t{#1}
#: zsh.texi:40873 zsh.texi:40881
#, no-wrap
msgid "run-help-openssl"
msgstr "run-help-openssl"

#. type: t{#1}
#: zsh.texi:40874 zsh.texi:40882
#, no-wrap
msgid "run-help-p4"
msgstr "run-help-p4"

#. type: t{#1}
#: zsh.texi:40875 zsh.texi:40883
#, no-wrap
msgid "run-help-sudo"
msgstr "run-help-sudo"

#. type: t{#1}
#: zsh.texi:40876 zsh.texi:40884
#, no-wrap
msgid "run-help-svk"
msgstr "run-help-svk"

#. type: t{#1}
#: zsh.texi:40877 zsh.texi:40885
#, no-wrap
msgid "run-help-svn"
msgstr "run-help-svn"

#. type: table
#: zsh.texi:40897
msgid "Assistant functions for the @t{btrfs}, @t{git}, @t{ip}, @t{openssl}, @t{p4}, @t{sudo}, @t{svk}, and @t{svn}, commands."
msgstr "@t{btrfs}, @t{git}, @t{ip}, @t{openssl}, @t{p4}, @t{sudo}, @t{svk}, 和 @t{svn} 命令的辅助函数."

#. type: t{#1}
#: zsh.texi:40900
#, no-wrap
msgid "tetris"
msgstr "tetris"

#. type: table
#: zsh.texi:40904
msgid "Zsh was once accused of not being as complete as Emacs, because it lacked a Tetris game.  This function was written to refute this vicious slander."
msgstr "Zsh 曾被指责不如 Emacs 完整，因为它缺少俄罗斯方块游戏。 编写这个函数就是为了驳斥这种恶毒的诽谤。"

#. type: table
#: zsh.texi:40907
msgid "This function must be used as a ZLE widget:"
msgstr "该功能必须作为 ZLE 小部件使用："

#. type: example
#: zsh.texi:40913
#, no-wrap
msgid ""
"autoload -U tetris\n"
"zle -N tetris\n"
"bindkey @var{keys} tetris\n"
msgstr ""
"autoload -U tetris\n"
"zle -N tetris\n"
"bindkey @var{keys} tetris\n"

#. type: table
#: zsh.texi:40920
msgid ""
"To start a game, execute the widget by typing the @var{keys}.  Whatever command line you were editing disappears temporarily, and your keymap is also temporarily replaced by the Tetris control keys.  The "
"previous editor state is restored when you quit the game (by pressing `@t{q}') or when you lose."
msgstr "要开始游戏，请输入 @var{keys} 执行小部件。 你正在编辑的命令行会暂时消失，你的键映射也会被俄罗斯方块控制键暂时取代。 退出游戏（按下 `@t{q}' ）或输掉游戏后，编辑器将恢复之前的状态。"

#. type: table
#: zsh.texi:40925
msgid "If you quit in the middle of a game, the next invocation of the @t{tetris} widget will continue where you left off.  If you lost, it will start a new game."
msgstr "如果您在游戏中途退出，下一次调用 @t{tetris} 小部件时，游戏将继续进行。 如果输了，则会重新开始游戏。"

#. type: t{#1}
#: zsh.texi:40926
#, no-wrap
msgid "tetriscurses"
msgstr "tetriscurses"

#. type: table
#: zsh.texi:40930
msgid "This is a port of the above to zcurses.  The input handling is improved a bit so that moving a block sideways doesn't automatically advance a timestep, and the graphics use unicode block graphics."
msgstr "这是上面内容的 zcurses 移植版。 输入处理稍微改进了一点，这样移动方块时不会自动推进一个时间步，并且图形使用了 Unicode 方块图形。"

#. type: table
#: zsh.texi:40934
msgid "This version does not save the game state between invocations, and is not invoked as a widget, but rather as:"
msgstr "该版本不会在两次调用之间保存游戏状态，也不会以小部件的形式调用，而是以："

#. type: example
#: zsh.texi:40939
#, no-wrap
msgid ""
"autoload -U tetriscurses\n"
"tetriscurses\n"
msgstr ""
"autoload -U tetriscurses\n"
"tetriscurses\n"

#. type: item
#: zsh.texi:40942
#, no-wrap
msgid "@t{zargs} [ @var{option} ... @t{-}@t{-} ] [ @var{input} ... ] [ @t{-}@t{-} @var{command} [ @var{arg} ... ] ]"
msgstr "@t{zargs} [ @var{option} ... @t{-}@t{-} ] [ @var{input} ... ] [ @t{-}@t{-} @var{command} [ @var{arg} ... ] ]"

#. type: table
#: zsh.texi:40948
msgid ""
"This function has a similar purpose to GNU xargs.  Instead of reading lines of arguments from the standard input, it takes them from the command line.  This is useful because zsh, especially with "
"recursive glob operators, often can construct a command line for a shell function that is longer than can be accepted by an external command."
msgstr "该函数的作用与 GNU xargs 类似。 它不是从标准输入中读取参数行，而是从命令行中获取参数。 这很有用，因为 zsh（尤其是使用递归 glob 操作符时）经常可以为 shell 函数构造出比外部命令所能接受的更长的命令行。"

#. type: table
#: zsh.texi:40959
msgid ""
"The @var{option} list represents options of the @t{zargs} command itself, which are the same as those of @t{xargs}.  The @var{input} list is the collection of strings (often file names) that become the "
"arguments of the @t{command}, analogous to the standard input of @t{xargs}.  Finally, the @var{arg} list consists of those arguments (usually options) that are passed to the @var{command} each time it "
"runs.  The @var{arg} list precedes the elements from the @t{input} list in each run.  If no @var{command} is provided, then no @var{arg} list may be provided, and in that event the default command is "
"`@t{print}' with arguments `@t{-r -}@t{-}'."
msgstr ""
"@var{option} 列表代表 @t{zargs} 命令本身的选项，与 @t{xargs} 的选项相同。 @var{input} 列表是字符串（通常是文件名）的集合，它们将成为 @t{command} 的参数，类似于 @t{xargs} 的标准输入。 最后，@var{arg} 列表包"
"含每次运行 @var{command} 时传递给它的参数（通常是选项）。 每次运行时，@var{arg} 列表都位于 @t{input} 列表元素之前。如果没有提供 @var{command}，则不能提供 @var{arg} 列表。在这种情况下，默认命令是带有参数 "
"`@t{-r -}@t{-}' 的 `@t{print}' 。"

#. type: table
#: zsh.texi:40963
msgid "For example, to get a long @t{ls} listing of all non-hidden plain files in the current directory or its subdirectories:"
msgstr "例如，要获取当前目录或其子目录中所有非隐藏普通（plain）文件的 @t{ls} 长列表："

#. type: example
#: zsh.texi:40968
#, no-wrap
msgid ""
"autoload -U zargs\n"
"zargs -- **/*(.) -- ls -ld --\n"
msgstr ""
"autoload -U zargs\n"
"zargs -- **/*(.) -- ls -ld --\n"

#. type: table
#: zsh.texi:40975
msgid ""
"The first and third occurrences of `@t{-}@t{-}' are used to mark the end of options for @t{zargs} and @t{ls} respectively to guard against filenames starting with `@t{-}', while the second is used to "
"separate the list of files from the command to run (`@t{ls -ld --}')."
msgstr "第一和第三次出现的 `@t{-}@t{-}' 分别用来标记 @t{zargs} 和 @t{ls} 的选项的末尾，以防止文件名以 `@t{-}' 开头，而第二次出现的 `@t{-}' 则用来分隔文件列表和要运行的命令（`@t{ls -ld --}'）。"

#. type: table
#: zsh.texi:40979
msgid "The first `@t{-}@t{-}' would also be needed if there was a chance the list might be empty as in:"
msgstr "如果列表有可能是空的，也需要第一个 `@t{-}@t{-}' ："

#. type: example
#: zsh.texi:40983
#, no-wrap
msgid "zargs -r -- ./*.back(#qN) -- rm -f\n"
msgstr "zargs -r -- ./*.back(#qN) -- rm -f\n"

#. type: table
#: zsh.texi:40990
msgid ""
"In the event that the string `@t{-}@t{-}' is or may be an @var{input}, the @t{-e} option may be used to change the end-of-inputs marker.  Note that this does @emph{not} change the end-of-options marker.  "
"For example, to use `@t{..}' as the marker:"
msgstr "如果字符串 `@t{-}@t{-}' 是或可能是 @var{input}（输入），可以使用 @t{-e} 选项来更改输入结束标记。 需要注意的是，这@emph{不会} 改变选项结束标记。 例如，使用 `@t{..}' 作为标记："

#. type: example
#: zsh.texi:40994
#, no-wrap
msgid "zargs -e.. -- **/*(.) .. ls -ld --\n"
msgstr "zargs -e.. -- **/*(.) .. ls -ld --\n"

#. type: table
#: zsh.texi:40999
msgid "This is a good choice in that example because no plain file can be named `@t{..}', but the best end-marker depends on the circumstances."
msgstr "在该示例中，这是一个不错的选择，因为任何普通文件都不能命名为  `@t{..}'，但最佳的结束标记取决于具体情况。"

#. type: table
#: zsh.texi:41007
msgid ""
"The options @t{-i}, @t{-I}, @t{-l}, @t{-L}, and @t{-n} differ slightly from their usage in @t{xargs}.  There are no input lines for @t{zargs} to count, so @t{-l} and @t{-L} count through the @var{input} "
"list, and @t{-n} counts the number of arguments passed to each execution of @var{command}, @emph{including} any @var{arg} list.  Also, any time @t{-i} or @t{-I} is used, each @var{input} is processed "
"separately as if by `@t{-L} @t{1}'."
msgstr ""
"选项 @t{-i}、@t{-I}、@t{-l}、@t{-L} 和 @t{-n} 与 @t{xargs} 中的用法略有不同。 @t{zargs} 没有输入行可供计数，因此 @t{-l} 和 @t{-L} 会对 @var{input} 列表进行计数，而 @t{-n} 则会对 @var{command} 的每次执行所"
"传递的参数进行计数，@emph{包括} 任何 @var{arg} 列表。 此外，在使用 @t{-i} 或 @t{-I} 时，每个 @var{input} 都会被单独处理，就像使用 `@t{-L} @t{1}' 一样。"

#. type: table
#: zsh.texi:41012
msgid "For details of the other @t{zargs} options, see the xargs(1) man page (but note the difference in function between @t{zargs} and @t{xargs}) or run @t{zargs} with the @t{-}@t{-help} option."
msgstr "有关其他 @t{zargs} 选项的详情，请参阅 xargs(1) 手册（但请注意 @t{zargs} 和 @t{xargs} 在功能上的区别），或使用 @t{-}@t{-help} 选项运行 @t{zargs}。"

#. type: findex
#: zsh.texi:41013
#, no-wrap
msgid "zed"
msgstr "zed"

#. type: item
#: zsh.texi:41014
#, no-wrap
msgid "@t{zed} [ @t{-f} [ @t{-x} @var{num} ] ] @var{name}"
msgstr "@t{zed} [ @t{-f} [ @t{-x} @var{num} ] ] @var{name}"

#. type: itemx
#: zsh.texi:41015
#, no-wrap
msgid "@t{zed} [ @t{-h} [ @var{name} ] @var{size} ]"
msgstr "@t{zed} [ @t{-h} [ @var{name} ] @var{size} ]"

#. type: t{#1}
#: zsh.texi:41016
#, no-wrap
msgid "zed -b"
msgstr "zed -b"

#. type: table
#: zsh.texi:41018
msgid "This function uses the ZLE editor to edit a file or function."
msgstr "该函数使用 ZLE 编辑器编辑文件或函数。"

#. type: table
#: zsh.texi:41029
msgid ""
"Only one @var{name} argument is allowed.  If the @t{-f} option is given, the name is taken to be that of a function; if the function is marked for autoloading, @t{zed} searches for it in the @t{fpath} and "
"loads it.  Note that functions edited this way are installed into the current shell, but @emph{not} written back to the autoload file.  In this case the @t{-x} option specifies that leading tabs indenting "
"the function according to syntax should be converted into the given number of spaces; `@t{-x 2}' is consistent with the layout of functions distributed with the shell."
msgstr ""
"只允许使用一个 @var{name} 参数。 如果给出 @t{-f} 选项，名称将被视为函数名称；如果函数被标记为自动加载，@t{zed} 将在 @t{fpath} 中搜索并加载该函数。 请注意，以这种方式编辑的函数会安装到当前 shell 中，但 "
"@emph{不} 会写回自动加载文件。 在这种情况下，@t{-x} 选项指定将根据语法对函数进行缩进，前导制表符转换为给定数量的空格；`@t{-x 2}' 与 shell 随附的函数布局一致。"

#. type: table
#: zsh.texi:41034
msgid "Without @t{-f}, @var{name} is the path name of the file to edit, which need not exist; it is created on write, if necessary.  With @t{-h}, the file is presumed to contain history events."
msgstr "在没有 @t{-f} 的情况下，@var{name} 是要编辑的文件的路径名，该文件不一定存在；如有必要，会在写入时创建。 如果使用 @t{-h}，则假定文件包含历史事件。"

#. type: table
#: zsh.texi:41038
msgid "When no file name is provided for @t{-h} the current shell history is edited in place.  The history is renumbered when zed exits successfully."
msgstr "如果没有为 @t{-h} 提供文件名，当前的 shell 历史记录将被编辑(in place)。 当 zed 成功退出后，历史记录将重新编号。"

#. type: table
#: zsh.texi:41042
msgid "When editing history, multi-line events must have a trailing backslash on every line before the last."
msgstr "编辑历史记录时，多行事件在最后一行之前的每一行都必须有一个尾部反斜线。"

#. type: table
#: zsh.texi:41048
msgid ""
"While editing, the function sets the main keymap to @t{zed} and the vi command keymap to @t{zed-vicmd}.  These will be copied from the existing @t{main} and @t{vicmd} keymaps if they do not exist the "
"first time @t{zed} is run.  They can be used to provide special key bindings used only in zed."
msgstr ""
"编辑时，函数会将主键映射设置为 @t{zed}，将 vi 命令键映射设置为 @t{zed-vicmd}。 如果首次运行 @t{zed} 时 @t{main} 和 @t{vicmd} 键映射不存在，则将从现有的 @t{main} 和 @t{vicmd} 键映射中复制这些映射。 它们可用"
"于提供仅在 zed 中使用的特殊按键绑定。"

#. type: table
#: zsh.texi:41053
msgid ""
"If it creates the keymap, @t{zed} rebinds the return key to insert a line break and `@t{^X^W}' to accept the edit in the @t{zed} keymap, and binds `@t{ZZ}' to accept the edit in the @t{zed-vicmd} keymap."
msgstr "如果创建了键映射，@t{zed} 会重新绑定回车键以插入换行符，并绑定 `@t{^X^W}' 以接受 @t{zed} 键映射中的编辑，同时绑定 `@t{ZZ}' 以接受 @t{zed-vicmd} 键映射中的编辑。"

#. type: table
#: zsh.texi:41058
msgid ""
"The bindings alone can be installed by running `@t{zed -b}'.  This is suitable for putting into a startup file.  Note that, if rerun, this will overwrite the existing @t{zed} and @t{zed-vicmd} keymaps."
msgstr "运行 `@t{zed -b}' 可单独安装绑定。 这适合放入启动文件。 请注意，如果重新运行，将覆盖现有的 @t{zed} 和 @t{zed-vicmd} 键映射。"

#. type: table
#: zsh.texi:41062
msgid "Completion is available, and styles may be set with the context prefix `@t{:completion:zed:}'."
msgstr "可使用补全功能，并可使用上下文前缀 `@t{:completion:zed:}' 设置样式。"

#. type: findex
#: zsh.texi:41064
#, no-wrap
msgid "zed-set-file-name"
msgstr "zed-set-file-name"

#. type: table
#: zsh.texi:41076
msgid ""
"A zle widget @t{zed-set-file-name} is available.  This can be called by name from within zed using `@t{\\ex zed-set-file-name}' or can be bound to a key in either of the @t{zed} or @t{zed-vicmd} keymaps "
"after `@t{zed -b}' has been run.  When the widget is called, it prompts for a new name for the file being edited.  When zed exits the file will be written under that name and the original file will be "
"left alone.  The widget has no effect when invoked from `@t{zed -f}'.  The completion context is changed to `@t{:completion:zed-set-file-name:}'.  When editing the current history with `@t{zed -h}', the "
"history is first updated and then the file is written, but the global setting of @t{HISTFILE} is not altered."
msgstr ""
"可使用一个 zle 小部件 @t{zed-set-file-name}。你可以在 zed 内部使用`@t{\\ex zed-set-file-name}' 调用它，也可以在运行 `@t{zed -b}' 后将它绑定到 @t{zed} 或 @t{zed-vicmd} 键映射中的某个键上。 调用该小部件时，"
"它会提示为正在编辑的文件取一个新名称。 当 zed 退出时，文件将以该名称写入，而原始文件将保持不变。 从 `@t{zed -f}' 调用时，该小部件无效。 补全上下文更改为 `@t{:completion:zed-set-file-name:}'。 使用`@t{zed -"
"h}' 编辑当前历史时，首先更新历史，然后写入文件，但 @t{HISTFILE} 的全局设置不会改变。"

#. type: table
#: zsh.texi:41083
msgid ""
"While @t{zed-set-file-name} is running, zed uses the keymap @t{zed-normal-keymap}, which is linked from the main keymap in effect at the time zed initialised its bindings.  (This is to make the return key "
"operate normally.)  The result is that if the main keymap has been changed, the widget won't notice.  This is not a concern for most users."
msgstr ""
"当 @t{zed-set-file-name} 运行时，zed 会使用 @t{zed-normal-keymap} 的键映射，该键映射与 zed 初始化绑定时有效的主键映射相连。 (这是为了让返回键正常工作。）这样做的结果是，如果主键映射发生变化，小部件不会察"
"觉。 这对大多数用户来说并不重要。"

#. type: findex
#: zsh.texi:41084
#, no-wrap
msgid "zcp"
msgstr "zcp"

#. type: findex
#: zsh.texi:41085
#, no-wrap
msgid "zln"
msgstr "zln"

#. type: item
#: zsh.texi:41086
#, no-wrap
msgid "@t{zcp} [ @t{-finqQvwW} ] @var{srcpat} @var{dest}"
msgstr "@t{zcp} [ @t{-finqQvwW} ] @var{srcpat} @var{dest}"

#. type: itemx
#: zsh.texi:41087
#, no-wrap
msgid "@t{zln} [ @t{-finqQsvwW} ] @var{srcpat} @var{dest}"
msgstr "@t{zln} [ @t{-finqQsvwW} ] @var{srcpat} @var{dest}"

#. type: table
#: zsh.texi:41091
msgid ""
"Same as @t{zmv -C} and @t{zmv -L}, respectively.  These functions do not appear in the zsh distribution, but can be created by linking @t{zmv} to the names @t{zcp} and @t{zln} in some directory in your "
"@t{fpath}."
msgstr "分别与 @t{zmv -C} 和 @t{zmv -L} 相同。 这些函数并未出现在 zsh 发行版中，但可以通过将 @t{zmv} 链接到  @t{fpath} 中的某个目录里的@t{zcp} 和 @t{zln} 来创建。"

#. type: table
#: zsh.texi:41095
msgid "See `Keyboard Definition' (@ref{Utilities})."
msgstr "请参阅 `键盘定义'（@ref{实用程序}）。"

#. type: item
#: zsh.texi:41098
#, no-wrap
msgid "@t{zmv} [ @t{-finqQsvwW} ] [ @t{-C} | @t{-L} | @t{-M} | -@{@t{p}|@t{P}@} @var{program} ] [ @t{-o} @var{optstring} ]"
msgstr "@t{zmv} [ @t{-finqQsvwW} ] [ @t{-C} | @t{-L} | @t{-M} | -@{@t{p}|@t{P}@} @var{program} ] [ @t{-o} @var{optstring} ]"

#. type: itemx
#: zsh.texi:41099
#, no-wrap
msgid "@t{@ @ @ @ }@var{srcpat} @var{dest}"
msgstr "@t{@ @ @ @ }@var{srcpat} @var{dest}"

#. type: table
#: zsh.texi:41104
msgid ""
"Move (usually, rename) files matching the pattern @var{srcpat} to corresponding files having names of the form given by @var{dest}, where @var{srcpat} contains parentheses surrounding patterns which will "
"be replaced in turn by @t{$1}, @t{$2}, ... in @var{dest}.  For example,"
msgstr "移动（通常是重命名）与 @var{srcpat} 模式匹配的文件，到名称与 @var{dest} 所给形式相同的相应文件，其中 @var{srcpat} 包含围绕模式的括号，这些模式将依次被 @var{dest} 中的 @t{$1}、@t{$2}...替换。 例如"

#. type: example
#: zsh.texi:41108
#, no-wrap
msgid "zmv '(*).lis' '$1.txt'\n"
msgstr "zmv '(*).lis' '$1.txt'\n"

#. type: table
#: zsh.texi:41113
msgid "renames `@t{foo.lis}' to `@t{foo.txt}', `@t{my.old.stuff.lis}' to `@t{my.old.stuff.txt}', and so on."
msgstr "将 `@t{foo.lis}' 重命名为 `@t{foo.txt}' ，将`@t{my.old.stuff.lis}' 重命名为`@t{my.old.stuff.lis}' ，以此类推。"

#. type: table
#: zsh.texi:41121
msgid ""
"The pattern is always treated as an @t{EXTENDED_GLOB} pattern.  Any file whose name is not changed by the substitution is simply ignored.  Any error (a substitution resulted in an empty string, two "
"substitutions gave the same result, the destination was an existing regular file and @t{-f} was not given) causes the entire function to abort without doing anything."
msgstr ""
"该模式始终被视为 @t{EXTENDED_GLOB} 模式。 任何文件,名称未通过替换而改变的，都会被忽略。 任何错误（一次替换结果为空字符串、两次替换结果相同、目标文件为现有常规文件且未给出 @t{-f}）都会导致整个函数终止，不会"
"执行任何操作。"

#. type: table
#: zsh.texi:41126
msgid ""
"In addition to pattern replacement, the variable @t{$f} can be referred to in the second (replacement) argument.  This makes it possible to use variable substitution to alter the argument; see examples "
"below."
msgstr "除了模式替换外，还可以在第二个（替换）参数中引用变量 @t{$f}。 这使得使用变量替换来更改参数成为可能；请参阅下面的示例。"

#. type: table
#: zsh.texi:41136
msgid "Force overwriting of destination files.  Not currently passed down to the @t{mv}/@t{cp}/@t{ln} command due to vagaries of implementations (but you can use @t{-o-f} to do that)."
msgstr "强制覆盖目标文件。 由于实现方式的不同，目前还不能向 @t{mv}/@t{cp}/@t{ln} 命令传递（但可以使用 @t{-o-f} 来实现）。"

#. type: table
#: zsh.texi:41140
msgid "Interactive: show each line to be executed and ask the user whether to execute it.  `@t{Y}' or `@t{y}' will execute it, anything else will skip it.  Note that you just need to type one character."
msgstr "交互式：显示要执行的每一行，并询问用户是否执行。  `@t{Y}' 或 `@t{y}' 将执行该行，否则将跳过该行。 请注意，您只需键入一个字符即可。"

#. type: table
#: zsh.texi:41142
msgid "No execution: print what would happen, but don't do it."
msgstr "不执行：打印会发生的事情，但不要去做。"

#. type: table
#: zsh.texi:41145
msgid "Turn bare glob qualifiers off: now assumed by default, so this has no effect."
msgstr "关闭裸 glob 限定符：现在默认为关闭，因此没有影响。"

#. type: table
#: zsh.texi:41148
msgid "Force bare glob qualifiers on.  Don't turn this on unless you are actually using glob qualifiers in a pattern."
msgstr "强制开启裸 glob 限定符。 除非您真的要在模式中使用 glob 限定符，否则不要打开它。"

#. type: table
#: zsh.texi:41150
msgid "Symbolic, passed down to @t{ln}; only works with @t{-L}."
msgstr "符号，向下传递至 @t{ln}；仅适用于 @t{-L}。"

#. type: table
#: zsh.texi:41152
msgid "Verbose: print each command as it's being executed."
msgstr "详细：执行每条命令时打印执行的命令。"

#. type: table
#: zsh.texi:41155
msgid "Pick out wildcard parts of the pattern, as described above, and implicitly add parentheses for referring to them."
msgstr "如上文所述，挑出模式中的通配符部分，并隐式添加括号用于引用它们。"

#. type: table
#: zsh.texi:41158
msgid "Just like @t{-w}, with the addition of turning wildcards in the replacement pattern into sequential @t{$@{1@}} .. @t{$@{N@}} references."
msgstr "就像 @t{-w}一样，只是把替换模式中的通配符变成了连续的 @t{$@{1@}} .. @t{$@{N@}} 引用。"

#. type: table
#: zsh.texi:41163
msgid "Force @t{cp}, @t{ln} or @t{mv}, respectively, regardless of the name of the function."
msgstr "分别强制执行 @t{cp}、@t{ln} 或 @t{mv}，与函数名称无关。"

#. type: item
#: zsh.texi:41163
#, no-wrap
msgid "@t{-p} @var{program}"
msgstr "@t{-p} @var{program}"

#. type: table
#: zsh.texi:41166
msgid "Call @var{program} instead of @t{cp}, @t{ln} or @t{mv}.  Whatever it does, it should at least understand the form"
msgstr "调用 @var{program} 而不是 @t{cp}、@t{ln} 或 @t{mv}。 无论它做什么，至少应该理解以下形式"

#. type: example
#: zsh.texi:41168
#, no-wrap
msgid "@var{program} @t{-}@t{-} @var{oldname} @var{newname}\n"
msgstr "@var{program} @t{-}@t{-} @var{oldname} @var{newname}\n"

#. type: table
#: zsh.texi:41172
msgid "where @var{oldname} and @var{newname} are filenames generated by @t{zmv}.  @var{program} will be split into words, so might be e.g. the name of an archive tool plus a copy or rename subcommand."
msgstr "其中 @var{oldname} 和 @var{newname} 是 @t{zmv} 生成的文件名。 @var{program} 将被分割成单词，因此可能是归档工具的名称加上复制或重命名子命令。"

#. type: item
#: zsh.texi:41172
#, no-wrap
msgid "@t{-P} @var{program}"
msgstr "@t{-P} @var{program}"

#. type: table
#: zsh.texi:41177
msgid ""
"As @t{-p} @var{program}, except that @var{program} does not accept a following @t{-}@t{-} to indicate the end of options.  In this case filenames must already be in a sane form for the program in question."
msgstr "@t{-p} @var{program} 除了 @var{program} 不接受后面的 @t{-}@t{-} 来表示选项的结束外，其他都与 @var{program} 相同。 在这种情况下，文件名必须已经是相关程序的正常形式。"

#. type: item
#: zsh.texi:41177
#, no-wrap
msgid "@t{-o} @var{optstring}"
msgstr "@t{-o} @var{optstring}"

#. type: table
#: zsh.texi:41181
msgid "The @var{optstring} is split into words and passed down verbatim to the @t{cp}, @t{ln} or @t{mv} command called to perform the work.  It should probably begin with a `@t{-}'."
msgstr "@var{optstring} 会被分割成单词，并逐字传给 @t{cp}、@t{ln} 或 @t{mv} 命令来执行工作。 这也许应该以`@t{-}'开头。"

#. type: table
#: zsh.texi:41185
msgid "Further examples:"
msgstr "更多例子:"

#. type: example
#: zsh.texi:41189
#, no-wrap
msgid "zmv -v '(* *)' '$@{1// /_@}'\n"
msgstr "zmv -v '(* *)' '$@{1// /_@}'\n"

#. type: table
#: zsh.texi:41194
msgid "For any file in the current directory with at least one space in the name, replace every space by an underscore and display the commands executed."
msgstr "对于当前目录中名称中至少有一个空格的文件，用下划线替换每个空格，并显示执行的命令。"

#. type: example
#: zsh.texi:41198
#, no-wrap
msgid "zmv -v '* *' '$@{f// /_@}'\n"
msgstr "zmv -v '* *' '$@{f// /_@}'\n"

#. type: table
#: zsh.texi:41202
msgid "This does exactly the same by referring to the file name stored in @t{$f}."
msgstr "通过引用 @t{$f} 中存储的文件名，可以实现完全相同的功能。"

#. type: table
#: zsh.texi:41207
msgid ""
"For more complete examples and other implementation details, see the @t{zmv} source file, usually located in one of the directories named in your @t{fpath}, or in @t{Functions/Misc/zmv} in the zsh "
"distribution."
msgstr "有关更完整的示例和其他实现细节，请参阅 @t{zmv} 源文件，该文件通常位于 @t{fpath} 中命名的某个目录中，或 zsh 发行版中的 @t{Functions/Misc/zmv} 中。"

#. type: table
#: zsh.texi:41211
msgid "See `Recompiling Functions' (@ref{Utilities})."
msgstr "请参阅 `重新编译函数'（@ref{实用程序}）。"

#. type: findex
#: zsh.texi:41212
#, no-wrap
msgid "zstyle+"
msgstr "zstyle+"

#. type: item
#: zsh.texi:41213
#, no-wrap
msgid "@t{zstyle+} @var{context} @var{style} @var{value} [ @t{+} @var{subcontext} @var{style} @var{value} ... ]"
msgstr "@t{zstyle+} @var{context} @var{style} @var{value} [ @t{+} @var{subcontext} @var{style} @var{value} ... ]"

#. type: table
#: zsh.texi:41217
msgid "This makes defining styles a bit simpler by using a single `@t{+}' as a special token that allows you to append a context name to the previously used context name.  Like this:"
msgstr "通过使用单个 `@t{+}' 作为特殊标记，可以将上下文名称追加到之前使用的上下文名称中，从而使样式定义变得更加简单。 就像这样"

#. type: example
#: zsh.texi:41223
#, no-wrap
msgid ""
"zstyle+ ':foo:bar' @var{style1} @var{value1} \\ \n"
"       +':baz'     @var{style2} @var{value2} \\ \n"
"       +':frob'    @var{style3} @var{value3}\n"
msgstr ""
"zstyle+ ':foo:bar' @var{style1} @var{value1} \\ \n"
"       +':baz'     @var{style2} @var{value2} \\ \n"
"       +':frob'    @var{style3} @var{value3}\n"

#. type: table
#: zsh.texi:41231
msgid ""
"This defines @var{style1} with @var{value1} for the context @t{:foo:bar} as usual, but it also defines @var{style2} with @var{value2} for the context @t{:foo:bar:baz} and @var{style3} with @var{value3} "
"for @t{:foo:bar:frob}.  Any @var{subcontext} may be the empty string to re-use the first context unchanged."
msgstr ""
"与往常一样，这里为上下文 @t{:foo:bar} 定义了 @var{style1} 和 @var{value1}，但同时也为上下文 @t{:foo:bar:baz} 定义了 @var{style2} 和 @var{value2}，并为 @t{:foo:bar:frob} 定义了 @var{style3} 和 "
"@var{value3}。 任何 @var{subcontext} 都可以是空字符串，以便在不改变上下文的情况下重新使用第一个上下文。"

#. type: table
#: zsh.texi:41246
msgid ""
"The @t{zed} function @emph{sets} this style in context `@t{:completion:zed:*}' to turn off completion when @t{TAB} is typed at the beginning of a line.  You may override this by setting your own value for "
"this context and style."
msgstr "@t{zed} 函数 在`@t{:completion:zed:*}'中@emph{设置} 了该样式，以便在行首键入 @t{TAB} 时关闭补全功能。 您可以为该上下文和样式设置自己的值，从而覆盖该设置。"

#. type: kindex
#: zsh.texi:41247
#, no-wrap
msgid "pager, nslookup style"
msgstr "pager, nslookup 样式"

#. type: table
#: zsh.texi:41252
msgid "The @t{nslookup} function looks up this style in the context `@t{:nslookup}' to determine the program used to display output that does not fit on a single screen."
msgstr "@t{nslookup} 函数在上下文`@t{:nslookup}'中查找这种样式，以确定用于显示无法在单个屏幕上显示的输出的程序。"

#. type: kindex
#: zsh.texi:41253
#, no-wrap
msgid "prompt, nslookup style"
msgstr "prompt, nslookup 样式"

#. type: kindex
#: zsh.texi:41254
#, no-wrap
msgid "rprompt, nslookup style"
msgstr "rprompt, nslookup 样式"

#. type: t{#1}
#: zsh.texi:41256
#, no-wrap
msgid "rprompt"
msgstr "rprompt"

#. type: table
#: zsh.texi:41262
msgid ""
"The @t{nslookup} function looks up this style in the context `@t{:nslookup}' to set the prompt and the right-side prompt, respectively.  The usual expansions for the @t{PS1} and @t{RPS1} parameters may be "
"used (see @ref{Prompt Expansion})."
msgstr "@t{nslookup} 函数在上下文`@t{:nslookup}'中查找此样式，分别设置提示符和右侧提示符。 可以使用 @t{PS1} 和 @t{RPS1} 参数的常规扩展（参见 @ref{提示符扩展}）。"

#. type: node
#: zsh.texi:41268 zsh.texi:41270 zsh.texi:41275
#, no-wrap
msgid "Concept Index"
msgstr "概念索引"

#. type: node
#: zsh.texi:41268 zsh.texi:41275 zsh.texi:41277 zsh.texi:41282
#, no-wrap
msgid "Variables Index"
msgstr "变量索引"

#. type: node
#: zsh.texi:41275 zsh.texi:41282 zsh.texi:41284 zsh.texi:41289
#, no-wrap
msgid "Options Index"
msgstr "选项索引"

#. type: node
#: zsh.texi:41282 zsh.texi:41289 zsh.texi:41291 zsh.texi:41296
#, no-wrap
msgid "Functions Index"
msgstr "函数索引"

#. type: node
#: zsh.texi:41289 zsh.texi:41296 zsh.texi:41298 zsh.texi:41303
#, no-wrap
msgid "Editor Functions Index"
msgstr "编辑器函数索引"
